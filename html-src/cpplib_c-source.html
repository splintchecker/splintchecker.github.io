<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cpplib.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:39 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>cpplib.c</h1><a href="cpplib_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** cpplib.c</font>
00026 <font class="comment">*/</font>
00027 <font class="comment">/*</font>
00028 <font class="comment">   Copyright (C) 1986, 87, 89, 92-6, 1997 Free Software Foundation, Inc.</font>
00029 <font class="comment">   Contributed by Per Bothner, 1994-95.</font>
00030 <font class="comment">   Based on CCCP program by Paul Rubin, June 1986</font>
00031 <font class="comment">   Adapted to ANSI C, Richard Stallman, Jan 1987</font>
00032 <font class="comment"></font>
00033 <font class="comment">This program is free software; you can redistribute it and/or modify it</font>
00034 <font class="comment">under the terms of the GNU General Public License as published by the</font>
00035 <font class="comment">Free Software Foundation; either version 2, or (at your option) any</font>
00036 <font class="comment">later version.</font>
00037 <font class="comment"></font>
00038 <font class="comment">This program is distributed in the hope that it will be useful,</font>
00039 <font class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00040 <font class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
00041 <font class="comment">GNU General Public License for more details.</font>
00042 <font class="comment"></font>
00043 <font class="comment">You should have received a copy of the GNU General Public License</font>
00044 <font class="comment">along with this program; if not, write to the Free Software</font>
00045 <font class="comment">Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</font>
00046 <font class="comment"></font>
00047 <font class="comment"> In other words, you are welcome to use, share and improve this program.</font>
00048 <font class="comment"> You are forbidden to forbid anyone else to use, share and improve</font>
00049 <font class="comment"> what you give them.   Help stamp out software-hoarding!  */</font>
00050 
00051 <font class="comment">/*</font>
00052 <font class="comment"> * Herbert 06/12/2000:</font>
00053 <font class="comment"> * - OS2 drive specs like WIN32</font>
00054 <font class="comment"> * - Includes for IBMs OS/2 compiler</font>
00055 <font class="comment"> */</font>
00056 
00057 <font class="preprocessor"># include &lt;ctype.h&gt;</font>
00058 <font class="preprocessor"># include &lt;stdio.h&gt;</font>
00059 <font class="preprocessor"># include &lt;signal.h&gt;</font>
00060 <font class="preprocessor"># ifdef __STDC__</font>
00061 <font class="preprocessor"></font><font class="preprocessor"># include &lt;stdlib.h&gt;</font>
00062 <font class="preprocessor"># endif</font>
00063 <font class="preprocessor"></font>
00064 <font class="preprocessor"># include &lt;string.h&gt;</font>
00065 
00066 <font class="preprocessor"># if !(defined (WIN32) || defined (OS2) &amp;&amp; defined (__IBMC__))</font>
00067 <font class="preprocessor"></font><font class="preprocessor"># include &lt;unistd.h&gt;</font>
00068 <font class="preprocessor"># endif</font>
00069 <font class="preprocessor"></font>
00070 <font class="preprocessor"># include &lt;sys/types.h&gt;</font>
00071 <font class="preprocessor"># include &lt;sys/stat.h&gt;</font>
00072 <font class="preprocessor"># include &lt;fcntl.h&gt;</font>
00073 
00074 <font class="preprocessor"># if defined (WIN32) || defined (OS2) &amp;&amp; defined (__IBMC__)</font>
00075 <font class="preprocessor"></font><font class="preprocessor"># include &lt;io.h&gt;</font>
00076 <font class="preprocessor"># include &lt;sys/utime.h&gt;</font>         <font class="comment">/* for __DATE__ and __TIME__ */</font>
00077 <font class="preprocessor"># include &lt;time.h&gt;</font>
00078 <font class="preprocessor"># else</font>
00079 <font class="preprocessor"></font><font class="preprocessor"># ifndef VMS</font>
00080 <font class="preprocessor"></font><font class="preprocessor"># ifndef USG</font>
00081 <font class="preprocessor"></font><font class="preprocessor"># include &lt;sys/time.h&gt;</font>
00082 <font class="preprocessor"># include &lt;sys/resource.h&gt;</font>
00083 <font class="preprocessor"># else</font>
00084 <font class="preprocessor"></font><font class="preprocessor"># include &lt;sys/times.h&gt;</font>
00085 <font class="preprocessor"># include &lt;time.h&gt;</font>
00086 <font class="preprocessor"># include &lt;fcntl.h&gt;</font>
00087 <font class="preprocessor"># endif </font><font class="comment">/* USG */</font>
00088 <font class="preprocessor"># endif </font><font class="comment">/* not VMS */</font>
00089 <font class="preprocessor"># endif </font><font class="comment">/* not WIN32 */</font>
00090 
00091 <font class="comment">/* This defines "errno" properly for VMS, and gives us EACCES.  */</font>
00092 <font class="preprocessor"># include &lt;errno.h&gt;</font>
00093 
00094 <font class="preprocessor"># include "lclintMacros.nf"</font>
00095 <font class="preprocessor"># include "llbasic.h"</font>
00096 <font class="preprocessor"># include "lcllib.h"</font>
00097 <font class="preprocessor"># include "cpp.h"</font>
00098 <font class="preprocessor"># include "cpplib.h"</font>
00099 <font class="preprocessor"># include "cpperror.h"</font>
00100 <font class="preprocessor"># include "cpphash.h"</font>
00101 <font class="preprocessor"># include "cppexp.h"</font>
00102 <font class="preprocessor"># include "version.h"</font>
00103 <font class="preprocessor"># include "portab.h"</font>
00104 <font class="preprocessor"># include "osd.h"</font>
00105 
00106 <font class="comment">/*</font>
00107 <font class="comment">** This is really kludgey code...</font>
00108 <font class="comment">*/</font>
00109 
00110 <font class="comment">/*@+boolint@*/</font>
00111 <font class="comment">/*@+charint@*/</font>
00112 
<a name="l00113"></a><a class="code" href="cpplib_c.html#a0">00113</a> <font class="preprocessor">#define NO_SHORTNAMES</font>
00114 <font class="preprocessor"></font>
00115 <font class="preprocessor"># ifdef open</font>
00116 <font class="preprocessor"></font><font class="preprocessor"># undef open</font>
00117 <font class="preprocessor"></font><font class="preprocessor"># undef read</font>
00118 <font class="preprocessor"></font><font class="preprocessor"># undef write</font>
00119 <font class="preprocessor"></font><font class="preprocessor"># endif </font><font class="comment">/* open */</font>
00120 
00121 <font class="comment">/*@constant int IMPORT_FOUND@*/</font>
<a name="l00122"></a><a class="code" href="cpplib_c.html#a1">00122</a> <font class="preprocessor"># define IMPORT_FOUND -2</font>
00123 <font class="preprocessor"></font>
00124 <font class="comment">/*@constant int SKIP_INCLUDE@*/</font>
<a name="l00125"></a><a class="code" href="cpplib_c.html#a2">00125</a> <font class="preprocessor"># define SKIP_INCLUDE IMPORT_FOUND</font>
00126 <font class="preprocessor"></font>
00127 <font class="comment">/*@constant unused int IMPORT_NOT_FOUND@*/</font>
<a name="l00128"></a><a class="code" href="cpplib_c.html#a3">00128</a> <font class="preprocessor"># define IMPORT_NOT_FOUND -1</font>
00129 <font class="preprocessor"></font>
00130 <font class="preprocessor">#ifndef STDC_VALUE</font>
00131 <font class="preprocessor"></font><font class="comment">/*@constant unused int STDC_VALUE@*/</font>
<a name="l00132"></a><a class="code" href="cpplib_c.html#a4">00132</a> <font class="preprocessor">#define STDC_VALUE 1</font>
00133 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00134 <font class="preprocessor"></font>
00135 <font class="comment">/* By default, colon separates directories in a path.  */</font>
00136 <font class="preprocessor">#ifndef PATH_SEPARATOR</font>
00137 <font class="preprocessor"></font><font class="comment">/*@constant char PATH_SEPARATOR@*/</font>
<a name="l00138"></a><a class="code" href="cpplib_c.html#a5">00138</a> <font class="preprocessor">#define PATH_SEPARATOR ':'</font>
00139 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00140 <font class="preprocessor"></font>
00141 <font class="keyword">static</font> <font class="keywordtype">void</font> parse_name (cppReader *, <font class="keywordtype">int</font>);
00142 
00143 <font class="keyword">static</font> <font class="keywordtype">int</font> cpp_openIncludeFile (<font class="keywordtype">char</font> *p_filename)
00144      <font class="comment">/*@modifies fileSystem @*/</font> ;
00145 
00146 <font class="keyword">static</font> <font class="keywordtype">void</font> cpp_setLocation (cppReader *p_pfile)
00147      <font class="comment">/*@modifies g_currentloc@*/</font> ;
00148 
00149 <font class="keyword">static</font> <font class="keyword">enum</font> cpp_token cpp_handleComment (cppReader *p_pfile,
00150                                          <font class="keyword">struct</font> parse_marker *p_smark)
00151      <font class="comment">/*@modifies *p_pfile, *p_smark@*/</font>;
00152 
00153 <font class="keyword">static</font> <font class="keywordtype">bool</font> cpp_shouldCheckMacro (cppReader *p_pfile, <font class="keywordtype">char</font> *p_p) <font class="comment">/*@*/</font> ;
00154 
00155 <font class="keyword">static</font> <font class="keywordtype">bool</font> cpp_skipIncludeFile (cstring p_fname) <font class="comment">/*@*/</font> ;
00156 
00157 <font class="preprocessor">#ifndef O_RDONLY</font>
<a name="l00158"></a><a class="code" href="cpplib_c.html#a6">00158</a> <font class="preprocessor"></font><font class="preprocessor">#define O_RDONLY 0</font>
00159 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00160 <font class="preprocessor"></font>
00161 <font class="comment">/* Symbols to predefine.  */</font>
00162 
00163 <font class="preprocessor">#ifdef CPP_PREDEFINES</font>
00164 <font class="preprocessor"></font><font class="keyword">static</font> <font class="comment">/*@observer@*/</font> <font class="keywordtype">char</font> *predefs = CPP_PREDEFINES;
00165 <font class="preprocessor">#else</font>
00166 <font class="preprocessor"></font><font class="keyword">static</font> <font class="comment">/*@observer@*/</font> <font class="keywordtype">char</font> *predefs = <font class="stringliteral">""</font>;
00167 <font class="preprocessor">#endif</font>
00168 <font class="preprocessor"></font>
00169 <font class="comment">/* We let tm.h override the types used here, to handle trivial differences</font>
00170 <font class="comment">   such as the choice of unsigned int or long unsigned int for size_t.</font>
00171 <font class="comment">   When machines start needing nontrivial differences in the size type,</font>
00172 <font class="comment">   it would be best to do something here to figure out automatically</font>
00173 <font class="comment">   from other information what type to use.  */</font>
00174 
00175 <font class="comment">/* The string value for __SIZE_TYPE__.  */</font>
00176 
00177 <font class="preprocessor">#ifndef SIZE_TYPE</font>
00178 <font class="preprocessor"></font><font class="comment">/*@constant observer char *SIZE_TYPE@*/</font>
<a name="l00179"></a><a class="code" href="cpplib_c.html#a7">00179</a> <font class="preprocessor">#define SIZE_TYPE "long unsigned int"</font>
00180 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00181 <font class="preprocessor"></font>
00182 <font class="comment">/* The string value for __PTRDIFF_TYPE__.  */</font>
00183 
00184 <font class="preprocessor">#ifndef PTRDIFF_TYPE</font>
00185 <font class="preprocessor"></font><font class="comment">/*@constant observer char *PTRDIFF_TYPE@*/</font>
<a name="l00186"></a><a class="code" href="cpplib_c.html#a8">00186</a> <font class="preprocessor">#define PTRDIFF_TYPE "long int"</font>
00187 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00188 <font class="preprocessor"></font>
00189 <font class="comment">/* The string value for __WCHAR_TYPE__.  */</font>
00190 
00191 <font class="preprocessor">#ifndef WCHAR_TYPE</font>
00192 <font class="preprocessor"></font><font class="comment">/*@constant observer char *WCHAR_TYPE@*/</font>
<a name="l00193"></a><a class="code" href="cpplib_c.html#a9">00193</a> <font class="preprocessor">#define WCHAR_TYPE "int"</font>
00194 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00195 <font class="preprocessor"></font>
00196 <font class="comment">/* The string value for __USER_LABEL_PREFIX__ */</font>
00197 
00198 <font class="preprocessor">#ifndef USER_LABEL_PREFIX</font>
00199 <font class="preprocessor"></font><font class="comment">/*@constant observer char *USER_LABEL_PREFIX@*/</font>
<a name="l00200"></a><a class="code" href="cpplib_c.html#a10">00200</a> <font class="preprocessor">#define USER_LABEL_PREFIX ""</font>
00201 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00202 <font class="preprocessor"></font>
00203 <font class="comment">/* The string value for __REGISTER_PREFIX__ */</font>
00204 
00205 <font class="preprocessor">#ifndef REGISTER_PREFIX</font>
00206 <font class="preprocessor"></font><font class="comment">/*@constant observer char *REGISTER_PREFIX@*/</font>
<a name="l00207"></a><a class="code" href="cpplib_c.html#a11">00207</a> <font class="preprocessor">#define REGISTER_PREFIX ""</font>
00208 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00209 <font class="preprocessor"></font>
00210 <font class="comment">/* table to tell if char can be part of a C identifier.  */</font>
00211 <font class="keyword">static</font> <font class="keywordtype">bool</font> is_idchar[256];
00212 <font class="comment">/* table to tell if char can be first char of a c identifier.  */</font>
00213 <font class="keyword">static</font> <font class="keywordtype">bool</font> is_idstart[256];
00214 <font class="comment">/* table to tell if c is horizontal space.  */</font>
00215 <font class="keyword">static</font> <font class="keywordtype">bool</font> is_hor_space[256];
00216 <font class="comment">/* table to tell if c is horizontal or vertical space.  */</font>
00217 <font class="keyword">static</font> <font class="keywordtype">bool</font> is_space[256];
00218 
00219 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@null@*/</font> cppBuffer *
00220 cppReader_getBuffer (<font class="comment">/*@special@*/</font> cppReader *p_pfile)
00221      <font class="comment">/*@uses p_pfile-&gt;buffer@*/</font>
00222      <font class="comment">/*@modifies nothing@*/</font> ;
00223 
00224 <font class="comment">/*@notfunction@*/</font>
<a name="l00225"></a><a class="code" href="cpplib_c.html#a12">00225</a> <font class="preprocessor"># define SKIP_WHITE_SPACE(p) do { </font><font class="comment">/*@access cstring@*/</font> while (is_hor_space[(int) *(p)]) { (p)++; } } <font class="comment">/*@noaccess cstring@*/</font> while (0)
00226 
00227 <font class="comment">/*@notfunction@*/</font>
<a name="l00228"></a><a class="code" href="cpplib_c.html#a13">00228</a> <font class="preprocessor"># define SKIP_ALL_WHITE_SPACE(p) do { while (is_space[*(p)]) { (p)++; } } while (0)</font>
00229 <font class="preprocessor"></font>
00230 <font class="keyword">static</font> <font class="keywordtype">int</font> cpp_peekN (cppReader *p_pfile, <font class="keywordtype">int</font> p_n) <font class="comment">/*@*/</font> ;
00231 
00232 <font class="comment">/*@function static int cppBuffer_get (sef cppBuffer *p_b) modifies *p_b ; @*/</font>
<a name="l00233"></a><a class="code" href="cpplib_c.html#a14">00233</a> <font class="preprocessor"># define cppBuffer_get(BUFFER) \</font>
00234 <font class="preprocessor">  ((BUFFER)-&gt;cur &lt; (BUFFER)-&gt;rlimit ? *(BUFFER)-&gt;cur++ : EOF)</font>
00235 <font class="preprocessor"></font>
00236 <font class="comment">/* Append string STR (of length N) to PFILE's output buffer.  Make space. */</font>
00237 <font class="comment">/*@function static void cppReader_puts (sef cppReader *p_file, char *p_str, sef size_t p_n)</font>
00238 <font class="comment">                     modifies *p_file; @*/</font>
<a name="l00239"></a><a class="code" href="cpplib_c.html#a15">00239</a> <font class="preprocessor"># define cppReader_puts(PFILE, STR, N) \</font>
00240 <font class="preprocessor">  cppReader_reserve(PFILE, N), cppReader_putStrN (PFILE, STR,N)</font>
00241 <font class="preprocessor"></font>
00242 <font class="comment">/* Append character CH to PFILE's output buffer.  Assume sufficient space. */</font>
00243 
00244 <font class="comment">/*@function static void cppReader_putCharQ (cppReader *p_file, char p_ch)</font>
00245 <font class="comment">                    modifies *p_file; @*/</font>
<a name="l00246"></a><a class="code" href="cpplib_c.html#a16">00246</a> <font class="preprocessor"># define cppReader_putCharQ(PFILE, CH) (*(PFILE)-&gt;limit++ = (CH))</font>
00247 <font class="preprocessor"></font>
00248 <font class="comment">/* Append character CH to PFILE's output buffer.  Make space if need be. */</font>
00249 
00250 <font class="comment">/*@function static void cppReader_putChar (sef cppReader *p_file, char p_ch)</font>
00251 <font class="comment">                    modifies *p_file; @*/</font>
<a name="l00252"></a><a class="code" href="cpplib_c.html#a17">00252</a> <font class="preprocessor">#define cppReader_putChar(PFILE, CH) (cppReader_reserve (PFILE, (size_t) 1), cppReader_putCharQ (PFILE, CH))</font>
00253 <font class="preprocessor"></font>
00254 <font class="comment">/* Make sure PFILE-&gt;limit is followed by '\0'. */</font>
00255 <font class="comment">/*@function static void cppReader_nullTerminateQ (cppReader *p_file)</font>
00256 <font class="comment">      modifies *p_file; @*/</font>
00257 
<a name="l00258"></a><a class="code" href="cpplib_c.html#a18">00258</a> <font class="preprocessor">#define cppReader_nullTerminateQ(PFILE) (*(PFILE)-&gt;limit = 0)</font>
00259 <font class="preprocessor"></font>
00260 <font class="comment">/*@function static void cppReader_nullTerminate (sef cppReader *p_file)</font>
00261 <font class="comment">                           modifies *p_file; @*/</font>
<a name="l00262"></a><a class="code" href="cpplib_c.html#a19">00262</a> <font class="preprocessor"># define cppReader_nullTerminate(PFILE) \</font>
00263 <font class="preprocessor">  (cppReader_reserve (PFILE, (size_t) 1), *(PFILE)-&gt;limit = 0)</font>
00264 <font class="preprocessor"></font>
00265 <font class="comment">/*@function static void cppReader_adjustWritten (cppReader *p_file, size_t)</font>
00266 <font class="comment">                           modifies *p_file; @*/</font>
<a name="l00267"></a><a class="code" href="cpplib_c.html#a20">00267</a> <font class="preprocessor">#define cppReader_adjustWritten(PFILE,DELTA) ((PFILE)-&gt;limit += (DELTA))</font>
00268 <font class="preprocessor"></font>
00269 <font class="comment">/*@function static bool cppReader_isC89 (cppReader *) modifies nothing; @*/</font>
<a name="l00270"></a><a class="code" href="cpplib_c.html#a21">00270</a> <font class="preprocessor">#define cppReader_isC89(PFILE) (CPPOPTIONS(PFILE)-&gt;c89)</font>
00271 <font class="preprocessor"></font>
00272 <font class="comment">/*@function static observer char *cppReader_wcharType (cppReader *)</font>
00273 <font class="comment">     modifies nothing; @*/</font>
00274 
<a name="l00275"></a><a class="code" href="cpplib_c.html#a22">00275</a> <font class="preprocessor"># define cppReader_wcharType(PFILE) \</font>
00276 <font class="preprocessor">  (CPPOPTIONS (PFILE)-&gt;cplusplus ? "__wchar_t" : WCHAR_TYPE)</font>
00277 <font class="preprocessor"></font>
00278 <font class="keyword">static</font> <font class="keywordtype">void</font> cppBuffer_forward (cppBuffer *p_buf, <font class="keywordtype">int</font> p_n) <font class="comment">/*@modifies *p_buf@*/</font> ;
00279 
00280 <font class="comment">/*@function static void cppReader_forward (cppReader *p_pfile, int) modifies *p_pfile; @*/</font>
<a name="l00281"></a><a class="code" href="cpplib_c.html#a23">00281</a> <font class="preprocessor"># define cppReader_forward(pfile, N) \</font>
00282 <font class="preprocessor">  (cppBuffer_forward (cppReader_getBufferSafe (pfile), (N)))</font>
00283 <font class="preprocessor"></font>
00284 <font class="comment">/*@function static int cppReader_getC (cppReader *p_pfile) modifies *p_pfile; @*/</font>
<a name="l00285"></a><a class="code" href="cpplib_c.html#a24">00285</a> <font class="preprocessor"># define cppReader_getC(pfile)   (cppBuffer_get (cppReader_getBufferSafe (pfile)))</font>
00286 <font class="preprocessor"></font>
00287 <font class="comment">/*@function static int cppReader_peekC (cppReader *) modifies nothing;@*/</font>
<a name="l00288"></a><a class="code" href="cpplib_c.html#a25">00288</a> <font class="preprocessor"># define cppReader_peekC(pfile)  (cppBufPeek (cppReader_getBufferSafe (pfile)))</font>
00289 <font class="preprocessor"></font>
00290 <font class="comment">/* Move all backslash-newline pairs out of embarrassing places.</font>
00291 <font class="comment">   Exchange all such pairs following BP</font>
00292 <font class="comment">   with any potentially-embarrassing characters that follow them.</font>
00293 <font class="comment">   Potentially-embarrassing characters are / and *</font>
00294 <font class="comment">   (because a backslash-newline inside a comment delimiter</font>
00295 <font class="comment">   would cause it not to be recognized).  */</font>
00296 
00297 <font class="comment">/*@notfunction@*/</font>
<a name="l00298"></a><a class="code" href="cpplib_c.html#a26">00298</a> <font class="preprocessor"># define NEWLINE_FIX \</font>
00299 <font class="preprocessor">   do { while (cppReader_peekC (pfile) == '\\' &amp;&amp; cpp_peekN (pfile, 1) == '\n') { cppReader_forward (pfile, 2); } } while(FALSE)</font>
00300 <font class="preprocessor"></font>
00301      <font class="comment">/* Same, but assume we've already read the potential '\\' into C.  */</font>
00302 <font class="comment">/*@notfunction@*/</font>
<a name="l00303"></a><a class="code" href="cpplib_c.html#a27">00303</a> <font class="preprocessor"># define NEWLINE_FIX1(C) do { \</font>
00304 <font class="preprocessor">     while ((C) == '\\' &amp;&amp; cppReader_peekC (pfile) == '\n') { cppReader_forward (pfile, 1); (C) = cppReader_getC (pfile); }\</font>
00305 <font class="preprocessor">                                                                           } while(0)</font>
00306 <font class="preprocessor"></font>
00307 <font class="keyword">static</font> <font class="keywordtype">void</font> parseSetMark (<font class="comment">/*@out@*/</font> <font class="keyword">struct</font> parse_marker *,
00308                           cppReader *);
00309 <font class="keyword">static</font> <font class="keywordtype">void</font> parseClearMark (<font class="keyword">struct</font> parse_marker *);
00310 <font class="keyword">static</font> <font class="keywordtype">void</font> parseGotoMark (<font class="keyword">struct</font> parse_marker *, cppReader *);
00311 <font class="keyword">static</font> <font class="keywordtype">void</font> parseMoveMark (<font class="keyword">struct</font> parse_marker *, cppReader *);
00312 
00313 <font class="comment">/* If we have a huge buffer, may need to cache more recent counts */</font>
00314 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> <font class="keywordtype">char</font> *cppLineBase (<font class="comment">/*@sef@*/</font> cppBuffer *);
00315 
00316 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@null@*/</font> cppBuffer *
00317    cppReader_pushBuffer (cppReader *p_pfile,
00318                          <font class="comment">/*@owned@*/</font> <font class="comment">/*@null@*/</font> <font class="keywordtype">char</font> *, size_t)
00319      <font class="comment">/*@modifies p_pfile@*/</font> ;
00320 
00321 <font class="keyword">static</font> <font class="keywordtype">void</font> cppReader_appendIncludeChain
00322 (cppReader *p_pfile,
00323  <font class="comment">/*@keep@*/</font> <font class="keyword">struct </font>file_name_list *p_first,
00324  <font class="comment">/*@dependent@*/</font> struct file_name_list *p_last);
00325 
00326 <font class="keyword">static</font> <font class="keywordtype">void</font> cppReader_macroCleanup (cppBuffer *p_pbuf, cppReader *p_pfile);
00327 <font class="keyword">static</font> <font class="keyword">enum</font> cpp_token cppReader_nullUnderflow (<font class="comment">/*@unused@*/</font> cppReader *p_pfile);
00328 
00329 <font class="keyword">static</font> <font class="keywordtype">void</font> cppReader_nullCleanup (<font class="comment">/*@unused@*/</font> cppBuffer *p_pbuf,
00330                                    <font class="comment">/*@unused@*/</font> cppReader *p_pfile);
00331 
00332 <font class="keyword">static</font> <font class="keywordtype">void</font> cppReader_fileCleanup (cppBuffer *p_pbuf,
00333                                    <font class="comment">/*@unused@*/</font> cppReader *p_pfile);
00334 
00335 <font class="keyword">static</font> <font class="keywordtype">int</font> cppReader_handleDirective (cppReader *p_pfile);
00336 
00337 <font class="keyword">static</font> <font class="keywordtype">void</font> cppReader_scanBuffer (cppReader *p_pfile);
00338 
00339 <font class="preprocessor"># if defined (WIN32) || defined (OS2) &amp;&amp; defined (__IBMC__)</font>
00340 <font class="preprocessor"></font>
00341 <font class="comment">/*</font>
00342 <font class="comment">** WIN32 (at least the VC++ include files) does not define mode_t.</font>
00343 <font class="comment">*/</font>
00344 
00345 <font class="comment">/*@-incondefs@*/</font> <font class="comment">/*@-czechtypes@*/</font>
00346 <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> mode_t;
00347 <font class="comment">/*@=incondefs@*/</font> <font class="comment">/*@=czechtypes@*/</font>
00348 
00349 <font class="preprocessor"># endif</font>
00350 <font class="preprocessor"></font>
00351 <font class="keyword">static</font> <font class="keywordtype">int</font> file_size_and_mode (<font class="keywordtype">int</font> p_fd, <font class="comment">/*@out@*/</font> mode_t *p_mode_pointer,
00352                                <font class="comment">/*@out@*/</font> size_t *p_size_pointer);
00353 <font class="keyword">static</font> <font class="keywordtype">int</font> safe_read (<font class="keywordtype">int</font> p_desc, <font class="comment">/*@out@*/</font> <font class="keywordtype">char</font> *p_ptr, <font class="keywordtype">int</font> p_len);
00354 
00355 
00356 <font class="comment">/*</font>
00357 <font class="comment">** cppBuffer_isMacro is true if the buffer contains macro expansion.</font>
00358 <font class="comment">** (Note that it is false while we're expanding marco *arguments*.)</font>
00359 <font class="comment">*/</font>
00360 
00361 <font class="keyword">static</font> <font class="keywordtype">bool</font> cppBuffer_isMacro (<font class="comment">/*@null@*/</font> cppBuffer *) <font class="comment">/*@*/</font> ;
00362 
00363 <font class="keyword">static</font> <font class="keywordtype">void</font> path_include (cppReader *p_pfile, <font class="keywordtype">char</font> *p_path)
00364      <font class="comment">/*@modifies p_pfile@*/</font> ;
00365 
00366 <font class="keyword">static</font> <font class="keywordtype">void</font> initialize_builtins (cppReader *p_pfile)
00367      <font class="comment">/*@modifies p_pfile@*/</font> ;
00368 
00369 <font class="keyword">static</font> <font class="keywordtype">void</font> initialize_char_syntax (<font class="keyword">struct</font> cppOptions *p_opts) ;
00370 
00371 <font class="keyword">static</font> <font class="keywordtype">int</font> <font class="comment">/*@alt void@*/</font> finclude (cppReader *p_pfile, <font class="keywordtype">int</font> p_f,
00372                                     cstring p_fname,
00373                                     <font class="keywordtype">bool</font> p_system_header_p,
00374                                     <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <font class="keyword">struct</font> file_name_list *p_dirptr);
00375 
00376 <font class="keyword">static</font> <font class="keywordtype">void</font> validate_else (cppReader *p_pfile, cstring p_directive);
00377 
00378 <font class="keyword">static</font> <font class="keywordtype">void</font> conditional_skip (cppReader *p_pfile, <font class="keywordtype">int</font> p_skip,
00379                               <font class="keyword">enum</font> node_type p_type,
00380                               <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <font class="keywordtype">char</font> *p_control_macro);
00381 
00382 <font class="keyword">static</font> HOST_WIDE_INT eval_if_expression (cppReader *p_pfile,
00383                                          <font class="keywordtype">char</font> *p_buf,
00384                                          <font class="keywordtype">int</font> p_length);
00385 
00386 <font class="keyword">static</font> <font class="keywordtype">void</font> skip_if_group (cppReader *p_pfile, <font class="keywordtype">int</font> p_any);
00387 
00388 <font class="keyword">static</font> <font class="keywordtype">bool</font> comp_def_part (<font class="keywordtype">bool</font> p_first, <font class="keywordtype">char</font> *p_beg1, <font class="keywordtype">int</font> p_len1,
00389                            <font class="keywordtype">char</font> *p_beg2, <font class="keywordtype">int</font> p_len2, <font class="keywordtype">bool</font> p_last);
00390 
00391 <font class="preprocessor">#ifdef abort</font>
00392 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="keywordtype">void</font> fancy_abort ();
00393 <font class="preprocessor">#endif</font>
00394 <font class="preprocessor"></font>
00395 <font class="keyword">static</font> <font class="keywordtype">bool</font> redundant_include_p (cppReader *p_pfile, <font class="comment">/*@null@*/</font> cstring p_name);
00396 <font class="keyword">static</font> <font class="keywordtype">bool</font> is_system_include (cppReader *p_pfile, cstring p_filename);
00397 
00398 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> <font class="comment">/*@null@*/</font> <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *
00399 read_name_map (cppReader *p_pfile, cstring p_dirname);
00400 
00401 <font class="keyword">static</font> cstring read_filename_string (<font class="keywordtype">int</font> p_ch, FILE *p_f);
00402 
00403 <font class="keyword">static</font> <font class="keywordtype">int</font> open_include_file (cppReader *p_pfile,
00404                               <font class="comment">/*@owned@*/</font> cstring p_fname,
00405                               <font class="comment">/*@null@*/</font> <font class="keyword">struct</font> file_name_list *p_searchptr);
00406 
00407 <font class="keyword">static</font> <font class="keywordtype">void</font> push_macro_expansion (cppReader *,
00408                                   <font class="comment">/*@owned@*/</font> <font class="keywordtype">char</font> *, size_t,
00409                                   <font class="comment">/*@dependent@*/</font> HASHNODE *);
00410 
00411 <font class="comment">/* Last arg to output_line_command.  */</font>
<a name="l00412"></a><a class="code" href="cpplib_c.html#a150">00412</a> <font class="keyword">enum</font> file_change_code {
00413   same_file, enter_file, leave_file
00414 };
00415 
00416 <font class="comment">/* `struct directive' defines one #-directive, including how to handle it.  */</font>
00417 
<a name="l00418"></a><a class="code" href="struct_directive.html">00418</a> <font class="keyword">struct </font><a class="code" href="struct_directive.html">directive</a> {
<a name="l00419"></a><a class="code" href="struct_directive.html#m0">00419</a>   <font class="keywordtype">int</font> length;                   <font class="comment">/* Length of name */</font>
00420   <font class="comment">/*@null@*/</font> int (*func)();     <font class="comment">/* Function to handle directive */</font>
<a name="l00421"></a><a class="code" href="struct_directive.html#m2">00421</a>   <font class="comment">/*@observer@*/</font> cstring name;  <font class="comment">/* Name of directive */</font>
<a name="l00422"></a><a class="code" href="struct_directive.html#m3">00422</a>   <font class="keyword">enum</font> node_type type;          <font class="comment">/* Code which describes which directive.  */</font>
<a name="l00423"></a><a class="code" href="struct_directive.html#m4">00423</a>   <font class="keywordtype">bool</font> command_reads_line;      <font class="comment">/* One if rest of line is read by func.  */</font>
<a name="l00424"></a><a class="code" href="struct_directive.html#m5">00424</a>   <font class="keywordtype">bool</font> traditional_comments;    <font class="comment">/* Nonzero: keep comments if -traditional.  */</font>
<a name="l00425"></a><a class="code" href="struct_directive.html#m6">00425</a>   <font class="keywordtype">bool</font> pass_thru;               <font class="comment">/* Copy preprocessed directive to output file.*/</font>
00426 };
00427 
00428 <font class="comment">/* These functions are declared to return int instead of void since they</font>
00429 <font class="comment">   are going to be placed in a table and some old compilers have trouble with</font>
00430 <font class="comment">   pointers to functions returning void.  */</font>
00431 
00432 <font class="keyword">static</font> <font class="keywordtype">int</font> do_define (cppReader *, <font class="comment">/*@null@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, 
00433                       <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00434 <font class="keyword">static</font> <font class="keywordtype">int</font> do_defineAux (cppReader *, <font class="comment">/*@null@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *,
00435                          <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *, <font class="keywordtype">bool</font>);
00436      
00437 <font class="keyword">static</font> <font class="keywordtype">int</font> do_line (cppReader *, <font class="comment">/*@null@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *);
00438 <font class="keyword">static</font> <font class="keywordtype">int</font> do_include (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00439 <font class="keyword">static</font> <font class="keywordtype">int</font> do_undef (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00440 <font class="keyword">static</font> <font class="keywordtype">int</font> do_error (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00441 <font class="keyword">static</font> <font class="keywordtype">int</font> do_pragma (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00442 <font class="keyword">static</font> <font class="keywordtype">int</font> do_ident (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00443 <font class="keyword">static</font> <font class="keywordtype">int</font> do_if (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00444 <font class="keyword">static</font> <font class="keywordtype">int</font> do_xifdef (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00445 <font class="keyword">static</font> <font class="keywordtype">int</font> do_else (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00446 <font class="keyword">static</font> <font class="keywordtype">int</font> do_elif (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00447 <font class="keyword">static</font> <font class="keywordtype">int</font> do_endif (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00448 <font class="keyword">static</font> <font class="keywordtype">int</font> do_warning (cppReader *, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *, <font class="keywordtype">char</font> *, <font class="keywordtype">char</font> *);
00449 
00450 <font class="comment">/* If a buffer's dir field is SELF_DIR_DUMMY, it means the file was found</font>
00451 <font class="comment">   via the same directory as the file that #included it.  */</font>
00452 
00453 <font class="comment">/*@constant observer struct file_name_list *SELF_DIR_DUMMY@*/</font>
<a name="l00454"></a><a class="code" href="cpplib_c.html#a28">00454</a> <font class="preprocessor">#define SELF_DIR_DUMMY ((struct file_name_list *) (~0))</font>
00455 <font class="preprocessor"></font>
00456 <font class="comment">/* #include "file" looks in source file dir, then stack.  */</font>
00457 <font class="comment">/* #include &lt;file&gt; just looks in the stack.  */</font>
00458 <font class="comment">/* -I directories are added to the end, then the defaults are added.  */</font>
00459 
00460 <font class="comment">/*@access cstring@*/</font>
00461 
<a name="l00462"></a><a class="code" href="struct_default_include.html">00462</a> <font class="keyword">static</font> <font class="keyword">struct </font><a class="code" href="struct_default_include.html">default_include</a> {
<a name="l00463"></a><a class="code" href="struct_default_include.html#m0">00463</a>   <font class="comment">/*@dependent@*/</font> <font class="comment">/*@observer@*/</font> cstring fname; <font class="comment">/* The name of the directory.  */</font>
<a name="l00464"></a><a class="code" href="struct_default_include.html#m1">00464</a>   <font class="keywordtype">int</font> cplusplus;                <font class="comment">/* Only look here if we're compiling C++.  */</font>
<a name="l00465"></a><a class="code" href="struct_default_include.html#m2">00465</a>   <font class="keywordtype">int</font> cxx_aware;                <font class="comment">/* Includes in this directory don't need to</font>
00466 <font class="comment">                                   be wrapped in extern "C" when compiling</font>
00467 <font class="comment">                                   C++.  */</font>
00468 } include_defaults_array[]
00469 = {
00470   <font class="comment">/* This is the dir for fixincludes.  Put it just before</font>
00471 <font class="comment">     the files that we fix.  */</font>
00472   { GCC_INCLUDE_DIR, 0, 0 },
00473   { GCC_INCLUDE_DIR2, 0, 0 },
00474   { cstring_undefined, 0, 0 }
00475 };
00476 
00477 <font class="comment">/*@noaccess cstring@*/</font>
00478 
00479 <font class="comment">/* Here is the actual list of #-directives, most-often-used first.</font>
00480 <font class="comment">   The initialize_builtins function assumes #define is the very first.  */</font>
00481 
00482 <font class="comment">/*@access cstring@*/</font>
00483 
00484 <font class="keyword">static</font> <font class="keyword">struct </font><a class="code" href="struct_directive.html">directive</a> directive_table[] = {
00485   {  6, do_define, <font class="stringliteral">"define"</font>, T_DEFINE, FALSE, TRUE, FALSE },
00486   {  5, do_xifdef, <font class="stringliteral">"ifdef"</font>, T_IFDEF, TRUE, FALSE, FALSE },
00487   {  6, do_xifdef, <font class="stringliteral">"ifndef"</font>, T_IFNDEF, TRUE, FALSE, FALSE },
00488   {  7, do_include, <font class="stringliteral">"include"</font>, T_INCLUDE, TRUE, FALSE, FALSE },
00489   {  5, do_endif, <font class="stringliteral">"endif"</font>, T_ENDIF, TRUE, FALSE, FALSE },
00490   {  4, do_else, <font class="stringliteral">"else"</font>, T_ELSE, TRUE, FALSE, FALSE },
00491   {  2, do_if, <font class="stringliteral">"if"</font>, T_IF, TRUE, FALSE, FALSE },
00492   {  4, do_elif, <font class="stringliteral">"elif"</font>, T_ELIF, TRUE, FALSE, FALSE },
00493   {  5, do_undef, <font class="stringliteral">"undef"</font>, T_UNDEF, FALSE, FALSE, FALSE },
00494   {  5, do_error, <font class="stringliteral">"error"</font>, T_ERROR, FALSE, FALSE, FALSE },
00495   {  7, do_warning, <font class="stringliteral">"warning"</font>, T_WARNING, FALSE, FALSE, FALSE },
00496   {  6, do_pragma, <font class="stringliteral">"pragma"</font>, T_PRAGMA, FALSE, FALSE, TRUE},
00497   {  4, do_line, <font class="stringliteral">"line"</font>, T_LINE, TRUE, FALSE, FALSE },
00498   {  5, do_ident, <font class="stringliteral">"ident"</font>, T_IDENT, TRUE, FALSE, TRUE },
00499   <font class="comment">/* {  8, do_unassert, "unassert", T_UNASSERT, TRUE, FALSE, FALSE }, */</font>
00500   {  -1, 0, <font class="stringliteral">""</font>, T_UNUSED, FALSE, FALSE, FALSE },
00501 };
00502 
00503 <font class="comment">/*@noaccess cstring@*/</font>
00504 <font class="comment">/*@+charint@*/</font>
00505 
00506 <font class="keyword">static</font> <font class="keywordtype">void</font>
00507 initialize_char_syntax (<font class="keyword">struct</font> cppOptions *opts)<font class="keyword"></font>
00508 <font class="keyword"></font>{
00509   <font class="keywordtype">char</font> i;
00510 
00511   <font class="comment">/*</font>
00512 <font class="comment">   * Set up is_idchar and is_idstart tables.  These should be</font>
00513 <font class="comment">   * faster than saying (is_alpha (c) || c == '_'), etc.</font>
00514 <font class="comment">   * Set up these things before calling any routines tthat</font>
00515 <font class="comment">   * refer to them.</font>
00516 <font class="comment">   */</font>
00517 
00518   <font class="keywordflow">for</font> (i = <font class="charliteral">'a'</font>; i &lt;= <font class="charliteral">'z'</font>; i++) {
00519     is_idchar[i - <font class="charliteral">'a'</font> + <font class="charliteral">'A'</font>] = TRUE;
00520     is_idchar[(<font class="keywordtype">int</font>) i] = TRUE;
00521     is_idstart[i - <font class="charliteral">'a'</font> + <font class="charliteral">'A'</font>] = TRUE;
00522     is_idstart[(<font class="keywordtype">int</font>) i] = TRUE;
00523   }
00524 
00525   <font class="keywordflow">for</font> (i = <font class="charliteral">'0'</font>; i &lt;= <font class="charliteral">'9'</font>; i++)
00526     {
00527       is_idchar[(<font class="keywordtype">int</font>) i] = TRUE;
00528     }
00529 
00530   is_idchar[<font class="charliteral">'_'</font>] = TRUE;
00531   is_idstart[<font class="charliteral">'_'</font>] = TRUE;
00532   is_idchar[<font class="charliteral">'$'</font>] = opts-&gt;dollars_in_ident;
00533   is_idstart[<font class="charliteral">'$'</font>] = opts-&gt;dollars_in_ident;
00534 
00535   <font class="comment">/* horizontal space table */</font>
00536   is_hor_space[<font class="charliteral">' '</font>] = TRUE;
00537   is_hor_space[<font class="charliteral">'\t'</font>] = TRUE;
00538   is_hor_space[<font class="charliteral">'\v'</font>] = TRUE;
00539   is_hor_space[<font class="charliteral">'\f'</font>] = TRUE;
00540   is_hor_space[<font class="charliteral">'\r'</font>] = TRUE;
00541 
00542   is_space[<font class="charliteral">' '</font>] = TRUE;
00543   is_space[<font class="charliteral">'\t'</font>] = TRUE;
00544   is_space[<font class="charliteral">'\v'</font>] = TRUE;
00545   is_space[<font class="charliteral">'\f'</font>] = TRUE;
00546   is_space[<font class="charliteral">'\n'</font>] = TRUE;
00547   is_space[<font class="charliteral">'\r'</font>] = TRUE;
00548 }
00549 
<a name="l00550"></a><a class="code" href="cpplib_c.html#a106">00550</a> <font class="keywordtype">bool</font> <a class="code" href="cpplib_c.html#a106">isIdentifierChar</a> (<font class="keywordtype">char</font> c)<font class="keyword"></font>
00551 <font class="keyword"></font>{
00552   <font class="keywordflow">return</font> is_idchar[(<font class="keywordtype">int</font>) c];
00553 }
00554 
00555 <font class="comment">/* Place into P_PFILE a quoted string representing the string SRC.</font>
00556 <font class="comment">   Caller must reserve enough space in pfile-&gt;token_buffer.  */</font>
00557 
00558 <font class="keyword">static</font> <font class="keywordtype">void</font>
00559 quote_string (cppReader *pfile, <font class="keywordtype">char</font> *src)<font class="keyword"></font>
00560 <font class="keyword"></font>{
00561   <font class="keywordtype">char</font> c;
00562 
00563   <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'\"'</font>);
00564   <font class="keywordflow">for</font> (;;)
00565     {
00566       <font class="keywordflow">switch</font> ((c = *src++))
00567         {
00568         <font class="keywordflow">default</font>:
00569           <font class="keywordflow">if</font> (isprint (c))
00570             <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
00571           <font class="keywordflow">else</font>
00572             {
00573               sprintf (cppReader_getPWritten (pfile), <font class="stringliteral">"\\%03o"</font>,
00574                        (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) c);
00575               <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, (size_t) 4);
00576             }
00577           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00578 
00579         <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
00580         <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
00581           <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'\\'</font>);
00582           <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
00583           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00584 
00585         <font class="keywordflow">case</font> <font class="charliteral">'\0'</font>:
00586           <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'\"'</font>);
00587           <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
00588           <font class="keywordflow">return</font>;
00589         }
00590     }
00591 }
00592 
00593 <font class="comment">/* Re-allocates PFILE-&gt;token_buffer so it will hold at least N more chars.  */</font>
00594 
00595 <font class="keywordtype">void</font>
<a name="l00596"></a><a class="code" href="cpplib_c.html#a108">00596</a> <a class="code" href="cpplib_c.html#a108">cppReader_growBuffer</a> (cppReader *pfile, size_t n)<font class="keyword"></font>
00597 <font class="keyword"></font>{
00598   size_t old_written = cppReader_getWritten (pfile);
00599   pfile-&gt;token_buffer_size = n + 2 * pfile-&gt;token_buffer_size;
00600   pfile-&gt;token_buffer = (<font class="keywordtype">char</font> *)
00601     drealloc (pfile-&gt;token_buffer, pfile-&gt;token_buffer_size);
00602   cppReader_setWritten (pfile, old_written);
00603 }
00604 
00605 <font class="comment">/*</font>
00606 <font class="comment"> * process a given definition string, for initialization</font>
00607 <font class="comment"> * If STR is just an identifier, define it with value 1.</font>
00608 <font class="comment"> * If STR has anything after the identifier, then it should</font>
00609 <font class="comment"> * be identifier=definition.</font>
00610 <font class="comment"> */</font>
00611 
00612 <font class="keywordtype">void</font>
<a name="l00613"></a><a class="code" href="cpplib_c.html#a109">00613</a> <a class="code" href="cpplib_c.html#a109">cppReader_define</a> (cppReader *pfile, <font class="keywordtype">char</font> *str)<font class="keyword"></font>
00614 <font class="keyword"></font>{
00615   <font class="keywordtype">char</font> *buf = NULL;
00616   <font class="keywordtype">char</font> *p = str;
00617 
00618   DPRINTF ((<font class="stringliteral">"Cpp reader define: %s"</font>, str));
00619 
00620   <font class="keywordflow">if</font> (!is_idstart[(<font class="keywordtype">int</font>) *p])
00621     {
00622       DPRINTF ((<font class="stringliteral">"ERROR 1"</font>));
00623       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
00624                        message (<font class="stringliteral">"Malformed option `-D%s'"</font>,
00625                                 cstring_fromChars (str)));
00626       
00627       <font class="keywordflow">return</font>;
00628     }
00629 
00630   p++;
00631 
00632   DPRINTF ((<font class="stringliteral">"Here 2"</font>));
00633 
00634   <font class="keywordflow">while</font> (is_idchar[(<font class="keywordtype">int</font>) *p])
00635     {
00636       p++;
00637     }
00638 
00639   <font class="keywordflow">if</font> (*p == <font class="charliteral">'('</font>) {
00640     p++;
00641     <font class="keywordflow">while</font> (*p != <font class="charliteral">')'</font> &amp;&amp; *p != <font class="charliteral">'\0'</font>) {
00642       p++;
00643     }
00644 
00645     <font class="keywordflow">if</font> (*p == <font class="charliteral">')'</font>) {
00646       p++;
00647     } <font class="keywordflow">else</font> {
00648       cppReader_error 
00649         (pfile,
00650          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Malformed option: -D%s (no closing parenthesis)"</font>, 
00651                   cstring_fromChars (str)));
00652     }
00653   }
00654 
00655   DPRINTF ((<font class="stringliteral">"Here 2"</font>));
00656 
00657   <font class="keywordflow">if</font> (*p == <font class="charliteral">'\0'</font>)
00658     {
00659       buf = (<font class="keywordtype">char</font> *) dmalloc (size_fromInt (p - str + 4));
00660       strcpy ((<font class="keywordtype">char</font> *) buf, str);
00661       strcat ((<font class="keywordtype">char</font> *) buf, <font class="stringliteral">" 1"</font>);
00662     }
00663   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (*p != <font class="charliteral">'='</font>)
00664     {
00665       DPRINTF ((<font class="stringliteral">"ERROR 2"</font>));
00666       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
00667                        message (<font class="stringliteral">"Malformed option: -D%s (expected '=', found '%c')"</font>,
00668                                 cstring_fromChars (str),
00669                                 *p));
00670       <font class="keywordflow">return</font>;
00671     }
00672   <font class="keywordflow">else</font>
00673     {
00674       <font class="keywordtype">char</font> *q;
00675       <font class="comment">/* Copy the entire option so we can modify it.  */</font>
00676       DPRINTF ((<font class="stringliteral">"Copying..."</font>));
00677       buf = (<font class="keywordtype">char</font> *) dmalloc (2 * strlen (str) + 1);
00678       strncpy (buf, str, size_fromInt (p - str));
00679 
00680       <font class="comment">/* Change the = to a space.  */</font>
00681       buf[p - str] = <font class="charliteral">' '</font>;
00682       <font class="comment">/* Scan for any backslash-newline and remove it.  */</font>
00683       p++;
00684       q = &amp;buf[p - str];
00685 
00686       <font class="keywordflow">while</font> (*p != <font class="charliteral">'\0'</font>)
00687         {
00688           <font class="keywordflow">if</font> (*p == <font class="charliteral">'\\'</font> &amp;&amp; p[1] == <font class="charliteral">'\n'</font>)
00689             p += 2;
00690           <font class="keywordflow">else</font>
00691             *q++ = *p++;
00692         }
00693 
00694       DPRINTF ((<font class="stringliteral">"Here we are..."</font>));
00695       *q = <font class="charliteral">'\0'</font>;
00696     }
00697 
00698   llassert (buf != NULL);
00699   DPRINTF ((<font class="stringliteral">"Do define: %s / %ld"</font>, buf, size_toLong (strlen (buf))));
00700   (<font class="keywordtype">void</font>) do_define (pfile, NULL, buf, buf + strlen (buf));
00701   <a class="code" href="general_c.html#a0">sfree</a> (buf);
00702 }
00703 
00704 <font class="comment">/* Append a chain of `struct file_name_list's</font>
00705 <font class="comment">   to the end of the main include chain.</font>
00706 <font class="comment">   FIRST is the beginning of the chain to append, and LAST is the end.  */</font>
00707 
00708 <font class="keywordtype">void</font>
00709 cppReader_appendIncludeChain (cppReader *pfile,
00710                       <font class="keyword">struct</font> file_name_list *first,
00711                       <font class="keyword">struct</font> file_name_list *last)<font class="keyword"></font>
00712 <font class="keyword"></font>{
00713   <font class="keyword">struct </font>cppOptions *opts = CPPOPTIONS (pfile);
00714   <font class="keyword">struct </font>file_name_list *dir;
00715 
00716   <font class="keywordflow">if</font> (first == NULL || last == NULL)
00717     {
00718       <font class="keywordflow">return</font>;
00719     }
00720 
00721   <font class="keywordflow">if</font> (opts-&gt;include == 0)
00722     {
00723       opts-&gt;include = first;
00724     }
00725   <font class="keywordflow">else</font>
00726     {
00727       llassert (opts-&gt;last_include-&gt;next == NULL);
00728       opts-&gt;last_include-&gt;next = first;
00729     }
00730 
00731   <font class="keywordflow">if</font> (opts-&gt;first_bracket_include == 0)
00732     {
00733       opts-&gt;first_bracket_include = first;
00734 
00735       <font class="keywordflow">for</font> (dir = first; ; dir = dir-&gt;next) {
00736         <font class="keywordtype">int</font> len = <a class="code" href="cstring_c.html#a30">cstring_length</a> (dir-&gt;fname) + INCLUDE_LEN_FUDGE;
00737         <font class="keywordflow">if</font> (len &gt; pfile-&gt;max_include_len)
00738           pfile-&gt;max_include_len = len;
00739         <font class="keywordflow">if</font> (dir == last)
00740           <font class="keywordflow">break</font>;
00741       }
00742     }
00743 
00744   llassert (last-&gt;next == NULL);
00745   <font class="comment">/* last-&gt;next = NULL; */</font>
00746   opts-&gt;last_include = last;
00747 }
00748 
00749 <font class="keyword">static</font> <font class="comment">/*@unused@*/</font> <font class="keywordtype">void</font> 
00750 cppReader_showIncludeChain (cppReader *pfile)<font class="keyword"></font>
00751 <font class="keyword"></font>{
00752   <font class="keyword">struct </font>file_name_list *dirs = CPPOPTIONS (pfile)-&gt;include;
00753 
00754   <font class="keywordflow">if</font> (dirs != NULL)
00755     {
00756       <font class="keywordflow">while</font> (dirs != NULL)
00757         {
00758           fprintf (stderr, <font class="stringliteral">"*%s*:"</font>, cstring_toCharsSafe (dirs-&gt;fname));
00759           dirs = dirs-&gt;next;
00760         }
00761 
00762       fprintf (stderr, <font class="stringliteral">"\n"</font>);
00763     }
00764   <font class="keywordflow">else</font>
00765     {
00766       fprintf (stderr, <font class="stringliteral">"No includes\n"</font>);
00767     }
00768 }
00769 
00770 <font class="keywordtype">void</font>
<a name="l00771"></a><a class="code" href="cpplib_c.html#a111">00771</a> <a class="code" href="cpplib_c.html#a111">cppReader_addIncludeChain</a> (cppReader *pfile, <font class="keyword">struct</font> file_name_list *dir)<font class="keyword"></font>
00772 <font class="keyword"></font>{
00773   <font class="keyword">struct </font>cppOptions *opts = CPPOPTIONS (pfile);
00774 
00775   <font class="keywordflow">if</font> (dir == 0)
00776     {
00777       <font class="keywordflow">return</font>;
00778     }
00779 
00780   <font class="keywordflow">if</font> (opts-&gt;include == 0)
00781     {
00782       opts-&gt;include = dir;
00783     }
00784   <font class="keywordflow">else</font>
00785     {
00786       llassert (opts-&gt;last_include-&gt;next == NULL);
00787       opts-&gt;last_include-&gt;next = dir;
00788     }
00789 
00790   <font class="keywordflow">if</font> (opts-&gt;first_bracket_include == 0)
00791     {
00792       <font class="keywordtype">int</font> len = <a class="code" href="cstring_c.html#a30">cstring_length</a> (dir-&gt;fname) + INCLUDE_LEN_FUDGE;
00793       opts-&gt;first_bracket_include = dir;
00794       <font class="keywordflow">if</font> (len &gt; pfile-&gt;max_include_len)
00795         {
00796           pfile-&gt;max_include_len = len;
00797         }
00798     }
00799 
00800   dir-&gt;next = NULL;
00801   opts-&gt;last_include = dir;
00802   <font class="comment">/* cppReader_showIncludeChain (pfile); */</font>
00803 }
00804 
00805 <font class="comment">/* Given a colon-separated list of file names PATH,</font>
00806 <font class="comment">   add all the names to the search path for include files.  */</font>
00807 
00808 <font class="keyword">static</font> <font class="keywordtype">void</font>
00809 path_include (cppReader *pfile, <font class="keywordtype">char</font> *path)<font class="keyword"></font>
00810 <font class="keyword"></font>{
00811   <font class="keywordtype">char</font> *p;
00812 
00813 <font class="preprocessor">#ifdef __CYGWIN32__</font>
00814 <font class="preprocessor"></font>  <font class="keywordtype">char</font> *win32temp;
00815 
00816   <font class="comment">/* if we have a posix path list, convert to win32 path list */</font>
00817   win32temp = (<font class="keywordtype">char</font> *) dmalloc <font class="comment">/*@i4@*/</font>
00818     (cygwin32_posix_to_win32_path_list_buf_size (path));
00819   cygwin32_posix_to_win32_path_list (path, win32temp);
00820   path = win32temp;
00821 <font class="preprocessor">#endif</font>
00822 <font class="preprocessor"></font>
00823   p = path;
00824 
00825   <font class="keywordflow">if</font> (*p != <font class="charliteral">'\0'</font>)
00826     <font class="keywordflow">while</font> (1) {
00827       <font class="keywordtype">char</font> *q = p;
00828       <font class="keywordtype">char</font> *name;
00829       <font class="keyword">struct </font>file_name_list *dirtmp;
00830 
00831       <font class="comment">/* Find the end of this name.  */</font>
00832       <font class="keywordflow">while</font> (*q != <font class="charliteral">'\0'</font> &amp;&amp; *q != PATH_SEPARATOR)
00833         {
00834           q++;
00835         }
00836 
00837       <font class="keywordflow">if</font> (p == q)
00838         {
00839           <font class="comment">/* An empty name in the path stands for the current directory.  */</font>
00840           name = (<font class="keywordtype">char</font> *) dmalloc ((size_t) 2);
00841           name[0] = <font class="charliteral">'.'</font>;
00842           name[1] = <font class="charliteral">'\0'</font>;
00843         }
00844       <font class="keywordflow">else</font>
00845         {
00846           <font class="comment">/* Otherwise use the directory that is named.  */</font>
00847           name = (<font class="keywordtype">char</font> *) dmalloc (size_fromInt (q - p + 1));
00848           memcpy (name, p, size_fromInt (q - p));
00849           name[q - p] = <font class="charliteral">'\0'</font>;
00850         }
00851 
00852       dirtmp = (<font class="keyword">struct </font>file_name_list *) dmalloc (sizeof (*dirtmp));
00853       dirtmp-&gt;next = 0;         <font class="comment">/* New one goes on the end */</font>
00854       dirtmp-&gt;control_macro = 0;
00855       dirtmp-&gt;c_system_include_path = 0;
00856       dirtmp-&gt;fname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (name);
00857       dirtmp-&gt;got_name_map = 0;
00858       <a class="code" href="cpplib_c.html#a111">cppReader_addIncludeChain</a> (pfile, dirtmp);
00859 
00860       <font class="comment">/* Advance past this name.  */</font>
00861       p = q;
00862       <font class="keywordflow">if</font> (*p == <font class="charliteral">'\0'</font>)
00863         <font class="keywordflow">break</font>;
00864       <font class="comment">/* Skip the colon.  */</font>
00865       p++;
00866     }
00867 }
00868 
00869 <font class="keywordtype">void</font>
<a name="l00870"></a><a class="code" href="cpplib_c.html#a112">00870</a> <a class="code" href="cpplib_c.html#a112">cppOptions_init</a> (cppOptions *opts)<font class="keyword"></font>
00871 <font class="keyword"></font>{
00872   memset ((<font class="keywordtype">char</font> *) opts, 0, <font class="keyword">sizeof</font> *opts);
00873   assertSet (opts);
00874 
00875   opts-&gt;in_fname = NULL;
00876   opts-&gt;out_fname = NULL;
00877 
00878   <font class="comment">/* Initialize is_idchar to allow $.  */</font>
00879   opts-&gt;dollars_in_ident = TRUE;
00880 
00881   opts-&gt;no_line_commands = 0;
00882   opts-&gt;no_trigraphs = TRUE;
00883   opts-&gt;put_out_comments = 1;
00884   opts-&gt;print_include_names = 0;
00885   opts-&gt;dump_macros = DUMP_DEFINITIONS; <font class="comment">/* DUMP_NONE; */</font>
00886   opts-&gt;no_output = 0;
00887   opts-&gt;cplusplus = 0;
00888 
00889   opts-&gt;cplusplus_comments = 1;
00890   opts-&gt;verbose = 0;
00891   opts-&gt;lang_asm = 0;
00892   opts-&gt;for_lint = 0;
00893   opts-&gt;chill = 0;
00894   opts-&gt;pedantic_errors = 0;
00895   opts-&gt;inhibit_warnings = 0;
00896   opts-&gt;warn_comments = 0;
00897   opts-&gt;warnings_are_errors = 0;
00898 
00899   initialize_char_syntax (opts);
00900 }
00901 
00902 <font class="keyword">enum</font> cpp_token
00903 cppReader_nullUnderflow (<font class="comment">/*@unused@*/</font> cppReader *pfile)<font class="keyword"></font>
00904 <font class="keyword"></font>{
00905   <font class="keywordflow">return</font> CPP_EOF;
00906 }
00907 
00908 <font class="keywordtype">void</font>
00909 cppReader_nullCleanup (<font class="comment">/*@unused@*/</font> cppBuffer *pbuf,
00910               <font class="comment">/*@unused@*/</font> cppReader *pfile)<font class="keyword"></font>
00911 <font class="keyword"></font>{
00912   ;
00913 }
00914 
00915 <font class="keywordtype">void</font>
00916 cppReader_macroCleanup (cppBuffer *pbuf, <font class="comment">/*@unused@*/</font> cppReader *pfile)<font class="keyword"></font>
00917 <font class="keyword"></font>{
00918   HASHNODE *macro = pbuf-&gt;hnode;
00919 
00920   <font class="keywordflow">if</font> (macro-&gt;type == T_DISABLED)
00921     {
00922       macro-&gt;type = T_MACRO;
00923     }
00924 
00925   <font class="keywordflow">if</font> (macro-&gt;type != T_MACRO || pbuf-&gt;buf != macro-&gt;value.defn-&gt;expansion)
00926     {
00927       <a class="code" href="general_c.html#a0">sfree</a> (pbuf-&gt;buf);
00928       pbuf-&gt;buf = NULL;
00929     }
00930 }
00931 
00932 <font class="keywordtype">void</font>
00933 cppReader_fileCleanup (cppBuffer *pbuf, <font class="comment">/*@unused@*/</font> cppReader *pfile)<font class="keyword"></font>
00934 <font class="keyword"></font>{
00935   <font class="keywordflow">if</font> (pbuf-&gt;buf != NULL)
00936     {
00937       <a class="code" href="general_c.html#a0">sfree</a> (pbuf-&gt;buf);
00938       pbuf-&gt;buf = NULL;
00939     }
00940 }
00941 
00942 <font class="comment">/* Assuming we have read '/'.</font>
00943 <font class="comment">   If this is the start of a comment (followed by '*' or '/'),</font>
00944 <font class="comment">   skip to the end of the comment, and return ' '.</font>
00945 <font class="comment">   Return EOF if we reached the end of file before the end of the comment.</font>
00946 <font class="comment">   If not the start of a comment, return '/'.  */</font>
00947 
00948 <font class="keyword">static</font> <font class="keywordtype">int</font>
00949 skip_comment (cppReader *pfile, <font class="comment">/*@null@*/</font> <font class="keywordtype">long</font> *linep)<font class="keyword"></font>
00950 <font class="keyword"></font>{
00951   <font class="keywordtype">int</font> c = 0;
00952 
00953   llassert (pfile-&gt;buffer != NULL);
00954   llassert (pfile-&gt;buffer-&gt;cur != NULL);
00955 
00956   <font class="keywordflow">while</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\\'</font> &amp;&amp; cpp_peekN (pfile, 1) == <font class="charliteral">'\n'</font>)
00957     {
00958       <font class="keywordflow">if</font> (linep != NULL)
00959         {
00960           (*linep)++;
00961         }
00962 
00963       <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 2);
00964     }
00965 
00966   <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'*'</font>)
00967     {
00968       <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
00969 
00970       <font class="keywordflow">for</font> (;;)
00971         {
00972           <font class="keywordtype">int</font> prev_c = c;
00973           c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
00974 
00975           <font class="keywordflow">if</font> (c == EOF)
00976             {
00977               <font class="keywordflow">return</font> EOF;
00978             }
00979 
00980           <font class="keywordflow">while</font> (c == (<font class="keywordtype">int</font>) <font class="charliteral">'\\'</font> &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == (<font class="keywordtype">int</font>) <font class="charliteral">'\n'</font>)
00981             {
00982               <font class="keywordflow">if</font> (linep != NULL )
00983                 {
00984                   (*linep)++;
00985                 }
00986 
00987               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1), c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
00988             }
00989 
00990           <font class="keywordflow">if</font> (prev_c == (<font class="keywordtype">int</font>) <font class="charliteral">'*'</font> &amp;&amp; c == (<font class="keywordtype">int</font>) <font class="charliteral">'/'</font>)
00991             {
00992               <font class="keywordflow">return</font> (<font class="keywordtype">int</font>) <font class="charliteral">' '</font>;
00993             }
00994 
00995           <font class="keywordflow">if</font> (c == (<font class="keywordtype">int</font>) <font class="charliteral">'\n'</font> &amp;&amp; (linep != NULL))
00996             {
00997               (*linep)++;
00998             }
00999         }
01000     }
01001   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'/'</font> 
01002            &amp;&amp; CPPOPTIONS (pfile)-&gt;cplusplus_comments)
01003     {
01004       <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
01005 
01006       <font class="keywordflow">for</font> (;;)
01007         {
01008           c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
01009 
01010           <font class="keywordflow">if</font> (c == EOF)
01011             {
01012               <font class="comment">/* Allow hash comment to be terminated by EOF.  */</font>
01013               <font class="keywordflow">return</font> (<font class="keywordtype">int</font>) <font class="charliteral">' '</font>; 
01014             }
01015 
01016           <font class="keywordflow">while</font> (c == (<font class="keywordtype">int</font>) <font class="charliteral">'\\'</font> &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
01017             {
01018               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
01019               c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
01020 
01021               <font class="keywordflow">if</font> (linep != NULL)
01022                 {
01023                   (*linep)++;
01024                 }
01025             }
01026 
01027           <font class="keywordflow">if</font> (c == (<font class="keywordtype">int</font>) <font class="charliteral">'\n'</font>)
01028             {
01029               <font class="comment">/* Don't consider final '\n' to be part of comment.  */</font>
01030               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
01031               <font class="keywordflow">return</font> (<font class="keywordtype">int</font>) <font class="charliteral">' '</font>;
01032             }
01033         }
01034     }
01035   <font class="keywordflow">else</font>
01036     {
01037       <font class="keywordflow">return</font> (<font class="keywordtype">int</font>) <font class="charliteral">'/'</font>;
01038     }
01039 }
01040 
01041 <font class="comment">/* Skip whitespace \-newline and comments.  Does not macro-expand.  */</font>
01042 <font class="keywordtype">int</font> <font class="comment">/*@alt void@*/</font>
<a name="l01043"></a><a class="code" href="cpplib_c.html#a114">01043</a> <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (cppReader *pfile)<font class="keyword"></font>
01044 <font class="keyword"></font>{
01045   <font class="keywordtype">int</font> nspaces = 0;
01046 
01047   <font class="keywordflow">while</font> (TRUE)
01048     {
01049       <font class="keywordtype">int</font> c;
01050 
01051       llassert (pfile-&gt;buffer != NULL);
01052 
01053       c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
01054 
01055       <font class="keywordflow">if</font> (c == EOF)
01056         {
01057           <font class="keywordflow">return</font> 0; <font class="comment">/* FIXME */</font>
01058         }
01059 
01060       <font class="keywordflow">if</font> (is_hor_space[c])
01061         {
01062           <font class="keywordflow">if</font> ((c == <font class="charliteral">'\f'</font> || c == <font class="charliteral">'\v'</font>) &amp;&amp; cppReader_isPedantic (pfile))
01063             <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
01064                          message (<font class="stringliteral">"%s in preprocessing directive"</font>,
01065                                   c == <font class="charliteral">'\f'</font>
01066                                   ? cstring_makeLiteralTemp (<font class="stringliteral">"formfeed"</font>)
01067                                   : cstring_makeLiteralTemp (<font class="stringliteral">"vertical tab"</font>)));
01068 
01069           nspaces++;
01070           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
01071         }
01072       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c == <font class="charliteral">'/'</font>)
01073         {
01074           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
01075           c = skip_comment (pfile, NULL);
01076 
01077           <font class="keywordflow">if</font> (c == <font class="charliteral">'/'</font>)
01078             {
01079               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
01080             }
01081 
01082           <font class="keywordflow">if</font> (c == EOF || c == <font class="charliteral">'/'</font>)
01083             {
01084               <font class="keywordflow">return</font> nspaces;
01085             }
01086         }
01087       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c == <font class="charliteral">'\\'</font> &amp;&amp; cpp_peekN (pfile, 1) == <font class="charliteral">'\n'</font>)
01088         {
01089           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 2);
01090         }
01091       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c == <font class="charliteral">'@'</font> &amp;&amp; CPPBUFFER (pfile)-&gt;has_escapes
01092                &amp;&amp; is_hor_space [cpp_peekN (pfile, 1)])
01093         {
01094           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 2);
01095         }
01096       <font class="keywordflow">else</font>
01097         {
01098           <font class="keywordflow">return</font> nspaces;
01099         }
01100     }
01101 }
01102 
01103 <font class="comment">/* Read the rest of the current line.</font>
01104 <font class="comment">   The line is appended to PFILE's output buffer.  */</font>
01105 
01106 <font class="keyword">static</font> <font class="keywordtype">void</font>
01107 copy_rest_of_line (cppReader *pfile)<font class="keyword"></font>
01108 <font class="keyword"></font>{
01109   <font class="keyword">struct </font>cppOptions *opts = CPPOPTIONS (pfile);
01110 
01111   <font class="keywordflow">for</font> (;;)
01112     {
01113       <font class="keywordtype">int</font> c;
01114       <font class="keywordtype">int</font> nextc;
01115 
01116       llassert (pfile-&gt;buffer != NULL);
01117 
01118       c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
01119       <font class="keywordflow">switch</font> (c)
01120         {
01121         <font class="keywordflow">case</font> EOF:
01122           <font class="keywordflow">goto</font> end_directive;
01123         <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
01124           <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
01125             {
01126               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
01127               <font class="keywordflow">continue</font>;
01128             }
01129 
01130         <font class="comment">/*@fallthrough@*/</font> <font class="keywordflow">case</font> <font class="charliteral">'\''</font>: <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
01131           <font class="keywordflow">goto</font> scan_directive_token;
01132 
01133         <font class="keywordflow">case</font> <font class="charliteral">'/'</font>:
01134           nextc = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
01135 
01136           <font class="comment">/*</font>
01137 <font class="comment">          ** was (opts-&gt;cplusplus_comments &amp;&amp; nextc == '*')</font>
01138 <font class="comment">          ** yoikes!</font>
01139 <font class="comment">          */</font>
01140 
01141           <font class="keywordflow">if</font> (nextc == <font class="charliteral">'*'</font>
01142               || (opts-&gt;cplusplus_comments &amp;&amp; nextc == <font class="charliteral">'/'</font>))
01143             {
01144               <font class="keywordflow">goto</font> scan_directive_token;
01145             }
01146           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01147         <font class="keywordflow">case</font> <font class="charliteral">'\f'</font>:
01148         <font class="keywordflow">case</font> <font class="charliteral">'\v'</font>:
01149           <font class="keywordflow">if</font> (cppReader_isPedantic (pfile))
01150             <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
01151                          message (<font class="stringliteral">"%s in preprocessing directive"</font>,
01152                                   c == <font class="charliteral">'\f'</font>
01153                                   ? cstring_makeLiteralTemp (<font class="stringliteral">"formfeed"</font>)
01154                                   : cstring_makeLiteralTemp ("vertical tab")));
01155           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01156 
01157         <font class="keywordflow">case</font> <font class="charliteral">'\n'</font>:
01158           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
01159           <font class="keywordflow">goto</font> end_directive;
01160         scan_directive_token:
01161           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
01162           (<font class="keywordtype">void</font>) <a class="code" href="cpplib_c.html#a141">cppGetToken</a> (pfile);
01163           <font class="keywordflow">continue</font>;
01164         }
01165       <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
01166     }
01167 end_directive: ;
01168   <a class="code" href="cpplib_c.html#a19">cppReader_nullTerminate</a> (pfile);
01169 }
01170 
01171 <font class="keywordtype">void</font>
<a name="l01172"></a><a class="code" href="cpplib_c.html#a116">01172</a> <a class="code" href="cpplib_c.html#a116">cppReader_skipRestOfLine</a> (cppReader *pfile)<font class="keyword"></font>
01173 <font class="keyword"></font>{
01174   size_t old = cppReader_getWritten (pfile);
01175   copy_rest_of_line (pfile);
01176   cppReader_setWritten (pfile, old);
01177 }
01178 
01179 <font class="comment">/* Handle a possible # directive.</font>
01180 <font class="comment">   '#' has already been read.  */</font>
01181 
01182 <font class="keywordtype">int</font>
01183 cppReader_handleDirective (cppReader *pfile)<font class="keyword"></font>
01184 <font class="keyword"></font>{
01185   <font class="keywordtype">int</font> c;
01186   <font class="keyword">struct </font><a class="code" href="struct_directive.html">directive</a> *kt = NULL;
01187   <font class="keywordtype">int</font> ident_length;
01188   size_t after_ident = 0;
01189   <font class="keywordtype">char</font> *ident, *line_end = NULL;
01190   size_t old_written = cppReader_getWritten (pfile);
01191   <font class="keywordtype">int</font> nspaces = <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
01192 
01193   c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
01194 
01195   <font class="keywordflow">if</font> (c &gt;= <font class="charliteral">'0'</font> &amp;&amp; c &lt;= <font class="charliteral">'9'</font>)
01196     {
01197       <font class="comment">/* Handle # followed by a line number.  */</font>
01198       <font class="keywordflow">if</font> (cppReader_isPedantic (pfile))
01199         {
01200           cppReader_pedwarnLit
01201             (pfile,
01202              cstring_makeLiteralTemp (<font class="stringliteral">"`#' followed by integer"</font>));
01203         }
01204 
01205       (<font class="keywordtype">void</font>) do_line (pfile, NULL);
01206       <font class="keywordflow">goto</font> done_a_directive;
01207     }
01208 
01209 
01210   <font class="comment">/* Now find the directive name.  */</font>
01211 
01212   <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">'#'</font>);
01213 
01214   parse_name (pfile, cppReader_getC (pfile));
01215 
01216   llassert (pfile-&gt;token_buffer != NULL);
01217   ident = pfile-&gt;token_buffer + old_written + 1;
01218 
01219   ident_length = cppReader_getPWritten (pfile) - ident;
01220 
01221   <font class="keywordflow">if</font> (ident_length == 0 &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
01222     {
01223       <font class="comment">/* A line of just `#' becomes blank.  */</font>
01224       <font class="keywordflow">return</font> 1; 
01225     }
01226 
01227   <font class="keywordflow">for</font> (kt = directive_table; ; kt++) 
01228     {
01229       <font class="keywordflow">if</font> (kt-&gt;length &lt;= 0)
01230         {
01231           <font class="keywordflow">return</font> 0; <font class="comment">/* goto not_a_directive; */</font>
01232         }
01233 
01234       <font class="keywordflow">if</font> (kt-&gt;length == ident_length
01235           &amp;&amp; (<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (kt-&gt;name, ident)))
01236         {
01237           <font class="keywordflow">break</font>;
01238         }
01239     }
01240 
01241   <font class="keywordflow">if</font> (kt-&gt;command_reads_line)
01242     {
01243       after_ident = 0;
01244     }
01245   <font class="keywordflow">else</font>
01246     {
01247       <font class="comment">/* Nonzero means do not delete comments within the directive.</font>
01248 <font class="comment">         #define needs this when -traditional.  */</font>
01249       <font class="keywordtype">bool</font> comments = 1; <font class="comment">/*cppReader_isTraditional (pfile) &amp;&amp; kt-&gt;traditional_comments;  */</font>
01250       <font class="keywordtype">int</font> save_put_out_comments = CPPOPTIONS (pfile)-&gt;put_out_comments;
01251       CPPOPTIONS (pfile)-&gt;put_out_comments = comments;
01252       after_ident = cppReader_getWritten (pfile);
01253       copy_rest_of_line (pfile);
01254       CPPOPTIONS (pfile)-&gt;put_out_comments = save_put_out_comments;
01255     }
01256 
01257 
01258   <font class="comment">/* For #pragma and #define, we may want to pass through the directive.</font>
01259 <font class="comment">     Other directives may create output, but we don't want the directive</font>
01260 <font class="comment">     itself out, so we pop it now.  For example #include may write a #line</font>
01261 <font class="comment">     command (see comment in do_include), and conditionals may emit</font>
01262 <font class="comment">     #failed ... #endfailed stuff.  But note that popping the buffer</font>
01263 <font class="comment">     means the parameters to kt-&gt;func may point after pfile-&gt;limit</font>
01264 <font class="comment">     so these parameters are invalid as soon as something gets appended</font>
01265 <font class="comment">     to the token_buffer.  */</font>
01266 
01267   line_end = cppReader_getPWritten (pfile);
01268 
01269 
01270   <font class="keywordflow">if</font> (!kt-&gt;pass_thru &amp;&amp; kt-&gt;type != T_DEFINE)
01271     {
01272       cppReader_setWritten (pfile, old_written);
01273     }
01274 
01275   llassert (pfile-&gt;token_buffer != NULL);
01276 
01277   <font class="comment">/* was kt-&gt;pass_thru || */</font>
01278 
01279   <font class="keywordflow">if</font> (kt-&gt;type == T_DEFINE
01280       &amp;&amp; cpp_shouldCheckMacro (pfile, pfile-&gt;token_buffer + old_written))
01281     {
01282       <font class="keywordtype">char</font> *p = pfile-&gt;token_buffer + old_written;
01283 
01284       <font class="comment">/*</font>
01285 <font class="comment">      ** Still need to record value for preprocessing, so </font>
01286 <font class="comment">      ** #ifdef's, etc. using the value behave correctly.</font>
01287 <font class="comment">      */</font>
01288       
01289       (<font class="keywordtype">void</font>) do_defineAux (pfile, kt, 
01290                            pfile-&gt;token_buffer + after_ident,
01291                            line_end,
01292                            TRUE);
01293       
01294       <font class="keywordflow">if</font> (*p == <font class="charliteral">'#'</font>)
01295         {
01296           *p = <font class="charliteral">' '</font>;
01297         }
01298 
01299       <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (p);
01300 
01301       llassert (*p == <font class="charliteral">'d'</font>);
01302       *p++ = LLMRCODE[0];
01303 
01304       llassert (*p == <font class="charliteral">'e'</font>);
01305       *p++ = LLMRCODE[1];
01306 
01307       llassert (*p == <font class="charliteral">'f'</font>);
01308       *p++ = LLMRCODE[2];
01309 
01310       llassert (*p == <font class="charliteral">'i'</font>);
01311       *p++ = LLMRCODE[3];
01312 
01313       llassert (*p == <font class="charliteral">'n'</font>);
01314       *p++ = LLMRCODE[4];
01315 
01316       llassert (*p == <font class="charliteral">'e'</font>);
01317 
01318       <font class="comment">/*</font>
01319 <font class="comment">      ** This is way-bogus.  We use the last char to record the number of</font>
01320 <font class="comment">      ** spaces.  Its too hard to get them back into the input stream.</font>
01321 <font class="comment">      */</font>
01322 
01323       <font class="keywordflow">if</font> (nspaces &gt; 9) nspaces = 9;
01324 
01325       *p++ = <font class="charliteral">'0'</font> + nspaces;
01326 
01327       <font class="keywordflow">return</font> 0; <font class="comment">/* not_a_directive */</font>
01328     }
01329   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (kt-&gt;pass_thru)
01330     {
01331       <font class="comment">/* Just leave the entire #define in the output stack.  */</font>
01332       <font class="keywordflow">return</font> 0; <font class="comment">/* not_a_directive */</font>
01333 
01334     }
01335   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (kt-&gt;type == T_DEFINE
01336            &amp;&amp; CPPOPTIONS (pfile)-&gt;dump_macros == DUMP_NAMES)
01337     {
01338       <font class="keywordtype">char</font> *p = pfile-&gt;token_buffer + old_written + 7;  <font class="comment">/* Skip "#define". */</font>
01339       <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (p);
01340 
01341       <font class="keywordflow">while</font> (is_idchar[(<font class="keywordtype">int</font>) *p])
01342         {
01343           p++;
01344         }
01345 
01346       pfile-&gt;limit = p;
01347       <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">'\n'</font>);
01348     }
01349   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (kt-&gt;type == T_DEFINE)
01350     {
01351       cppReader_setWritten (pfile, old_written);
01352     }
01353   <font class="keywordflow">else</font>
01354     {
01355       ;
01356     }
01357 
01358 done_a_directive:
01359   <font class="keywordflow">if</font> (kt == NULL) {
01360     <font class="keywordflow">return</font> 1;
01361   } <font class="keywordflow">else</font> {
01362     llassert (kt-&gt;func != NULL);
01363     (<font class="keywordtype">void</font>) (kt-&gt;func) (pfile, kt, pfile-&gt;token_buffer + after_ident, line_end);
01364     <font class="keywordflow">return</font> 1;
01365   }
01366 }
01367 
01368 <font class="comment">/* Pass a directive through to the output file.</font>
01369 <font class="comment">   BUF points to the contents of the directive, as a contiguous string.</font>
01370 <font class="comment">   LIMIT points to the first character past the end of the directive.</font>
01371 <font class="comment">   KEYWORD is the keyword-table entry for the directive.  */</font>
01372 
01373 <font class="keyword">static</font> <font class="keywordtype">void</font>
01374 pass_thru_directive (<font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit,
01375                      cppReader *pfile,
01376                      <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword)<font class="keyword"></font>
01377 <font class="keyword"></font>{
01378   <font class="keywordtype">int</font> keyword_length = keyword-&gt;length;
01379 
01380   cppReader_reserve (pfile,
01381                      size_fromInt (2 + keyword_length + (limit - buf)));
01382   <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'#'</font>);
01383   <font class="comment">/*@-observertrans@*/</font>
01384   cppReader_putStrN (pfile, cstring_toCharsSafe (keyword-&gt;name),
01385                      <a class="code" href="general_c.html#a33">size_fromInt</a> (keyword_length));
01386   <font class="comment">/*:=observertrans@*/</font>
01387 
01388   <font class="keywordflow">if</font> (limit != buf &amp;&amp; buf[0] != <font class="charliteral">' '</font>)
01389     {
01390       <font class="comment">/* Was a bug, since reserve only used 1 + ... */</font>
01391       <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">' '</font>);
01392     }
01393 
01394   cppReader_putStrN (pfile, buf, size_fromInt (limit - buf));
01395 }
01396 
01397 <font class="comment">/* Read a replacement list for a macro with parameters.</font>
01398 <font class="comment">   Build the DEFINITION structure.</font>
01399 <font class="comment">   Reads characters of text starting at BUF until END.</font>
01400 <font class="comment">   ARGLIST specifies the formal parameters to look for</font>
01401 <font class="comment">   in the text of the definition; NARGS is the number of args</font>
01402 <font class="comment">   in that list, or -1 for a macro name that wants no argument list.</font>
01403 <font class="comment">   MACRONAME is the macro name itself (so we can avoid recursive expansion)</font>
01404 <font class="comment">   and NAMELEN is its length in characters.</font>
01405 <font class="comment"></font>
01406 <font class="comment">   Note that comments, backslash-newlines, and leading white space</font>
01407 <font class="comment">   have already been deleted from the argument.  */</font>
01408 
01409 <font class="keyword">static</font> DEFINITION *
01410 collect_expansion (cppReader *pfile, <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit,
01411                    <font class="keywordtype">int</font> nargs, <font class="comment">/*@null@*/</font> <font class="keyword">struct</font> arglist *arglist)<font class="keyword"></font>
01412 <font class="keyword"></font>{
01413   DEFINITION *defn;
01414   <font class="keywordtype">char</font> *p, *lastp, *exp_p;
01415   <font class="keyword">struct </font>reflist *endpat = NULL;
01416   <font class="comment">/* Pointer to first nonspace after last ## seen.  */</font>
01417   <font class="keywordtype">char</font> *concat = 0;
01418   <font class="comment">/* Pointer to first nonspace after last single-# seen.  */</font>
01419   <font class="keywordtype">char</font> *stringify = 0;
01420   size_t maxsize;
01421   <font class="keywordtype">char</font> expected_delimiter = <font class="charliteral">'\0'</font>;
01422 
01423 
01424   <font class="comment">/* Scan thru the replacement list, ignoring comments and quoted</font>
01425 <font class="comment">     strings, picking up on the macro calls.  It does a linear search</font>
01426 <font class="comment">     thru the arg list on every potential symbol.  Profiling might say</font>
01427 <font class="comment">     that something smarter should happen.  */</font>
01428 
01429   <font class="keywordflow">if</font> (limit &lt; buf)
01430     abort ();
01431 
01432   <font class="comment">/* Find the beginning of the trailing whitespace.  */</font>
01433   p = buf;
01434 
01435   <font class="keywordflow">while</font> (p &lt; limit &amp;&amp; is_space[(<font class="keywordtype">int</font>) limit[-1]])
01436     {
01437       limit--;
01438     }
01439 
01440   <font class="comment">/* Allocate space for the text in the macro definition.</font>
01441 <font class="comment">     Leading and trailing whitespace chars need 2 bytes each.</font>
01442 <font class="comment">     Each other input char may or may not need 1 byte,</font>
01443 <font class="comment">     so this is an upper bound.  The extra 5 are for invented</font>
01444 <font class="comment">     leading and trailing newline-marker and final null.  */</font>
01445   maxsize = (<font class="keyword">sizeof</font> (*defn) + (limit - p) + 5);
01446 
01447   <font class="comment">/* Occurrences of '@' get doubled, so allocate extra space for them.  */</font>
01448   <font class="keywordflow">while</font> (p &lt; limit)
01449     {
01450       <font class="keywordflow">if</font> (*p++ == <font class="charliteral">'@'</font>)
01451         {
01452           maxsize++;
01453         }
01454     }
01455 
01456   defn = (DEFINITION *) dmalloc (maxsize);
01457   defn-&gt;noExpand = FALSE;
01458   defn-&gt;file = NULL;
01459   defn-&gt;pattern = NULL;
01460   defn-&gt;nargs = nargs;
01461   defn-&gt;predefined = NULL;
01462 
01463   exp_p = defn-&gt;expansion = (<font class="keywordtype">char</font> *) defn + <font class="keyword">sizeof</font> (*defn);
01464 
01465   defn-&gt;line = 0;
01466   defn-&gt;rest_args = NULL;
01467   defn-&gt;args.argnames = NULL;
01468 
01469   lastp = exp_p;
01470 
01471   p = buf;
01472 
01473   <font class="comment">/* Add one initial space escape-marker to prevent accidental</font>
01474 <font class="comment">     token-pasting (often removed by macroexpand).  */</font>
01475   *exp_p++ = <font class="charliteral">'@'</font>;
01476   *exp_p++ = <font class="charliteral">' '</font>;
01477 
01478   <font class="keywordflow">if</font> (limit - p &gt;= 2 &amp;&amp; p[0] == <font class="charliteral">'#'</font> &amp;&amp; p[1] == <font class="charliteral">'#'</font>) {
01479     <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
01480                   cstring_makeLiteralTemp (<font class="stringliteral">"`##' at start of macro definition"</font>));
01481     p += 2;
01482   }
01483 
01484   <font class="comment">/* Process the main body of the definition.  */</font>
01485   <font class="keywordflow">while</font> (p &lt; limit) {
01486     <font class="keywordtype">int</font> skipped_arg = 0;
01487     <font class="keyword">register</font> <font class="keywordtype">char</font> c = *p++;
01488 
01489     *exp_p++ = c;
01490 
01491     <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile)) {
01492       <font class="keywordflow">switch</font> (c) {
01493       <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
01494       <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
01495         <font class="keywordflow">if</font> (expected_delimiter != <font class="charliteral">'\0'</font>)
01496           {
01497             <font class="keywordflow">if</font> (c == expected_delimiter)
01498               expected_delimiter = <font class="charliteral">'\0'</font>;
01499           }
01500         <font class="keywordflow">else</font>
01501           {
01502             expected_delimiter = c;
01503           }
01504         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01505 
01506       <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
01507         <font class="keywordflow">if</font> (p &lt; limit &amp;&amp; (expected_delimiter != <font class="charliteral">'\0'</font>))
01508           {
01509             <font class="comment">/* In a string, backslash goes through</font>
01510 <font class="comment">               and makes next char ordinary.  */</font>
01511             *exp_p++ = *p++;
01512           }
01513         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01514 
01515       <font class="keywordflow">case</font> <font class="charliteral">'@'</font>:
01516         <font class="comment">/* An '@' in a string or character constant stands for itself,</font>
01517 <font class="comment">           and does not need to be escaped.  */</font>
01518         <font class="keywordflow">if</font> (expected_delimiter == <font class="charliteral">'\0'</font>)
01519           {
01520             *exp_p++ = c;
01521           }
01522 
01523         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01524 
01525       <font class="keywordflow">case</font> <font class="charliteral">'#'</font>:
01526         <font class="comment">/* # is ordinary inside a string.  */</font>
01527         <font class="keywordflow">if</font> (expected_delimiter != <font class="charliteral">'\0'</font>)
01528           {
01529             <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01530           }
01531 
01532         <font class="keywordflow">if</font> (p &lt; limit &amp;&amp; *p == <font class="charliteral">'#'</font>) {
01533           <font class="comment">/* ##: concatenate preceding and following tokens.  */</font>
01534           <font class="comment">/* Take out the first #, discard preceding whitespace.  */</font>
01535           exp_p--;
01536 
01537           <font class="comment">/*@-usedef@*/</font>
01538           <font class="keywordflow">while</font> (exp_p &gt; lastp &amp;&amp; is_hor_space[(<font class="keywordtype">int</font>) exp_p[-1]])
01539             {
01540               --exp_p;
01541             }
01542           <font class="comment">/*@=usedef@*/</font>
01543 
01544           <font class="comment">/* Skip the second #.  */</font>
01545           p++;
01546           <font class="comment">/* Discard following whitespace.  */</font>
01547           <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (p);
01548           concat = p;
01549           <font class="keywordflow">if</font> (p == limit)
01550             {
01551               <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
01552                             cstring_makeLiteralTemp (<font class="stringliteral">"`##' at end of macro definition"</font>));
01553             }
01554         } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (nargs &gt;= 0) {
01555           <font class="comment">/* Single #: stringify following argument ref.</font>
01556 <font class="comment">             Don't leave the # in the expansion.  */</font>
01557           exp_p--;
01558           <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (p);
01559           <font class="keywordflow">if</font> (p == limit || ! is_idstart[(<font class="keywordtype">int</font>) *p]
01560               || (*p == <font class="charliteral">'L'</font> &amp;&amp; p + 1 &lt; limit &amp;&amp; (p[1] == <font class="charliteral">'\''</font> || p[1] == <font class="charliteral">'"'</font>)))
01561             <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
01562                           cstring_makeLiteralTemp (<font class="stringliteral">"`#' operator is not followed by a macro argument name"</font>));
01563           <font class="keywordflow">else</font>
01564             stringify = p;
01565         } <font class="keywordflow">else</font> {
01566           ; <font class="comment">/* BADBRANCH; */</font>
01567         }
01568 
01569         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01570       }
01571     } <font class="keywordflow">else</font> {
01572       <font class="comment">/* In -traditional mode, recognize arguments inside strings and</font>
01573 <font class="comment">         and character constants, and ignore special properties of #.</font>
01574 <font class="comment">         Arguments inside strings are considered "stringified", but no</font>
01575 <font class="comment">         extra quote marks are supplied.  */</font>
01576       <font class="keywordflow">switch</font> (c) {
01577       <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
01578       <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
01579         <font class="keywordflow">if</font> (expected_delimiter != <font class="charliteral">'\0'</font>) {
01580           <font class="keywordflow">if</font> (c == expected_delimiter)
01581             expected_delimiter = <font class="charliteral">'\0'</font>;
01582         } <font class="keywordflow">else</font>
01583           expected_delimiter = c;
01584         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01585 
01586       <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
01587         <font class="comment">/* Backslash quotes delimiters and itself, but not macro args.  */</font>
01588         <font class="keywordflow">if</font> (expected_delimiter != <font class="charliteral">'\0'</font> &amp;&amp; p &lt; limit
01589             &amp;&amp; (*p == expected_delimiter || *p == <font class="charliteral">'\\'</font>)) {
01590           *exp_p++ = *p++;
01591           <font class="keywordflow">continue</font>;
01592         }
01593         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01594 
01595       <font class="keywordflow">case</font> <font class="charliteral">'/'</font>:
01596         <font class="keywordflow">if</font> (expected_delimiter != <font class="charliteral">'\0'</font>) <font class="comment">/* No comments inside strings.  */</font>
01597           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01598         <font class="keywordflow">if</font> (*p == <font class="charliteral">'*'</font>) {
01599           <font class="comment">/* If we find a comment that wasn't removed by cppReader_handleDirective,</font>
01600 <font class="comment">             this must be -traditional.  So replace the comment with</font>
01601 <font class="comment">             nothing at all.  */</font>
01602           exp_p--;
01603           p += 1;
01604           <font class="keywordflow">while</font> (p &lt; limit &amp;&amp; !(p[-2] == <font class="charliteral">'*'</font> &amp;&amp; p[-1] == <font class="charliteral">'/'</font>))
01605             {
01606               p++;
01607             }
01608         }
01609         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01610       }
01611     }
01612 
01613     <font class="comment">/* Handle the start of a symbol.  */</font>
01614     <font class="keywordflow">if</font> (is_idchar[(<font class="keywordtype">int</font>) c] &amp;&amp; nargs &gt; 0) {
01615       <font class="keywordtype">char</font> *id_beg = p - 1;
01616       <font class="keywordtype">int</font> id_len;
01617 
01618       --exp_p;
01619       <font class="keywordflow">while</font> (p != limit &amp;&amp; is_idchar[(<font class="keywordtype">int</font>) *p])
01620         {
01621           p++;
01622         }
01623 
01624       id_len = p - id_beg;
01625 
01626       <font class="keywordflow">if</font> (is_idstart[(<font class="keywordtype">int</font>) c]
01627           &amp;&amp; ! (id_len == 1 &amp;&amp; c == <font class="charliteral">'L'</font> &amp;&amp; (*p == <font class="charliteral">'\''</font> || *p == <font class="charliteral">'"'</font>))) {
01628         <font class="keyword">register</font> <font class="keyword">struct </font>arglist *arg;
01629 
01630         <font class="keywordflow">for</font> (arg = arglist; arg != NULL; arg = arg-&gt;next) {
01631           <font class="keyword">struct </font>reflist *tpat;
01632 
01633           <font class="keywordflow">if</font> (arg-&gt;name[0] == c
01634               &amp;&amp; arg-&gt;length == id_len
01635               &amp;&amp; strncmp (arg-&gt;name, id_beg, size_fromInt (id_len)) == 0) {
01636             <font class="keywordtype">char</font> *p1;
01637 
01638             <font class="keywordflow">if</font> (expected_delimiter &amp;&amp; CPPOPTIONS (pfile)-&gt;warn_stringify) {
01639               <font class="keywordflow">if</font> (cppReader_isTraditional (pfile)) {
01640                 <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile,
01641                                    message (<font class="stringliteral">"macro argument `%x' is stringified."</font>,
01642                                             cstring_prefix (cstring_fromChars (arg-&gt;name), id_len)));
01643               } <font class="keywordflow">else</font> {
01644                 <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile,
01645                                    message (<font class="stringliteral">"macro arg `%x' would be stringified with -traditional."</font>,
01646                                             cstring_prefix (cstring_fromChars (arg-&gt;name), id_len)));
01647               }
01648             }
01649             <font class="comment">/* If ANSI, don't actually substitute inside a string.  */</font>
01650             <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile) &amp;&amp; expected_delimiter)
01651               <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
01652             <font class="comment">/* make a pat node for this arg and append it to the end of</font>
01653 <font class="comment">               the pat list */</font>
01654             tpat = (<font class="keyword">struct </font>reflist *) dmalloc (sizeof (*tpat));
01655             tpat-&gt;next = NULL;
01656             tpat-&gt;raw_before = (concat == id_beg);
01657             tpat-&gt;raw_after = 0;
01658             tpat-&gt;rest_args = arg-&gt;rest_args;
01659             tpat-&gt;stringify = (cppReader_isTraditional (pfile)
01660                                ? expected_delimiter != <font class="charliteral">'\0'</font>
01661                                : stringify == id_beg);
01662 
01663             <font class="keywordflow">if</font> (endpat == NULL)
01664               {
01665                 defn-&gt;pattern = tpat;
01666               }
01667             <font class="keywordflow">else</font>
01668               {
01669                 endpat-&gt;next = tpat;
01670                 <font class="comment">/*@-branchstate@*/</font>
01671               } <font class="comment">/*@=branchstate@*/</font> <font class="comment">/* evs 2000 was =branchstate */</font>
01672 
01673             endpat = tpat;
01674 
01675             tpat-&gt;argno = arg-&gt;argno;
01676             tpat-&gt;nchars = exp_p - lastp;
01677 
01678             p1 = p;
01679 
01680             <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (p1);
01681 
01682             <font class="keywordflow">if</font> (p1 + 2 &lt;= limit &amp;&amp; p1[0] == <font class="charliteral">'#'</font> &amp;&amp; p1[1] == <font class="charliteral">'#'</font>)
01683               {
01684                 tpat-&gt;raw_after = 1;
01685               }
01686 
01687             lastp = exp_p;      <font class="comment">/* place to start copying from next time */</font>
01688             skipped_arg = 1;
01689 
01690             <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
01691           }
01692         }
01693       }
01694 
01695       <font class="comment">/* If this was not a macro arg, copy it into the expansion.  */</font>
01696       <font class="keywordflow">if</font> (skipped_arg == 0) {
01697         <font class="keyword">register</font> <font class="keywordtype">char</font> *lim1 = p;
01698         p = id_beg;
01699 
01700         <font class="keywordflow">while</font> (p != lim1)
01701           {
01702             *exp_p++ = *p++;
01703           }
01704 
01705         <font class="keywordflow">if</font> (stringify == id_beg)
01706           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
01707                               cstring_makeLiteralTemp (<font class="stringliteral">"`#' operator should be followed by a macro argument name"</font>));
01708       }
01709     }
01710   }
01711 
01712   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile) &amp;&amp; expected_delimiter == <font class="charliteral">'\0'</font>)
01713     {
01714       <font class="comment">/* If ANSI, put in a "@ " marker to prevent token pasting.</font>
01715 <font class="comment">         But not if "inside a string" (which in ANSI mode</font>
01716 <font class="comment">         happens only for -D option).  */</font>
01717       *exp_p++ = <font class="charliteral">'@'</font>;
01718       *exp_p++ = <font class="charliteral">' '</font>;
01719     }
01720 
01721   *exp_p = <font class="charliteral">'\0'</font>;
01722 
01723   defn-&gt;length = <a class="code" href="general_c.html#a33">size_fromInt</a> (exp_p - defn-&gt;expansion);
01724 
01725   <font class="comment">/* Crash now if we overrun the allocated size.  */</font>
01726   <font class="keywordflow">if</font> (defn-&gt;length + 1 &gt; maxsize)
01727     {
01728       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (cstring_makeLiteral (<font class="stringliteral">"Maximum definition size exceeded."</font>));
01729     }
01730 
01731   <font class="keywordflow">return</font> defn;
01732 }
01733 
01734 <font class="comment">/*</font>
01735 <font class="comment"> * special extension string that can be added to the last macro argument to</font>
01736 <font class="comment"> * allow it to absorb the "rest" of the arguments when expanded.  Ex:</font>
01737 <font class="comment"> *              #define wow(a, b...)            process (b, a, b)</font>
01738 <font class="comment"> *              { wow (1, 2, 3); }      -&gt;      { process (2, 3, 1, 2, 3); }</font>
01739 <font class="comment"> *              { wow (one, two); }     -&gt;      { process (two, one, two); }</font>
01740 <font class="comment"> * if this "rest_arg" is used with the concat token '##' and if it is not</font>
01741 <font class="comment"> * supplied then the token attached to with ## will not be outputted.  Ex:</font>
01742 <font class="comment"> *              #define wow (a, b...)           process (b ## , a, ## b)</font>
01743 <font class="comment"> *              { wow (1, 2); }         -&gt;      { process (2, 1, 2); }</font>
01744 <font class="comment"> *              { wow (one); }          -&gt;      { process (one); {</font>
01745 <font class="comment"> */</font>
01746 
01747 <font class="comment">/*@-readonlytrans@*/</font>
01748 <font class="keyword">static</font> <font class="keywordtype">char</font> rest_extension[] = <font class="stringliteral">"..."</font>;
01749 <font class="comment">/*:=readonlytrans@*/</font>
01750 
01751 <font class="comment">/*@notfunction@*/</font>
<a name="l01752"></a><a class="code" href="cpplib_c.html#a29">01752</a> <font class="preprocessor">#define REST_EXTENSION_LENGTH   (sizeof (rest_extension) - 1)</font>
01753 <font class="preprocessor"></font>
01754 <font class="comment">/* Create a DEFINITION node from a #define directive.  Arguments are</font>
01755 <font class="comment">   as for do_define.  */</font>
01756 
01757 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> MACRODEF
01758 create_definition (<font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit,
01759                    cppReader *pfile, <font class="keywordtype">bool</font> predefinition,
01760                    <font class="keywordtype">bool</font> noExpand)<font class="keyword"></font>
01761 <font class="keyword"></font>{
01762   <font class="keywordtype">char</font> *bp;                     <font class="comment">/* temp ptr into input buffer */</font>
01763   <font class="keywordtype">char</font> *symname;                <font class="comment">/* remember where symbol name starts */</font>
01764   <font class="keywordtype">int</font> sym_length;               <font class="comment">/* and how long it is */</font>
01765   <font class="keywordtype">int</font> rest_args = 0;   <font class="comment">/* really int! */</font>
01766   <font class="keywordtype">int</font> line;
01767   <font class="keywordtype">int</font> col;
01768   cstring file = (CPPBUFFER (pfile) != NULL)
01769     ? CPPBUFFER (pfile)-&gt;nominal_fname : cstring_makeLiteralTemp (<font class="stringliteral">""</font>);
01770   DEFINITION *defn;
01771   <font class="keywordtype">int</font> arglengths = 0;           <font class="comment">/* Accumulate lengths of arg names</font>
01772 <font class="comment">                                   plus number of args.  */</font>
01773   MACRODEF mdef;
01774 
01775   <a class="code" href="cpplib_c.html#a126">cppBuffer_lineAndColumn</a> (CPPBUFFER (pfile), &amp;line, &amp;col);
01776 
01777   bp = buf;
01778 
01779   <font class="keywordflow">while</font> (is_hor_space[(<font class="keywordtype">int</font>) *bp])
01780     {
01781       bp++;
01782     }
01783 
01784   symname = bp;                 <font class="comment">/* remember where it starts */</font>
01785 
01786   sym_length = <a class="code" href="cpplib_c.html#a120">cppReader_checkMacroName</a> (pfile, bp, cstring_makeLiteralTemp (<font class="stringliteral">"macro"</font>));
01787 
01788   bp += sym_length;
01789 
01790   <font class="comment">/* Lossage will occur if identifiers or control keywords are broken</font>
01791 <font class="comment">     across lines using backslash.  This is not the right place to take</font>
01792 <font class="comment">     care of that.  */</font>
01793 
01794   <font class="keywordflow">if</font> (*bp == <font class="charliteral">'('</font>) {
01795     <font class="keyword">struct </font>arglist *arg_ptrs = NULL;
01796     <font class="keywordtype">int</font> argno = 0;
01797 
01798     bp++;                       <font class="comment">/* skip '(' */</font>
01799     <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (bp);
01800 
01801     <font class="comment">/* Loop over macro argument names.  */</font>
01802     <font class="keywordflow">while</font> (*bp != <font class="charliteral">')'</font>)
01803       {
01804         <font class="keyword">struct </font>arglist *temp = (struct arglist *) dmalloc (sizeof (*temp));
01805         temp-&gt;name = bp;
01806         temp-&gt;next = arg_ptrs;
01807         temp-&gt;argno = argno++;
01808         temp-&gt;rest_args = 0;
01809 
01810         arg_ptrs = temp;
01811 
01812         <font class="keywordflow">if</font> (rest_args != 0)
01813           {
01814             <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
01815                          message (<font class="stringliteral">"another parameter follows `%s'"</font>,
01816                                   cstring_fromChars (rest_extension)));
01817           }
01818 
01819         <font class="keywordflow">if</font> (!is_idstart[(<font class="keywordtype">int</font>) *bp])
01820           {
01821             <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
01822                             cstring_makeLiteralTemp (<font class="stringliteral">"invalid character in macro parameter name"</font>));
01823           }
01824 
01825         <font class="comment">/* Find the end of the arg name.  */</font>
01826         <font class="keywordflow">while</font> (is_idchar[(<font class="keywordtype">int</font>) *bp])
01827           {
01828             bp++;
01829             <font class="comment">/* do we have a "special" rest-args extension here? */</font>
01830             <font class="keywordflow">if</font> (limit - bp &gt; <a class="code" href="general_c.html#a34">size_toInt</a> (REST_EXTENSION_LENGTH)
01831                 &amp;&amp; strncmp (rest_extension, bp, REST_EXTENSION_LENGTH) == 0)
01832               {
01833                 rest_args = 1;
01834                 temp-&gt;rest_args = 1;
01835                 <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
01836               }
01837           }
01838 
01839         temp-&gt;length = bp - temp-&gt;name;
01840 
01841         <font class="keywordflow">if</font> (rest_args != 0)
01842           {
01843             bp += REST_EXTENSION_LENGTH;
01844           }
01845 
01846         arglengths += temp-&gt;length + 2;
01847         <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (bp);
01848 
01849         <font class="keywordflow">if</font> (temp-&gt;length == 0 || (*bp != <font class="charliteral">','</font> &amp;&amp; *bp != <font class="charliteral">')'</font>)) {
01850           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
01851                         cstring_makeLiteralTemp (<font class="stringliteral">"Parameter list for #define is not parseable"</font>));
01852           <font class="keywordflow">goto</font> nope;
01853         }
01854 
01855         <font class="keywordflow">if</font> (*bp == <font class="charliteral">','</font>) {
01856           bp++;
01857           <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (bp);
01858         }
01859         <font class="keywordflow">if</font> (bp &gt;= limit) {
01860           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
01861                         cstring_makeLiteralTemp (<font class="stringliteral">"unterminated parameter list in `#define'"</font>));
01862           <font class="keywordflow">goto</font> nope;
01863         }
01864         {
01865           <font class="keyword">struct </font>arglist *otemp;
01866 
01867           <font class="keywordflow">for</font> (otemp = temp-&gt;next; otemp != NULL; otemp = otemp-&gt;next)
01868             {
01869               <font class="keywordflow">if</font> (temp-&gt;length == otemp-&gt;length &amp;&amp;
01870                   strncmp (temp-&gt;name, otemp-&gt;name, size_fromInt (temp-&gt;length)) == 0) {
01871                 cstring name = <a class="code" href="cstring_c.html#a10">cstring_copyLength</a> (temp-&gt;name, temp-&gt;length);
01872                 <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
01873                            message (<font class="stringliteral">"duplicate argument name `%x' in `#define'"</font>, name));
01874                 <font class="keywordflow">goto</font> nope;
01875               }
01876             }
01877         }
01878       }
01879 
01880     ++bp;                       <font class="comment">/* skip paren */</font>
01881     <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (bp);
01882     <font class="comment">/* now everything from bp before limit is the definition.  */</font>
01883     defn = collect_expansion (pfile, bp, limit, argno, arg_ptrs);
01884     defn-&gt;rest_args = rest_args;
01885     
01886     <font class="comment">/* Now set defn-&gt;args.argnames to the result of concatenating</font>
01887 <font class="comment">       the argument names in reverse order</font>
01888 <font class="comment">       with comma-space between them.  */</font>
01889     defn-&gt;args.argnames = (<font class="keywordtype">char</font> *) dmalloc (size_fromInt (arglengths + 1));
01890 
01891     {
01892       <font class="keyword">struct </font>arglist *temp;
01893       <font class="keywordtype">int</font> i = 0;
01894       <font class="keywordflow">for</font> (temp = arg_ptrs; temp != NULL; temp = temp-&gt;next) {
01895         memcpy (&amp;defn-&gt;args.argnames[i], temp-&gt;name, size_fromInt (temp-&gt;length));
01896         i += temp-&gt;length;
01897         <font class="keywordflow">if</font> (temp-&gt;next != 0) {
01898           defn-&gt;args.argnames[i++] = <font class="charliteral">','</font>;
01899           defn-&gt;args.argnames[i++] = <font class="charliteral">' '</font>;
01900         }
01901       }
01902 
01903       defn-&gt;args.argnames[i] = <font class="charliteral">'\0'</font>;
01904     }
01905 
01906     <a class="code" href="general_c.html#a0">sfree</a> (arg_ptrs);
01907   } <font class="keywordflow">else</font> {
01908     <font class="comment">/* Simple expansion or empty definition.  */</font>
01909 
01910     <font class="keywordflow">if</font> (bp &lt; limit)
01911       {
01912         <font class="keywordflow">if</font> (is_hor_space[(<font class="keywordtype">int</font>) *bp]) {
01913           bp++;
01914           <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (bp);
01915         } <font class="keywordflow">else</font> {
01916           <font class="keywordflow">switch</font> (*bp) {
01917           <font class="keywordflow">case</font> <font class="charliteral">'!'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'"'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'#'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'%'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'&amp;'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
01918           <font class="keywordflow">case</font> <font class="charliteral">')'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'*'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'+'</font>:  <font class="keywordflow">case</font> <font class="charliteral">','</font>:  <font class="keywordflow">case</font> <font class="charliteral">'-'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'.'</font>:
01919           <font class="keywordflow">case</font> <font class="charliteral">'/'</font>:  <font class="keywordflow">case</font> <font class="charliteral">':'</font>:  <font class="keywordflow">case</font> <font class="charliteral">';'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'&lt;'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'='</font>:  <font class="keywordflow">case</font> <font class="charliteral">'&gt;'</font>:
01920           <font class="keywordflow">case</font> <font class="charliteral">'?'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'['</font>:  <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>: <font class="keywordflow">case</font> <font class="charliteral">']'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'^'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'{'</font>:
01921           <font class="keywordflow">case</font> <font class="charliteral">'|'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'}'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'~'</font>:
01922             <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile,
01923                          message (<font class="stringliteral">"Missing white space after #define %x"</font>,
01924                                   cstring_prefix (cstring_fromChars (symname),
01925                                                   sym_length)));
01926             <font class="keywordflow">break</font>;
01927 
01928           <font class="keywordflow">default</font>:
01929             <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
01930                          message (<font class="stringliteral">"Missing white space after #define %x"</font>,
01931                                   cstring_prefix (cstring_fromChars (symname),
01932                                                   sym_length)));
01933             <font class="keywordflow">break</font>;
01934           }
01935         }
01936       }
01937     <font class="comment">/* now everything from bp before limit is the definition.  */</font>
01938     defn = collect_expansion (pfile, bp, limit, -1, NULL);
01939     defn-&gt;args.argnames = mstring_createEmpty ();
01940   }
01941 
01942   defn-&gt;noExpand = noExpand;
01943   DPRINTF ((<font class="stringliteral">"No expand: %d"</font>, noExpand));
01944 
01945   defn-&gt;line = line;
01946 
01947   <font class="comment">/* not: llassert (cstring_isUndefined (defn-&gt;file)); */</font>
01948   defn-&gt;file = file;
01949 
01950   <font class="comment">/* OP is null if this is a predefinition */</font>
01951   defn-&gt;predefined = predefinition;
01952   mdef.defn = defn;
01953   mdef.symnam = symname;
01954   mdef.symlen = sym_length;
01955 
01956   <font class="keywordflow">return</font> mdef;
01957 
01958 nope:
01959   mdef.defn = NULL;
01960   mdef.symnam = NULL;
01961   <font class="keywordflow">return</font> mdef;
01962 }
01963 
01964 <font class="comment">/* Check a purported macro name SYMNAME, and yield its length.</font>
01965 <font class="comment">   USAGE is the kind of name this is intended for.  */</font>
01966 
<a name="l01967"></a><a class="code" href="cpplib_c.html#a120">01967</a> <font class="keywordtype">int</font> <a class="code" href="cpplib_c.html#a120">cppReader_checkMacroName</a> (cppReader *pfile,
01968                       <font class="keywordtype">char</font> *symname,
01969                       cstring usage)<font class="keyword"></font>
01970 <font class="keyword"></font>{
01971   <font class="keywordtype">char</font> *p;
01972   size_t sym_length;
01973 
01974   <font class="keywordflow">for</font> (p = symname; is_idchar[(<font class="keywordtype">int</font>) *p]; p++)
01975     {
01976       ;
01977     }
01978 
01979   sym_length = <a class="code" href="general_c.html#a33">size_fromInt</a> (p - symname);
01980 
01981   <font class="keywordflow">if</font> (sym_length == 0
01982       || (sym_length == 1 &amp;&amp; *symname == <font class="charliteral">'L'</font> &amp;&amp; (*p == <font class="charliteral">'\''</font> || *p == <font class="charliteral">'"'</font>)))
01983     <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile, message (<font class="stringliteral">"invalid %s name"</font>, usage));
01984   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!is_idstart[(<font class="keywordtype">int</font>) *symname])
01985     {
01986       <font class="keywordtype">char</font> *msg = (<font class="keywordtype">char</font> *) dmalloc (sym_length + 1);
01987       memcpy (msg, symname, sym_length);
01988       msg[sym_length] = <font class="charliteral">'\0'</font>;
01989       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile, message (<font class="stringliteral">"invalid %s name `%s'"</font>, usage,
01990                                        cstring_fromChars (msg)));
01991       <a class="code" href="general_c.html#a0">sfree</a> (msg);
01992     }
01993   <font class="keywordflow">else</font>
01994     {
01995       <font class="keywordflow">if</font> ((strncmp (symname, <font class="stringliteral">"defined"</font>, 7) == 0) &amp;&amp; sym_length == 7)
01996         {
01997           <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile, message (<font class="stringliteral">"invalid %s name `defined'"</font>, usage));
01998         }
01999     }
02000 
02001   <font class="keywordflow">return</font> <a class="code" href="general_c.html#a34">size_toInt</a> (sym_length);
02002 }
02003 
02004 <font class="comment">/* Return zero if two DEFINITIONs are isomorphic.  */</font>
02005 
02006 <font class="keyword">static</font> <font class="keywordtype">bool</font>
02007 compare_defs (DEFINITION *d1, DEFINITION *d2)<font class="keyword"></font>
02008 <font class="keyword"></font>{
02009   <font class="keyword">register</font> <font class="keyword">struct </font>reflist *a1, *a2;
02010   <font class="keyword">register</font> <font class="keywordtype">char</font> *p1 = d1-&gt;expansion;
02011   <font class="keyword">register</font> <font class="keywordtype">char</font> *p2 = d2-&gt;expansion;
02012   <font class="keywordtype">bool</font> first = TRUE;
02013 
02014   <font class="keywordflow">if</font> (d1-&gt;nargs != d2-&gt;nargs)
02015     {
02016       <font class="keywordflow">return</font> TRUE;
02017     }
02018 
02019   llassert (d1-&gt;args.argnames != NULL);
02020   llassert (d2-&gt;args.argnames != NULL);
02021 
02022   <font class="keywordflow">if</font> (strcmp ((<font class="keywordtype">char</font> *)d1-&gt;args.argnames, (<font class="keywordtype">char</font> *)d2-&gt;args.argnames) != 0)
02023     {
02024       <font class="keywordflow">return</font> TRUE;
02025     }
02026 
02027   <font class="keywordflow">for</font> (a1 = d1-&gt;pattern, a2 = d2-&gt;pattern;
02028        (a1 != NULL) &amp;&amp; (a2 != NULL);
02029        a1 = a1-&gt;next, a2 = a2-&gt;next) {
02030     <font class="keywordflow">if</font> (!((a1-&gt;nchars == a2-&gt;nchars
02031            &amp;&amp; (strncmp (p1, p2, size_fromInt (a1-&gt;nchars)) == 0))
02032           || ! comp_def_part (first, p1, a1-&gt;nchars, p2, a2-&gt;nchars, 0))
02033         || a1-&gt;argno != a2-&gt;argno
02034         || a1-&gt;stringify != a2-&gt;stringify
02035         || a1-&gt;raw_before != a2-&gt;raw_before
02036         || a1-&gt;raw_after != a2-&gt;raw_after)
02037       <font class="keywordflow">return</font> TRUE;
02038     first = 0;
02039     p1 += a1-&gt;nchars;
02040     p2 += a2-&gt;nchars;
02041   }
02042   <font class="keywordflow">if</font> (a1 != a2)
02043     <font class="keywordflow">return</font> TRUE;
02044 
02045   <font class="keywordflow">if</font> (comp_def_part (first, p1, d1-&gt;length - (p1 - d1-&gt;expansion),
02046                      p2, d2-&gt;length - (p2 - d2-&gt;expansion), 1))
02047     <font class="keywordflow">return</font> TRUE;
02048 
02049   <font class="keywordflow">return</font> FALSE;
02050 }
02051 
02052 <font class="comment">/* Return TRUE if two parts of two macro definitions are effectively different.</font>
02053 <font class="comment">   One of the parts starts at BEG1 and has LEN1 chars;</font>
02054 <font class="comment">   the other has LEN2 chars at BEG2.</font>
02055 <font class="comment">   Any sequence of whitespace matches any other sequence of whitespace.</font>
02056 <font class="comment">   FIRST means these parts are the first of a macro definition;</font>
02057 <font class="comment">   so ignore leading whitespace entirely.</font>
02058 <font class="comment">   LAST means these parts are the last of a macro definition;</font>
02059 <font class="comment">   so ignore trailing whitespace entirely.  */</font>
02060 
02061 <font class="keyword">static</font> <font class="keywordtype">bool</font>
02062 comp_def_part (<font class="keywordtype">bool</font> first, <font class="keywordtype">char</font> *beg1, <font class="keywordtype">int</font> len1, <font class="keywordtype">char</font> *beg2, <font class="keywordtype">int</font> len2, <font class="keywordtype">bool</font> last)<font class="keyword"></font>
02063 <font class="keyword"></font>{
02064   <font class="keywordtype">char</font> *end1 = beg1 + len1;
02065   <font class="keywordtype">char</font> *end2 = beg2 + len2;
02066 
02067   <font class="keywordflow">if</font> (first) {
02068     <font class="keywordflow">while</font> (beg1 != end1 &amp;&amp; is_space[(<font class="keywordtype">int</font>) *beg1]) { beg1++; }
02069     <font class="keywordflow">while</font> (beg2 != end2 &amp;&amp; is_space[(<font class="keywordtype">int</font>) *beg2]) { beg2++; }
02070   }
02071   <font class="keywordflow">if</font> (last) {
02072     <font class="keywordflow">while</font> (beg1 != end1 &amp;&amp; is_space[(<font class="keywordtype">int</font>) end1[-1]]) { end1--; }
02073     <font class="keywordflow">while</font> (beg2 != end2 &amp;&amp; is_space[(<font class="keywordtype">int</font>) end2[-1]]) { end2--; }
02074   }
02075   <font class="keywordflow">while</font> (beg1 != end1 &amp;&amp; beg2 != end2) {
02076     <font class="keywordflow">if</font> (is_space[(<font class="keywordtype">int</font>) *beg1] &amp;&amp; is_space[(<font class="keywordtype">int</font>) *beg2]) {
02077       <font class="keywordflow">while</font> (beg1 != end1 &amp;&amp; is_space[(<font class="keywordtype">int</font>) *beg1]) { beg1++; }
02078       <font class="keywordflow">while</font> (beg2 != end2 &amp;&amp; is_space[(<font class="keywordtype">int</font>) *beg2]) { beg2++; }
02079     } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (*beg1 == *beg2) {
02080       beg1++; beg2++;
02081     } <font class="keywordflow">else</font> <font class="keywordflow">break</font>;
02082   }
02083   <font class="keywordflow">return</font> (beg1 != end1) || (beg2 != end2);
02084 }
02085 
02086 <font class="comment">/* Process a #define command.</font>
02087 <font class="comment">   BUF points to the contents of the #define command, as a contiguous string.</font>
02088 <font class="comment">   LIMIT points to the first character past the end of the definition.</font>
02089 <font class="comment">   KEYWORD is the keyword-table entry for #define,</font>
02090 <font class="comment">   or NULL for a "predefined" macro.  */</font>
02091 
02092 <font class="keyword">static</font> <font class="keywordtype">int</font>
02093 do_defineAux (cppReader *pfile, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
02094               <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit, <font class="keywordtype">bool</font> noExpand)<font class="keyword"></font>
02095 <font class="keyword"></font>{
02096   <font class="keywordtype">int</font> hashcode;
02097   MACRODEF mdef;
02098   HASHNODE *hp;
02099   
02100   DPRINTF ((<font class="stringliteral">"Define aux: %d"</font>, noExpand));
02101 
02102   mdef = create_definition (buf, limit, pfile, keyword == NULL, noExpand);
02103 
02104   <font class="keywordflow">if</font> (mdef.defn == 0)
02105     <font class="keywordflow">goto</font> nope;
02106 
02107   hashcode = <a class="code" href="cpphash_c.html#a9">hashf</a> (mdef.symnam, mdef.symlen, CPP_HASHSIZE);
02108 
02109   DPRINTF ((<font class="stringliteral">"Macro: %s / %s"</font>, 
02110             cstring_copyLength (mdef.symnam, mdef.symlen),
02111             bool_unparse (noExpand)));
02112 
02113   <font class="keywordflow">if</font> ((hp = <a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (mdef.symnam, mdef.symlen, hashcode)) != NULL)
02114     {
02115       <font class="keywordtype">bool</font> ok = FALSE;
02116 
02117       <font class="comment">/* Redefining a precompiled key is ok.  */</font>
02118       <font class="keywordflow">if</font> (hp-&gt;type == T_PCSTRING)
02119         ok = TRUE;
02120       <font class="comment">/* Redefining a macro is ok if the definitions are the same.  */</font>
02121       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (hp-&gt;type == T_MACRO)
02122         ok = !compare_defs (mdef.defn, hp-&gt;value.defn);
02123       <font class="comment">/* Redefining a constant is ok with -D.  */</font>
02124       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (hp-&gt;type == T_CONST)
02125         ok = !CPPOPTIONS (pfile)-&gt;done_initializing;
02126       <font class="keywordflow">else</font> {
02127         BADBRANCH;
02128       }
02129 
02130       <font class="comment">/* Print the warning if it's not ok.  */</font>
02131       <font class="keywordflow">if</font> (!ok)
02132         {
02133           <font class="comment">/*</font>
02134 <font class="comment">          ** If we are passing through #define and #undef directives, do</font>
02135 <font class="comment">          ** that for this re-definition now.</font>
02136 <font class="comment">          */</font>
02137 
02138           <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;debug_output &amp;&amp; (keyword != NULL))
02139             {
02140               <font class="comment">/* llassert (keyword != NULL); */</font>
02141               pass_thru_directive (buf, limit, pfile, keyword);
02142             }
02143 
02144           cpp_setLocation (pfile);
02145 
02146           <font class="keywordflow">if</font> (hp-&gt;type == T_MACRO)
02147             {
02148               <font class="keywordflow">if</font> (hp-&gt;value.defn-&gt;noExpand)
02149                 {
02150                   ; <font class="comment">/* error will be reported checking macros */</font>
02151                 }
02152               <font class="keywordflow">else</font>
02153                 {
02154                   genppllerrorhint
02155                     (FLG_MACROREDEF,
02156                      <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Macro %q already defined"</font>,
02157                               cstring_copyLength (mdef.symnam, mdef.symlen)),
02158                      <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Previous definition of %q"</font>,
02159                               fileloc_unparseRaw (hp-&gt;value.defn-&gt;file,
02160                                                  (<font class="keywordtype">int</font>) hp-&gt;value.defn-&gt;line),
02161                               <a class="code" href="cstring_c.html#a10">cstring_copyLength</a> (mdef.symnam, mdef.symlen)));
02162                 }
02163             }
02164           <font class="keywordflow">else</font>
02165             {
02166               <a class="code" href="llerror_c.html#a59">genppllerror</a> (FLG_MACROREDEF,
02167                             message (<font class="stringliteral">"Macro %q already defined"</font>,
02168                                      cstring_copyLength (mdef.symnam,
02169                                                          mdef.symlen)));
02170 
02171             }
02172         }
02173 
02174       <font class="comment">/* Replace the old definition.  */</font>
02175       hp-&gt;type = T_MACRO;
02176       hp-&gt;value.defn = mdef.defn;
02177     }
02178   <font class="keywordflow">else</font>
02179     {
02180       <font class="comment">/*</font>
02181 <font class="comment">      ** If we are passing through #define and #undef directives, do</font>
02182 <font class="comment">      ** that for this new definition now.</font>
02183 <font class="comment">      */</font>
02184 
02185       HASHNODE *hn;
02186 
02187       <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;debug_output &amp;&amp; (keyword != NULL))
02188         {
02189           pass_thru_directive (buf, limit, pfile, keyword);
02190         }
02191 
02192       DPRINTF ((<font class="stringliteral">"Define macro: %s / %d"</font>, 
02193                 mdef.symnam, mdef.defn-&gt;noExpand));
02194       
02195       hn = <a class="code" href="cpphash_c.html#a14">cppReader_installMacro</a> (mdef.symnam, mdef.symlen, mdef.defn, hashcode);
02196       <font class="comment">/*@-branchstate@*/</font>
02197     } <font class="comment">/*@=branchstate@*/</font>
02198 
02199   <font class="keywordflow">return</font> 0;
02200 
02201 nope:
02202 
02203   <font class="keywordflow">return</font> 1;
02204 }
02205 
02206 <font class="keyword">static</font> <font class="keywordtype">int</font>
02207 do_define (cppReader *pfile, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
02208            <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
02209 <font class="keyword"></font>{
02210   DPRINTF ((<font class="stringliteral">"Regular do define"</font>));
02211   <font class="keywordflow">return</font> do_defineAux (pfile, keyword, buf, limit, FALSE);
02212 }
02213 
02214 <font class="comment">/* This structure represents one parsed argument in a macro call.</font>
02215 <font class="comment">   `raw' points to the argument text as written (`raw_length' is its length).</font>
02216 <font class="comment">   `expanded' points to the argument's macro-expansion</font>
02217 <font class="comment">   (its length is `expand_length').</font>
02218 <font class="comment">   `stringified_length' is the length the argument would have</font>
02219 <font class="comment">   if stringified.</font>
02220 <font class="comment">   `use_count' is the number of times this macro arg is substituted</font>
02221 <font class="comment">   into the macro.  If the actual use count exceeds 10,</font>
02222 <font class="comment">   the value stored is 10.  */</font>
02223 
02224 <font class="comment">/* raw and expanded are relative to ARG_BASE */</font>
02225 <font class="comment">/*@notfunction@*/</font>
<a name="l02226"></a><a class="code" href="cpplib_c.html#a30">02226</a> <font class="preprocessor">#define ARG_BASE ((pfile)-&gt;token_buffer)</font>
02227 <font class="preprocessor"></font>
<a name="l02228"></a><a class="code" href="struct_argdata.html">02228</a> <font class="keyword">struct </font><a class="code" href="struct_argdata.html">argdata</a> {
02229   <font class="comment">/* Strings relative to pfile-&gt;token_buffer */</font>
<a name="l02230"></a><a class="code" href="struct_argdata.html#m0">02230</a>   <font class="keywordtype">long</font> raw;
<a name="l02231"></a><a class="code" href="struct_argdata.html#m1">02231</a>   size_t expanded;
<a name="l02232"></a><a class="code" href="struct_argdata.html#m2">02232</a>   size_t stringified;
<a name="l02233"></a><a class="code" href="struct_argdata.html#m3">02233</a>   <font class="keywordtype">int</font> raw_length;
<a name="l02234"></a><a class="code" href="struct_argdata.html#m4">02234</a>   <font class="keywordtype">int</font> expand_length;
<a name="l02235"></a><a class="code" href="struct_argdata.html#m5">02235</a>   <font class="keywordtype">int</font> stringified_length;
<a name="l02236"></a><a class="code" href="struct_argdata.html#m6">02236</a>   <font class="keywordtype">bool</font> newlines;
<a name="l02237"></a><a class="code" href="struct_argdata.html#m7">02237</a>   <font class="keywordtype">int</font> use_count;
02238 };
02239 
02240 <font class="comment">/* Allocate a new cppBuffer for PFILE, and push it on the input buffer stack.</font>
02241 <font class="comment">   If BUFFER != NULL, then use the LENGTH characters in BUFFER</font>
02242 <font class="comment">   as the new input buffer.</font>
02243 <font class="comment">   Return the new buffer, or NULL on failure.  */</font>
02244 
02245 <font class="comment">/*@null@*/</font> <font class="comment">/*@exposed@*/</font> cppBuffer *
02246 cppReader_pushBuffer (cppReader *pfile, <font class="keywordtype">char</font> *buffer, size_t length)<font class="keyword"></font>
02247 <font class="keyword"></font>{
02248   cppBuffer *buf = cppReader_getBuffer (pfile);
02249 
02250   <font class="keywordflow">if</font> (buf == pfile-&gt;buffer_stack)
02251     {
02252       cppReader_fatalError
02253         (pfile,
02254          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s: macro or `#include' recursion too deep"</font>,
02255                   (buf-&gt;fname != NULL)
02256                   ? buf-&gt;fname
02257                   : cstring_makeLiteral (<font class="stringliteral">"&lt;no name&gt;"</font>)));
02258       <a class="code" href="general_c.html#a1">sfreeEventually</a> (buffer);
02259       <font class="keywordflow">return</font> NULL;
02260     }
02261 
02262   llassert (buf != NULL);
02263 
02264   buf--;
02265   memset ((<font class="keywordtype">char</font> *) buf, 0, <font class="keyword">sizeof</font> (*buf));
02266   CPPBUFFER (pfile) = buf;
02267 
02268   buf-&gt;if_stack = pfile-&gt;if_stack;
02269   buf-&gt;cleanup = cppReader_nullCleanup;
02270   buf-&gt;underflow = cppReader_nullUnderflow;
02271   buf-&gt;buf = buffer;
02272   buf-&gt;cur = buf-&gt;buf;
02273 
02274   <font class="keywordflow">if</font> (buffer != NULL)
02275     {
02276       buf-&gt;alimit = buf-&gt;rlimit = buffer + length;
02277     }
02278   <font class="keywordflow">else</font>
02279     {
02280       buf-&gt;alimit = buf-&gt;rlimit = NULL;
02281     }
02282 
02283   <font class="keywordflow">return</font> buf;
02284 }
02285 
02286 cppBuffer *
<a name="l02287"></a><a class="code" href="cpplib_c.html#a122">02287</a> <a class="code" href="cpplib_c.html#a122">cppReader_popBuffer</a> (cppReader *pfile)<font class="keyword"></font>
02288 <font class="keyword"></font>{
02289   cppBuffer *buf = CPPBUFFER (pfile);
02290 
02291   llassert (buf != NULL);
02292 
02293   (<font class="keywordtype">void</font>) (*buf-&gt;cleanup) (buf, pfile);
02294   <font class="keywordflow">return</font> ++CPPBUFFER (pfile);
02295 }
02296 
02297 <font class="comment">/* Scan until CPPBUFFER (PFILE) is exhausted into PFILE-&gt;token_buffer.</font>
02298 <font class="comment">   Pop the buffer when done.  */</font>
02299 
02300 <font class="keywordtype">void</font>
02301 cppReader_scanBuffer (cppReader *pfile)<font class="keyword"></font>
02302 <font class="keyword"></font>{
02303   cppBuffer *buffer = CPPBUFFER (pfile);
02304   <font class="keywordflow">for</font> (;;)
02305     {
02306       <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
02307       
02308       <a class="code" href="struct_token.html">token</a> = <a class="code" href="cpplib_c.html#a141">cppGetToken</a> (pfile);
02309 
02310       <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_EOF) <font class="comment">/* Should not happen ...  */</font>
02311         {
02312           <font class="keywordflow">break</font>;
02313         }
02314 
02315       <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_POP &amp;&amp; CPPBUFFER (pfile) == buffer)
02316         {
02317           (<font class="keywordtype">void</font>) <a class="code" href="cpplib_c.html#a122">cppReader_popBuffer</a> (pfile);
02318           <font class="keywordflow">break</font>;
02319         }
02320     }
02321 }
02322 
02323 <font class="comment">/*</font>
02324 <font class="comment"> * Rescan a string (which may have escape marks) into pfile's buffer.</font>
02325 <font class="comment"> * Place the result in pfile-&gt;token_buffer.</font>
02326 <font class="comment"> *</font>
02327 <font class="comment"> * The input is copied before it is scanned, so it is safe to pass</font>
02328 <font class="comment"> * it something from the token_buffer that will get overwritten</font>
02329 <font class="comment"> * (because it follows cppReader_getWritten).  This is used by do_include.</font>
02330 <font class="comment"> */</font>
02331 
02332 <font class="keyword">static</font> <font class="keywordtype">void</font>
02333 cpp_expand_to_buffer (cppReader *pfile, <font class="keywordtype">char</font> *buf, size_t length)<font class="keyword"></font>
02334 <font class="keyword"></font>{
02335   <font class="keyword">register</font> cppBuffer *ip;
02336   <font class="keywordtype">char</font> *limit = buf + length;
02337   <font class="keywordtype">char</font> *buf1, *p1, *p2;
02338 
02339   <font class="keywordflow">if</font> (length &lt; 0)
02340     abort ();
02341 
02342   <font class="comment">/* Set up the input on the input stack.  */</font>
02343 
02344   buf1 = (<font class="keywordtype">char</font> *) dmalloc (length + 1);
02345 
02346   p1 = buf;
02347   p2 = buf1;
02348 
02349   <font class="keywordflow">while</font> (p1 != limit)
02350     {
02351       *p2++ = *p1++;
02352     }
02353 
02354   buf1[length] = <font class="charliteral">'\0'</font>;
02355 
02356   ip = cppReader_pushBuffer (pfile, buf1, length);
02357 
02358   <font class="keywordflow">if</font> (ip == NULL)
02359     <font class="keywordflow">return</font>;
02360 
02361   ip-&gt;has_escapes = TRUE;
02362 
02363   <font class="comment">/* Scan the input, create the output.  */</font>
02364   cppReader_scanBuffer (pfile);
02365 
02366   <a class="code" href="cpplib_c.html#a19">cppReader_nullTerminate</a> (pfile);
02367 }
02368 
02369 <font class="keyword">static</font> <font class="keywordtype">void</font>
02370 adjust_position (<font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit, <font class="keywordtype">int</font> *linep, <font class="keywordtype">int</font> *colp)<font class="keyword"></font>
02371 <font class="keyword"></font>{
02372   <font class="keywordflow">while</font> (buf &lt; limit)
02373     {
02374       <font class="keywordtype">char</font> ch = *buf++;
02375       <font class="keywordflow">if</font> (ch == <font class="charliteral">'\n'</font>)
02376         (*linep)++, (*colp) = 1;
02377       <font class="keywordflow">else</font>
02378         (*colp)++;
02379     }
02380 }
02381 
02382 <font class="comment">/* Move line_base forward, updating lineno and colno.  */</font>
02383 
02384 <font class="keyword">static</font> <font class="keywordtype">void</font>
02385 update_position (cppBuffer *pbuf)<font class="keyword"></font>
02386 <font class="keyword"></font>{
02387   <font class="keywordtype">char</font> *old_pos;
02388   <font class="keywordtype">char</font> *new_pos = pbuf-&gt;cur;
02389   <font class="keyword">register</font> <font class="keyword">struct </font>parse_marker *mark;
02390 
02391   llassert (pbuf-&gt;buf != NULL);
02392   old_pos = pbuf-&gt;buf + pbuf-&gt;line_base;
02393 
02394   <font class="keywordflow">for</font> (mark = pbuf-&gt;marks;  mark != NULL; mark = mark-&gt;next)
02395     {
02396       <font class="keywordflow">if</font> (pbuf-&gt;buf + mark-&gt;position &lt; new_pos)
02397         new_pos = pbuf-&gt;buf + mark-&gt;position;
02398     }
02399   pbuf-&gt;line_base += new_pos - old_pos;
02400 
02401   llassert (old_pos != NULL);
02402   llassert (new_pos != NULL);
02403 
02404   adjust_position (old_pos, new_pos, &amp;pbuf-&gt;lineno, &amp;pbuf-&gt;colno);
02405 }
02406 
02407 <font class="keywordtype">void</font>
<a name="l02408"></a><a class="code" href="cpplib_c.html#a126">02408</a> <a class="code" href="cpplib_c.html#a126">cppBuffer_lineAndColumn</a> (<font class="comment">/*@null@*/</font> cppBuffer *pbuf, <font class="comment">/*@out@*/</font> <font class="keywordtype">int</font> *linep,
02409                          <font class="comment">/*@null@*/</font> <font class="comment">/*@out@*/</font> <font class="keywordtype">int</font> *colp)<font class="keyword"></font>
02410 <font class="keyword"></font>{
02411   <font class="keywordtype">int</font> dummy;
02412 
02413   <font class="keywordflow">if</font> (colp == NULL)
02414     {
02415       colp = &amp;dummy;
02416       <font class="comment">/*@-branchstate@*/</font>
02417     } <font class="comment">/*@=branchstate@*/</font>
02418 
02419   <font class="keywordflow">if</font> (pbuf != NULL)
02420     {
02421       *linep = pbuf-&gt;lineno;
02422       *colp = pbuf-&gt;colno;
02423 
02424       llassert (pbuf-&gt;buf != NULL);
02425       llassert (pbuf-&gt;cur != NULL);
02426 
02427       adjust_position (pbuf-&gt;buf + pbuf-&gt;line_base, pbuf-&gt;cur, linep, colp);
02428     }
02429   <font class="keywordflow">else</font>
02430     {
02431       *linep = 0;
02432       *colp = 0;
02433     }
02434 }
02435 
02436 <font class="comment">/* Return the cppBuffer that corresponds to a file (not a macro).  */</font>
02437 
<a name="l02438"></a><a class="code" href="cpplib_c.html#a127">02438</a> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@null@*/</font> cppBuffer *<a class="code" href="cpplib_c.html#a127">cppReader_fileBuffer</a> (cppReader *pfile)<font class="keyword"></font>
02439 <font class="keyword"></font>{
02440   cppBuffer *ip = cppReader_getBuffer (pfile);
02441 
02442   <font class="keywordflow">for</font> ( ;
02443         ip != NULL &amp;&amp; ip != cppReader_nullBuffer (pfile); 
02444         ip = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (ip))
02445     {
02446       <font class="keywordflow">if</font> (ip-&gt;fname != NULL)
02447         {
02448           <font class="keywordflow">return</font> ip;
02449         }
02450     }
02451   
02452   <font class="keywordflow">return</font> NULL;
02453 }
02454 
02455 <font class="keyword">static</font> <font class="keywordtype">long</font>
02456 count_newlines (<font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
02457 <font class="keyword"></font>{
02458   <font class="keyword">register</font> <font class="keywordtype">long</font> count = 0;
02459 
02460   <font class="keywordflow">while</font> (buf &lt; limit)
02461     {
02462       <font class="keywordtype">char</font> ch = *buf++;
02463       <font class="keywordflow">if</font> (ch == <font class="charliteral">'\n'</font>)
02464         count++;
02465     }
02466   <font class="keywordflow">return</font> count;
02467 }
02468 
02469 <font class="comment">/*</font>
02470 <font class="comment"> * write out a #line command, for instance, after an #include file.</font>
02471 <font class="comment"> * If CONDITIONAL is nonzero, we can omit the #line if it would</font>
02472 <font class="comment"> * appear to be a no-op, and we can output a few newlines instead</font>
02473 <font class="comment"> * if we want to increase the line number by a small amount.</font>
02474 <font class="comment"> * FILE_CHANGE says whether we are entering a file, leaving, or neither.</font>
02475 <font class="comment"> */</font>
02476 
02477 <font class="keyword">static</font> <font class="keywordtype">void</font>
02478 output_line_command (cppReader *pfile, <font class="keywordtype">bool</font> conditional,
02479                      <font class="keyword">enum</font> file_change_code file_change)<font class="keyword"></font>
02480 <font class="keyword"></font>{
02481   <font class="keywordtype">int</font> line, col;
02482   cppBuffer *ip = CPPBUFFER (pfile);
02483   cppBuffer *buf;
02484 
02485   llassert (ip != NULL);
02486 
02487   <font class="keywordflow">if</font> (ip-&gt;fname == NULL)
02488     <font class="keywordflow">return</font>;
02489 
02490   update_position (ip);
02491 
02492   <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;no_line_commands
02493       || CPPOPTIONS (pfile)-&gt;no_output)
02494     <font class="keywordflow">return</font>;
02495 
02496   buf = CPPBUFFER (pfile);
02497 
02498   llassert (buf != NULL);
02499 
02500   line = buf-&gt;lineno;
02501   col = buf-&gt;colno;
02502 
02503   llassert (ip-&gt;cur != NULL);
02504 
02505   adjust_position (cppLineBase (ip), ip-&gt;cur, &amp;line, &amp;col);
02506 
02507   <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;no_line_commands)
02508     <font class="keywordflow">return</font>;
02509 
02510   <font class="keywordflow">if</font> (conditional) {
02511     <font class="keywordflow">if</font> (line == pfile-&gt;lineno)
02512       <font class="keywordflow">return</font>;
02513 
02514     <font class="comment">/* If the inherited line number is a little too small,</font>
02515 <font class="comment">       output some newlines instead of a #line command.  */</font>
02516 
02517     <font class="keywordflow">if</font> (line &gt; pfile-&gt;lineno &amp;&amp; line &lt; pfile-&gt;lineno + 8)
02518       {
02519         cppReader_reserve (pfile, 20);
02520         <font class="keywordflow">while</font> (line &gt; pfile-&gt;lineno)
02521           {
02522             <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'\n'</font>);
02523             pfile-&gt;lineno++;
02524           }
02525 
02526         <font class="keywordflow">return</font>;
02527       }
02528   }
02529 
02530   cppReader_reserve (pfile,
02531                      size_fromInt (4 * cstring_length (ip-&gt;nominal_fname) + 50));
02532 
02533   {
02534 <font class="preprocessor">#ifdef OUTPUT_LINE_COMMANDS</font>
02535 <font class="preprocessor"></font>    <font class="keyword">static</font> <font class="keywordtype">char</font> sharp_line[] = <font class="stringliteral">"#line "</font>;
02536 <font class="preprocessor">#else</font>
02537 <font class="preprocessor"></font>    <font class="keyword">static</font> <font class="keywordtype">char</font> sharp_line[] = <font class="stringliteral">"# "</font>;
02538 <font class="preprocessor">#endif</font>
02539 <font class="preprocessor"></font>    cppReader_putStrN (pfile, sharp_line, <font class="keyword">sizeof</font>(sharp_line)-1);
02540   }
02541 
02542   sprintf (cppReader_getPWritten (pfile), <font class="stringliteral">"%d "</font>, line);
02543   <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, strlen (cppReader_getPWritten (pfile)));
02544 
02545   quote_string (pfile, cstring_toCharsSafe (ip-&gt;nominal_fname));
02546 
02547   <font class="keywordflow">if</font> (file_change != same_file) {
02548     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">' '</font>);
02549     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, file_change == enter_file ? <font class="charliteral">'1'</font> : <font class="charliteral">'2'</font>);
02550   }
02551   <font class="comment">/* Tell cc1 if following text comes from a system header file.  */</font>
02552   <font class="keywordflow">if</font> (ip-&gt;system_header_p != <font class="charliteral">'\0'</font>) {
02553     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">' '</font>);
02554     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'3'</font>);
02555   }
02556 <font class="preprocessor">#ifndef NO_IMPLICIT_EXTERN_C</font>
02557 <font class="preprocessor"></font>  <font class="comment">/* Tell cc1plus if following text should be treated as C.  */</font>
02558   <font class="keywordflow">if</font> (ip-&gt;system_header_p == (<font class="keywordtype">char</font>) 2 &amp;&amp; CPPOPTIONS (pfile)-&gt;cplusplus) {
02559     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">' '</font>);
02560     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'4'</font>);
02561   }
02562 <font class="preprocessor">#endif</font>
02563 <font class="preprocessor"></font>  <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'\n'</font>);
02564   pfile-&gt;lineno = line;
02565 }
02566 
02567 
02568 <font class="comment">/*</font>
02569 <font class="comment"> * Parse a macro argument and append the info on PFILE's token_buffer.</font>
02570 <font class="comment"> * REST_ARGS means to absorb the rest of the args.</font>
02571 <font class="comment"> * Return nonzero to indicate a syntax error.</font>
02572 <font class="comment"> */</font>
02573 
02574 <font class="keyword">static</font> <font class="keyword">enum</font> cpp_token
02575 macarg (cppReader *pfile, <font class="keywordtype">int</font> rest_args)<font class="keyword"></font>
02576 <font class="keyword"></font>{
02577   <font class="keywordtype">int</font> paren = 0;
02578   <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
02579   <font class="keywordtype">char</font> save_put_out_comments = CPPOPTIONS (pfile)-&gt;put_out_comments;
02580   <font class="keywordtype">bool</font> oldexpand = pfile-&gt;no_macro_expand;
02581   CPPOPTIONS (pfile)-&gt;put_out_comments = 1;
02582 
02583   <font class="comment">/* Try to parse as much of the argument as exists at this</font>
02584 <font class="comment">     input stack level.  */</font>
02585 
02586   pfile-&gt;no_macro_expand = TRUE;
02587 
02588   <font class="keywordflow">for</font> (;;)
02589     {
02590       <a class="code" href="struct_token.html">token</a> = <a class="code" href="cpplib_c.html#a141">cppGetToken</a> (pfile);
02591 
02592       <font class="keywordflow">switch</font> (<a class="code" href="struct_token.html">token</a>)
02593         {
02594         <font class="keywordflow">case</font> CPP_EOF:
02595           <font class="keywordflow">goto</font> done;
02596         <font class="keywordflow">case</font> CPP_POP:
02597           <font class="comment">/* If we've hit end of file, it's an error (reported by caller).</font>
02598 <font class="comment">             Ditto if it's the end of cpp_expand_to_buffer text.</font>
02599 <font class="comment">             If we've hit end of macro, just continue.  */</font>
02600           <font class="keywordflow">if</font> (!cppBuffer_isMacro (CPPBUFFER (pfile)))
02601             <font class="keywordflow">goto</font> done;
02602           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02603         <font class="keywordflow">case</font> CPP_LPAREN:
02604           paren++;
02605           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02606         <font class="keywordflow">case</font> CPP_RPAREN:
02607           <font class="keywordflow">if</font> (--paren &lt; 0)
02608             <font class="keywordflow">goto</font> found;
02609           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02610         <font class="keywordflow">case</font> CPP_COMMA:
02611           <font class="comment">/* if we've returned to lowest level and</font>
02612 <font class="comment">             we aren't absorbing all args */</font>
02613           <font class="keywordflow">if</font> (paren == 0 &amp;&amp; rest_args == 0)
02614             <font class="keywordflow">goto</font> found;
02615           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02616         found:
02617           <font class="comment">/* Remove ',' or ')' from argument buffer.  */</font>
02618           <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, -1);
02619           <font class="keywordflow">goto</font> done;
02620         <font class="keywordflow">default</font>:
02621           ;
02622         }
02623     }
02624 
02625 done:
02626   CPPOPTIONS (pfile)-&gt;put_out_comments = save_put_out_comments;
02627   pfile-&gt;no_macro_expand = oldexpand;
02628 
02629   <font class="keywordflow">return</font> <a class="code" href="struct_token.html">token</a>;
02630 }
02631 
02632 
02633 <font class="comment">/* Turn newlines to spaces in the string of length LENGTH at START,</font>
02634 <font class="comment">   except inside of string constants.</font>
02635 <font class="comment">   The string is copied into itself with its beginning staying fixed.  */</font>
02636 
02637 <font class="keyword">static</font> <font class="keywordtype">int</font>
02638 change_newlines (<font class="keywordtype">char</font> *start, <font class="keywordtype">int</font> length)<font class="keyword"></font>
02639 <font class="keyword"></font>{
02640   <font class="keyword">register</font> <font class="keywordtype">char</font> *ibp;
02641   <font class="keyword">register</font> <font class="keywordtype">char</font> *obp;
02642   <font class="keyword">register</font> <font class="keywordtype">char</font> *limit;
02643   <font class="keywordtype">char</font> c;
02644 
02645   ibp = start;
02646   limit = start + length;
02647   obp = start;
02648 
02649   <font class="keywordflow">while</font> (ibp &lt; limit) {
02650     *obp++ = c = *ibp++;
02651     <font class="keywordflow">switch</font> (c) {
02652 
02653     <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
02654     <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
02655       <font class="comment">/* Notice and skip strings, so that we don't delete newlines in them.  */</font>
02656       {
02657         <font class="keywordtype">char</font> quotec = c;
02658         <font class="keywordflow">while</font> (ibp &lt; limit) {
02659           *obp++ = c = *ibp++;
02660           <font class="keywordflow">if</font> (c == quotec)
02661             <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
02662           <font class="keywordflow">if</font> (c == <font class="charliteral">'\n'</font> &amp;&amp; quotec == <font class="charliteral">'\''</font>)
02663             <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
02664         }
02665       }
02666     <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02667     }
02668   }
02669 
02670   <font class="keywordflow">return</font> obp - start;
02671 }
02672 
02673 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> <font class="keyword">struct </font>tm *
02674 timestamp (<font class="comment">/*@returned@*/</font> cppReader *pfile)
02675 {
02676   <font class="keywordflow">if</font> (pfile-&gt;timebuf == NULL)
02677     {
02678       time_t t = time ((time_t *) 0);
02679       pfile-&gt;timebuf = localtime (&amp;t);
02680     }
02681 
02682   llassert (pfile-&gt;timebuf != NULL);
02683 
02684   <font class="keywordflow">return</font> pfile-&gt;timebuf;
02685 }
02686 
02687 <font class="keyword">static</font> ob_mstring monthnames[] = {
02688   <font class="stringliteral">"Jan"</font>, <font class="stringliteral">"Feb"</font>, <font class="stringliteral">"Mar"</font>, <font class="stringliteral">"Apr"</font>, <font class="stringliteral">"May"</font>, <font class="stringliteral">"Jun"</font>,
02689   <font class="stringliteral">"Jul"</font>, <font class="stringliteral">"Aug"</font>, <font class="stringliteral">"Sep"</font>, <font class="stringliteral">"Oct"</font>, <font class="stringliteral">"Nov"</font>, <font class="stringliteral">"Dec"</font>,
02690 } ;
02691 
02692 <font class="comment">/*</font>
02693 <font class="comment"> * expand things like __FILE__.  Place the expansion into the output</font>
02694 <font class="comment"> * buffer *without* rescanning.</font>
02695 <font class="comment"> */</font>
02696 
02697 <font class="keyword">static</font> <font class="keywordtype">void</font>
02698 special_symbol (HASHNODE *hp, cppReader *pfile)<font class="keyword"></font>
02699 <font class="keyword"></font>{
02700   cstring buf = cstring_undefined;
02701   size_t len;
02702   <font class="keywordtype">int</font> true_indepth;
02703   cppBuffer *ip;
02704   <font class="keyword">struct </font>tm *timebuf;
02705 
02706   <font class="keywordtype">int</font> paren = 0;                <font class="comment">/* For special `defined' keyword */</font>
02707 
02708   <font class="keywordflow">for</font> (ip = cppReader_getBuffer (pfile); ip != NULL; ip = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (ip))
02709     {
02710       <font class="keywordflow">if</font> (ip == cppReader_nullBuffer (pfile))
02711         {
02712           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
02713                         cstring_makeLiteralTemp (<font class="stringliteral">"cccp error: not in any file?!"</font>));
02714           <font class="keywordflow">return</font>;                       <font class="comment">/* the show must go on */</font>
02715         }
02716 
02717       <font class="keywordflow">if</font> (ip != NULL &amp;&amp; ip-&gt;fname != NULL)
02718         {
02719           <font class="keywordflow">break</font>;
02720         }
02721     }
02722 
02723   <font class="keywordflow">switch</font> (hp-&gt;type)
02724     {
02725     <font class="keywordflow">case</font> T_FILE:
02726     <font class="keywordflow">case</font> T_BASE_FILE:
02727       {
02728         <font class="keywordtype">char</font> *string;
02729         <font class="keywordflow">if</font> (hp-&gt;type == T_BASE_FILE)
02730           {
02731             <font class="keywordflow">while</font> (<a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (ip) != cppReader_nullBuffer (pfile))
02732               {
02733                 ip = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (ip);
02734               }
02735           }
02736 
02737         llassert (ip != NULL);
02738         string = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (ip-&gt;nominal_fname);
02739 
02740         <font class="keywordflow">if</font> (string == NULL)
02741           {
02742             string = <font class="stringliteral">""</font>;
02743           }
02744 
02745         cppReader_reserve (pfile, 3 + 4 * strlen (string));
02746         quote_string (pfile, string);
02747         <font class="keywordflow">return</font>;
02748       }
02749 
02750     <font class="keywordflow">case</font> T_INCLUDE_LEVEL:
02751       true_indepth = 0;
02752       ip = cppReader_getBuffer (pfile);
02753 
02754       <font class="keywordflow">for</font> (;  ip != cppReader_nullBuffer (pfile) &amp;&amp; ip != NULL;
02755            ip = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (ip))
02756         {
02757           <font class="keywordflow">if</font> (ip != NULL &amp;&amp; ip-&gt;fname != NULL)
02758             {
02759               true_indepth++;
02760             }
02761         }
02762 
02763       buf = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%d"</font>, true_indepth - 1);
02764       <font class="keywordflow">break</font>;
02765 
02766     <font class="keywordflow">case</font> T_VERSION:
02767       buf = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"\"%s\""</font>, cstring_makeLiteralTemp (CPP_VERSION));
02768       <font class="keywordflow">break</font>;
02769 
02770 <font class="preprocessor">#ifndef NO_BUILTIN_SIZE_TYPE</font>
02771 <font class="preprocessor"></font>    <font class="keywordflow">case</font> T_SIZE_TYPE:
02772       buf = cstring_makeLiteral (SIZE_TYPE);
02773       <font class="keywordflow">break</font>;
02774 <font class="preprocessor">#endif</font>
02775 <font class="preprocessor"></font>
02776 <font class="preprocessor">#ifndef NO_BUILTIN_PTRDIFF_TYPE</font>
02777 <font class="preprocessor"></font>    <font class="keywordflow">case</font> T_PTRDIFF_TYPE:
02778       buf = cstring_makeLiteral (PTRDIFF_TYPE);
02779       <font class="keywordflow">break</font>;
02780 <font class="preprocessor">#endif</font>
02781 <font class="preprocessor"></font>
02782     <font class="keywordflow">case</font> T_WCHAR_TYPE:
02783       buf = cstring_makeLiteral (cppReader_wcharType (pfile));
02784       <font class="keywordflow">break</font>;
02785 
02786     <font class="keywordflow">case</font> T_USER_LABEL_PREFIX_TYPE:
02787       buf = cstring_makeLiteral (USER_LABEL_PREFIX);
02788       <font class="keywordflow">break</font>;
02789 
02790     <font class="keywordflow">case</font> T_REGISTER_PREFIX_TYPE:
02791       buf = cstring_makeLiteral (REGISTER_PREFIX);
02792       <font class="keywordflow">break</font>;
02793 
02794     <font class="keywordflow">case</font> T_CONST:
02795       buf = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%d"</font>, hp-&gt;value.ival);
02796       <font class="keywordflow">break</font>;
02797 
02798     <font class="keywordflow">case</font> T_SPECLINE:
02799       {
02800         <font class="keywordflow">if</font> (ip != NULL)
02801           {
02802             <font class="keywordtype">int</font> line = ip-&gt;lineno;
02803             <font class="keywordtype">int</font> col = ip-&gt;colno;
02804 
02805             llassert (ip-&gt;cur != NULL);
02806             adjust_position (cppLineBase (ip), ip-&gt;cur, &amp;line, &amp;col);
02807 
02808             buf = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%d"</font>, (<font class="keywordtype">int</font>) line);
02809           }
02810         <font class="keywordflow">else</font>
02811           {
02812             BADBRANCH;
02813           }
02814       }
02815     <font class="keywordflow">break</font>;
02816 
02817     <font class="keywordflow">case</font> T_DATE:
02818     <font class="keywordflow">case</font> T_TIME:
02819       {
02820         <font class="keywordtype">char</font> *sbuf = (<font class="keywordtype">char</font> *) dmalloc (20);
02821         timebuf = timestamp (pfile);
02822         <font class="keywordflow">if</font> (hp-&gt;type == T_DATE)
02823           {
02824             sprintf (sbuf, <font class="stringliteral">"\"%s %2d %4d\""</font>, monthnames[timebuf-&gt;tm_mon],
02825                      timebuf-&gt;tm_mday, timebuf-&gt;tm_year + 1900);
02826           }
02827         <font class="keywordflow">else</font>
02828           {
02829             sprintf (sbuf, <font class="stringliteral">"\"%02d:%02d:%02d\""</font>, timebuf-&gt;tm_hour, timebuf-&gt;tm_min,
02830                      timebuf-&gt;tm_sec);
02831           }
02832 
02833         buf = cstring_fromCharsNew (sbuf);
02834         <a class="code" href="general_c.html#a0">sfree</a> (sbuf);
02835         <font class="keywordflow">break</font>;
02836       }
02837 
02838     <font class="keywordflow">case</font> T_SPEC_DEFINED:
02839       buf = cstring_makeLiteral (<font class="stringliteral">" 0 "</font>);     <font class="comment">/* Assume symbol is not defined */</font>
02840       ip = cppReader_getBuffer (pfile);
02841 
02842       llassert (ip-&gt;cur != NULL);
02843       <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (ip-&gt;cur);
02844 
02845       <font class="keywordflow">if</font> (*ip-&gt;cur == <font class="charliteral">'('</font>)
02846         {
02847           paren++;
02848           ip-&gt;cur++;                    <font class="comment">/* Skip over the paren */</font>
02849           <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (ip-&gt;cur);
02850         }
02851 
02852       <font class="keywordflow">if</font> (!is_idstart[(<font class="keywordtype">int</font>) *ip-&gt;cur])
02853         <font class="keywordflow">goto</font> oops;
02854       <font class="keywordflow">if</font> (ip-&gt;cur[0] == <font class="charliteral">'L'</font> &amp;&amp; (ip-&gt;cur[1] == <font class="charliteral">'\''</font> || ip-&gt;cur[1] == <font class="charliteral">'"'</font>))
02855         <font class="keywordflow">goto</font> oops;
02856 
02857       <font class="keywordflow">if</font> ((hp = <a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (ip-&gt;cur, -1, -1)) != 0)
02858         {
02859           <a class="code" href="cstring_c.html#a27">cstring_free</a> (buf);
02860           buf = cstring_makeLiteral (<font class="stringliteral">" 1 "</font>);
02861         }
02862 
02863       <font class="keywordflow">while</font> (is_idchar[(<font class="keywordtype">int</font>) *ip-&gt;cur])
02864         {
02865           ++ip-&gt;cur;
02866         }
02867 
02868       <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (ip-&gt;cur);
02869 
02870       <font class="keywordflow">if</font> (paren != 0)
02871         {
02872           <font class="keywordflow">if</font> (*ip-&gt;cur != <font class="charliteral">')'</font>)
02873             <font class="keywordflow">goto</font> oops;
02874           ++ip-&gt;cur;
02875         }
02876       <font class="keywordflow">break</font>;
02877 
02878     oops:
02879 
02880       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
02881                     cstring_makeLiteralTemp (<font class="stringliteral">"`defined' without an identifier"</font>));
02882       <font class="keywordflow">break</font>;
02883 
02884     <font class="keywordflow">default</font>:
02885       cpp_setLocation (pfile);
02886       <a class="code" href="llerror_c.html#a48">llfatalerror</a> (message (<font class="stringliteral">"Pre-processing error: invalid special hash type"</font>));
02887     }
02888 
02889   len = <a class="code" href="general_c.html#a33">size_fromInt</a> (cstring_length (buf));
02890 
02891   cppReader_reserve (pfile, len + 1);
02892   cppReader_putStrN (pfile, cstring_toCharsSafe (buf), len);
02893   <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
02894 
02895   <a class="code" href="cstring_c.html#a27">cstring_free</a> (buf);
02896   <font class="keywordflow">return</font>;
02897 }
02898 
02899 <font class="comment">/* Write out a #define command for the special named MACRO_NAME</font>
02900 <font class="comment">   to PFILE's token_buffer.  */</font>
02901 
02902 <font class="keyword">static</font> <font class="keywordtype">void</font>
02903 dump_special_to_buffer (cppReader *pfile, <font class="keywordtype">char</font> *macro_name)<font class="keyword"></font>
02904 <font class="keyword"></font>{
02905   <font class="keyword">static</font> <font class="keywordtype">char</font> define_directive[] = <font class="stringliteral">"#define "</font>;
02906   size_t macro_name_length = strlen (macro_name);
02907   output_line_command (pfile, 0, same_file);
02908   cppReader_reserve (pfile, <font class="keyword">sizeof</font>(define_directive) + macro_name_length);
02909   cppReader_putStrN (pfile, define_directive, <font class="keyword">sizeof</font>(define_directive)-1);
02910   cppReader_putStrN (pfile, macro_name, macro_name_length);
02911   <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">' '</font>);
02912   cpp_expand_to_buffer (pfile, macro_name, macro_name_length);
02913   <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">'\n'</font>);
02914 }
02915 
02916 <font class="comment">/* Initialize the built-in macros.  */</font>
02917 
02918 <font class="keyword">static</font> <font class="keywordtype">void</font>
02919 cppReader_installBuiltin (<font class="comment">/*@observer@*/</font> <font class="keywordtype">char</font> *name, ctype ctyp,
02920                           <font class="keywordtype">int</font> len, <font class="keyword">enum</font> node_type type,
02921                           <font class="keywordtype">int</font> ivalue, <font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> <font class="keywordtype">char</font> *value,
02922                           <font class="keywordtype">int</font> hash)<font class="keyword"></font>
02923 <font class="keyword"></font>{
02924   cstring sname = cstring_fromCharsNew (name);
02925 
02926   llassert (usymtab_inGlobalScope ());
02927 
02928   <font class="comment">/*</font>
02929 <font class="comment">  ** Be careful here: this is done before the ctype table has</font>
02930 <font class="comment">  ** been initialized.</font>
02931 <font class="comment">  */</font>
02932 
02933   <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (sname))
02934     {
02935       uentry ue = <a class="code" href="uentry_c.html#a85">uentry_makeConstant</a> (sname, ctyp, fileloc_createBuiltin ());
02936 
02937       <font class="keywordflow">if</font> (ctype_equal (ctyp, ctype_string))
02938         {
02939           qualList ql = <a class="code" href="qualList_c.html#a0">qualList_new</a> ();
02940           ql = <a class="code" href="qualList_c.html#a4">qualList_add</a> (ql, QU_OBSERVER);
02941           <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (ue, ql);
02942           <a class="code" href="qualList_c.html#a11">qualList_free</a> (ql);
02943         }
02944 
02945       <a class="code" href="usymtab_c.html#a47">usymtab_addGlobalEntry</a> (ue);
02946     }
02947   <font class="keywordflow">else</font>
02948     {
02949       ;
02950     }
02951 
02952   (<font class="keywordtype">void</font>) <a class="code" href="cpphash_c.html#a13">cppReader_install</a> (name, len, type, ivalue, value, hash);
02953   <a class="code" href="cstring_c.html#a27">cstring_free</a> (sname);
02954 }
02955 
02956 <font class="keyword">static</font> <font class="keywordtype">void</font>
02957 cppReader_installBuiltinType (<font class="comment">/*@observer@*/</font> <font class="keywordtype">char</font> *name, ctype ctyp,
02958                               <font class="keywordtype">int</font> len, <font class="keyword">enum</font> node_type type,
02959                               <font class="keywordtype">int</font> ivalue,
02960                               <font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> <font class="keywordtype">char</font> *value, <font class="keywordtype">int</font> hash)<font class="keyword"></font>
02961 <font class="keyword"></font>{
02962   cstring sname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (name);
02963   <font class="comment">/* evs 2000 07 10 - removed a memory leak, detected by lclint */</font>
02964 
02965   llassert (usymtab_inGlobalScope ());
02966 
02967   <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (sname))
02968     {
02969       uentry ue = <a class="code" href="uentry_c.html#a112">uentry_makeDatatype</a> (sname, ctyp,
02970                                        NO, NO,
02971                                        fileloc_createBuiltin ());
02972       <a class="code" href="usymtab_c.html#a47">usymtab_addGlobalEntry</a> (ue);
02973     }
02974 
02975   (<font class="keywordtype">void</font>) <a class="code" href="cpphash_c.html#a13">cppReader_install</a> (name, len, type, ivalue, value, hash);
02976 }
02977 
02978 <font class="keyword">static</font> <font class="keywordtype">void</font>
02979 initialize_builtins (cppReader *pfile)<font class="keyword"></font>
02980 <font class="keyword"></font>{
02981   cppReader_installBuiltin (<font class="stringliteral">"__LINE__"</font>, ctype_int, -1, T_SPECLINE, 0, NULL, -1);
02982   cppReader_installBuiltin (<font class="stringliteral">"__DATE__"</font>, ctype_string, -1, T_DATE, 0, NULL, -1);
02983   cppReader_installBuiltin (<font class="stringliteral">"__FILE__"</font>, ctype_string, -1, T_FILE, 0, NULL, -1);
02984   cppReader_installBuiltin (<font class="stringliteral">"__BASE_FILE__"</font>, ctype_string, -1, T_BASE_FILE, 0, NULL, -1);
02985   cppReader_installBuiltin (<font class="stringliteral">"__INCLUDE_LEVEL__"</font>, ctype_int, -1, T_INCLUDE_LEVEL, 0, NULL, -1);
02986   cppReader_installBuiltin (<font class="stringliteral">"__VERSION__"</font>, ctype_string, -1, T_VERSION, 0, NULL, -1);
02987 <font class="preprocessor">#ifndef NO_BUILTIN_SIZE_TYPE</font>
02988 <font class="preprocessor"></font>  cppReader_installBuiltinType (<font class="stringliteral">"__SIZE_TYPE__"</font>, ctype_anyintegral, -1, T_SIZE_TYPE, 0, NULL, -1);
02989 <font class="preprocessor">#endif</font>
02990 <font class="preprocessor"></font><font class="preprocessor">#ifndef NO_BUILTIN_PTRDIFF_TYPE</font>
02991 <font class="preprocessor"></font>  cppReader_installBuiltinType (<font class="stringliteral">"__PTRDIFF_TYPE__ "</font>, ctype_anyintegral, -1, T_PTRDIFF_TYPE, 0, NULL, -1);
02992 <font class="preprocessor">#endif</font>
02993 <font class="preprocessor"></font>  cppReader_installBuiltinType (<font class="stringliteral">"__WCHAR_TYPE__"</font>, ctype_anyintegral, -1, T_WCHAR_TYPE, 0, NULL, -1);
02994   cppReader_installBuiltin (<font class="stringliteral">"__USER_LABEL_PREFIX__"</font>, ctype_string, -1, T_USER_LABEL_PREFIX_TYPE, 0, NULL, -1);
02995   cppReader_installBuiltin (<font class="stringliteral">"__REGISTER_PREFIX__"</font>, ctype_string, -1, T_REGISTER_PREFIX_TYPE, 0, NULL, -1);
02996   cppReader_installBuiltin (<font class="stringliteral">"__TIME__"</font>, ctype_string, -1, T_TIME, 0, NULL, -1);
02997 
02998   <font class="comment">/*</font>
02999 <font class="comment">  ** No, don't define __STDC__</font>
03000 <font class="comment">  **</font>
03001 <font class="comment"></font>
03002 <font class="comment">  if (!cppReader_isTraditional (pfile))</font>
03003 <font class="comment">    {</font>
03004 <font class="comment">      cppReader_installBuiltin ("__STDC__", ctype_int, -1, T_CONST, STDC_VALUE, NULL, -1);</font>
03005 <font class="comment">    }</font>
03006 <font class="comment"></font>
03007 <font class="comment">  **</font>
03008 <font class="comment">  */</font>
03009 
03010 <font class="preprocessor"># ifdef WIN32</font>
03011 <font class="preprocessor"></font>    cppReader_installBuiltin (<font class="stringliteral">"_WIN32"</font>, ctype_int, -1, T_CONST, STDC_VALUE, NULL, -1);
03012 <font class="preprocessor"># endif</font>
03013 <font class="preprocessor"></font>
03014   <font class="comment">/*</font>
03015 <font class="comment">  ** This is supplied using a -D by the compiler driver</font>
03016 <font class="comment">  ** so that it is present only when truly compiling with GNU C.</font>
03017 <font class="comment">  */</font>
03018 
03019   <font class="comment">/*  cppReader_install ("__GNUC__", -1, T_CONST, 2, 0, -1);  */</font>
03020 
03021   cppReader_installBuiltin (<font class="stringliteral">"__LCLINT__"</font>, ctype_int, -1, T_CONST, 2, NULL, -1);
03022 
03023   <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;debug_output)
03024     {
03025       dump_special_to_buffer (pfile, <font class="stringliteral">"__BASE_FILE__"</font>);
03026       dump_special_to_buffer (pfile, <font class="stringliteral">"__VERSION__"</font>);
03027 <font class="preprocessor">#ifndef NO_BUILTIN_SIZE_TYPE</font>
03028 <font class="preprocessor"></font>      dump_special_to_buffer (pfile, <font class="stringliteral">"__SIZE_TYPE__"</font>);
03029 <font class="preprocessor">#endif</font>
03030 <font class="preprocessor"></font><font class="preprocessor">#ifndef NO_BUILTIN_PTRDIFF_TYPE</font>
03031 <font class="preprocessor"></font>      dump_special_to_buffer (pfile, <font class="stringliteral">"__PTRDIFF_TYPE__"</font>);
03032 <font class="preprocessor">#endif</font>
03033 <font class="preprocessor"></font>      dump_special_to_buffer (pfile, <font class="stringliteral">"__WCHAR_TYPE__"</font>);
03034       dump_special_to_buffer (pfile, <font class="stringliteral">"__DATE__"</font>);
03035       dump_special_to_buffer (pfile, <font class="stringliteral">"__TIME__"</font>);
03036       <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
03037         dump_special_to_buffer (pfile, <font class="stringliteral">"__STDC__"</font>);
03038     }
03039 }
03040 
03041 
03042 <font class="comment">/* Return 1 iff a token ending in C1 followed directly by a token C2</font>
03043 <font class="comment">   could cause mis-tokenization.  */</font>
03044 
03045 <font class="keyword">static</font> <font class="keywordtype">bool</font>
03046 unsafe_chars (<font class="keywordtype">char</font> c1, <font class="keywordtype">char</font> c2)<font class="keyword"></font>
03047 <font class="keyword"></font>{
03048   <font class="keywordflow">switch</font> (c1)
03049     {
03050     <font class="keywordflow">case</font> <font class="charliteral">'+'</font>: <font class="keywordflow">case</font> <font class="charliteral">'-'</font>:
03051       <font class="keywordflow">if</font> (c2 == c1 || c2 == <font class="charliteral">'='</font>)
03052         <font class="keywordflow">return</font> 1;
03053       <font class="keywordflow">goto</font> letter;
03054     <font class="keywordflow">case</font> <font class="charliteral">'.'</font>:
03055     <font class="keywordflow">case</font> <font class="charliteral">'0'</font>: <font class="keywordflow">case</font> <font class="charliteral">'1'</font>: <font class="keywordflow">case</font> <font class="charliteral">'2'</font>: <font class="keywordflow">case</font> <font class="charliteral">'3'</font>: <font class="keywordflow">case</font> <font class="charliteral">'4'</font>:
03056     <font class="keywordflow">case</font> <font class="charliteral">'5'</font>: <font class="keywordflow">case</font> <font class="charliteral">'6'</font>: <font class="keywordflow">case</font> <font class="charliteral">'7'</font>: <font class="keywordflow">case</font> <font class="charliteral">'8'</font>: <font class="keywordflow">case</font> <font class="charliteral">'9'</font>:
03057     <font class="keywordflow">case</font> <font class="charliteral">'e'</font>: <font class="keywordflow">case</font> <font class="charliteral">'E'</font>: <font class="keywordflow">case</font> <font class="charliteral">'p'</font>: <font class="keywordflow">case</font> <font class="charliteral">'P'</font>:
03058       <font class="keywordflow">if</font> (c2 == <font class="charliteral">'-'</font> || c2 == <font class="charliteral">'+'</font>)
03059         <font class="keywordflow">return</font> 1; <font class="comment">/* could extend a pre-processing number */</font>
03060       <font class="keywordflow">goto</font> letter;
03061     <font class="keywordflow">case</font> <font class="charliteral">'L'</font>:
03062       <font class="keywordflow">if</font> (c2 == <font class="charliteral">'\''</font> || c2 == <font class="charliteral">'\"'</font>)
03063         <font class="keywordflow">return</font> 1;   <font class="comment">/* Could turn into L"xxx" or L'xxx'.  */</font>
03064       <font class="keywordflow">goto</font> letter;
03065     letter:
03066     <font class="keywordflow">case</font> <font class="charliteral">'_'</font>:
03067     <font class="keywordflow">case</font> <font class="charliteral">'a'</font>: <font class="keywordflow">case</font> <font class="charliteral">'b'</font>: <font class="keywordflow">case</font> <font class="charliteral">'c'</font>: <font class="keywordflow">case</font> <font class="charliteral">'d'</font>:           <font class="keywordflow">case</font> <font class="charliteral">'f'</font>:
03068     <font class="keywordflow">case</font> <font class="charliteral">'g'</font>: <font class="keywordflow">case</font> <font class="charliteral">'h'</font>: <font class="keywordflow">case</font> <font class="charliteral">'i'</font>: <font class="keywordflow">case</font> <font class="charliteral">'j'</font>: <font class="keywordflow">case</font> <font class="charliteral">'k'</font>: <font class="keywordflow">case</font> <font class="charliteral">'l'</font>:
03069     <font class="keywordflow">case</font> <font class="charliteral">'m'</font>: <font class="keywordflow">case</font> <font class="charliteral">'n'</font>: <font class="keywordflow">case</font> <font class="charliteral">'o'</font>:           <font class="keywordflow">case</font> <font class="charliteral">'q'</font>: <font class="keywordflow">case</font> <font class="charliteral">'r'</font>:
03070     <font class="keywordflow">case</font> <font class="charliteral">'s'</font>: <font class="keywordflow">case</font> <font class="charliteral">'t'</font>: <font class="keywordflow">case</font> <font class="charliteral">'u'</font>: <font class="keywordflow">case</font> <font class="charliteral">'v'</font>: <font class="keywordflow">case</font> <font class="charliteral">'w'</font>: <font class="keywordflow">case</font> <font class="charliteral">'x'</font>:
03071     <font class="keywordflow">case</font> <font class="charliteral">'y'</font>: <font class="keywordflow">case</font> <font class="charliteral">'z'</font>:
03072     <font class="keywordflow">case</font> <font class="charliteral">'A'</font>: <font class="keywordflow">case</font> <font class="charliteral">'B'</font>: <font class="keywordflow">case</font> <font class="charliteral">'C'</font>: <font class="keywordflow">case</font> <font class="charliteral">'D'</font>:           <font class="keywordflow">case</font> <font class="charliteral">'F'</font>:
03073     <font class="keywordflow">case</font> <font class="charliteral">'G'</font>: <font class="keywordflow">case</font> <font class="charliteral">'H'</font>: <font class="keywordflow">case</font> <font class="charliteral">'I'</font>: <font class="keywordflow">case</font> <font class="charliteral">'J'</font>: <font class="keywordflow">case</font> <font class="charliteral">'K'</font>:
03074     <font class="keywordflow">case</font> <font class="charliteral">'M'</font>: <font class="keywordflow">case</font> <font class="charliteral">'N'</font>: <font class="keywordflow">case</font> <font class="charliteral">'O'</font>:           <font class="keywordflow">case</font> <font class="charliteral">'Q'</font>: <font class="keywordflow">case</font> <font class="charliteral">'R'</font>:
03075     <font class="keywordflow">case</font> <font class="charliteral">'S'</font>: <font class="keywordflow">case</font> <font class="charliteral">'T'</font>: <font class="keywordflow">case</font> <font class="charliteral">'U'</font>: <font class="keywordflow">case</font> <font class="charliteral">'V'</font>: <font class="keywordflow">case</font> <font class="charliteral">'W'</font>: <font class="keywordflow">case</font> <font class="charliteral">'X'</font>:
03076     <font class="keywordflow">case</font> <font class="charliteral">'Y'</font>: <font class="keywordflow">case</font> <font class="charliteral">'Z'</font>:
03077       <font class="comment">/* We're in the middle of either a name or a pre-processing number.  */</font>
03078       <font class="keywordflow">return</font> (is_idchar[(<font class="keywordtype">int</font>) c2] || c2 == <font class="charliteral">'.'</font>);
03079     <font class="keywordflow">case</font> <font class="charliteral">'&lt;'</font>: <font class="keywordflow">case</font> <font class="charliteral">'&gt;'</font>: <font class="keywordflow">case</font> <font class="charliteral">'!'</font>: <font class="keywordflow">case</font> <font class="charliteral">'%'</font>: <font class="keywordflow">case</font> <font class="charliteral">'#'</font>: <font class="keywordflow">case</font> <font class="charliteral">':'</font>:
03080     <font class="keywordflow">case</font> <font class="charliteral">'^'</font>: <font class="keywordflow">case</font> <font class="charliteral">'&amp;'</font>: <font class="keywordflow">case</font> <font class="charliteral">'|'</font>: <font class="keywordflow">case</font> <font class="charliteral">'*'</font>: <font class="keywordflow">case</font> <font class="charliteral">'/'</font>: <font class="keywordflow">case</font> <font class="charliteral">'='</font>:
03081       <font class="keywordflow">return</font> (c2 == c1 || c2 == <font class="charliteral">'='</font>);
03082     }
03083   <font class="keywordflow">return</font> 0;
03084 }
03085 
03086 <font class="comment">/* Expand a macro call.</font>
03087 <font class="comment">   HP points to the symbol that is the macro being called.</font>
03088 <font class="comment">   Put the result of expansion onto the input stack</font>
03089 <font class="comment">   so that subsequent input by our caller will use it.</font>
03090 <font class="comment"></font>
03091 <font class="comment">   If macro wants arguments, caller has already verified that</font>
03092 <font class="comment">   an argument list follows; arguments come from the input stack.  */</font>
03093 
03094 <font class="keyword">static</font> <font class="keywordtype">void</font>
03095 macroexpand (cppReader *pfile, <font class="comment">/*@dependent@*/</font> HASHNODE *hp)<font class="keyword"></font>
03096 <font class="keyword"></font>{
03097   <font class="keywordtype">int</font> nargs;
03098   DEFINITION *defn = hp-&gt;value.defn;
03099   <font class="keywordtype">char</font> *xbuf;
03100   <font class="keywordtype">char</font> *oxbuf = NULL;
03101   <font class="keywordtype">int</font> start_line;
03102   <font class="keywordtype">int</font> start_column;
03103   size_t xbuf_len;
03104   size_t old_written = cppReader_getWritten (pfile);
03105   <font class="keywordtype">int</font> rest_args;
03106   <font class="keywordtype">int</font> rest_zero = 0;
03107   <font class="keywordtype">int</font> i;
03108   <font class="keyword">struct </font><a class="code" href="struct_argdata.html">argdata</a> *args = NULL;
03109 
03110   pfile-&gt;output_escapes++;
03111 
03112   <a class="code" href="cpplib_c.html#a126">cppBuffer_lineAndColumn</a> (cppReader_fileBuffer (pfile), &amp;start_line, &amp;start_column);
03113 
03114   nargs = defn-&gt;nargs;
03115 
03116   <font class="keywordflow">if</font> (nargs &gt;= 0)
03117     {
03118       <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a> = CPP_EOF;
03119 
03120       args = (<font class="keyword">struct </font><a class="code" href="struct_argdata.html">argdata</a> *) dmalloc ((nargs + 1) * sizeof (*args));
03121 
03122       <font class="keywordflow">for</font> (i = 0; i &lt; nargs; i++)
03123         {
03124           args[i].expanded = 0;
03125           args[i].raw = 0;
03126           args[i].raw_length = 0;
03127           args[i].expand_length = args[i].stringified_length = -1;
03128           args[i].use_count = 0;
03129         }
03130 
03131       <font class="comment">/*</font>
03132 <font class="comment">      ** Parse all the macro args that are supplied.  I counts them.</font>
03133 <font class="comment">      ** The first NARGS args are stored in ARGS.</font>
03134 <font class="comment">      ** The rest are discarded.  If rest_args is set then we assume</font>
03135 <font class="comment">      ** macarg absorbed the rest of the args.</font>
03136 <font class="comment">      */</font>
03137 
03138       i = 0;
03139       rest_args = 0;
03140 
03141       <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1); <font class="comment">/* Discard the open-parenthesis before the first arg.  */</font>
03142       <font class="keywordflow">do</font>
03143         {
03144           <font class="keywordflow">if</font> (rest_args != 0)
03145             {
03146               <font class="keywordflow">continue</font>;
03147             }
03148 
03149           <font class="keywordflow">if</font> (i &lt; nargs || (nargs == 0 &amp;&amp; i == 0))
03150             {
03151               <font class="comment">/* if we are working on last arg which absorbs rest of args... */</font>
03152               <font class="keywordflow">if</font> (i == nargs - 1 &amp;&amp; defn-&gt;rest_args)
03153                 {
03154                   rest_args = 1;
03155                 }
03156 
03157               args[i].raw = <a class="code" href="general_c.html#a35">size_toLong</a> (cppReader_getWritten (pfile));
03158               <a class="code" href="struct_token.html">token</a> = macarg (pfile, rest_args);
03159               args[i].raw_length = cppReader_getWritten (pfile) - args[i].raw;
03160               args[i].newlines = FALSE; <font class="comment">/* FIXME */</font>
03161             }
03162           <font class="keywordflow">else</font>
03163             {
03164               <a class="code" href="struct_token.html">token</a> = macarg (pfile, 0);
03165             }
03166 
03167           <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_EOF || <a class="code" href="struct_token.html">token</a> == CPP_POP)
03168             {
03169               <a class="code" href="cpperror_c.html#a14">cppReader_errorWithLine</a> (pfile, start_line, start_column,
03170                                    cstring_fromCharsNew (<font class="stringliteral">"unterminated macro call"</font>));
03171               <a class="code" href="general_c.html#a0">sfree</a> (args);
03172               <font class="keywordflow">return</font>;
03173             }
03174           i++;
03175         } <font class="keywordflow">while</font> (<a class="code" href="struct_token.html">token</a> == CPP_COMMA);
03176 
03177       <font class="comment">/* If we got one arg but it was just whitespace, call that 0 args.  */</font>
03178       <font class="keywordflow">if</font> (i == 1)
03179         {
03180           <font class="keywordtype">char</font> *bp;
03181           <font class="keywordtype">char</font> *lim;
03182 
03183           assertSet (args);
03184 
03185           bp = ARG_BASE + args[0].raw;
03186           lim = bp + args[0].raw_length;
03187 
03188           <font class="comment">/* cpp.texi says for foo ( ) we provide one argument.</font>
03189 <font class="comment">             However, if foo wants just 0 arguments, treat this as 0.  */</font>
03190 
03191           <font class="keywordflow">if</font> (nargs == 0)
03192             {
03193               <font class="keywordflow">while</font> (bp != lim &amp;&amp; is_space[(<font class="keywordtype">int</font>) *bp])
03194                 {
03195                   bp++;
03196                 }
03197             }
03198 
03199           <font class="keywordflow">if</font> (bp == lim)
03200             i = 0;
03201         }
03202 
03203       <font class="comment">/* Don't output an error message if we have already output one for</font>
03204 <font class="comment">         a parse error above.  */</font>
03205       rest_zero = 0;
03206 
03207       <font class="keywordflow">if</font> (nargs == 0 &amp;&amp; i &gt; 0)
03208         {
03209           <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03210                      message (<font class="stringliteral">"arguments given to macro `%s'"</font>, hp-&gt;name));
03211         }
03212       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (i &lt; nargs)
03213         {
03214           <font class="comment">/* traditional C allows foo() if foo wants one argument.  */</font>
03215           <font class="keywordflow">if</font> (nargs == 1 &amp;&amp; i == 0 &amp;&amp; cppReader_isTraditional (pfile))
03216             {
03217               ;
03218             }
03219           <font class="comment">/* the rest args token is allowed to absorb 0 tokens */</font>
03220           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (i == nargs - 1 &amp;&amp; defn-&gt;rest_args)
03221             rest_zero = 1;
03222           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (i == 0)
03223             <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03224                        message (<font class="stringliteral">"macro `%s' used without args"</font>, hp-&gt;name));
03225           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (i == 1)
03226             <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03227                        message (<font class="stringliteral">"macro `%s' used with just one arg"</font>, hp-&gt;name));
03228           <font class="keywordflow">else</font>
03229             {
03230               <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03231                          message (<font class="stringliteral">"macro `%s' used with only %d args"</font>,
03232                                   hp-&gt;name, i));
03233             }
03234         }
03235       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (i &gt; nargs)
03236         {
03237           <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03238                      message (<font class="stringliteral">"macro `%s' used with too many (%d) args"</font>, hp-&gt;name, i));
03239         }
03240       <font class="keywordflow">else</font>
03241         {
03242           ;
03243         }
03244     }
03245 
03246   <font class="comment">/* If macro wants zero args, we parsed the arglist for checking only.</font>
03247 <font class="comment">     Read directly from the macro definition.  */</font>
03248 
03249   <font class="keywordflow">if</font> (nargs &lt;= 0)
03250     {
03251       xbuf = defn-&gt;expansion;
03252       xbuf_len = defn-&gt;length;
03253     }
03254   <font class="keywordflow">else</font>
03255     {
03256       <font class="keywordtype">char</font> *exp = defn-&gt;expansion;
03257       <font class="keywordtype">int</font> offset;       <font class="comment">/* offset in expansion,</font>
03258 <font class="comment">                                   copied a piece at a time */</font>
03259       size_t totlen;    <font class="comment">/* total amount of exp buffer filled so far */</font>
03260 
03261       <font class="keyword">register</font> <font class="keyword">struct </font>reflist *ap, *last_ap;
03262 
03263       <font class="comment">/* Macro really takes args.  Compute the expansion of this call.  */</font>
03264 
03265       <font class="comment">/* Compute length in characters of the macro's expansion.</font>
03266 <font class="comment">         Also count number of times each arg is used.  */</font>
03267       xbuf_len = defn-&gt;length;
03268 
03269       llassert (args != NULL);
03270 
03271       <font class="keywordflow">for</font> (ap = defn-&gt;pattern; ap != NULL; ap = ap-&gt;next)
03272         {
03273           <font class="keywordflow">if</font> (ap-&gt;stringify)
03274             {
03275               <font class="keyword">struct </font><a class="code" href="struct_argdata.html">argdata</a> *arg = &amp;args[ap-&gt;argno];
03276 
03277               <font class="comment">/* Stringify it it hasn't already been */</font>
03278               assertSet (arg);
03279 
03280               <font class="keywordflow">if</font> (arg-&gt;stringified_length &lt; 0)
03281                 {
03282                   <font class="keywordtype">int</font> arglen = arg-&gt;raw_length;
03283                   <font class="keywordtype">bool</font> escaped = FALSE;
03284                   <font class="keywordtype">char</font> in_string = <font class="charliteral">'\0'</font>;
03285                   <font class="keywordtype">char</font> c;
03286 
03287                   <font class="comment">/* Initially need_space is -1.  Otherwise, 1 means the</font>
03288 <font class="comment">                     previous character was a space, but we suppressed it;</font>
03289 <font class="comment">                     0 means the previous character was a non-space.  */</font>
03290                   <font class="keywordtype">int</font> need_space = -1;
03291 
03292                   i = 0;
03293                   arg-&gt;stringified = cppReader_getWritten (pfile);
03294                   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
03295                     <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">'\"'</font>); <font class="comment">/* insert beginning quote */</font>
03296                   <font class="keywordflow">for</font> (; i &lt; arglen; i++)
03297                     {
03298                       c = (ARG_BASE + arg-&gt;raw)[i];
03299 
03300                       <font class="keywordflow">if</font> (in_string == <font class="charliteral">'\0'</font>)
03301                         {
03302                           <font class="comment">/* Internal sequences of whitespace are replaced by</font>
03303 <font class="comment">                             one space except within an string or char token.*/</font>
03304                           <font class="keywordflow">if</font> (is_space[(<font class="keywordtype">int</font>) c])
03305                             {
03306                               <font class="keywordflow">if</font> (cppReader_getWritten (pfile) &gt; arg-&gt;stringified
03307                                   &amp;&amp; (cppReader_getPWritten (pfile))[-1] == <font class="charliteral">'@'</font>)
03308                                 {
03309                                   <font class="comment">/* "@ " escape markers are removed */</font>
03310                                   <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, -1);
03311                                   <font class="comment">/*@innercontinue@*/</font> <font class="keywordflow">continue</font>;
03312                                 }
03313                               <font class="keywordflow">if</font> (need_space == 0)
03314                                 need_space = 1;
03315                               <font class="comment">/*@innercontinue@*/</font> <font class="keywordflow">continue</font>;
03316                             }
03317                           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (need_space &gt; 0)
03318                             <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">' '</font>);
03319                           <font class="keywordflow">else</font>
03320                             {
03321                               ;
03322                             }
03323 
03324                           need_space = 0;
03325                         }
03326 
03327                       <font class="keywordflow">if</font> (escaped)
03328                         escaped = 0;
03329                       <font class="keywordflow">else</font>
03330                         {
03331                           <font class="keywordflow">if</font> (c == <font class="charliteral">'\\'</font>)
03332                             escaped = 1;
03333 
03334                           <font class="keywordflow">if</font> (in_string != <font class="charliteral">'\0'</font>)
03335                             {
03336                               <font class="keywordflow">if</font> (c == in_string)
03337                                 in_string = <font class="charliteral">'\0'</font>;
03338                             }
03339                           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c == <font class="charliteral">'\"'</font> || c == <font class="charliteral">'\''</font>)
03340                             {
03341                               in_string = c;
03342                             }
03343                           <font class="keywordflow">else</font>
03344                             {
03345                               ;
03346                             }
03347                         }
03348 
03349                       <font class="comment">/* Escape these chars */</font>
03350                       <font class="keywordflow">if</font> (c == <font class="charliteral">'\"'</font> || (in_string != <font class="charliteral">'\0'</font> &amp;&amp; c == <font class="charliteral">'\\'</font>))
03351                         <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">'\\'</font>);
03352                       <font class="keywordflow">if</font> (isprint (c))
03353                         <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
03354                       <font class="keywordflow">else</font>
03355                         {
03356                           cppReader_reserve (pfile, 4);
03357                           sprintf (cppReader_getPWritten (pfile), <font class="stringliteral">"\\%03o"</font>,
03358                                    (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) c);
03359                           <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, 4);
03360                         }
03361                     }
03362                   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
03363                     <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, <font class="charliteral">'\"'</font>); <font class="comment">/* insert ending quote */</font>
03364                   arg-&gt;stringified_length
03365                     = <a class="code" href="general_c.html#a34">size_toInt</a> (cppReader_getWritten (pfile) - arg-&gt;stringified);
03366                 }
03367 
03368               xbuf_len += args[ap-&gt;argno].stringified_length;
03369             }
03370           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ap-&gt;raw_before || ap-&gt;raw_after || cppReader_isTraditional (pfile))
03371             {
03372               <font class="comment">/* Add 4 for two newline-space markers to prevent</font>
03373 <font class="comment">                 token concatenation.  */</font>
03374               xbuf_len += args[ap-&gt;argno].raw_length + 4;
03375             }
03376           <font class="keywordflow">else</font>
03377             {
03378               <font class="comment">/* We have an ordinary (expanded) occurrence of the arg.</font>
03379 <font class="comment">                 So compute its expansion, if we have not already.  */</font>
03380 
03381               <font class="keywordflow">if</font> (args[ap-&gt;argno].expand_length &lt; 0)
03382                 {
03383                   args[ap-&gt;argno].expanded = cppReader_getWritten (pfile);
03384                   cpp_expand_to_buffer (pfile,
03385                                         ARG_BASE + args[ap-&gt;argno].raw,
03386                                         size_fromInt (args[ap-&gt;argno].raw_length));
03387 
03388                   args[ap-&gt;argno].expand_length
03389                     = <a class="code" href="general_c.html#a34">size_toInt</a> (cppReader_getWritten (pfile) - args[ap-&gt;argno].expanded);
03390                 }
03391 
03392               <font class="comment">/* Add 4 for two newline-space markers to prevent</font>
03393 <font class="comment">                 token concatenation.  */</font>
03394               xbuf_len += args[ap-&gt;argno].expand_length + 4;
03395            }
03396           <font class="keywordflow">if</font> (args[ap-&gt;argno].use_count &lt; 10)
03397             args[ap-&gt;argno].use_count++;
03398         }
03399 
03400       xbuf = (<font class="keywordtype">char</font> *) dmalloc (xbuf_len + 1);
03401       oxbuf = xbuf;
03402 
03403       <font class="comment">/*</font>
03404 <font class="comment">      ** Generate in XBUF the complete expansion</font>
03405 <font class="comment">      ** with arguments substituted in.</font>
03406 <font class="comment">      ** TOTLEN is the total size generated so far.</font>
03407 <font class="comment">      ** OFFSET is the index in the definition</font>
03408 <font class="comment">      ** of where we are copying from.</font>
03409 <font class="comment">      */</font>
03410 
03411       offset = 0;
03412       totlen = 0;
03413 
03414       <font class="keywordflow">for</font> (last_ap = NULL, ap = defn-&gt;pattern; ap != NULL;
03415            last_ap = ap, ap = ap-&gt;next)
03416         {
03417           <font class="keyword">register</font> <font class="keyword">struct </font><a class="code" href="struct_argdata.html">argdata</a> *arg = &amp;args[ap-&gt;argno];
03418           size_t count_before = totlen;
03419 
03420           <font class="comment">/* Add chars to XBUF.  */</font>
03421           <font class="keywordflow">for</font> (i = 0; i &lt; ap-&gt;nchars; i++, offset++)
03422             {
03423               xbuf[totlen++] = exp[offset];
03424             }
03425 
03426           <font class="comment">/* If followed by an empty rest arg with concatenation,</font>
03427 <font class="comment">             delete the last run of nonwhite chars.  */</font>
03428           <font class="keywordflow">if</font> (rest_zero &amp;&amp; totlen &gt; count_before
03429               &amp;&amp; ((ap-&gt;rest_args &amp;&amp; ap-&gt;raw_before)
03430                   || (last_ap != NULL &amp;&amp; last_ap-&gt;rest_args
03431                       &amp;&amp; last_ap-&gt;raw_after)))
03432             {
03433               <font class="comment">/* Delete final whitespace.  */</font>
03434               <font class="keywordflow">while</font> (totlen &gt; count_before &amp;&amp; is_space[(<font class="keywordtype">int</font>) xbuf[totlen - 1]])
03435                 {
03436                   totlen--;
03437                 }
03438 
03439               <font class="comment">/* Delete the nonwhites before them.  */</font>
03440               <font class="keywordflow">while</font> (totlen &gt; count_before &amp;&amp; ! is_space[(<font class="keywordtype">int</font>) xbuf[totlen - 1]])
03441                 {
03442                   totlen--;
03443                 }
03444             }
03445 
03446           <font class="keywordflow">if</font> (ap-&gt;stringify != 0)
03447             {
03448               assertSet(arg);
03449               memcpy (xbuf + totlen,
03450                       ARG_BASE + arg-&gt;stringified,
03451                       size_fromInt (arg-&gt;stringified_length));
03452               totlen += arg-&gt;stringified_length;
03453             }
03454           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ap-&gt;raw_before || ap-&gt;raw_after || cppReader_isTraditional (pfile))
03455             {
03456               <font class="keywordtype">char</font> *p1;
03457               <font class="keywordtype">char</font> *l1;
03458 
03459               assertSet (arg);
03460 
03461               p1 = ARG_BASE + arg-&gt;raw;
03462               l1 = p1 + arg-&gt;raw_length;
03463 
03464               <font class="keywordflow">if</font> (ap-&gt;raw_before)
03465                 {
03466                   <font class="keywordflow">while</font> (p1 != l1 &amp;&amp; is_space[(<font class="keywordtype">int</font>) *p1])
03467                     {
03468                       p1++;
03469                     }
03470 
03471                   <font class="keywordflow">while</font> (p1 != l1 &amp;&amp; is_idchar[(<font class="keywordtype">int</font>) *p1])
03472                     {
03473                       xbuf[totlen++] = *p1++;
03474                     }
03475 
03476                   <font class="comment">/* Delete any no-reexpansion marker that follows</font>
03477 <font class="comment">                     an identifier at the beginning of the argument</font>
03478 <font class="comment">                     if the argument is concatenated with what precedes it.  */</font>
03479                   <font class="keywordflow">if</font> (p1[0] == <font class="charliteral">'@'</font> &amp;&amp; p1[1] == <font class="charliteral">'-'</font>)
03480                     p1 += 2;
03481                 }
03482               <font class="keywordflow">if</font> (ap-&gt;raw_after)
03483                 {
03484                   <font class="comment">/* Arg is concatenated after: delete trailing whitespace,</font>
03485 <font class="comment">                     whitespace markers, and no-reexpansion markers.  */</font>
03486                   <font class="keywordflow">while</font> (p1 != l1)
03487                     {
03488                       <font class="keywordflow">if</font> (is_space[(<font class="keywordtype">int</font>) l1[-1]]) l1--;
03489                       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (l1[-1] == <font class="charliteral">'-'</font>)
03490                         {
03491                           <font class="keywordtype">char</font> *p2 = l1 - 1;
03492                           <font class="comment">/* If a `-' is preceded by an odd number of newlines then it</font>
03493 <font class="comment">                             and the last newline are a no-reexpansion marker.  */</font>
03494                           <font class="keywordflow">while</font> (p2 != p1 &amp;&amp; p2[-1] == <font class="charliteral">'\n'</font>)
03495                             {
03496                               p2--;
03497                             }
03498 
03499                           <font class="keywordflow">if</font> (((l1 - 1 - p2) &amp; 1) != 0)
03500                             {
03501                               l1 -= 2;
03502                             }
03503                           <font class="keywordflow">else</font>
03504                             {
03505                               <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
03506                             }
03507                         }
03508                       <font class="keywordflow">else</font>
03509                         {
03510                           <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
03511                         }
03512                     }
03513                 }
03514 
03515               memcpy (xbuf + totlen, p1, size_fromInt (l1 - p1));
03516               totlen += l1 - p1;
03517             }
03518           <font class="keywordflow">else</font>
03519             {
03520               <font class="keywordtype">char</font> *expanded;
03521 
03522               assertSet (arg);
03523               expanded = ARG_BASE + arg-&gt;expanded;
03524 
03525               <font class="keywordflow">if</font> (!ap-&gt;raw_before &amp;&amp; totlen &gt; 0
03526                   &amp;&amp; (arg-&gt;expand_length != 0)
03527                   &amp;&amp; !cppReader_isTraditional(pfile)
03528                   &amp;&amp; unsafe_chars (xbuf[totlen-1], expanded[0]))
03529                 {
03530                   xbuf[totlen++] = <font class="charliteral">'@'</font>;
03531                   xbuf[totlen++] = <font class="charliteral">' '</font>;
03532                 }
03533 
03534               memcpy (xbuf + totlen, expanded,
03535                       size_fromInt (arg-&gt;expand_length));
03536               totlen += arg-&gt;expand_length;
03537 
03538               <font class="keywordflow">if</font> (!ap-&gt;raw_after &amp;&amp; totlen &gt; 0
03539                   &amp;&amp; offset &lt; size_toInt (defn-&gt;length)
03540                   &amp;&amp; !cppReader_isTraditional(pfile)
03541                   &amp;&amp; unsafe_chars (xbuf[totlen-1], exp[offset]))
03542                 {
03543                   xbuf[totlen++] = <font class="charliteral">'@'</font>;
03544                   xbuf[totlen++] = <font class="charliteral">' '</font>;
03545                 }
03546 
03547               <font class="comment">/* If a macro argument with newlines is used multiple times,</font>
03548 <font class="comment">                 then only expand the newlines once.  This avoids creating</font>
03549 <font class="comment">                 output lines which don't correspond to any input line,</font>
03550 <font class="comment">                 which confuses gdb and gcov.  */</font>
03551               <font class="keywordflow">if</font> (arg-&gt;use_count &gt; 1 &amp;&amp; arg-&gt;newlines &gt; 0)
03552                 {
03553                   <font class="comment">/* Don't bother doing change_newlines for subsequent</font>
03554 <font class="comment">                     uses of arg.  */</font>
03555                   arg-&gt;use_count = 1;
03556                   arg-&gt;expand_length
03557                     = change_newlines (expanded, arg-&gt;expand_length);
03558                 }
03559             }
03560 
03561           <font class="keywordflow">if</font> (totlen &gt; xbuf_len)
03562             abort ();
03563         }
03564 
03565       <font class="comment">/* if there is anything left of the definition</font>
03566 <font class="comment">         after handling the arg list, copy that in too.  */</font>
03567 
03568       <font class="keywordflow">for</font> (i = offset; i &lt; size_toInt (defn-&gt;length); i++)
03569         {
03570           <font class="comment">/* if we've reached the end of the macro */</font>
03571           <font class="keywordflow">if</font> (exp[i] == <font class="charliteral">')'</font>)
03572             rest_zero = 0;
03573           <font class="keywordflow">if</font> (! (rest_zero &amp;&amp; last_ap != NULL &amp;&amp; last_ap-&gt;rest_args
03574                  &amp;&amp; last_ap-&gt;raw_after))
03575             xbuf[totlen++] = exp[i];
03576         }
03577 
03578       xbuf[totlen] = <font class="charliteral">'\0'</font>;
03579       xbuf_len = totlen;
03580     }
03581 
03582   pfile-&gt;output_escapes--;
03583 
03584   <font class="comment">/* Now put the expansion on the input stack</font>
03585 <font class="comment">     so our caller will commence reading from it.  */</font>
03586   push_macro_expansion (pfile, xbuf, xbuf_len, hp);
03587   cppReader_getBuffer (pfile)-&gt;has_escapes = 1;
03588 
03589   <font class="comment">/* Pop the space we've used in the token_buffer for argument expansion.  */</font>
03590   cppReader_setWritten (pfile, old_written);
03591 
03592   <font class="comment">/* Recursive macro use sometimes works traditionally.</font>
03593 <font class="comment">     #define foo(x,y) bar (x (y,0), y)</font>
03594 <font class="comment">     foo (foo, baz)  */</font>
03595 
03596   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
03597     hp-&gt;type = T_DISABLED;
03598 
03599   <a class="code" href="general_c.html#a0">sfree</a> (args);
03600 }
03601 
03602 <font class="keyword">static</font> <font class="keywordtype">void</font>
03603 push_macro_expansion (cppReader *pfile, <font class="keywordtype">char</font> *xbuf, size_t xbuf_len,
03604                       <font class="comment">/*@dependent@*/</font> HASHNODE *hp)<font class="keyword"></font>
03605 <font class="keyword"></font>{
03606   cppBuffer *mbuf = cppReader_pushBuffer (pfile, xbuf, xbuf_len);
03607 
03608   <font class="keywordflow">if</font> (mbuf == NULL)
03609     {
03610       <font class="keywordflow">return</font>;
03611     }
03612 
03613   mbuf-&gt;cleanup = cppReader_macroCleanup;
03614 
03615   llassert (mbuf-&gt;hnode == NULL);
03616   mbuf-&gt;hnode = hp;
03617 
03618   <font class="comment">/* The first chars of the expansion should be a "@ " added by</font>
03619 <font class="comment">     collect_expansion.  This is to prevent accidental token-pasting</font>
03620 <font class="comment">     between the text preceding the macro invocation, and the macro</font>
03621 <font class="comment">     expansion text.</font>
03622 <font class="comment"></font>
03623 <font class="comment">     We would like to avoid adding unneeded spaces (for the sake of</font>
03624 <font class="comment">     tools that use cpp, such as imake).  In some common cases we can</font>
03625 <font class="comment">     tell that it is safe to omit the space.</font>
03626 <font class="comment"></font>
03627 <font class="comment">     The character before the macro invocation cannot have been an</font>
03628 <font class="comment">     idchar (or else it would have been pasted with the idchars of</font>
03629 <font class="comment">     the macro name).  Therefore, if the first non-space character</font>
03630 <font class="comment">     of the expansion is an idchar, we do not need the extra space</font>
03631 <font class="comment">     to prevent token pasting.</font>
03632 <font class="comment"></font>
03633 <font class="comment">     Also, we don't need the extra space if the first char is '(',</font>
03634 <font class="comment">     or some other (less common) characters.  */</font>
03635 
03636   <font class="keywordflow">if</font> (xbuf[0] == <font class="charliteral">'@'</font> &amp;&amp; xbuf[1] == <font class="charliteral">' '</font>
03637       &amp;&amp; (is_idchar[(<font class="keywordtype">int</font>) xbuf[2]] || xbuf[2] == <font class="charliteral">'('</font> || xbuf[2] == <font class="charliteral">'\''</font>
03638           || xbuf[2] == <font class="charliteral">'\"'</font>))
03639   {
03640     llassert (mbuf-&gt;cur != NULL);
03641     mbuf-&gt;cur += 2;
03642   }
03643 }
03644 
03645 
03646 <font class="comment">/* Like cppGetToken, except that it does not read past end-of-line.</font>
03647 <font class="comment">   Also, horizontal space is skipped, and macros are popped.  */</font>
03648 
03649 <font class="keyword">static</font> <font class="keyword">enum</font> cpp_token
03650 get_directive_token (cppReader *pfile)<font class="keyword"></font>
03651 <font class="keyword"></font>{
03652   <font class="keywordflow">for</font> (;;)
03653     {
03654       size_t old_written = cppReader_getWritten (pfile);
03655       <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
03656       <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
03657       <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
03658         {
03659           <font class="keywordflow">return</font> CPP_VSPACE;
03660         }
03661 
03662       <a class="code" href="struct_token.html">token</a> = <a class="code" href="cpplib_c.html#a141">cppGetToken</a> (pfile);
03663 
03664       <font class="keywordflow">switch</font> (<a class="code" href="struct_token.html">token</a>)
03665         {
03666         <font class="keywordflow">case</font> CPP_POP:
03667           <font class="keywordflow">if</font> (!cppBuffer_isMacro (cppReader_getBuffer (pfile)))
03668             <font class="keywordflow">return</font> <a class="code" href="struct_token.html">token</a>;
03669           <font class="comment">/*@fallthrough@*/</font>
03670         <font class="keywordflow">case</font> CPP_HSPACE:
03671         <font class="keywordflow">case</font> CPP_COMMENT:
03672           cppReader_setWritten (pfile, old_written);
03673           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
03674         <font class="keywordflow">default</font>:
03675           <font class="keywordflow">return</font> <a class="code" href="struct_token.html">token</a>;
03676         }
03677     }
03678 }
03679 
03680 
03681 <font class="comment">/* Handle #include and #import.</font>
03682 <font class="comment">   This function expects to see "fname" or &lt;fname&gt; on the input.</font>
03683 <font class="comment"></font>
03684 <font class="comment">   The input is normally in part of the output_buffer following</font>
03685 <font class="comment">   cppReader_getWritten, and will get overwritten by output_line_command.</font>
03686 <font class="comment">   I.e. in input file specification has been popped by cppReader_handleDirective.</font>
03687 <font class="comment">   This is safe.  */</font>
03688 
03689 <font class="keyword">static</font> <font class="keywordtype">int</font>
03690 do_include (cppReader *pfile, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
03691             <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *unused1, <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *unused2)<font class="keyword"></font>
03692 <font class="keyword"></font>{
03693   <font class="keywordtype">bool</font> skip_dirs = (keyword-&gt;type == T_INCLUDE_NEXT);
03694   cstring fname;
03695   <font class="keywordtype">char</font> *fbeg, *fend;            <font class="comment">/* Beginning and end of fname */</font>
03696   <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
03697 
03698   <font class="comment">/* Chain of dirs to search */</font>
03699   <font class="keyword">struct </font>file_name_list *search_start = CPPOPTIONS (pfile)-&gt;include;
03700   <font class="keyword">struct </font>file_name_list dsp[1]; <font class="comment">/* First in chain, if #include "..." */</font>
03701   <font class="keyword">struct </font>file_name_list *searchptr = NULL;
03702   size_t old_written = cppReader_getWritten (pfile);
03703 
03704   <font class="keywordtype">int</font> flen;
03705 
03706   <font class="keywordtype">int</font> f;                        <font class="comment">/* file number */</font>
03707   <font class="keywordtype">int</font> angle_brackets = 0;       <font class="comment">/* 0 for "...", 1 for &lt;...&gt; */</font>
03708   f= -1;                        <font class="comment">/* JF we iz paranoid! */</font>
03709 
03710   pfile-&gt;parsing_include_directive++;
03711   <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
03712   pfile-&gt;parsing_include_directive--;
03713 
03714   <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_STRING)
03715     {
03716       <font class="comment">/* FIXME - check no trailing garbage */</font>
03717       fbeg = pfile-&gt;token_buffer + old_written + 1;
03718       fend = cppReader_getPWritten (pfile) - 1;
03719       <font class="keywordflow">if</font> (fbeg[-1] == <font class="charliteral">'&lt;'</font>)
03720         {
03721           angle_brackets = 1;
03722           <font class="comment">/* If -I-, start with the first -I dir after the -I-.  */</font>
03723           <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;first_bracket_include != NULL)
03724             search_start = CPPOPTIONS (pfile)-&gt;first_bracket_include;
03725         }
03726       <font class="comment">/* If -I- was specified, don't search current dir, only spec'd ones.  */</font>
03727       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!CPPOPTIONS (pfile)-&gt;ignore_srcdir)
03728         {
03729           cppBuffer *fp = CPPBUFFER (pfile);
03730           <font class="comment">/* We have "filename".  Figure out directory this source</font>
03731 <font class="comment">             file is coming from and put it on the front of the list.  */</font>
03732 
03733           <font class="keywordflow">for</font> ( ; fp != cppReader_nullBuffer (pfile); fp = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (fp))
03734             {
03735               <font class="keywordtype">int</font> n;
03736               <font class="keywordtype">char</font> *ep,*nam;
03737 
03738               llassert (fp != NULL);
03739 
03740               nam = NULL;
03741 
03742               <font class="keywordflow">if</font> (cstring_isDefined (fp-&gt;nominal_fname))
03743                 {
03744                   nam = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (fp-&gt;nominal_fname);
03745 
03746                   <font class="comment">/* Found a named file.  Figure out dir of the file,</font>
03747 <font class="comment">                     and put it in front of the search list.  */</font>
03748                   dsp[0].next = search_start;
03749                   search_start = dsp;
03750 
03751 <font class="preprocessor">#ifndef VMS</font>
03752 <font class="preprocessor"></font>                  ep = strrchr (nam, CONNECTCHAR);
03753 <font class="preprocessor">#else                           </font><font class="comment">/* VMS */</font>
03754                   ep = strrchr (nam, <font class="charliteral">']'</font>);
03755                   <font class="keywordflow">if</font> (ep == NULL) ep = strrchr (nam, <font class="charliteral">'&gt;'</font>);
03756                   <font class="keywordflow">if</font> (ep == NULL) ep = strrchr (nam, <font class="charliteral">':'</font>);
03757                   <font class="keywordflow">if</font> (ep != NULL) ep++;
03758 <font class="preprocessor">#endif                          </font><font class="comment">/* VMS */</font>
03759                   <font class="keywordflow">if</font> (ep != NULL)
03760                     {
03761                       <font class="keywordtype">char</font> save;
03762 
03763                       n = ep - nam;
03764                       save = nam[n];
03765                       nam[n] = <font class="charliteral">'\0'</font>;
03766 
03767                       <font class="comment">/*@-onlytrans@*/</font> <font class="comment">/* This looks like a memory leak... */</font> 
03768                       dsp[0].fname = cstring_fromCharsNew (nam); <font class="comment">/* evs 2000-07-20: was fromChars */</font>
03769                       <font class="comment">/*@=onlytrans@*/</font>
03770                       nam[n] = save;
03771 
03772                       <font class="keywordflow">if</font> (n + INCLUDE_LEN_FUDGE &gt; pfile-&gt;max_include_len)
03773                         pfile-&gt;max_include_len = n + INCLUDE_LEN_FUDGE;
03774                     }
03775                   <font class="keywordflow">else</font>
03776                     {
03777                       dsp[0].fname = cstring_undefined; <font class="comment">/* Current directory */</font>
03778                     }
03779 
03780                   dsp[0].got_name_map = 0;
03781                   <font class="keywordflow">break</font>;
03782                 }
03783             }
03784         }
03785       <font class="keywordflow">else</font>
03786         {
03787           ;
03788         }
03789     }
03790 <font class="preprocessor">#ifdef VMS</font>
03791 <font class="preprocessor"></font>  <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_NAME)
03792     {
03793       <font class="comment">/*</font>
03794 <font class="comment">       * Support '#include xyz' like VAX-C to allow for easy use of all the</font>
03795 <font class="comment">       * decwindow include files. It defaults to '#include &lt;xyz.h&gt;' (so the</font>
03796 <font class="comment">       * code from case '&lt;' is repeated here) and generates a warning.</font>
03797 <font class="comment">       */</font>
03798       <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile,
03799                    <font class="stringliteral">"VAX-C-style include specification found, use '#include &lt;filename.h&gt;' !"</font>);
03800       angle_brackets = 1;
03801       <font class="comment">/* If -I-, start with the first -I dir after the -I-.  */</font>
03802       <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;first_bracket_include)
03803         search_start = CPPOPTIONS (pfile)-&gt;first_bracket_include;
03804       fbeg = pfile-&gt;token_buffer + old_written;
03805       fend = cppReader_getPWritten (pfile);
03806     }
03807 <font class="preprocessor">#endif</font>
03808 <font class="preprocessor"></font>  <font class="keywordflow">else</font>
03809     {
03810       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03811                  message (<font class="stringliteral">"Preprocessor command #%s expects \"FILENAME\" or &lt;FILENAME&gt;"</font>,
03812                           keyword-&gt;name));
03813 
03814       cppReader_setWritten (pfile, old_written);
03815       <a class="code" href="cpplib_c.html#a116">cppReader_skipRestOfLine</a> (pfile);
03816       <font class="keywordflow">return</font> 0;
03817     }
03818 
03819   *fend = 0;
03820 
03821   <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
03822   <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> != CPP_VSPACE)
03823     {
03824       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
03825                     cstring_makeLiteralTemp (<font class="stringliteral">"Junk at end of #include"</font>));
03826 
03827       <font class="keywordflow">while</font> (<a class="code" href="struct_token.html">token</a> != CPP_VSPACE &amp;&amp; <a class="code" href="struct_token.html">token</a> != CPP_EOF &amp;&amp; <a class="code" href="struct_token.html">token</a> != CPP_POP)
03828         {
03829           <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
03830         }
03831     }
03832 
03833   <font class="comment">/*</font>
03834 <font class="comment">  ** For #include_next, skip in the search path</font>
03835 <font class="comment">  ** past the dir in which the containing file was found.</font>
03836 <font class="comment">  */</font>
03837 
03838   <font class="keywordflow">if</font> (skip_dirs)
03839     {
03840       cppBuffer *fp = CPPBUFFER (pfile);
03841 
03842       <font class="keywordflow">for</font> (; fp != cppReader_nullBuffer (pfile); fp = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (fp))
03843         {
03844           llassert (fp != NULL);
03845 
03846           <font class="keywordflow">if</font> (fp-&gt;fname != NULL)
03847             {
03848               <font class="comment">/* fp-&gt;dir is null if the containing file was specified with</font>
03849 <font class="comment">                 an absolute file name.  In that case, don't skip anything.  */</font>
03850               <font class="keywordflow">if</font> (fp-&gt;dir == SELF_DIR_DUMMY)
03851                 {
03852                   search_start = CPPOPTIONS (pfile)-&gt;include;
03853                 }
03854               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (fp-&gt;dir != NULL)
03855                 {
03856                   search_start = fp-&gt;dir-&gt;next;
03857                 }
03858               <font class="keywordflow">else</font>
03859                 {
03860                   ;
03861                 }
03862 
03863               <font class="keywordflow">break</font>;
03864             }
03865         }
03866     }
03867 
03868   cppReader_setWritten (pfile, old_written);
03869 
03870   flen = fend - fbeg;
03871 
03872   DPRINTF ((<font class="stringliteral">"fbeg: %s"</font>, fbeg));
03873 
03874   <font class="keywordflow">if</font> (flen == 0)
03875     {
03876       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
03877                  message (<font class="stringliteral">"Empty file name in #%s"</font>, keyword-&gt;name));
03878       <font class="keywordflow">return</font> 0;
03879     }
03880 
03881   <font class="comment">/*</font>
03882 <font class="comment">  ** Allocate this permanently, because it gets stored in the definitions</font>
03883 <font class="comment">  ** of macros.</font>
03884 <font class="comment">  */</font>
03885 
03886   fname = cstring_undefined;
03887 
03888   <font class="comment">/* + 2 above for slash and terminating null.  */</font>
03889   <font class="comment">/* + 2 added for '.h' on VMS (to support '#include filename') */</font>
03890 
03891   <font class="comment">/* If specified file name is absolute, just open it.  */</font>
03892 
03893   <font class="keywordflow">if</font> (<a class="code" href="osd_c.html#a19">osd_isConnectChar</a> (*fbeg)
03894 <font class="preprocessor"># if defined (WIN32) || defined (OS2)</font>
03895 <font class="preprocessor"></font>      || (*(fbeg + 1) == <font class="charliteral">':'</font>)
03896 <font class="preprocessor"># endif</font>
03897 <font class="preprocessor"></font>      )
03898     {
03899       fname = <a class="code" href="cstring_c.html#a10">cstring_copyLength</a> (fbeg, flen);
03900       
03901       <font class="keywordflow">if</font> (redundant_include_p (pfile, fname))
03902         {
03903           <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
03904           <font class="keywordflow">return</font> 0;
03905         }
03906       
03907       f = open_include_file (pfile, fname, NULL);
03908       
03909       <font class="keywordflow">if</font> (f == IMPORT_FOUND)
03910         {
03911           <font class="keywordflow">return</font> 0;             <font class="comment">/* Already included this file */</font>
03912         }
03913     } 
03914   <font class="keywordflow">else</font> 
03915     {
03916       <font class="comment">/* Search directory path, trying to open the file.</font>
03917 <font class="comment">         Copy each filename tried into FNAME.  */</font>
03918 
03919       <font class="keywordflow">for</font> (searchptr = search_start; searchptr != NULL;
03920            searchptr = searchptr-&gt;next)
03921         {
03922           <font class="keywordflow">if</font> (!cstring_isEmpty (searchptr-&gt;fname))
03923             {
03924               <font class="comment">/* The empty string in a search path is ignored.</font>
03925 <font class="comment">                 This makes it possible to turn off entirely</font>
03926 <font class="comment">                 a standard piece of the list.  */</font>
03927               <font class="keywordflow">if</font> (cstring_isEmpty (searchptr-&gt;fname))
03928                 <font class="keywordflow">continue</font>;
03929               
03930               fname = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (searchptr-&gt;fname);
03931               fname = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (fname, CONNECTCHAR);
03932               DPRINTF ((<font class="stringliteral">"Here: %s"</font>, fname));
03933             }
03934           <font class="keywordflow">else</font>
03935             {
03936               ;
03937             }
03938           
03939           fname = <a class="code" href="cstring_c.html#a41">cstring_concatLength</a> (fname, fbeg, flen);
03940 
03941           DPRINTF ((<font class="stringliteral">"fname: %s"</font>, fname));
03942           
03943 <font class="preprocessor">#ifdef VMS</font>
03944 <font class="preprocessor"></font>          <font class="comment">/* Change this 1/2 Unix 1/2 VMS file specification into a</font>
03945 <font class="comment">             full VMS file specification */</font>
03946           <font class="keywordflow">if</font> (searchptr-&gt;fname &amp;&amp; (searchptr-&gt;fname[0] != 0)) {
03947             <font class="comment">/* Fix up the filename */</font>
03948             hack_vms_include_specification (fname);
03949           } <font class="keywordflow">else</font> {
03950             <font class="comment">/* This is a normal VMS filespec, so use it unchanged.  */</font>
03951             strncpy (fname, fbeg, flen);
03952             fname[flen] = 0;
03953             <font class="comment">/* if it's '#include filename', add the missing .h */</font>
03954             <font class="keywordflow">if</font> (strchr (fname,<font class="charliteral">'.'</font>) == NULL) {
03955               strcat (fname, <font class="stringliteral">".h"</font>);
03956             }
03957           }
03958 <font class="preprocessor">#endif </font><font class="comment">/* VMS */</font>
03959           <font class="comment">/* ??? There are currently 3 separate mechanisms for avoiding processing</font>
03960 <font class="comment">             of redundant include files: #import, #pragma once, and</font>
03961 <font class="comment">             redundant_include_p.  It would be nice if they were unified.  */</font>
03962           
03963           <font class="keywordflow">if</font> (redundant_include_p (pfile, fname))
03964             {
03965               <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
03966               <font class="keywordflow">return</font> 0;
03967             }
03968 
03969           DPRINTF ((<font class="stringliteral">"Trying: %s"</font>, fname));
03970 
03971           f = open_include_file (pfile, fname, searchptr);
03972           
03973           <font class="keywordflow">if</font> (f == IMPORT_FOUND)
03974             {
03975               <font class="keywordflow">return</font> 0;                 <font class="comment">/* Already included this file */</font>
03976             }
03977 <font class="preprocessor">#ifdef EACCES</font>
03978 <font class="preprocessor"></font>          <font class="keywordflow">else</font> <font class="keywordflow">if</font> (f == IMPORT_NOT_FOUND &amp;&amp; errno == EACCES)
03979             {
03980               <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile,
03981                                  message (<font class="stringliteral">"Header file %s exists, but is not readable"</font>, fname));
03982             }
03983 <font class="preprocessor">#endif</font>
03984 <font class="preprocessor"></font>          
03985           <font class="keywordflow">if</font> (f &gt;= 0)
03986             {
03987               <font class="keywordflow">break</font>;
03988             }
03989         }
03990     }
03991   
03992   <font class="keywordflow">if</font> (f &lt; 0)
03993     {
03994       <font class="comment">/* A file that was not found.  */</font>
03995       fname = <a class="code" href="cstring_c.html#a10">cstring_copyLength</a> (fbeg, flen);
03996 
03997       <font class="keywordflow">if</font> (search_start != NULL)
03998         {
03999           <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
04000                            message (<font class="stringliteral">"Cannot find include file %s"</font>, fname));
04001         }
04002       <font class="keywordflow">else</font>
04003         {
04004           <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
04005                            message (<font class="stringliteral">"No include path in which to find %s"</font>, fname));
04006         }
04007     }
04008   <font class="keywordflow">else</font> {
04009     <font class="comment">/*</font>
04010 <font class="comment">    ** Check to see if this include file is a once-only include file.</font>
04011 <font class="comment">    ** If so, give up.</font>
04012 <font class="comment">    */</font>
04013 
04014     <font class="keyword">struct </font>file_name_list *ptr;
04015 
04016     <font class="keywordflow">for</font> (ptr = pfile-&gt;all_include_files; ptr != NULL; ptr = ptr-&gt;next)
04017       {
04018         <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (ptr-&gt;fname, fname))
04019           {
04020             <font class="comment">/* This file was included before.  */</font>
04021             <font class="keywordflow">break</font>;
04022           }
04023       }
04024 
04025     <font class="keywordflow">if</font> (ptr == NULL)
04026       {
04027         <font class="comment">/* This is the first time for this file.  */</font>
04028         <font class="comment">/* Add it to list of files included.  */</font>
04029 
04030         ptr = (<font class="keyword">struct </font>file_name_list *) dmalloc (sizeof (*ptr));
04031         ptr-&gt;control_macro = NULL;
04032         ptr-&gt;c_system_include_path = NULL;
04033         ptr-&gt;next = pfile-&gt;all_include_files;
04034         ptr-&gt;fname = fname;
04035         ptr-&gt;got_name_map = NULL;
04036 
04037         pfile-&gt;all_include_files = ptr;
04038         assertSet (pfile-&gt;all_include_files);
04039       }
04040 
04041     <font class="keywordflow">if</font> (angle_brackets != 0)
04042       {
04043         pfile-&gt;system_include_depth++;
04044       }
04045 
04046     <font class="comment">/* Actually process the file */</font>
04047     <font class="keywordflow">if</font> (cppReader_pushBuffer (pfile, NULL, 0) == NULL)
04048       {
04049         <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
04050         <font class="keywordflow">return</font> 0;
04051       }
04052 
04053     <font class="keywordflow">if</font> (finclude (pfile, f, fname, is_system_include (pfile, fname),
04054                   searchptr != dsp ? searchptr : SELF_DIR_DUMMY))
04055       {
04056         output_line_command (pfile, 0, enter_file);
04057         pfile-&gt;only_seen_white = 2;
04058       }
04059 
04060     <font class="keywordflow">if</font> (angle_brackets)
04061       {
04062         pfile-&gt;system_include_depth--;
04063       }
04064     <font class="comment">/*@-branchstate@*/</font>
04065   } <font class="comment">/*@=branchstate@*/</font> 
04066 
04067   <font class="keywordflow">return</font> 0;
04068 }
04069 
04070 <font class="comment">/* Return nonzero if there is no need to include file NAME</font>
04071 <font class="comment">   because it has already been included and it contains a conditional</font>
04072 <font class="comment">   to make a repeated include do nothing.  */</font>
04073 
04074 <font class="keyword">static</font> <font class="keywordtype">bool</font>
04075 redundant_include_p (cppReader *pfile, cstring name)<font class="keyword"></font>
04076 <font class="keyword"></font>{
04077   <font class="keyword">struct </font>file_name_list *l = pfile-&gt;all_include_files;
04078 
04079   <font class="keywordflow">for</font> (; l != NULL; l = l-&gt;next)
04080     {
04081       <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (name, l-&gt;fname)
04082           &amp;&amp; (l-&gt;control_macro != NULL)
04083           &amp;&amp; (<a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (l-&gt;control_macro, -1, -1) != NULL))
04084         {
04085           <font class="keywordflow">return</font> TRUE;
04086         }
04087     }
04088 
04089   <font class="keywordflow">return</font> FALSE;
04090 }
04091 
04092 <font class="comment">/* Return nonzero if the given FILENAME is an absolute pathname which</font>
04093 <font class="comment">   designates a file within one of the known "system" include file</font>
04094 <font class="comment">   directories.  We assume here that if the given FILENAME looks like</font>
04095 <font class="comment">   it is the name of a file which resides either directly in a "system"</font>
04096 <font class="comment">   include file directory, or within any subdirectory thereof, then the</font>
04097 <font class="comment">   given file must be a "system" include file.  This function tells us</font>
04098 <font class="comment">   if we should suppress pedantic errors/warnings for the given FILENAME.</font>
04099 <font class="comment"></font>
04100 <font class="comment">   The value is 2 if the file is a C-language system header file</font>
04101 <font class="comment">   for which C++ should (on most systems) assume `extern "C"'.  */</font>
04102 
04103 <font class="keyword">static</font> <font class="keywordtype">bool</font>
04104 is_system_include (cppReader *pfile, cstring filename)<font class="keyword"></font>
04105 <font class="keyword"></font>{
04106   <font class="keyword">struct </font>file_name_list *searchptr;
04107 
04108   <font class="keywordflow">for</font> (searchptr = CPPOPTIONS (pfile)-&gt;first_system_include;
04109        searchptr != NULL;
04110        searchptr = searchptr-&gt;next)
04111     {
04112       <font class="keywordflow">if</font> (!cstring_isEmpty (searchptr-&gt;fname)) {
04113         cstring sys_dir = searchptr-&gt;fname;
04114         <font class="keywordtype">int</font> length = <a class="code" href="cstring_c.html#a30">cstring_length</a> (sys_dir);
04115 
04116         <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a19">cstring_equalLen</a> (sys_dir, filename, length)
04117             &amp;&amp; <a class="code" href="osd_c.html#a19">osd_isConnectChar</a> (cstring_getChar (filename, length)))
04118           {
04119             <font class="keywordflow">if</font> (searchptr-&gt;c_system_include_path)
04120               <font class="keywordflow">return</font> 2;
04121             <font class="keywordflow">else</font>
04122               <font class="keywordflow">return</font> 1;
04123           }
04124       }
04125     }
04126 
04127   <font class="keywordflow">return</font> 0;
04128 }
04129 
04130 <font class="comment">/* Convert a character string literal into a nul-terminated string.</font>
04131 <font class="comment">   The input string is [IN ... LIMIT).</font>
04132 <font class="comment">   The result is placed in RESULT.  RESULT can be the same as IN.</font>
04133 <font class="comment">   The value returned in the end of the string written to RESULT,</font>
04134 <font class="comment">   or NULL on error.  */</font>
04135 
04136 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> <font class="keywordtype">char</font> *
04137 convert_string (cppReader *pfile, <font class="comment">/*@returned@*/</font> <font class="keywordtype">char</font> *result,
04138                 <font class="keywordtype">char</font> *in, <font class="keywordtype">char</font> *limit, <font class="keywordtype">int</font> handle_escapes)<font class="keyword"></font>
04139 <font class="keyword"></font>{
04140   <font class="keywordtype">char</font> c;
04141   c = *in++;
04142 
04143   <font class="keywordflow">if</font> (c != <font class="charliteral">'\"'</font>)
04144     {
04145       <font class="keywordflow">return</font> NULL;
04146     }
04147 
04148   <font class="keywordflow">while</font> (in &lt; limit)
04149     {
04150       c = *in++;
04151 
04152       <font class="keywordflow">switch</font> (c)
04153         {
04154         <font class="keywordflow">case</font> <font class="charliteral">'\0'</font>:
04155           <font class="keywordflow">return</font> NULL;
04156         <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
04157           limit = in;
04158           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04159         <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
04160           <font class="keywordflow">if</font> (handle_escapes)
04161             {
04162               <font class="keywordtype">char</font> *bpc = (<font class="keywordtype">char</font> *) in;
04163               <font class="keywordtype">int</font> i = (<font class="keywordtype">char</font>) <a class="code" href="cppexp_c.html#a61">cppReader_parseEscape</a> (pfile, &amp;bpc);
04164               in = (<font class="keywordtype">char</font> *) bpc;
04165               <font class="keywordflow">if</font> (i &gt;= 0)
04166                 *result++ = (<font class="keywordtype">char</font>) c;
04167               <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04168             }
04169 
04170           <font class="comment">/*@fallthrough@*/</font>
04171         <font class="keywordflow">default</font>:
04172           *result++ = c;
04173         }
04174     }
04175 
04176   *result = 0;
04177   <font class="keywordflow">return</font> result;
04178 }
04179 
04180 <font class="comment">/*</font>
04181 <font class="comment"> * interpret #line command.  Remembers previously seen fnames</font>
04182 <font class="comment"> * in its very own hash table.</font>
04183 <font class="comment"> */</font>
04184 
04185 <font class="comment">/*@constant int FNAME_HASHSIZE@*/</font>
<a name="l04186"></a><a class="code" href="cpplib_c.html#a31">04186</a> <font class="preprocessor">#define FNAME_HASHSIZE 37</font>
04187 <font class="preprocessor"></font>
04188 <font class="keyword">static</font> <font class="keywordtype">int</font>
04189 do_line (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword)<font class="keyword"></font>
04190 <font class="keyword"></font>{
04191   cppBuffer *ip = cppReader_getBuffer (pfile);
04192   <font class="keywordtype">int</font> new_lineno;
04193   size_t old_written = cppReader_getWritten (pfile);
04194   <font class="keyword">enum</font> file_change_code file_change = same_file;
04195   <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
04196 
04197   <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
04198 
04199   <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> != CPP_NUMBER
04200       || !isdigit(pfile-&gt;token_buffer[old_written]))
04201     {
04202       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04203                     cstring_makeLiteralTemp (<font class="stringliteral">"invalid format `#line' command"</font>));
04204 
04205       <font class="keywordflow">goto</font> bad_line_directive;
04206     }
04207 
04208   <font class="comment">/* The Newline at the end of this line remains to be processed.</font>
04209 <font class="comment">     To put the next line at the specified line number,</font>
04210 <font class="comment">     we must store a line number now that is one less.  */</font>
04211   new_lineno = atoi (pfile-&gt;token_buffer + old_written) - 1;
04212   cppReader_setWritten (pfile, old_written);
04213 
04214   <font class="comment">/* NEW_LINENO is one less than the actual line number here.  */</font>
04215   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile) &amp;&amp; new_lineno &lt; 0)
04216     <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
04217                     cstring_makeLiteralTemp (<font class="stringliteral">"line number out of range in `#line' command"</font>));
04218 
04219   <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
04220 
04221   <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_STRING) {
04222     <font class="keywordtype">char</font> *fname = pfile-&gt;token_buffer + old_written;
04223     <font class="keywordtype">char</font> *end_name;
04224     <font class="keyword">static</font> HASHNODE *fname_table[FNAME_HASHSIZE];
04225     HASHNODE *hp, **hash_bucket;
04226     <font class="keywordtype">char</font> *p;
04227     size_t num_start;
04228     <font class="keywordtype">int</font> fname_length;
04229 
04230     <font class="comment">/* Turn the file name, which is a character string literal,</font>
04231 <font class="comment">       into a null-terminated string.  Do this in place.  */</font>
04232     end_name = convert_string (pfile, fname, fname, cppReader_getPWritten (pfile), 1);
04233     <font class="keywordflow">if</font> (end_name == NULL)
04234       {
04235         <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04236                       cstring_makeLiteralTemp (<font class="stringliteral">"invalid format `#line' command"</font>));
04237         <font class="keywordflow">goto</font> bad_line_directive;
04238       }
04239 
04240     fname_length = end_name - fname;
04241     num_start = cppReader_getWritten (pfile);
04242 
04243     <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
04244     <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> != CPP_VSPACE &amp;&amp; <a class="code" href="struct_token.html">token</a> != CPP_EOF &amp;&amp; <a class="code" href="struct_token.html">token</a> != CPP_POP) {
04245       p = pfile-&gt;token_buffer + num_start;
04246       <font class="keywordflow">if</font> (cppReader_isPedantic (pfile))
04247         <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
04248                         cstring_makeLiteralTemp (<font class="stringliteral">"garbage at end of `#line' command"</font>));
04249 
04250       <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> != CPP_NUMBER || *p &lt; '0' || *p &gt; <font class="charliteral">'4'</font> || p[1] != <font class="charliteral">'\0'</font>)
04251         {
04252           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04253                         cstring_makeLiteralTemp (<font class="stringliteral">"invalid format `#line' command"</font>));
04254           <font class="keywordflow">goto</font> bad_line_directive;
04255         }
04256       <font class="keywordflow">if</font> (*p == <font class="charliteral">'1'</font>)
04257         file_change = enter_file;
04258       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (*p == 2)
04259         file_change = leave_file;
04260       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (*p == 3)
04261         ip-&gt;system_header_p = 1;
04262       <font class="keywordflow">else</font> <font class="comment">/* if (*p == 4) */</font>
04263         ip-&gt;system_header_p = 2;
04264 
04265       cppReader_setWritten (pfile, num_start);
04266       <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
04267       p = pfile-&gt;token_buffer + num_start;
04268       <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_NUMBER &amp;&amp; p[1] == <font class="charliteral">'\0'</font> &amp;&amp; (*p == <font class="charliteral">'3'</font> || *p== <font class="charliteral">'4'</font>)) {
04269         ip-&gt;system_header_p = *p == 3 ? 1 : 2;
04270         <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
04271       }
04272       <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> != CPP_VSPACE) {
04273         <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04274                       cstring_makeLiteralTemp (<font class="stringliteral">"invalid format `#line' command"</font>));
04275 
04276         <font class="keywordflow">goto</font> bad_line_directive;
04277       }
04278     }
04279 
04280     hash_bucket =
04281       &amp;fname_table[<a class="code" href="cpphash_c.html#a9">hashf</a> (fname, fname_length, FNAME_HASHSIZE)];
04282     <font class="keywordflow">for</font> (hp = *hash_bucket; hp != NULL; hp = hp-&gt;next)
04283       {
04284         <font class="keywordflow">if</font> (hp-&gt;length == fname_length &amp;&amp;
04285             strncmp (hp-&gt;value.cpval, fname, size_fromInt (fname_length)) == 0) {
04286           ip-&gt;nominal_fname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (hp-&gt;value.cpval);
04287           <font class="keywordflow">break</font>;
04288         }
04289       }
04290 
04291     <font class="keywordflow">if</font> (hp == 0) {
04292       <font class="comment">/* Didn't find it; cons up a new one.  */</font>
04293       hp = (HASHNODE *) dmalloc (<font class="keyword">sizeof</font> (*hp) + fname_length + 1);
04294 
04295       hp-&gt;prev = NULL;
04296       hp-&gt;bucket_hdr = NULL;
04297       hp-&gt;type = T_NONE;
04298       hp-&gt;name = cstring_undefined;
04299       hp-&gt;next = *hash_bucket;
04300 
04301       *hash_bucket = hp;
04302 
04303       hp-&gt;length = fname_length;
04304       hp-&gt;value.cpval = dmalloc (<font class="keyword">sizeof</font> (*hp-&gt;value.cpval) * (fname_length + 1));
04305       memcpy (hp-&gt;value.cpval, fname, size_fromInt (fname_length));
04306       hp-&gt;value.cpval[fname_length] = <font class="charliteral">'\0'</font>;
04307       ip-&gt;nominal_fname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (hp-&gt;value.cpval);
04308     }
04309   }
04310   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> != CPP_VSPACE &amp;&amp; <a class="code" href="struct_token.html">token</a> != CPP_EOF)
04311     {
04312       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04313                     cstring_makeLiteralTemp (<font class="stringliteral">"invalid format `#line' command"</font>));
04314       <font class="keywordflow">goto</font> bad_line_directive;
04315     }
04316   <font class="keywordflow">else</font>
04317     {
04318       ;
04319     }
04320 
04321   ip-&gt;lineno = new_lineno;
04322 bad_line_directive:
04323   <a class="code" href="cpplib_c.html#a116">cppReader_skipRestOfLine</a> (pfile);
04324   cppReader_setWritten (pfile, old_written);
04325   output_line_command (pfile, 0, file_change);
04326   <font class="keywordflow">return</font> 0;
04327 }
04328 
04329 <font class="comment">/*</font>
04330 <font class="comment"> * remove the definition of a symbol from the symbol table.</font>
04331 <font class="comment"> * according to un*x /lib/cpp, it is not an error to undef</font>
04332 <font class="comment"> * something that has no definitions, so it isn't one here either.</font>
04333 <font class="comment"> */</font>
04334 
04335 <font class="keyword">static</font> <font class="keywordtype">int</font>
04336 do_undef (cppReader *pfile, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword, <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04337 <font class="keyword"></font>{
04338 
04339   <font class="keywordtype">int</font> sym_length;
04340   HASHNODE *hp;
04341   <font class="keywordtype">char</font> *orig_buf = buf;
04342 
04343   <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (buf);
04344 
04345   sym_length = <a class="code" href="cpplib_c.html#a120">cppReader_checkMacroName</a> (pfile, buf, cstring_makeLiteralTemp (<font class="stringliteral">"macro"</font>));
04346 
04347   <font class="keywordflow">while</font> ((hp = <a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (buf, sym_length, -1)) != NULL)
04348     {
04349       <font class="comment">/* If we are generating additional info for debugging (with -g) we</font>
04350 <font class="comment">         need to pass through all effective #undef commands.  */</font>
04351       <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;debug_output &amp;&amp; (keyword != NULL))
04352         {
04353           pass_thru_directive (orig_buf, limit, pfile, keyword);
04354         }
04355 
04356       <font class="keywordflow">if</font> (hp-&gt;type != T_MACRO)
04357         {
04358           <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile,
04359                        message (<font class="stringliteral">"Undefining preprocessor builtin: %s"</font>,
04360                                 hp-&gt;name));
04361         }
04362 
04363       <a class="code" href="cpphash_c.html#a12">cppReader_deleteMacro</a> (hp);
04364     }
04365 
04366   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile)) {
04367     buf += sym_length;
04368     <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (buf);
04369     <font class="keywordflow">if</font> (buf != limit)
04370       {
04371         <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
04372                         cstring_makeLiteralTemp (<font class="stringliteral">"garbage after `#undef' directive"</font>));
04373       }
04374   }
04375 
04376   <font class="keywordflow">return</font> 0;
04377 }
04378 
04379 
04380 <font class="comment">/*</font>
04381 <font class="comment"> * Report an error detected by the program we are processing.</font>
04382 <font class="comment"> * Use the text of the line in the error message.</font>
04383 <font class="comment"> * (We use error because it prints the filename &amp; line#.)</font>
04384 <font class="comment"> */</font>
04385 
04386 <font class="keyword">static</font> <font class="keywordtype">int</font>
04387 do_error (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04388           <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04389 <font class="keyword"></font>{
04390   <font class="keywordtype">int</font> length = limit - buf;
04391   cstring copy = <a class="code" href="cstring_c.html#a10">cstring_copyLength</a> (buf, length);
04392   cstring adv = <a class="code" href="cstring_c.html#a49">cstring_advanceWhiteSpace</a> (copy);
04393 
04394   <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile, message (<font class="stringliteral">"#error %s"</font>, adv));
04395   <a class="code" href="cstring_c.html#a27">cstring_free</a> (copy);
04396   <font class="keywordflow">return</font> 0;
04397 }
04398 
04399 <font class="comment">/*</font>
04400 <font class="comment"> * Report a warning detected by the program we are processing.</font>
04401 <font class="comment"> * Use the text of the line in the warning message, then continue.</font>
04402 <font class="comment"> * (We use error because it prints the filename &amp; line#.)</font>
04403 <font class="comment"> */</font>
04404 
04405 <font class="keyword">static</font> <font class="keywordtype">int</font>
04406 do_warning (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04407             <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04408 <font class="keyword"></font>{
04409   <font class="keywordtype">int</font> length = limit - buf;
04410   cstring copy = <a class="code" href="cstring_c.html#a10">cstring_copyLength</a> (buf, length);
04411   cstring adv = <a class="code" href="cstring_c.html#a49">cstring_advanceWhiteSpace</a> (copy);
04412   <a class="code" href="cpperror_c.html#a11">cppReader_warning</a> (pfile, message (<font class="stringliteral">"#warning %s"</font>, adv));
04413   <a class="code" href="cstring_c.html#a27">cstring_free</a> (copy);
04414   <font class="keywordflow">return</font> 0;
04415 }
04416 
04417 
04418 <font class="comment">/* #ident has already been copied to the output file, so just ignore it.  */</font>
04419 
04420 <font class="keyword">static</font> <font class="keywordtype">int</font>
04421 do_ident (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04422           <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *buf, <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04423 <font class="keyword"></font>{
04424   <font class="comment">/* Allow #ident in system headers, since that's not user's fault.  */</font>
04425   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile) &amp;&amp; !cppReader_getBuffer (pfile)-&gt;system_header_p)
04426     <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
04427                     cstring_makeLiteralTemp (<font class="stringliteral">"ANSI C does not allow `#ident'"</font>));
04428 
04429   <font class="comment">/* Leave rest of line to be read by later calls to cppGetToken.  */</font>
04430 
04431   <font class="keywordflow">return</font> 0;
04432 }
04433 
04434 <font class="comment">/* #pragma and its argument line have already been copied to the output file.</font>
04435 <font class="comment">   Just check for some recognized pragmas that need validation here.  */</font>
04436 
04437 <font class="keyword">static</font> <font class="keywordtype">int</font>
04438 do_pragma (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04439            <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *buf, <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04440 <font class="keyword"></font>{
04441   <font class="keywordflow">while</font> (*buf == <font class="charliteral">' '</font> || *buf == <font class="charliteral">'\t'</font>)
04442     {
04443       buf++;
04444     }
04445 
04446   <font class="keywordflow">if</font> (!strncmp (buf, <font class="stringliteral">"implementation"</font>, 14)) {
04447     <font class="comment">/* Be quiet about `#pragma implementation' for a file only if it hasn't</font>
04448 <font class="comment">       been included yet.  */</font>
04449     <font class="keyword">struct </font>file_name_list *ptr;
04450     <font class="keywordtype">char</font> *p = buf + 14, *fname, *inc_fname;
04451     <font class="keywordtype">int</font> fname_len;
04452     <a class="code" href="cpplib_c.html#a12">SKIP_WHITE_SPACE</a> (p);
04453     <font class="keywordflow">if</font> (*p == <font class="charliteral">'\n'</font> || *p != <font class="charliteral">'\"'</font>)
04454       <font class="keywordflow">return</font> 0;
04455 
04456     fname = p + 1;
04457     p = (<font class="keywordtype">char</font> *) strchr (fname, <font class="charliteral">'\"'</font>);
04458     fname_len = p != NULL ? p - fname : mstring_length (fname);
04459 
04460     <font class="keywordflow">for</font> (ptr = pfile-&gt;all_include_files; ptr != NULL; ptr = ptr-&gt;next)
04461       {
04462         inc_fname = (<font class="keywordtype">char</font> *) strrchr (cstring_toCharsSafe (ptr-&gt;fname), CONNECTCHAR);
04463         inc_fname = (inc_fname != NULL)
04464           ? inc_fname + 1 : <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (ptr-&gt;fname);
04465 
04466         <font class="keywordflow">if</font> ((inc_fname != NULL)
04467             &amp;&amp; (strncmp (inc_fname, fname, size_fromInt (fname_len)) == 0))
04468           {
04469             cpp_setLocation (pfile);
04470 
04471             <a class="code" href="llerror_c.html#a61">ppllerror</a> (message (<font class="stringliteral">"`#pragma implementation' for `%s' appears "</font>
04472                                 <font class="stringliteral">"after file is included"</font>,
04473                                 cstring_fromChars (fname)));
04474           }
04475       }
04476   }
04477 
04478   <font class="keywordflow">return</font> 0;
04479 }
04480 
04481 <font class="comment">/*</font>
04482 <font class="comment"> * handle #if command by</font>
04483 <font class="comment"> *   1) inserting special `defined' keyword into the hash table</font>
04484 <font class="comment"> *      that gets turned into 0 or 1 by special_symbol (thus,</font>
04485 <font class="comment"> *      if the luser has a symbol called `defined' already, it won't</font>
04486 <font class="comment"> *      work inside the #if command)</font>
04487 <font class="comment"> *   2) rescan the input into a temporary output buffer</font>
04488 <font class="comment"> *   3) pass the output buffer to the yacc parser and collect a value</font>
04489 <font class="comment"> *   4) clean up the mess left from steps 1 and 2.</font>
04490 <font class="comment"> *   5) call conditional_skip to skip til the next #endif (etc.),</font>
04491 <font class="comment"> *      or not, depending on the value from step 3.</font>
04492 <font class="comment"> */</font>
04493 
04494 <font class="keyword">static</font> <font class="keywordtype">int</font>
04495 do_if (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04496        <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04497 <font class="keyword"></font>{
04498   HOST_WIDE_INT value = eval_if_expression (pfile, buf, limit - buf);
04499   conditional_skip (pfile, value == 0, T_IF, NULL);
04500   <font class="keywordflow">return</font> 0;
04501 }
04502 
04503 <font class="comment">/*</font>
04504 <font class="comment"> * handle a #elif directive by not changing  if_stack  either.</font>
04505 <font class="comment"> * see the comment above do_else.</font>
04506 <font class="comment"> */</font>
04507 
04508 <font class="keyword">static</font> <font class="keywordtype">int</font> do_elif (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04509                     <font class="keywordtype">char</font> *buf, <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04510 <font class="keyword"></font>{
04511   <font class="keywordflow">if</font> (pfile-&gt;if_stack == cppReader_getBuffer (pfile)-&gt;if_stack)
04512     {
04513       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04514                     cstring_makeLiteralTemp (<font class="stringliteral">"Preprocessor command #elif is not within a conditional"</font>));
04515       <font class="keywordflow">return</font> 0;
04516     }
04517   <font class="keywordflow">else</font>
04518     {
04519       llassert (pfile-&gt;if_stack != NULL);
04520 
04521       <font class="keywordflow">if</font> (pfile-&gt;if_stack-&gt;type != T_IF &amp;&amp; pfile-&gt;if_stack-&gt;type != T_ELIF)
04522         {
04523           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04524                         cstring_makeLiteralTemp (<font class="stringliteral">"`#elif' after `#else'"</font>));
04525 
04526           <font class="keywordflow">if</font> (pfile-&gt;if_stack-&gt;fname != NULL
04527               &amp;&amp; cppReader_getBuffer (pfile)-&gt;fname != NULL
04528               &amp;&amp; !<a class="code" href="cstring_c.html#a18">cstring_equal</a> (pfile-&gt;if_stack-&gt;fname,
04529                                  cppReader_getBuffer (pfile)-&gt;nominal_fname))
04530             fprintf (stderr, <font class="stringliteral">", file %s"</font>, cstring_toCharsSafe (pfile-&gt;if_stack-&gt;fname));
04531           fprintf (stderr, <font class="stringliteral">")\n"</font>);
04532         }
04533       pfile-&gt;if_stack-&gt;type = T_ELIF;
04534     }
04535 
04536   <font class="keywordflow">if</font> (pfile-&gt;if_stack-&gt;if_succeeded)
04537     {
04538       skip_if_group (pfile, 0);
04539     }
04540   <font class="keywordflow">else</font>
04541     {
04542       HOST_WIDE_INT value = eval_if_expression (pfile, buf, limit - buf);
04543       <font class="keywordflow">if</font> (value == 0)
04544         skip_if_group (pfile, 0);
04545       <font class="keywordflow">else</font>
04546         {
04547           ++pfile-&gt;if_stack-&gt;if_succeeded;      <font class="comment">/* continue processing input */</font>
04548           output_line_command (pfile, 1, same_file);
04549         }
04550     }
04551 
04552   <font class="keywordflow">return</font> 0;
04553 }
04554 
04555 <font class="comment">/*</font>
04556 <font class="comment"> * evaluate a #if expression in BUF, of length LENGTH,</font>
04557 <font class="comment"> * then parse the result as a C expression and return the value as an int.</font>
04558 <font class="comment"> */</font>
04559 
04560 <font class="keyword">static</font> HOST_WIDE_INT
04561 eval_if_expression (cppReader *pfile,
04562                     <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *buf,
04563                     <font class="comment">/*@unused@*/</font> <font class="keywordtype">int</font> length)<font class="keyword"></font>
04564 <font class="keyword"></font>{
04565   HASHNODE *save_defined;
04566   HOST_WIDE_INT value;
04567   size_t old_written = cppReader_getWritten (pfile);
04568 
04569   save_defined = <a class="code" href="cpphash_c.html#a13">cppReader_install</a> (<font class="stringliteral">"defined"</font>, -1, T_SPEC_DEFINED, 0, 0, -1);
04570   pfile-&gt;pcp_inside_if = 1;
04571 
04572   value = <a class="code" href="cppexp_c.html#a62">cppReader_parseExpression</a> (pfile);
04573   pfile-&gt;pcp_inside_if = 0;
04574 
04575   <font class="comment">/* Clean up special symbol */</font>
04576   <a class="code" href="cpphash_c.html#a12">cppReader_deleteMacro</a> (save_defined);
04577 
04578   cppReader_setWritten (pfile, old_written); <font class="comment">/* Pop */</font>
04579 
04580   <font class="keywordflow">return</font> value;
04581 }
04582 
04583 <font class="comment">/*</font>
04584 <font class="comment"> * routine to handle ifdef/ifndef.  Try to look up the symbol,</font>
04585 <font class="comment"> * then do or don't skip to the #endif/#else/#elif depending</font>
04586 <font class="comment"> * on what directive is actually being processed.</font>
04587 <font class="comment"> */</font>
04588 
04589 <font class="keyword">static</font> <font class="keywordtype">int</font>
04590 do_xifdef (cppReader *pfile, <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04591            <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *unused1, <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *unused2)<font class="keyword"></font>
04592 <font class="keyword"></font>{
04593   <font class="keywordtype">int</font> skip;
04594   cppBuffer *ip = cppReader_getBuffer (pfile);
04595   <font class="keywordtype">char</font> *ident;
04596   <font class="keywordtype">int</font> ident_length;
04597   <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
04598   <font class="keywordtype">int</font> start_of_file = 0;
04599   <font class="keywordtype">char</font> *control_macro = 0;
04600   size_t old_written = cppReader_getWritten (pfile);
04601 
04602   DPRINTF ((<font class="stringliteral">"do xifdef: %d"</font>,
04603             keyword-&gt;type == T_IFNDEF));
04604 
04605   <font class="comment">/* Detect a #ifndef at start of file (not counting comments).  */</font>
04606   <font class="keywordflow">if</font> (cstring_isDefined (ip-&gt;fname) &amp;&amp; keyword-&gt;type == T_IFNDEF)
04607     {
04608       start_of_file = pfile-&gt;only_seen_white == 2;
04609     }
04610 
04611   pfile-&gt;no_macro_expand++;
04612   <a class="code" href="struct_token.html">token</a> = get_directive_token (pfile);
04613   pfile-&gt;no_macro_expand--;
04614 
04615   ident = pfile-&gt;token_buffer + old_written;
04616   ident_length = <a class="code" href="general_c.html#a34">size_toInt</a> (cppReader_getWritten (pfile) - old_written);
04617   cppReader_setWritten (pfile, old_written); <font class="comment">/* Pop */</font>
04618 
04619   <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_VSPACE || <a class="code" href="struct_token.html">token</a> == CPP_POP || <a class="code" href="struct_token.html">token</a> == CPP_EOF)
04620     {
04621       skip = (keyword-&gt;type == T_IFDEF);
04622       <font class="keywordflow">if</font> (! cppReader_isTraditional (pfile))
04623         {
04624           <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
04625                        message (<font class="stringliteral">"`#%s' with no argument"</font>, keyword-&gt;name));
04626         }
04627     }
04628   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="struct_token.html">token</a> == CPP_NAME)
04629     {
04630       HASHNODE *hp = <a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (ident, ident_length, -1);
04631       skip = (keyword-&gt;type == T_IFDEF) 
04632         ? (hp == NULL) : (hp != NULL);
04633 
04634       DPRINTF ((<font class="stringliteral">"hp null: %d / %d / %d"</font>,
04635                 (hp == NULL),
04636                 (keyword-&gt;type == T_IFNDEF),
04637                 skip));
04638                 
04639       <font class="keywordflow">if</font> (start_of_file &amp;&amp; !skip)
04640         {
04641           DPRINTF ((<font class="stringliteral">"Not skipping!"</font>));
04642           control_macro = (<font class="keywordtype">char</font> *) dmalloc (size_fromInt (ident_length + 1));
04643           memcpy (control_macro, ident, size_fromInt (ident_length + 1));
04644         }
04645     }
04646   <font class="keywordflow">else</font>
04647     {
04648       skip = (keyword-&gt;type == T_IFDEF);
04649       <font class="keywordflow">if</font> (! cppReader_isTraditional (pfile))
04650         {
04651           <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
04652                      message (<font class="stringliteral">"`#%s' with invalid argument"</font>, keyword-&gt;name));
04653         }
04654     }
04655 
04656   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
04657     {
04658       <font class="keywordtype">int</font> c;
04659       <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
04660       c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
04661       <font class="keywordflow">if</font> (c != EOF &amp;&amp; c != <font class="charliteral">'\n'</font>)
04662         {
04663           <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
04664                              message (<font class="stringliteral">"garbage at end of `#%s' argument"</font>, keyword-&gt;name));
04665         }
04666     }
04667 
04668   <a class="code" href="cpplib_c.html#a116">cppReader_skipRestOfLine</a> (pfile);
04669 
04670   DPRINTF ((<font class="stringliteral">"Conditional skip: %d"</font>, skip));
04671   conditional_skip (pfile, skip, T_IF, control_macro);
04672   <font class="keywordflow">return</font> 0;
04673 }
04674 
04675 <font class="comment">/* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.</font>
04676 <font class="comment">   If this is a #ifndef starting at the beginning of a file,</font>
04677 <font class="comment">   CONTROL_MACRO is the macro name tested by the #ifndef.</font>
04678 <font class="comment">   Otherwise, CONTROL_MACRO is 0.  */</font>
04679 
04680 <font class="keyword">static</font> <font class="keywordtype">void</font>
04681 conditional_skip (cppReader *pfile, <font class="keywordtype">int</font> skip,
04682                   <font class="keyword">enum</font> node_type type,
04683                   <font class="comment">/*@dependent@*/</font> <font class="keywordtype">char</font> *control_macro)<font class="keyword"></font>
04684 <font class="keyword"></font>{
04685   cppIfStackFrame *temp = (cppIfStackFrame *) dmalloc (<font class="keyword">sizeof</font> (*temp));
04686 
04687   temp-&gt;fname = cppReader_getBuffer (pfile)-&gt;nominal_fname;
04688   temp-&gt;next = pfile-&gt;if_stack;
04689   temp-&gt;control_macro = control_macro;
04690   temp-&gt;lineno = 0;
04691   temp-&gt;if_succeeded = 0;
04692 
04693   pfile-&gt;if_stack = temp;
04694   pfile-&gt;if_stack-&gt;type = type;
04695 
04696   <font class="keywordflow">if</font> (skip != 0)
04697     {
04698       skip_if_group (pfile, 0);
04699       <font class="keywordflow">return</font>;
04700     }
04701   <font class="keywordflow">else</font>
04702     {
04703       ++pfile-&gt;if_stack-&gt;if_succeeded;
04704       output_line_command (pfile, 1, same_file);
04705     }
04706 }
04707 
04708 <font class="comment">/*</font>
04709 <font class="comment"> * skip to #endif, #else, or #elif.  adjust line numbers, etc.</font>
04710 <font class="comment"> * leaves input ptr at the sharp sign found.</font>
04711 <font class="comment"> * If ANY is nonzero, return at next directive of any sort.</font>
04712 <font class="comment"> */</font>
04713 
04714 <font class="keyword">static</font> <font class="keywordtype">void</font>
04715 skip_if_group (cppReader *pfile, <font class="keywordtype">int</font> any)<font class="keyword"></font>
04716 <font class="keyword"></font>{
04717   <font class="keywordtype">int</font> c;
04718   <font class="keyword">struct </font><a class="code" href="struct_directive.html">directive</a> *kt;
04719   cppIfStackFrame *save_if_stack = pfile-&gt;if_stack; <font class="comment">/* don't pop past here */</font>
04720   <font class="keyword">register</font> <font class="keywordtype">int</font> ident_length;
04721   <font class="keywordtype">char</font> *ident;
04722   <font class="keyword">struct </font>parse_marker line_start_mark;
04723 
04724   parseSetMark (&amp;line_start_mark, pfile);
04725 
04726   <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;output_conditionals) {
04727     <font class="keyword">static</font> <font class="keywordtype">char</font> failed[] = <font class="stringliteral">"#failed\n"</font>;
04728     <a class="code" href="cpplib_c.html#a15">cppReader_puts</a> (pfile, failed, <font class="keyword">sizeof</font>(failed)-1);
04729     pfile-&gt;lineno++;
04730     output_line_command (pfile, 1, same_file);
04731   }
04732 
04733 beg_of_line:
04734   <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;output_conditionals)
04735     {
04736       cppBuffer *pbuf = cppReader_getBuffer (pfile);
04737       <font class="keywordtype">char</font> *start_line;
04738 
04739       llassert (pbuf-&gt;buf != NULL);
04740 
04741       start_line = pbuf-&gt;buf + line_start_mark.position;
04742       <a class="code" href="cpplib_c.html#a15">cppReader_puts</a> (pfile, start_line, size_fromInt (pbuf-&gt;cur - start_line));
04743     }
04744 
04745   parseMoveMark (&amp;line_start_mark, pfile);
04746 
04747   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
04748     {
04749       <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
04750     }
04751 
04752   c  = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
04753   <font class="keywordflow">if</font> (c == <font class="charliteral">'#'</font>)
04754     {
04755       size_t old_written = cppReader_getWritten (pfile);
04756       <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
04757 
04758       parse_name (pfile, cppReader_getC (pfile));
04759       ident_length = <a class="code" href="general_c.html#a34">size_toInt</a> (cppReader_getWritten (pfile) - old_written);
04760       ident = pfile-&gt;token_buffer + old_written;
04761       pfile-&gt;limit = ident;
04762 
04763       <font class="keywordflow">for</font> (kt = directive_table; kt-&gt;length &gt;= 0; kt++)
04764         {
04765           cppIfStackFrame *temp;
04766           <font class="keywordflow">if</font> (ident_length == kt-&gt;length
04767               &amp;&amp; <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (kt-&gt;name, ident))
04768             {
04769               <font class="comment">/* If we are asked to return on next directive, do so now.  */</font>
04770               <font class="keywordflow">if</font> (any)
04771                 {
04772                   <font class="keywordflow">goto</font> done;
04773                 }
04774 
04775               <font class="keywordflow">switch</font> (kt-&gt;type)
04776                 {
04777                 <font class="keywordflow">case</font> T_IF:
04778                 <font class="keywordflow">case</font> T_IFDEF:
04779                 <font class="keywordflow">case</font> T_IFNDEF:
04780                   temp = (cppIfStackFrame *) dmalloc (<font class="keyword">sizeof</font> (*temp));
04781                   temp-&gt;next = pfile-&gt;if_stack;
04782                   temp-&gt;fname = cppReader_getBuffer (pfile)-&gt;nominal_fname;
04783                   temp-&gt;type = kt-&gt;type;
04784                   temp-&gt;lineno = 0;
04785                   temp-&gt;if_succeeded = 0;
04786                   temp-&gt;control_macro = NULL;
04787 
04788                   pfile-&gt;if_stack = temp;
04789                   <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04790                 <font class="keywordflow">case</font> T_ELSE:
04791                 <font class="keywordflow">case</font> T_ENDIF:
04792                   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile) &amp;&amp; pfile-&gt;if_stack != save_if_stack)
04793                     validate_else (pfile,
04794                                    cstring_makeLiteralTemp (kt-&gt;type == T_ELSE ? "#<font class="keywordflow">else</font>" : "#endif"));
04795                   <font class="comment">/*@fallthrough@*/</font>
04796                 <font class="keywordflow">case</font> T_ELIF:
04797                   <font class="keywordflow">if</font> (pfile-&gt;if_stack == cppReader_getBuffer (pfile)-&gt;if_stack)
04798                     {
04799                       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
04800                                  message (<font class="stringliteral">"Preprocessor command #%s is not within a conditional"</font>, kt-&gt;name));
04801                       <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04802                     }
04803                   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (pfile-&gt;if_stack == save_if_stack)
04804                     {
04805                       <font class="keywordflow">goto</font> done;                <font class="comment">/* found what we came for */</font>
04806                     }
04807                   <font class="keywordflow">else</font>
04808                     {
04809                       ;
04810                     }
04811 
04812                   <font class="keywordflow">if</font> (kt-&gt;type != T_ENDIF)
04813                     {
04814                       llassert (pfile-&gt;if_stack != NULL);
04815 
04816                       <font class="keywordflow">if</font> (pfile-&gt;if_stack-&gt;type == T_ELSE)
04817                         {
04818                           <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04819                                         cstring_makeLiteralTemp (<font class="stringliteral">"`#else' or `#elif' after `#else'"</font>));
04820                         }
04821 
04822                       pfile-&gt;if_stack-&gt;type = kt-&gt;type;
04823                       <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04824                     }
04825 
04826                   temp = pfile-&gt;if_stack;
04827                   llassert (temp != NULL);
04828                   pfile-&gt;if_stack = temp-&gt;next;
04829                   <a class="code" href="general_c.html#a0">sfree</a> (temp);
04830                   <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04831                 <font class="keywordflow">default</font>: ;
04832                   <font class="comment">/*@-branchstate@*/</font> 
04833                 }
04834               <font class="comment">/*@=branchstate@*/</font>
04835               <font class="keywordflow">break</font>;
04836             }
04837           
04838           <font class="comment">/* Don't let erroneous code go by.  */</font>
04839           
04840           <font class="keywordflow">if</font> (kt-&gt;length &lt; 0 &amp;&amp; !CPPOPTIONS (pfile)-&gt;lang_asm
04841               &amp;&amp; cppReader_isPedantic (pfile))
04842             {
04843               <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
04844                                     cstring_makeLiteralTemp (<font class="stringliteral">"Invalid preprocessor directive name"</font>));
04845             }
04846         }
04847 
04848       c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
04849     }
04850   <font class="comment">/* We're in the middle of a line.  Skip the rest of it.  */</font>
04851   <font class="keywordflow">for</font> (;;) {
04852     <font class="keywordflow">switch</font> (c)
04853       {
04854         size_t old;
04855       <font class="keywordflow">case</font> EOF:
04856         <font class="keywordflow">goto</font> done;
04857       <font class="keywordflow">case</font> <font class="charliteral">'/'</font>:                 <font class="comment">/* possible comment */</font>
04858         c = skip_comment (pfile, NULL);
04859         <font class="keywordflow">if</font> (c == EOF)
04860           <font class="keywordflow">goto</font> done;
04861         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04862       <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
04863       <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
04864         <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
04865         old = cppReader_getWritten (pfile);
04866         (<font class="keywordtype">void</font>) <a class="code" href="cpplib_c.html#a141">cppGetToken</a> (pfile);
04867         cppReader_setWritten (pfile, old);
04868         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04869       <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
04870         <font class="comment">/* Char after backslash loses its special meaning.  */</font>
04871         <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
04872           {
04873             <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
04874           }
04875 
04876         <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
04877       <font class="keywordflow">case</font> <font class="charliteral">'\n'</font>:
04878         <font class="keywordflow">goto</font> beg_of_line;
04879       }
04880     c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
04881   }
04882 done:
04883   <font class="keywordflow">if</font> (CPPOPTIONS (pfile)-&gt;output_conditionals) {
04884     <font class="keyword">static</font> <font class="keywordtype">char</font> end_failed[] = <font class="stringliteral">"#endfailed\n"</font>;
04885     <a class="code" href="cpplib_c.html#a15">cppReader_puts</a> (pfile, end_failed, <font class="keyword">sizeof</font>(end_failed)-1);
04886     pfile-&gt;lineno++;
04887   }
04888   pfile-&gt;only_seen_white = 1;
04889 
04890   parseGotoMark (&amp;line_start_mark, pfile);
04891   parseClearMark (&amp;line_start_mark);
04892 }
04893 
04894 <font class="comment">/*</font>
04895 <font class="comment"> * handle a #else directive.  Do this by just continuing processing</font>
04896 <font class="comment"> * without changing  if_stack ;  this is so that the error message</font>
04897 <font class="comment"> * for missing #endif's etc. will point to the original #if.  It</font>
04898 <font class="comment"> * is possible that something different would be better.</font>
04899 <font class="comment"> */</font>
04900 
04901 <font class="keyword">static</font> <font class="keywordtype">int</font>
04902 do_else (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04903         <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *buf, <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04904 <font class="keyword"></font>{
04905   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile))
04906     {
04907       validate_else (pfile, cstring_makeLiteralTemp (<font class="stringliteral">"#else"</font>));
04908     }
04909 
04910   <a class="code" href="cpplib_c.html#a116">cppReader_skipRestOfLine</a> (pfile);
04911 
04912   <font class="keywordflow">if</font> (pfile-&gt;if_stack == cppReader_getBuffer (pfile)-&gt;if_stack) {
04913     <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
04914                   cstring_makeLiteralTemp (<font class="stringliteral">"Preprocessor command #else is not within a conditional"</font>));
04915     <font class="keywordflow">return</font> 0;
04916   } <font class="keywordflow">else</font> {
04917     <font class="comment">/* #ifndef can't have its special treatment for containing the whole file</font>
04918 <font class="comment">       if it has a #else clause.  */</font>
04919 
04920     llassert (pfile-&gt;if_stack != NULL);
04921 
04922     pfile-&gt;if_stack-&gt;control_macro = 0;
04923 
04924     <font class="keywordflow">if</font> (pfile-&gt;if_stack-&gt;type != T_IF &amp;&amp; pfile-&gt;if_stack-&gt;type != T_ELIF)
04925       {
04926         cpp_setLocation (pfile);
04927         <a class="code" href="llerror_c.html#a60">genppllerrorhint</a> (FLG_PREPROC,
04928                           message (<font class="stringliteral">"Pre-processor directive #else after #else"</font>),
04929                           <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Location of match"</font>,
04930                                    fileloc_unparseRaw (pfile-&gt;if_stack-&gt;fname,
04931                                                        pfile-&gt;if_stack-&gt;lineno)));
04932       }
04933 
04934     pfile-&gt;if_stack-&gt;type = T_ELSE;
04935   }
04936 
04937   <font class="keywordflow">if</font> (pfile-&gt;if_stack-&gt;if_succeeded)
04938     skip_if_group (pfile, 0);
04939   <font class="keywordflow">else</font> {
04940     ++pfile-&gt;if_stack-&gt;if_succeeded;    <font class="comment">/* continue processing input */</font>
04941     output_line_command (pfile, 1, same_file);
04942   }
04943 
04944   <font class="keywordflow">return</font> 0;
04945 }
04946 
04947 <font class="comment">/*</font>
04948 <font class="comment"> * unstack after #endif command</font>
04949 <font class="comment"> */</font>
04950 
04951 <font class="keyword">static</font> <font class="keywordtype">int</font>
04952 do_endif (cppReader *pfile, <font class="comment">/*@unused@*/</font> <font class="keyword">struct</font> <a class="code" href="struct_directive.html">directive</a> *keyword,
04953           <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *buf, <font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *limit)<font class="keyword"></font>
04954 <font class="keyword"></font>{
04955   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile))
04956     {
04957       validate_else (pfile, cstring_makeLiteralTemp (<font class="stringliteral">"#endif"</font>));
04958     }
04959 
04960   <a class="code" href="cpplib_c.html#a116">cppReader_skipRestOfLine</a> (pfile);
04961 
04962   <font class="keywordflow">if</font> (pfile-&gt;if_stack == cppReader_getBuffer (pfile)-&gt;if_stack)
04963     {
04964       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile, cstring_makeLiteralTemp (<font class="stringliteral">"Unbalanced #endif"</font>));
04965     }
04966   <font class="keywordflow">else</font>
04967     {
04968       cppIfStackFrame *temp = pfile-&gt;if_stack;
04969 
04970       llassert (temp != NULL);
04971 
04972       pfile-&gt;if_stack = temp-&gt;next;
04973       <font class="keywordflow">if</font> (temp-&gt;control_macro != 0)
04974         {
04975           <font class="comment">/* This #endif matched a #ifndef at the start of the file.</font>
04976 <font class="comment">             See if it is at the end of the file.  */</font>
04977           <font class="keyword">struct </font>parse_marker start_mark;
04978           <font class="keywordtype">int</font> c;
04979 
04980           parseSetMark (&amp;start_mark, pfile);
04981 
04982           <font class="keywordflow">for</font> (;;)
04983             {
04984               <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
04985               c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
04986 
04987               <font class="keywordflow">if</font> (c != <font class="charliteral">'\n'</font>)
04988                 <font class="keywordflow">break</font>;
04989             }
04990 
04991           parseGotoMark (&amp;start_mark, pfile);
04992           parseClearMark (&amp;start_mark);
04993 
04994           <font class="keywordflow">if</font> (c == EOF)
04995             {
04996               <font class="comment">/* If we get here, this #endif ends a #ifndef</font>
04997 <font class="comment">                 that contains all of the file (aside from whitespace).</font>
04998 <font class="comment">                 Arrange not to include the file again</font>
04999 <font class="comment">                 if the macro that was tested is defined.</font>
05000 <font class="comment"></font>
05001 <font class="comment">                 Do not do this for the top-level file in a -include or any</font>
05002 <font class="comment">                 file in a -imacros.  */</font>
05003               <font class="keyword">struct </font>file_name_list *ifile = pfile-&gt;all_include_files;
05004 
05005               <font class="keywordflow">for</font> ( ; ifile != NULL; ifile = ifile-&gt;next)
05006                 {
05007                   <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (ifile-&gt;fname, cppReader_getBuffer (pfile)-&gt;fname))
05008                     {
05009                       ifile-&gt;control_macro = temp-&gt;control_macro;
05010                       <font class="keywordflow">break</font>;
05011                     }
05012                 }
05013             }
05014         }
05015 
05016       <a class="code" href="general_c.html#a0">sfree</a> (temp);
05017       output_line_command (pfile, 1, same_file);
05018     }
05019   <font class="keywordflow">return</font> 0;
05020 }
05021 
05022 <font class="comment">/* When an #else or #endif is found while skipping failed conditional,</font>
05023 <font class="comment">   if -pedantic was specified, this is called to warn about text after</font>
05024 <font class="comment">   the command name.  P points to the first char after the command name.  */</font>
05025 
05026 <font class="keyword">static</font> <font class="keywordtype">void</font>
05027 validate_else (cppReader *pfile, cstring <a class="code" href="struct_directive.html">directive</a>)<font class="keyword"></font>
05028 <font class="keyword"></font>{
05029   <font class="keywordtype">int</font> c;
05030   <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
05031   c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05032   <font class="keywordflow">if</font> (c != EOF &amp;&amp; c != <font class="charliteral">'\n'</font>)
05033     {
05034       <a class="code" href="cpperror_c.html#a13">cppReader_pedwarn</a> (pfile,
05035                    message (<font class="stringliteral">"text following `%s' violates ANSI standard"</font>, <a class="code" href="struct_directive.html">directive</a>));
05036     }
05037 }
05038 
05039 <font class="comment">/*</font>
05040 <font class="comment">** Get the next token, and add it to the text in pfile-&gt;token_buffer.</font>
05041 <font class="comment">** Return the kind of token we got.</font>
05042 <font class="comment">*/</font>
05043 
05044 <font class="keyword">enum</font> cpp_token
<a name="l05045"></a><a class="code" href="cpplib_c.html#a141">05045</a> <a class="code" href="cpplib_c.html#a141">cppGetToken</a> (cppReader *pfile)<font class="keyword"></font>
05046 <font class="keyword"></font>{
05047   <font class="keywordtype">int</font> c, c2, c3;
05048   size_t old_written = 0;
05049   <font class="keywordtype">int</font> start_line, start_column;
05050   <font class="keyword">enum</font> cpp_token <a class="code" href="struct_token.html">token</a>;
05051   <font class="keyword">struct </font>cppOptions *opts = CPPOPTIONS (pfile);
05052   cppReader_getBuffer (pfile)-&gt;prev = cppReader_getBuffer (pfile)-&gt;cur;
05053 
05054 get_next:
05055   c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05056 
05057   <font class="keywordflow">if</font> (c == EOF)
05058     {
05059     handle_eof:
05060       <font class="keywordflow">if</font> (cppReader_getBuffer (pfile)-&gt;seen_eof)
05061         {
05062           cppBuffer *buf = <a class="code" href="cpplib_c.html#a122">cppReader_popBuffer</a> (pfile);
05063 
05064           <font class="keywordflow">if</font> (buf != cppReader_nullBuffer (pfile))
05065             {
05066               <font class="keywordflow">goto</font> get_next;
05067             }
05068           <font class="keywordflow">else</font>
05069             {
05070               <font class="keywordflow">return</font> CPP_EOF;
05071             }
05072         }
05073       <font class="keywordflow">else</font>
05074         {
05075           cppBuffer *next_buf = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (cppReader_getBuffer (pfile));
05076           cppReader_getBuffer (pfile)-&gt;seen_eof = 1;
05077 
05078           <font class="keywordflow">if</font> (cstring_isDefined (cppReader_getBuffer (pfile)-&gt;nominal_fname)
05079               &amp;&amp; next_buf != cppReader_nullBuffer (pfile))
05080             {
05081               <font class="comment">/* We're about to return from an #include file.</font>
05082 <font class="comment">                 Emit #line information now (as part of the CPP_POP) result.</font>
05083 <font class="comment">                 But the #line refers to the file we will pop to.  */</font>
05084               cppBuffer *cur_buffer = CPPBUFFER (pfile);
05085               CPPBUFFER (pfile) = next_buf;
05086               pfile-&gt;input_stack_listing_current = 0;
05087               output_line_command (pfile, 0, leave_file);
05088               CPPBUFFER (pfile) = cur_buffer;
05089             }
05090           <font class="keywordflow">return</font> CPP_POP;
05091         }
05092     }
05093   <font class="keywordflow">else</font>
05094     {
05095       <font class="keywordtype">long</font> newlines;
05096       <font class="keyword">struct </font>parse_marker start_mark;
05097 
05098       <font class="keywordflow">switch</font> (c)
05099         {
05100         <font class="keywordflow">case</font> <font class="charliteral">'/'</font>:
05101           <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'='</font>)
05102             {
05103               <font class="keywordflow">goto</font> op2;
05104             }
05105 
05106           <font class="keywordflow">if</font> (opts-&gt;put_out_comments)
05107             {
05108               parseSetMark (&amp;start_mark, pfile);
05109             }
05110 
05111           newlines = 0;
05112           <a class="code" href="cpplib_c.html#a126">cppBuffer_lineAndColumn</a> (cppReader_fileBuffer (pfile),
05113                                    &amp;start_line, &amp;start_column);
05114           c = skip_comment (pfile, &amp;newlines);
05115 
05116           <font class="keywordflow">if</font> (opts-&gt;put_out_comments &amp;&amp; (c == <font class="charliteral">'/'</font> || c == EOF))
05117             {
05118               assertSet (&amp;start_mark);
05119               parseClearMark (&amp;start_mark);
05120             }
05121 
05122           <font class="keywordflow">if</font> (c == <font class="charliteral">'/'</font>)
05123             <font class="keywordflow">goto</font> randomchar;
05124           <font class="keywordflow">if</font> (c == EOF)
05125             {
05126               <a class="code" href="cpperror_c.html#a14">cppReader_errorWithLine</a> (pfile, start_line, start_column,
05127                                        cstring_makeLiteral (<font class="stringliteral">"Unterminated comment"</font>));
05128               <font class="keywordflow">goto</font> handle_eof;
05129             }
05130           c = <font class="charliteral">'/'</font>;  <font class="comment">/* Initial letter of comment.  */</font>
05131         return_comment:
05132           <font class="comment">/* Comments are equivalent to spaces.</font>
05133 <font class="comment">             For -traditional, a comment is equivalent to nothing.  */</font>
05134 
05135           <font class="keywordflow">if</font> (opts-&gt;put_out_comments)
05136             {
05137               <font class="keyword">enum</font> cpp_token res;
05138 
05139               assertSet (&amp;start_mark);
05140               res = cpp_handleComment (pfile, &amp;start_mark);
05141               pfile-&gt;lineno += newlines;
05142               <font class="keywordflow">return</font> res;
05143             }
05144           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cppReader_isTraditional (pfile))
05145             {
05146               <font class="keywordflow">return</font> CPP_COMMENT;
05147             }
05148           <font class="keywordflow">else</font>
05149             {
05150               cppReader_reserve(pfile, 1);
05151               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">' '</font>);
05152               <font class="keywordflow">return</font> CPP_HSPACE;
05153             }
05154 
05155         <font class="keywordflow">case</font> <font class="charliteral">'#'</font>:
05156           <font class="keywordflow">if</font> (!pfile-&gt;only_seen_white)
05157             {
05158               <font class="keywordflow">goto</font> randomchar;
05159             }
05160 
05161           <font class="keywordflow">if</font> (cppReader_handleDirective (pfile))
05162             {
05163               <font class="keywordflow">return</font> CPP_DIRECTIVE;
05164             }
05165 
05166           pfile-&gt;only_seen_white = 0;
05167           <font class="keywordflow">return</font> CPP_OTHER;
05168 
05169         <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
05170         <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
05171           <font class="comment">/* A single quoted string is treated like a double -- some</font>
05172 <font class="comment">             programs (e.g., troff) are perverse this way */</font>
05173           <a class="code" href="cpplib_c.html#a126">cppBuffer_lineAndColumn</a> (cppReader_fileBuffer (pfile),
05174                                    &amp;start_line, &amp;start_column);
05175           old_written = cppReader_getWritten (pfile);
05176         string:
05177           <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05178           <font class="keywordflow">while</font> (TRUE)
05179             {
05180               <font class="keywordtype">int</font> cc = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05181               <font class="keywordflow">if</font> (cc == EOF)
05182                 {
05183                   <font class="keywordflow">if</font> (cppBuffer_isMacro (CPPBUFFER (pfile)))
05184                     {
05185                       <font class="comment">/* try harder: this string crosses a macro expansion</font>
05186 <font class="comment">                         boundary.  This can happen naturally if -traditional.</font>
05187 <font class="comment">                         Otherwise, only -D can make a macro with an unmatched</font>
05188 <font class="comment">                         quote.  */</font>
05189                       cppBuffer *next_buf
05190                         = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (cppReader_getBuffer (pfile));
05191                       (*cppReader_getBuffer (pfile)-&gt;cleanup)
05192                         (cppReader_getBuffer (pfile), pfile);
05193                       CPPBUFFER (pfile) = next_buf;
05194                       <font class="keywordflow">continue</font>;
05195                     }
05196                   <font class="keywordflow">if</font> (!cppReader_isTraditional (pfile))
05197                     {
05198                       cpp_setLocation (pfile);
05199 
05200                       setLine (long_toInt (start_line));
05201                       setColumn (long_toInt (start_column));
05202 
05203                       <font class="keywordflow">if</font> (pfile-&gt;multiline_string_line != <a class="code" href="general_c.html#a38">long_toInt</a> (start_line)
05204                           &amp;&amp; pfile-&gt;multiline_string_line != 0)
05205                         {
05206                           genppllerrorhint
05207                             (FLG_PREPROC,
05208                              <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unterminated string or character constant"</font>),
05209                              <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Possible real start of unterminated constant"</font>,
05210                                       fileloc_unparseRaw 
05211                                       (fileloc_filename (g_currentloc),
05212                                        pfile-&gt;multiline_string_line)));
05213                           pfile-&gt;multiline_string_line = 0;
05214                         }
05215                       <font class="keywordflow">else</font>
05216                         {
05217                           genppllerror
05218                             (FLG_PREPROC,
05219                              <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unterminated string or character constant"</font>));
05220                         }
05221                     }
05222                   <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05223                 }
05224               <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, cc);
05225               <font class="keywordflow">switch</font> (cc)
05226                 {
05227                 <font class="keywordflow">case</font> <font class="charliteral">'\n'</font>:
05228                   <font class="comment">/* Traditionally, end of line ends a string constant with</font>
05229 <font class="comment">                     no error.  So exit the loop and record the new line.  */</font>
05230                   <font class="keywordflow">if</font> (cppReader_isTraditional (pfile))
05231                     <font class="keywordflow">goto</font> while2end;
05232                   <font class="keywordflow">if</font> (c == <font class="charliteral">'\''</font>)
05233                     {
05234                       <font class="keywordflow">goto</font> while2end;
05235                     }
05236                   <font class="keywordflow">if</font> (cppReader_isPedantic (pfile)
05237                       &amp;&amp; pfile-&gt;multiline_string_line == 0)
05238                     {
05239                       cppReader_pedwarnWithLine
05240                         (pfile, <a class="code" href="general_c.html#a38">long_toInt</a> (start_line),
05241                          <a class="code" href="general_c.html#a38">long_toInt</a> (start_column),
05242                          cstring_makeLiteral (<font class="stringliteral">"String constant runs past end of line"</font>));
05243                     }
05244                   <font class="keywordflow">if</font> (pfile-&gt;multiline_string_line == 0)
05245                     {
05246                       pfile-&gt;multiline_string_line = start_line;
05247                     }
05248 
05249                   <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
05250 
05251                 <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
05252                   cc = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05253                   <font class="keywordflow">if</font> (cc == <font class="charliteral">'\n'</font>)
05254                     {
05255                       <font class="comment">/* Backslash newline is replaced by nothing at all.  */</font>
05256                       <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, -1);
05257                       pfile-&gt;lineno++;
05258                     }
05259                   <font class="keywordflow">else</font>
05260                     {
05261                       <font class="comment">/* ANSI stupidly requires that in \\ the second \</font>
05262 <font class="comment">                         is *not* prevented from combining with a newline.  */</font>
05263                       <a class="code" href="cpplib_c.html#a27">NEWLINE_FIX1</a>(cc);
05264                       <font class="keywordflow">if</font> (cc != EOF)
05265                         <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, cc);
05266                     }
05267                   <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
05268 
05269                 <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>:
05270                 <font class="keywordflow">case</font> <font class="charliteral">'\''</font>:
05271                   <font class="keywordflow">if</font> (cc == c)
05272                     <font class="keywordflow">goto</font> while2end;
05273                   <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
05274                 }
05275             }
05276         while2end:
05277           pfile-&gt;lineno += count_newlines (pfile-&gt;token_buffer + old_written,
05278                                            cppReader_getPWritten (pfile));
05279           pfile-&gt;only_seen_white = 0;
05280           <font class="keywordflow">return</font> c == <font class="charliteral">'\''</font> ? CPP_CHAR : CPP_STRING;
05281 
05282         <font class="keywordflow">case</font> <font class="charliteral">'$'</font>:
05283           <font class="keywordflow">if</font> (!opts-&gt;dollars_in_ident)
05284             <font class="keywordflow">goto</font> randomchar;
05285           <font class="keywordflow">goto</font> letter;
05286 
05287         <font class="keywordflow">case</font> <font class="charliteral">':'</font>:
05288           <font class="keywordflow">if</font> (opts-&gt;cplusplus &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">':'</font>)
05289             <font class="keywordflow">goto</font> op2;
05290           <font class="keywordflow">goto</font> randomchar;
05291 
05292         <font class="keywordflow">case</font> <font class="charliteral">'&amp;'</font>:
05293         <font class="keywordflow">case</font> <font class="charliteral">'+'</font>:
05294         <font class="keywordflow">case</font> <font class="charliteral">'|'</font>:
05295           NEWLINE_FIX;
05296           c2 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05297           <font class="keywordflow">if</font> (c2 == c || c2 == <font class="charliteral">'='</font>)
05298             <font class="keywordflow">goto</font> op2;
05299           <font class="keywordflow">goto</font> randomchar;
05300 
05301         <font class="keywordflow">case</font> <font class="charliteral">'*'</font>:
05302         <font class="keywordflow">case</font> <font class="charliteral">'!'</font>:
05303         <font class="keywordflow">case</font> <font class="charliteral">'%'</font>:
05304         <font class="keywordflow">case</font> <font class="charliteral">'='</font>:
05305         <font class="keywordflow">case</font> <font class="charliteral">'^'</font>:
05306           NEWLINE_FIX;
05307           <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'='</font>)
05308             <font class="keywordflow">goto</font> op2;
05309           <font class="keywordflow">goto</font> randomchar;
05310 
05311         <font class="keywordflow">case</font> <font class="charliteral">'-'</font>:
05312           NEWLINE_FIX;
05313           c2 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05314           <font class="keywordflow">if</font> (c2 == <font class="charliteral">'-'</font> &amp;&amp; opts-&gt;chill)
05315             {
05316               <font class="comment">/* Chill style comment */</font>
05317               <font class="keywordflow">if</font> (opts-&gt;put_out_comments)
05318                 {
05319                   parseSetMark (&amp;start_mark, pfile);
05320                 }
05321 
05322               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);  <font class="comment">/* Skip second '-'.  */</font>
05323 
05324               <font class="keywordflow">for</font> (;;)
05325                 {
05326                   c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05327                   <font class="keywordflow">if</font> (c == EOF)
05328                     <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05329                   <font class="keywordflow">if</font> (c == <font class="charliteral">'\n'</font>)
05330                     {
05331                       <font class="comment">/* Don't consider final '\n' to be part of comment.  */</font>
05332                       <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
05333                       <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05334                     }
05335                 }
05336               c = <font class="charliteral">'-'</font>;
05337               <font class="keywordflow">goto</font> return_comment;
05338             }
05339           <font class="keywordflow">if</font> (c2 == <font class="charliteral">'-'</font> || c2 == <font class="charliteral">'='</font> || c2 == <font class="charliteral">'&gt;'</font>)
05340             <font class="keywordflow">goto</font> op2;
05341           <font class="keywordflow">goto</font> randomchar;
05342 
05343         <font class="keywordflow">case</font> <font class="charliteral">'&lt;'</font>:
05344           <font class="keywordflow">if</font> (pfile-&gt;parsing_include_directive)
05345             {
05346               <font class="keywordflow">for</font> (;;)
05347                 {
05348                   <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05349                   <font class="keywordflow">if</font> (c == <font class="charliteral">'&gt;'</font>)
05350                     <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05351                   c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05352                   <a class="code" href="cpplib_c.html#a27">NEWLINE_FIX1</a> (c);
05353                   <font class="keywordflow">if</font> (c == <font class="charliteral">'\n'</font> || c == EOF)
05354                     {
05355                       <a class="code" href="cpperror_c.html#a8">cppReader_errorLit</a> (pfile,
05356                                     cstring_makeLiteralTemp (<font class="stringliteral">"Missing '&gt;' in \"#include &lt;FILENAME&gt;\""</font>));
05357                       <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05358                     }
05359                 }
05360               <font class="keywordflow">return</font> CPP_STRING;
05361             }
05362           <font class="comment">/*@fallthrough@*/</font>
05363         <font class="keywordflow">case</font> <font class="charliteral">'&gt;'</font>:
05364           NEWLINE_FIX;
05365           c2 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05366           <font class="keywordflow">if</font> (c2 == <font class="charliteral">'='</font>)
05367             <font class="keywordflow">goto</font> op2;
05368           <font class="keywordflow">if</font> (c2 != c)
05369             <font class="keywordflow">goto</font> randomchar;
05370           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
05371           cppReader_reserve (pfile, 4);
05372           <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05373           <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c2);
05374           NEWLINE_FIX;
05375           c3 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05376           <font class="keywordflow">if</font> (c3 == <font class="charliteral">'='</font>)
05377             <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, cppReader_getC (pfile));
05378           <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
05379           pfile-&gt;only_seen_white = 0;
05380           <font class="keywordflow">return</font> CPP_OTHER;
05381 
05382         <font class="keywordflow">case</font> <font class="charliteral">'@'</font>:
05383           <font class="keywordflow">if</font> (cppReader_getBuffer (pfile)-&gt;has_escapes)
05384             {
05385               c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05386               <font class="keywordflow">if</font> (c == <font class="charliteral">'-'</font>)
05387                 {
05388                   <font class="keywordflow">if</font> (pfile-&gt;output_escapes)
05389                     <a class="code" href="cpplib_c.html#a15">cppReader_puts</a> (pfile, <font class="stringliteral">"@-"</font>, 2);
05390                   parse_name (pfile, cppReader_getC (pfile));
05391                   <font class="keywordflow">return</font> CPP_NAME;
05392                 }
05393               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (is_space [c])
05394                 {
05395                   cppReader_reserve (pfile, 2);
05396                   <font class="keywordflow">if</font> (pfile-&gt;output_escapes)
05397                     <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'@'</font>);
05398                   <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
05399                   <font class="keywordflow">return</font> CPP_HSPACE;
05400                 }
05401               <font class="keywordflow">else</font>
05402                 {
05403                   ;
05404                 }
05405             }
05406           <font class="keywordflow">if</font> (pfile-&gt;output_escapes)
05407             {
05408               <a class="code" href="cpplib_c.html#a15">cppReader_puts</a> (pfile, <font class="stringliteral">"@@"</font>, 2);
05409               <font class="keywordflow">return</font> CPP_OTHER;
05410             }
05411           <font class="keywordflow">goto</font> randomchar;
05412         <font class="keywordflow">case</font> <font class="charliteral">'.'</font>:
05413           NEWLINE_FIX;
05414           c2 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05415           <font class="keywordflow">if</font> (isdigit(c2))
05416             {
05417               cppReader_reserve(pfile, 2);
05418               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'.'</font>);
05419               c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05420               <font class="keywordflow">goto</font> number;
05421             }
05422 
05423           <font class="comment">/* FIXME - misses the case "..\\\n." */</font>
05424           <font class="keywordflow">if</font> (c2 == <font class="charliteral">'.'</font> &amp;&amp; cpp_peekN (pfile, 1) == <font class="charliteral">'.'</font>)
05425             {
05426               cppReader_reserve(pfile, 4);
05427               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'.'</font>);
05428               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'.'</font>);
05429               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'.'</font>);
05430               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 2);
05431               <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
05432               pfile-&gt;only_seen_white = 0;
05433               <font class="keywordflow">return</font> CPP_3DOTS;
05434             }
05435           <font class="keywordflow">goto</font> randomchar;
05436         op2:
05437           <a class="code" href="struct_token.html">token</a> = CPP_OTHER;
05438           pfile-&gt;only_seen_white = 0;
05439         op2any:
05440           cppReader_reserve(pfile, 3);
05441           <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
05442           <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, cppReader_getC (pfile));
05443           <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
05444           <font class="keywordflow">return</font> <a class="code" href="struct_token.html">token</a>;
05445 
05446         <font class="keywordflow">case</font> <font class="charliteral">'L'</font>:
05447           NEWLINE_FIX;
05448           c2 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05449           <font class="keywordflow">if</font> ((c2 == <font class="charliteral">'\''</font> || c2 == <font class="charliteral">'\"'</font>) &amp;&amp; !cppReader_isTraditional (pfile))
05450             {
05451               <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05452               c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05453               <font class="keywordflow">goto</font> string;
05454             }
05455           <font class="keywordflow">goto</font> letter;
05456 
05457         <font class="keywordflow">case</font> <font class="charliteral">'0'</font>: <font class="keywordflow">case</font> <font class="charliteral">'1'</font>: <font class="keywordflow">case</font> <font class="charliteral">'2'</font>: <font class="keywordflow">case</font> <font class="charliteral">'3'</font>: <font class="keywordflow">case</font> <font class="charliteral">'4'</font>:
05458         <font class="keywordflow">case</font> <font class="charliteral">'5'</font>: <font class="keywordflow">case</font> <font class="charliteral">'6'</font>: <font class="keywordflow">case</font> <font class="charliteral">'7'</font>: <font class="keywordflow">case</font> <font class="charliteral">'8'</font>: <font class="keywordflow">case</font> <font class="charliteral">'9'</font>:
05459         number:
05460           c2  = <font class="charliteral">'.'</font>;
05461           <font class="keywordflow">for</font> (;;)
05462             {
05463               cppReader_reserve (pfile, 2);
05464               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
05465               NEWLINE_FIX;
05466               c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05467               <font class="keywordflow">if</font> (c == EOF)
05468                 <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05469               <font class="keywordflow">if</font> (!is_idchar[c] &amp;&amp; c != <font class="charliteral">'.'</font>
05470                   &amp;&amp; ((c2 != <font class="charliteral">'e'</font> &amp;&amp; c2 != <font class="charliteral">'E'</font>
05471                        &amp;&amp; ((c2 != <font class="charliteral">'p'</font> &amp;&amp; c2 != <font class="charliteral">'P'</font>) || <a class="code" href="cpplib_c.html#a21">cppReader_isC89</a> (pfile)))
05472                       || (c != <font class="charliteral">'+'</font> &amp;&amp; c != <font class="charliteral">'-'</font>)))
05473                 <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05474               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
05475               c2= c;
05476             }
05477 
05478           <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
05479           pfile-&gt;only_seen_white = 0;
05480           <font class="keywordflow">return</font> CPP_NUMBER;
05481 
05482         <font class="keywordflow">case</font> <font class="charliteral">'b'</font>: <font class="keywordflow">case</font> <font class="charliteral">'c'</font>: <font class="keywordflow">case</font> <font class="charliteral">'d'</font>: <font class="keywordflow">case</font> <font class="charliteral">'h'</font>: <font class="keywordflow">case</font> <font class="charliteral">'o'</font>:
05483         <font class="keywordflow">case</font> <font class="charliteral">'B'</font>: <font class="keywordflow">case</font> <font class="charliteral">'C'</font>: <font class="keywordflow">case</font> <font class="charliteral">'D'</font>: <font class="keywordflow">case</font> <font class="charliteral">'H'</font>: <font class="keywordflow">case</font> <font class="charliteral">'O'</font>:
05484           <font class="keywordflow">if</font> (opts-&gt;chill &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\''</font>)
05485             {
05486               pfile-&gt;only_seen_white = 0;
05487               cppReader_reserve (pfile, 2);
05488               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
05489               <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, <font class="charliteral">'\''</font>);
05490               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
05491               <font class="keywordflow">for</font> (;;)
05492                 {
05493                   c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05494                   <font class="keywordflow">if</font> (c == EOF)
05495                     <font class="keywordflow">goto</font> chill_number_eof;
05496                   <font class="keywordflow">if</font> (!is_idchar[c])
05497                     {
05498                       <font class="keywordflow">if</font> (c == <font class="charliteral">'\\'</font> &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
05499                         {
05500                           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 2);
05501                           <font class="keywordflow">continue</font>;
05502                         }
05503                       <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05504                     }
05505                   <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05506                 }
05507               <font class="keywordflow">if</font> (c == <font class="charliteral">'\''</font>)
05508                 {
05509                   cppReader_reserve (pfile, 2);
05510                   <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
05511                   <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
05512                   <font class="keywordflow">return</font> CPP_STRING;
05513                 }
05514               <font class="keywordflow">else</font>
05515                 {
05516                   <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
05517                 chill_number_eof:
05518                   <a class="code" href="cpplib_c.html#a19">cppReader_nullTerminate</a> (pfile);
05519                   <font class="keywordflow">return</font> CPP_NUMBER;
05520                 }
05521             }
05522           <font class="keywordflow">else</font>
05523             <font class="keywordflow">goto</font> letter;
05524         <font class="keywordflow">case</font> <font class="charliteral">'_'</font>:
05525         <font class="keywordflow">case</font> <font class="charliteral">'a'</font>: <font class="keywordflow">case</font> <font class="charliteral">'e'</font>: <font class="keywordflow">case</font> <font class="charliteral">'f'</font>: <font class="keywordflow">case</font> <font class="charliteral">'g'</font>: <font class="keywordflow">case</font> <font class="charliteral">'i'</font>: <font class="keywordflow">case</font> <font class="charliteral">'j'</font>:
05526         <font class="keywordflow">case</font> <font class="charliteral">'k'</font>: <font class="keywordflow">case</font> <font class="charliteral">'l'</font>: <font class="keywordflow">case</font> <font class="charliteral">'m'</font>: <font class="keywordflow">case</font> <font class="charliteral">'n'</font>: <font class="keywordflow">case</font> <font class="charliteral">'p'</font>: <font class="keywordflow">case</font> <font class="charliteral">'q'</font>:
05527         <font class="keywordflow">case</font> <font class="charliteral">'r'</font>: <font class="keywordflow">case</font> <font class="charliteral">'s'</font>: <font class="keywordflow">case</font> <font class="charliteral">'t'</font>: <font class="keywordflow">case</font> <font class="charliteral">'u'</font>: <font class="keywordflow">case</font> <font class="charliteral">'v'</font>: <font class="keywordflow">case</font> <font class="charliteral">'w'</font>:
05528         <font class="keywordflow">case</font> <font class="charliteral">'x'</font>: <font class="keywordflow">case</font> <font class="charliteral">'y'</font>: <font class="keywordflow">case</font> <font class="charliteral">'z'</font>:
05529         <font class="keywordflow">case</font> <font class="charliteral">'A'</font>: <font class="keywordflow">case</font> <font class="charliteral">'E'</font>: <font class="keywordflow">case</font> <font class="charliteral">'F'</font>: <font class="keywordflow">case</font> <font class="charliteral">'G'</font>: <font class="keywordflow">case</font> <font class="charliteral">'I'</font>: <font class="keywordflow">case</font> <font class="charliteral">'J'</font>:
05530         <font class="keywordflow">case</font> <font class="charliteral">'K'</font>: <font class="keywordflow">case</font> <font class="charliteral">'M'</font>: <font class="keywordflow">case</font> <font class="charliteral">'N'</font>: <font class="keywordflow">case</font> <font class="charliteral">'P'</font>: <font class="keywordflow">case</font> <font class="charliteral">'Q'</font>: <font class="keywordflow">case</font> <font class="charliteral">'R'</font>:
05531         <font class="keywordflow">case</font> <font class="charliteral">'S'</font>: <font class="keywordflow">case</font> <font class="charliteral">'T'</font>: <font class="keywordflow">case</font> <font class="charliteral">'U'</font>: <font class="keywordflow">case</font> <font class="charliteral">'V'</font>: <font class="keywordflow">case</font> <font class="charliteral">'W'</font>: <font class="keywordflow">case</font> <font class="charliteral">'X'</font>:
05532         <font class="keywordflow">case</font> <font class="charliteral">'Y'</font>: <font class="keywordflow">case</font> <font class="charliteral">'Z'</font>:
05533         letter:
05534           {
05535             HASHNODE *hp;
05536             <font class="keywordtype">char</font> *ident;
05537             size_t before_name_written = cppReader_getWritten (pfile);
05538             <font class="keywordtype">int</font> ident_len;
05539             parse_name (pfile, c);
05540             pfile-&gt;only_seen_white = 0;
05541             <font class="keywordflow">if</font> (pfile-&gt;no_macro_expand)
05542               {
05543                 <font class="keywordflow">return</font> CPP_NAME;
05544               }
05545 
05546             ident = pfile-&gt;token_buffer + before_name_written;
05547             ident_len = (cppReader_getPWritten (pfile)) - ident;
05548 
05549             hp = <a class="code" href="cpphash_c.html#a11">cppReader_lookupExpand</a> (ident, ident_len, -1);
05550 
05551             <font class="keywordflow">if</font> (hp == NULL)
05552               {
05553                 <font class="keywordflow">return</font> CPP_NAME;
05554               }
05555 
05556             <font class="keywordflow">if</font> (hp-&gt;type == T_DISABLED)
05557               {
05558                 <font class="keywordflow">if</font> (pfile-&gt;output_escapes)
05559                   { <font class="comment">/* Return "@-IDENT", followed by '\0'.  */</font>
05560                     <font class="keywordtype">int</font> i;
05561                     cppReader_reserve (pfile, 3);
05562                     ident = pfile-&gt;token_buffer + before_name_written;
05563                     <a class="code" href="cpplib_c.html#a20">cppReader_adjustWritten</a> (pfile, 2);
05564 
05565                     <font class="keywordflow">for</font> (i = ident_len; i &gt;= 0; i--)
05566                       {
05567                         ident[i+2] = ident[i];
05568                       }
05569 
05570                     ident[0] = <font class="charliteral">'@'</font>;
05571                     ident[1] = <font class="charliteral">'-'</font>;
05572                   }
05573                 <font class="keywordflow">return</font> CPP_NAME;
05574               }
05575 
05576             <font class="comment">/* If macro wants an arglist, verify that a '(' follows.</font>
05577 <font class="comment">               first skip all whitespace, copying it to the output</font>
05578 <font class="comment">               after the macro name.  Then, if there is no '(',</font>
05579 <font class="comment">               decide this is not a macro call and leave things that way.  */</font>
05580 
05581             <font class="keywordflow">if</font> (hp-&gt;type == T_MACRO &amp;&amp; hp-&gt;value.defn-&gt;nargs &gt;= 0)
05582               {
05583                 <font class="keyword">struct </font>parse_marker macro_mark;
05584                 <font class="keywordtype">int</font> is_macro_call;
05585 
05586                 <font class="keywordflow">while</font> (cppBuffer_isMacro (CPPBUFFER (pfile)))
05587                   {
05588                     cppBuffer *next_buf;
05589                     <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
05590                     <font class="keywordflow">if</font> (<a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) != EOF)
05591                       {
05592                         <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05593                       }
05594 
05595                   next_buf = <a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (cppReader_getBuffer (pfile));
05596                   (*cppReader_getBuffer (pfile)-&gt;cleanup) (cppReader_getBuffer (pfile), pfile);
05597                   CPPBUFFER (pfile) = next_buf;
05598                   }
05599 
05600                 parseSetMark (&amp;macro_mark, pfile);
05601 
05602                 <font class="keywordflow">for</font> (;;)
05603                   {
05604                     <a class="code" href="cpplib_c.html#a114">cppSkipHspace</a> (pfile);
05605                     c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05606                     is_macro_call = c == <font class="charliteral">'('</font>;
05607                     <font class="keywordflow">if</font> (c != <font class="charliteral">'\n'</font>)
05608                       <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05609                     <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
05610                   }
05611 
05612                 <font class="keywordflow">if</font> (!is_macro_call)
05613                   {
05614                     parseGotoMark (&amp;macro_mark, pfile);
05615                   }
05616 
05617                 parseClearMark (&amp;macro_mark);
05618 
05619                 <font class="keywordflow">if</font> (!is_macro_call)
05620                   {
05621                     <font class="keywordflow">return</font> CPP_NAME;
05622                   }
05623               }
05624             <font class="comment">/* This is now known to be a macro call.  */</font>
05625 
05626             <font class="comment">/* it might not actually be a macro.  */</font>
05627             <font class="keywordflow">if</font> (hp-&gt;type != T_MACRO)
05628               {
05629                 size_t xbuf_len;
05630                 <font class="keywordtype">char</font> *xbuf;
05631 
05632                 cppReader_setWritten (pfile, before_name_written);
05633                 special_symbol (hp, pfile);
05634                 xbuf_len = cppReader_getWritten (pfile) - before_name_written;
05635                 xbuf = (<font class="keywordtype">char</font> *) dmalloc (xbuf_len + 1);
05636                 cppReader_setWritten (pfile, before_name_written);
05637                 memcpy (xbuf, cppReader_getPWritten (pfile), xbuf_len + 1);
05638                 push_macro_expansion (pfile, xbuf, xbuf_len, hp);
05639               }
05640             <font class="keywordflow">else</font>
05641               {
05642                 <font class="comment">/* Expand the macro, reading arguments as needed,</font>
05643 <font class="comment">                   and push the expansion on the input stack.  */</font>
05644                                 macroexpand (pfile, hp);
05645                 cppReader_setWritten (pfile, before_name_written);
05646               }
05647 
05648             <font class="comment">/* An extra "@ " is added to the end of a macro expansion</font>
05649 <font class="comment">               to prevent accidental token pasting.  We prefer to avoid</font>
05650 <font class="comment">               unneeded extra spaces (for the sake of cpp-using tools like</font>
05651 <font class="comment">               imake).  Here we remove the space if it is safe to do so.  */</font>
05652 
05653             llassert (pfile-&gt;buffer-&gt;rlimit != NULL);
05654 
05655             <font class="keywordflow">if</font> (pfile-&gt;buffer-&gt;rlimit - pfile-&gt;buffer-&gt;cur &gt;= 3
05656                 &amp;&amp; pfile-&gt;buffer-&gt;rlimit[-2] == <font class="charliteral">'@'</font>
05657                 &amp;&amp; pfile-&gt;buffer-&gt;rlimit[-1] == <font class="charliteral">' '</font>)
05658               {
05659                 <font class="keywordtype">int</font> c1 = pfile-&gt;buffer-&gt;rlimit[-3];
05660                 <font class="keywordtype">int</font> cl2 = <a class="code" href="cpplib_c.html#a148">cppBufPeek</a> (cppBuffer_prevBuffer (CPPBUFFER (pfile)));
05661 
05662                 <font class="keywordflow">if</font> (cl2 == EOF || !unsafe_chars ((<font class="keywordtype">char</font>) c1, (<font class="keywordtype">char</font>) cl2))
05663                   pfile-&gt;buffer-&gt;rlimit -= 2;
05664               }
05665           }
05666           <font class="keywordflow">goto</font> get_next;
05667 
05668         <font class="keywordflow">case</font> <font class="charliteral">' '</font>:  <font class="keywordflow">case</font> <font class="charliteral">'\t'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'\v'</font>:  <font class="keywordflow">case</font> <font class="charliteral">'\r'</font>:
05669           <font class="keywordflow">for</font> (;;)
05670             {
05671               <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05672               c = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05673               <font class="keywordflow">if</font> (c == EOF || !is_hor_space[c])
05674                 <font class="comment">/*@loopbreak@*/</font> <font class="keywordflow">break</font>;
05675               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 1);
05676             }
05677           <font class="keywordflow">return</font> CPP_HSPACE;
05678 
05679         <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>:
05680           c2 = <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile);
05681           <font class="keywordflow">if</font> (c2 != <font class="charliteral">'\n'</font>)
05682             <font class="keywordflow">goto</font> randomchar;
05683           <a class="code" href="struct_token.html">token</a> = CPP_HSPACE;
05684           <font class="keywordflow">goto</font> op2any;
05685 
05686         <font class="keywordflow">case</font> <font class="charliteral">'\n'</font>:
05687           <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05688           <font class="keywordflow">if</font> (pfile-&gt;only_seen_white == 0)
05689             pfile-&gt;only_seen_white = 1;
05690           pfile-&gt;lineno++;
05691           output_line_command (pfile, 1, same_file);
05692           <font class="keywordflow">return</font> CPP_VSPACE;
05693 
05694         <font class="keywordflow">case</font> <font class="charliteral">'('</font>: <a class="code" href="struct_token.html">token</a> = CPP_LPAREN;    <font class="keywordflow">goto</font> char1;
05695         <font class="keywordflow">case</font> <font class="charliteral">')'</font>: <a class="code" href="struct_token.html">token</a> = CPP_RPAREN;    <font class="keywordflow">goto</font> char1;
05696         <font class="keywordflow">case</font> <font class="charliteral">'{'</font>: <a class="code" href="struct_token.html">token</a> = CPP_LBRACE;    <font class="keywordflow">goto</font> char1;
05697         <font class="keywordflow">case</font> <font class="charliteral">'}'</font>: <a class="code" href="struct_token.html">token</a> = CPP_RBRACE;    <font class="keywordflow">goto</font> char1;
05698         <font class="keywordflow">case</font> <font class="charliteral">','</font>: <a class="code" href="struct_token.html">token</a> = CPP_COMMA;     <font class="keywordflow">goto</font> char1;
05699         <font class="keywordflow">case</font> <font class="charliteral">';'</font>: <a class="code" href="struct_token.html">token</a> = CPP_SEMICOLON; <font class="keywordflow">goto</font> char1;
05700 
05701         randomchar:
05702         <font class="keywordflow">default</font>:
05703           <a class="code" href="struct_token.html">token</a> = CPP_OTHER;
05704         char1:
05705           pfile-&gt;only_seen_white = 0;
05706           <a class="code" href="cpplib_c.html#a17">cppReader_putChar</a> (pfile, c);
05707           <font class="keywordflow">return</font> <a class="code" href="struct_token.html">token</a>;
05708         }
05709     }
05710 
05711   BADBRANCH;
05712   <font class="comment">/*@notreached@*/</font>
05713 }
05714 
05715 <font class="comment">/* Parse an identifier starting with C.  */</font>
05716 
05717 <font class="keywordtype">void</font>
05718 parse_name (cppReader *pfile, <font class="keywordtype">int</font> c)<font class="keyword"></font>
05719 <font class="keyword"></font>{
05720   <font class="keywordflow">for</font> (;;)
05721     {
05722       <font class="keywordflow">if</font> (!is_idchar[c])
05723         {
05724           <font class="keywordflow">if</font> (c == <font class="charliteral">'\\'</font> &amp;&amp; <a class="code" href="cpplib_c.html#a25">cppReader_peekC</a> (pfile) == <font class="charliteral">'\n'</font>)
05725             {
05726               <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, 2);
05727               <font class="keywordflow">continue</font>;
05728             }
05729 
05730           <a class="code" href="cpplib_c.html#a23">cppReader_forward</a> (pfile, -1);
05731           <font class="keywordflow">break</font>;
05732         }
05733 
05734       <font class="keywordflow">if</font> (c == <font class="charliteral">'$'</font> &amp;&amp; cppReader_isPedantic (pfile))
05735         {
05736           <a class="code" href="cpperror_c.html#a12">cppReader_pedwarnLit</a> (pfile,
05737                           cstring_makeLiteralTemp (<font class="stringliteral">"`$' in identifier"</font>));
05738         }
05739 
05740       cppReader_reserve(pfile, 2); <font class="comment">/* One more for final NUL.  */</font>
05741       <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
05742       c = <a class="code" href="cpplib_c.html#a24">cppReader_getC</a> (pfile);
05743 
05744       <font class="keywordflow">if</font> (c == EOF)
05745         <font class="keywordflow">break</font>;
05746     }
05747 
05748   <a class="code" href="cpplib_c.html#a18">cppReader_nullTerminateQ</a> (pfile);
05749 }
05750 
05751 <font class="comment">/* The file_name_map structure holds a mapping of file names for a</font>
05752 <font class="comment">   particular directory.  This mapping is read from the file named</font>
05753 <font class="comment">   FILE_NAME_MAP_FILE in that directory.  Such a file can be used to</font>
05754 <font class="comment">   map filenames on a file system with severe filename restrictions,</font>
05755 <font class="comment">   such as DOS.  The format of the file name map file is just a series</font>
05756 <font class="comment">   of lines with two tokens on each line.  The first token is the name</font>
05757 <font class="comment">   to map, and the second token is the actual name to use.  */</font>
05758 
<a name="l05759"></a><a class="code" href="struct_file_name_map.html">05759</a> <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a>
05760 {
<a name="l05761"></a><a class="code" href="struct_file_name_map.html#m0">05761</a>   <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *map_next;
<a name="l05762"></a><a class="code" href="struct_file_name_map.html#m1">05762</a>   cstring map_from;
<a name="l05763"></a><a class="code" href="struct_file_name_map.html#m2">05763</a>   cstring map_to;
05764 };
05765 
05766 <font class="comment">/*@constant observer char *FILE_NAME_MAP_FILE*/</font>
<a name="l05767"></a><a class="code" href="cpplib_c.html#a32">05767</a> <font class="preprocessor">#define FILE_NAME_MAP_FILE "header.gcc"</font>
05768 <font class="preprocessor"></font>
05769 <font class="comment">/* Read a space delimited string of unlimited length from a stdio</font>
05770 <font class="comment">   file.  */</font>
05771 
05772 <font class="keyword">static</font> cstring read_filename_string (<font class="keywordtype">int</font> ch, FILE *f)<font class="keyword"></font>
05773 <font class="keyword"></font>{
05774   <font class="keywordtype">char</font> *alloc, *set;
05775   size_t len;
05776 
05777   len = 20;
05778   set = alloc = dmalloc (len + 1);
05779 
05780   <font class="keywordflow">if</font> (!is_space[ch])
05781     {
05782       *set++ = ch;
05783       <font class="keywordflow">while</font> ((ch = getc (f)) != EOF &amp;&amp; ! is_space[ch])
05784         {
05785           <font class="keywordflow">if</font> (set - alloc == <a class="code" href="general_c.html#a34">size_toInt</a> (len))
05786             {
05787               len *= 2;
05788               alloc = drealloc (alloc, len + 1);
05789               set = alloc + len / 2;
05790               <font class="comment">/*@-branchstate@*/</font> }
05791 
05792           *set++ = ch;
05793         } <font class="comment">/*@=branchstate@*/</font>
05794     }
05795   *set = <font class="charliteral">'\0'</font>;
05796   check (ungetc (ch, f) != EOF);
05797 
05798   <font class="keywordflow">return</font> <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (alloc);
05799 }
05800 
05801 <font class="comment">/* This structure holds a linked list of file name maps, one per directory.  */</font>
05802 
<a name="l05803"></a><a class="code" href="struct_file_name_map_list.html">05803</a> <font class="keyword">struct </font><a class="code" href="struct_file_name_map_list.html">file_name_map_list</a>
05804 {
<a name="l05805"></a><a class="code" href="struct_file_name_map_list.html#m0">05805</a>   <font class="keyword">struct </font><a class="code" href="struct_file_name_map_list.html">file_name_map_list</a> *map_list_next;
<a name="l05806"></a><a class="code" href="struct_file_name_map_list.html#m1">05806</a>   cstring map_list_name;
<a name="l05807"></a><a class="code" href="struct_file_name_map_list.html#m2">05807</a>   <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *map_list_map;
05808 };
05809 
05810 <font class="comment">/* Read the file name map file for DIRNAME.  */</font>
05811 
05812 <font class="keyword">static</font> <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *
05813 read_name_map (cppReader *pfile, cstring dirname)
05814 {
05815   <font class="keyword">struct </font><a class="code" href="struct_file_name_map_list.html">file_name_map_list</a> *map_list_ptr;
05816   cstring name;
05817   FILE *f;
05818 
05819   <font class="keywordflow">for</font> (map_list_ptr = CPPOPTIONS (pfile)-&gt;map_list;
05820        map_list_ptr != NULL;
05821        map_list_ptr = map_list_ptr-&gt;map_list_next)
05822     {
05823       <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (map_list_ptr-&gt;map_list_name, dirname))
05824         {
05825           <font class="keywordflow">return</font> map_list_ptr-&gt;map_list_map;
05826         }
05827     }
05828 
05829   map_list_ptr = (<font class="keyword">struct </font><a class="code" href="struct_file_name_map_list.html">file_name_map_list</a> *) dmalloc (sizeof (*map_list_ptr));
05830   map_list_ptr-&gt;map_list_name = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (dirname);
05831   map_list_ptr-&gt;map_list_map = NULL;
05832 
05833   name = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (dirname);
05834 
05835   <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a30">cstring_length</a> (dirname) &gt; 0)
05836     {
05837       name = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (name, CONNECTCHAR);
05838     }
05839 
05840   name = <a class="code" href="cstring_c.html#a39">cstring_concatFree1</a> (name, cstring_makeLiteralTemp (FILE_NAME_MAP_FILE));
05841 
05842   f = fopen (cstring_toCharsSafe (name), <font class="stringliteral">"r"</font>);
05843   <a class="code" href="cstring_c.html#a27">cstring_free</a> (name);
05844 
05845   <font class="keywordflow">if</font> (f == NULL)
05846     {
05847       map_list_ptr-&gt;map_list_map = NULL;
05848     }
05849   <font class="keywordflow">else</font>
05850     {
05851       <font class="keywordtype">int</font> ch;
05852 
05853       <font class="keywordflow">while</font> ((ch = getc (f)) != EOF)
05854         {
05855           cstring from, to;
05856           <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *ptr;
05857 
05858           <font class="keywordflow">if</font> (is_space[ch])
05859             {
05860               <font class="keywordflow">continue</font>;
05861             }
05862 
05863           from = read_filename_string (ch, f);
05864           <font class="keywordflow">while</font> ((ch = getc (f)) != EOF &amp;&amp; is_hor_space[ch])
05865             {
05866               ;
05867             }
05868 
05869           to = read_filename_string (ch, f);
05870 
05871           ptr = (<font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *) dmalloc (sizeof (*ptr));
05872           ptr-&gt;map_from = from;
05873 
05874           <font class="comment">/* Make the real filename absolute.  */</font>
05875           <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a30">cstring_length</a> (to) &gt; 1 
05876               &amp;&amp; <a class="code" href="osd_c.html#a19">osd_isConnectChar</a> (cstring_firstChar (to)))
05877             {
05878               ptr-&gt;map_to = to;
05879             }
05880           <font class="keywordflow">else</font>
05881             {
05882               ptr-&gt;map_to = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (dirname);
05883               ptr-&gt;map_to = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (ptr-&gt;map_to, CONNECTCHAR);
05884               ptr-&gt;map_to = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (ptr-&gt;map_to, to);
05885             }
05886 
05887           ptr-&gt;map_next = map_list_ptr-&gt;map_list_map;
05888           map_list_ptr-&gt;map_list_map = ptr;
05889 
05890           <font class="keywordflow">while</font> ((ch = getc (f)) != <font class="charliteral">'\n'</font>)
05891             {
05892               <font class="keywordflow">if</font> (ch == EOF)
05893                 {
05894                   <font class="comment">/*@innerbreak@*/</font> <font class="keywordflow">break</font>;
05895                 }
05896             }
05897         }
05898 
05899       assertSet (map_list_ptr-&gt;map_list_map);
05900       check (fclose (f) == 0);
05901     }
05902 
05903   map_list_ptr-&gt;map_list_next = pfile-&gt;opts-&gt;map_list;
05904   pfile-&gt;opts-&gt;map_list = map_list_ptr;
05905 
05906   <font class="keywordflow">return</font> map_list_ptr-&gt;map_list_map;
05907 }
05908 
05909 <font class="comment">/* Try to open include file FILENAME.  SEARCHPTR is the directory</font>
05910 <font class="comment">   being tried from the include file search path.  This function maps</font>
05911 <font class="comment">   filenames on file systems based on information read by</font>
05912 <font class="comment">   read_name_map.  */</font>
05913 
05914 <font class="keyword">static</font> <font class="keywordtype">int</font>
05915 open_include_file (cppReader *pfile,
05916                    cstring fname,
05917                    <font class="keyword">struct</font> file_name_list *searchptr)<font class="keyword"></font>
05918 <font class="keyword"></font>{
05919   <font class="keywordtype">char</font> *filename = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (fname);
05920   <font class="keyword">struct </font><a class="code" href="struct_file_name_map.html">file_name_map</a> *map;
05921   <font class="keywordtype">char</font> *from;
05922   <font class="keywordtype">char</font> *p, *dir;
05923 
05924   <a class="code" href="cstring_c.html#a26">cstring_markOwned</a> (fname);
05925 
05926   cpp_setLocation (pfile);
05927 
05928   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NEVERINCLUDE))
05929     {
05930       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a44">isHeaderFile</a> (fname))
05931         {
05932           <font class="keywordflow">return</font> SKIP_INCLUDE;
05933         }
05934     }
05935 
05936   <font class="keywordflow">if</font> ((searchptr != NULL) &amp;&amp; ! searchptr-&gt;got_name_map)
05937     {
05938       searchptr-&gt;name_map = read_name_map (pfile,
05939                                            !cstring_isEmpty (searchptr-&gt;fname)
05940                                            ? searchptr-&gt;fname :
05941                                            cstring_makeLiteralTemp (<font class="stringliteral">"."</font>));
05942       searchptr-&gt;got_name_map = 1;
05943     }
05944 
05945   <font class="comment">/* First check the mapping for the directory we are using.  */</font>
05946 
05947   <font class="keywordflow">if</font> ((searchptr != NULL)
05948       &amp;&amp; (searchptr-&gt;name_map != NULL))
05949     {
05950       from = filename;
05951 
05952       <font class="keywordflow">if</font> (!cstring_isEmpty (searchptr-&gt;fname))
05953         {
05954           from += <a class="code" href="cstring_c.html#a30">cstring_length</a> (searchptr-&gt;fname) + 1;
05955         }
05956 
05957       <font class="keywordflow">for</font> (map = searchptr-&gt;name_map;
05958            map != NULL;
05959            map = map-&gt;map_next)
05960         {
05961           <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (map-&gt;map_from, cstring_fromChars (from)))
05962             {
05963               <font class="comment">/*</font>
05964 <font class="comment">              ** Found a match.  Check if the file should be skipped</font>
05965 <font class="comment">              */</font>
05966               
05967               <font class="keywordflow">if</font> (cpp_skipIncludeFile (map-&gt;map_to))
05968                 {
05969                   <font class="keywordflow">return</font> SKIP_INCLUDE;
05970                 }
05971               <font class="keywordflow">else</font>
05972                 {
05973                   <font class="keywordflow">return</font> cpp_openIncludeFile (cstring_toCharsSafe (map-&gt;map_to));
05974                 }
05975             }
05976         }
05977     }
05978 
05979   <font class="comment">/*</font>
05980 <font class="comment">  ** Try to find a mapping file for the particular directory we are</font>
05981 <font class="comment">  ** looking in.  Thus #include &lt;sys/types.h&gt; will look up sys/types.h</font>
05982 <font class="comment">  ** in /usr/include/header.gcc and look up types.h in</font>
05983 <font class="comment">  ** /usr/include/sys/header.gcc.</font>
05984 <font class="comment">  */</font>
05985 
05986   p = strrchr (filename, CONNECTCHAR);
05987 
05988   <font class="keywordflow">if</font> (p == NULL)
05989     {
05990       p = filename;
05991     }
05992 
05993   <font class="keywordflow">if</font> ((searchptr != NULL)
05994       &amp;&amp; (cstring_isDefined (searchptr-&gt;fname))
05995       &amp;&amp; (<a class="code" href="cstring_c.html#a30">cstring_length</a> (searchptr-&gt;fname) == p - filename)
05996       &amp;&amp; !strncmp (cstring_toCharsSafe (searchptr-&gt;fname),
05997                    filename,
05998                    <a class="code" href="general_c.html#a33">size_fromInt</a> (p - filename)))
05999     {
06000       <font class="comment">/* filename is in SEARCHPTR, which we've already checked.  */</font>
06001 
06002       <font class="keywordflow">if</font> (cpp_skipIncludeFile (cstring_fromChars (filename)))
06003         {
06004           <font class="keywordflow">return</font> SKIP_INCLUDE;
06005         }
06006       <font class="keywordflow">else</font>
06007         {
06008           <font class="keywordflow">return</font> cpp_openIncludeFile (filename);
06009         }
06010     }
06011 
06012   <font class="keywordflow">if</font> (p == filename)
06013     {
06014       dir = <a class="code" href="general_c.html#a27">mstring_copy</a> (<font class="stringliteral">"."</font>);
06015       from = filename;
06016     }
06017   <font class="keywordflow">else</font>
06018     {
06019       dir = (<font class="keywordtype">char</font> *) dmalloc (size_fromInt (p - filename + 1));
06020       memcpy (dir, filename, size_fromInt (p - filename));
06021       dir[p - filename] = <font class="charliteral">'\0'</font>;
06022       from = p + 1;
06023     }
06024 
06025   <font class="keywordflow">for</font> (map = read_name_map (pfile, cstring_fromChars (dir));
06026        map != NULL;
06027        map = map-&gt;map_next)
06028     {
06029       <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (map-&gt;map_from, cstring_fromChars (from)))
06030         {
06031           <a class="code" href="general_c.html#a0">sfree</a> (dir);
06032 
06033           <font class="keywordflow">if</font> (cpp_skipIncludeFile (map-&gt;map_to))
06034             {
06035               <font class="keywordflow">return</font> SKIP_INCLUDE;
06036             }
06037           <font class="keywordflow">else</font>
06038             {
06039               <font class="keywordflow">return</font> cpp_openIncludeFile (cstring_toCharsSafe (map-&gt;map_to));
06040             }
06041         }
06042     }
06043 
06044   <a class="code" href="general_c.html#a0">sfree</a> (dir);
06045 
06046   <font class="keywordflow">if</font> (cpp_skipIncludeFile (cstring_fromChars (filename)))
06047     {
06048       <font class="keywordflow">return</font> SKIP_INCLUDE;
06049     }
06050   <font class="keywordflow">else</font>
06051     {
06052       <font class="keywordflow">return</font> cpp_openIncludeFile (filename);
06053     }
06054 }
06055 
06056 <font class="comment">/* Process the contents of include file FNAME, already open on descriptor F,</font>
06057 <font class="comment">   with output to OP.</font>
06058 <font class="comment">   SYSTEM_HEADER_P is 1 if this file resides in any one of the known</font>
06059 <font class="comment">   "system" include directories (as decided by the `is_system_include'</font>
06060 <font class="comment">   function above).</font>
06061 <font class="comment">   DIRPTR is the link in the dir path through which this file was found,</font>
06062 <font class="comment">   or 0 if the file name was absolute or via the current directory.</font>
06063 <font class="comment">   Return 1 on success, 0 on failure.</font>
06064 <font class="comment"></font>
06065 <font class="comment">   The caller is responsible for the cppReader_pushBuffer.  */</font>
06066 
06067 <font class="keyword">static</font> <font class="keywordtype">int</font>
06068 finclude (cppReader *pfile, <font class="keywordtype">int</font> f,
06069           cstring fname,
06070           <font class="keywordtype">bool</font> system_header_p,
06071           <font class="comment">/*@dependent@*/</font> <font class="keyword">struct</font> file_name_list *dirptr)<font class="keyword"></font>
06072 <font class="keyword"></font>{
06073   mode_t st_mode;
06074   size_t st_size;
06075   <font class="keywordtype">long</font> i;
06076   <font class="keywordtype">int</font> length = 0;
06077   cppBuffer *fp;                        <font class="comment">/* For input stack frame */</font>
06078 
06079   <font class="keywordflow">if</font> (file_size_and_mode (f, &amp;st_mode, &amp;st_size) &lt; 0)
06080     {
06081       <a class="code" href="cpperror_c.html#a16">cppReader_perrorWithName</a> (pfile, fname);
06082       check (close (f) == 0);
06083       (<font class="keywordtype">void</font>) <a class="code" href="cpplib_c.html#a122">cppReader_popBuffer</a> (pfile);
06084       <font class="comment">/*@-mustfree@*/</font>
06085       <font class="keywordflow">return</font> 0;
06086       <font class="comment">/*@=mustfree@*/</font>
06087     }
06088 
06089   fp = cppReader_getBuffer (pfile);
06090 
06091   <font class="comment">/*@-temptrans@*/</font> <font class="comment">/* fname shouldn't really be temp */</font>
06092   fp-&gt;nominal_fname = fp-&gt;fname = fname;
06093   <font class="comment">/*@=temptrans@*/</font>
06094 
06095   fp-&gt;dir = dirptr;
06096   fp-&gt;system_header_p = system_header_p;
06097   fp-&gt;lineno = 1;
06098   fp-&gt;colno = 1;
06099   fp-&gt;cleanup = cppReader_fileCleanup;
06100 
06101   <font class="keywordflow">if</font> (S_ISREG (st_mode))
06102     {
06103       <a class="code" href="general_c.html#a0">sfree</a> (fp-&gt;buf);
06104       fp-&gt;buf = (<font class="keywordtype">char</font> *) dmalloc (st_size + 2);
06105       fp-&gt;alimit = fp-&gt;buf + st_size + 2;
06106       fp-&gt;cur = fp-&gt;buf;
06107 
06108       <font class="comment">/* Read the file contents, knowing that st_size is an upper bound</font>
06109 <font class="comment">         on the number of bytes we can read.  */</font>
06110       length = safe_read (f, fp-&gt;buf, size_toInt (st_size));
06111       fp-&gt;rlimit = fp-&gt;buf + length;
06112       <font class="keywordflow">if</font> (length &lt; 0) <font class="keywordflow">goto</font> nope;
06113     }
06114   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (S_ISDIR (st_mode))
06115     {
06116       <a class="code" href="cpperror_c.html#a9">cppReader_error</a> (pfile,
06117                        message (<font class="stringliteral">"directory `%s' specified in #include"</font>, fname));
06118       check (close (f) == 0);
06119       <font class="keywordflow">return</font> 0;
06120     }
06121   <font class="keywordflow">else</font>
06122     {
06123       <font class="comment">/*</font>
06124 <font class="comment">      ** Cannot count its file size before reading.</font>
06125 <font class="comment">      ** First read the entire file into heap and</font>
06126 <font class="comment">      ** copy them into buffer on stack.</font>
06127 <font class="comment">      */</font>
06128 
06129       size_t bsize = 2000;
06130 
06131       st_size = 0;
06132 
06133       <a class="code" href="general_c.html#a0">sfree</a> (fp-&gt;buf);
06134       fp-&gt;buf = (<font class="keywordtype">char</font> *) dmalloc (bsize + 2);
06135 
06136       <font class="keywordflow">for</font> (;;) {
06137         i = safe_read (f, fp-&gt;buf + st_size, size_toInt (bsize - st_size));
06138 
06139         <font class="keywordflow">if</font> (i &lt; 0)
06140           <font class="keywordflow">goto</font> nope;      <font class="comment">/* error! */</font>
06141         st_size += i;
06142 
06143         <font class="keywordflow">if</font> (st_size != bsize)
06144           {
06145             <font class="keywordflow">break</font>;      <font class="comment">/* End of file */</font>
06146           }
06147 
06148         bsize *= 2;
06149         fp-&gt;buf = (<font class="keywordtype">char</font> *) drealloc (fp-&gt;buf, bsize + 2);
06150       }
06151 
06152       fp-&gt;cur = fp-&gt;buf;
06153       length = <a class="code" href="general_c.html#a34">size_toInt</a> (st_size);
06154     }
06155 
06156   <font class="keywordflow">if</font> ((length &gt; 0 &amp;&amp; fp-&gt;buf[length - 1] != <font class="charliteral">'\n'</font>)
06157       <font class="comment">/* Backslash-newline at end is not good enough.  */</font>
06158       || (length &gt; 1 &amp;&amp; fp-&gt;buf[length - 2] == <font class="charliteral">'\\'</font>)) {
06159     fp-&gt;buf[length++] = <font class="charliteral">'\n'</font>;
06160   }
06161 
06162   fp-&gt;buf[length] = <font class="charliteral">'\0'</font>;
06163   fp-&gt;rlimit = fp-&gt;buf + length;
06164 
06165 
06166   <font class="comment">/* Close descriptor now, so nesting does not use lots of descriptors.  */</font>
06167   check (close (f) == 0);
06168 
06169   <font class="comment">/* Must do this before calling trigraph_pcp, so that the correct file name</font>
06170 <font class="comment">     will be printed in warning messages.  */</font>
06171 
06172   pfile-&gt;input_stack_listing_current = 0;
06173   <font class="keywordflow">return</font> 1;
06174 
06175  nope:
06176 
06177   <a class="code" href="cpperror_c.html#a16">cppReader_perrorWithName</a> (pfile, fname);
06178   check (close (f) == 0);
06179   <a class="code" href="general_c.html#a0">sfree</a> (fp-&gt;buf);
06180   <font class="keywordflow">return</font> 1;
06181 }
06182 
06183 <font class="keywordtype">void</font>
<a name="l06184"></a><a class="code" href="cpplib_c.html#a142">06184</a> <a class="code" href="cpplib_c.html#a142">cppReader_init</a> (cppReader *pfile)<font class="keyword"></font>
06185 <font class="keyword"></font>{
06186   memset ((<font class="keywordtype">char</font> *) pfile, 0, <font class="keyword">sizeof</font> (*pfile));
06187 
06188   pfile-&gt;get_token = cppGetToken;
06189   pfile-&gt;token_buffer_size = 200;
06190   pfile-&gt;token_buffer = (<font class="keywordtype">char</font> *) dmalloc (pfile-&gt;token_buffer_size);
06191   pfile-&gt;all_include_files = NULL;
06192 
06193   assertSet (pfile);
06194 
06195   cppReader_setWritten (pfile, 0);
06196 
06197   pfile-&gt;system_include_depth = 0;
06198   pfile-&gt;max_include_len = 0;
06199   pfile-&gt;timebuf = NULL;
06200   pfile-&gt;only_seen_white = 1;
06201 
06202   pfile-&gt;buffer = cppReader_nullBuffer (pfile);
06203 }
06204 
06205 <font class="keywordtype">void</font>
<a name="l06206"></a><a class="code" href="cpplib_c.html#a143">06206</a> <a class="code" href="cpplib_c.html#a143">cppReader_finish</a> (<font class="comment">/*@unused@*/</font> cppReader *pfile)<font class="keyword"></font>
06207 <font class="keyword"></font>{
06208   ;
06209 }
06210 
06211 <font class="comment">/* Free resources used by PFILE.</font>
06212 <font class="comment">   This is the cppReader 'finalizer' or 'destructor' (in C++ terminology).  */</font>
06213 
06214 <font class="keywordtype">void</font>
<a name="l06215"></a><a class="code" href="cpplib_c.html#a144">06215</a> <a class="code" href="cpplib_c.html#a144">cppCleanup</a> (cppReader *pfile)<font class="keyword"></font>
06216 <font class="keyword"></font>{
06217   <font class="keywordflow">while</font> (CPPBUFFER (pfile) != cppReader_nullBuffer (pfile))
06218     {
06219       (<font class="keywordtype">void</font>) <a class="code" href="cpplib_c.html#a122">cppReader_popBuffer</a> (pfile);
06220     }
06221 
06222   <font class="keywordflow">if</font> (pfile-&gt;token_buffer != NULL)
06223     {
06224       <a class="code" href="general_c.html#a0">sfree</a> (pfile-&gt;token_buffer);
06225       pfile-&gt;token_buffer = NULL;
06226     }
06227 
06228   <font class="keywordflow">while</font> (pfile-&gt;if_stack != NULL)
06229     {
06230       cppIfStackFrame *temp = pfile-&gt;if_stack;
06231       pfile-&gt;if_stack = temp-&gt;next;
06232       <a class="code" href="general_c.html#a0">sfree</a> (temp);
06233     }
06234 
06235   <font class="keywordflow">while</font> (pfile-&gt;all_include_files != NULL)
06236     {
06237       <font class="keyword">struct </font>file_name_list *temp = pfile-&gt;all_include_files;
06238       pfile-&gt;all_include_files = temp-&gt;next;
06239       <font class="comment">/*@-dependenttrans@*/</font>
06240       <a class="code" href="cstring_c.html#a27">cstring_free</a> (temp-&gt;fname);
06241       <font class="comment">/*@=dependenttrans@*/</font>
06242       <a class="code" href="general_c.html#a0">sfree</a> (temp);
06243     }
06244 
06245   <a class="code" href="cpphash_c.html#a15">cppReader_hashCleanup</a> ();
06246 }
06247 
06248 <font class="comment">/*</font>
06249 <font class="comment">** Get the file-mode and data size of the file open on FD</font>
06250 <font class="comment">** and store them in *MODE_POINTER and *SIZE_POINTER.</font>
06251 <font class="comment">*/</font>
06252 
06253 <font class="keyword">static</font> <font class="keywordtype">int</font>
06254 file_size_and_mode (<font class="keywordtype">int</font> fd, mode_t *mode_pointer, size_t *size_pointer)<font class="keyword"></font>
06255 <font class="keyword"></font>{
06256   <font class="keyword">struct </font>stat sbuf;
06257 
06258   <font class="keywordflow">if</font> (fstat (fd, &amp;sbuf) &lt; 0) {
06259     <font class="keywordflow">return</font> (-1);
06260   }
06261 
06262   <font class="keywordflow">if</font> (mode_pointer != NULL)
06263     {
06264       *mode_pointer = sbuf.st_mode;
06265     }
06266 
06267   <font class="keywordflow">if</font> (size_pointer != NULL)
06268     {
06269       *size_pointer = (size_t) sbuf.st_size;
06270     }
06271 
06272   <font class="keywordflow">return</font> 0;
06273 }
06274 
06275 <font class="comment">/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,</font>
06276 <font class="comment">   retrying if necessary.  Return a negative value if an error occurs,</font>
06277 <font class="comment">   otherwise return the actual number of bytes read,</font>
06278 <font class="comment">   which must be LEN unless end-of-file was reached.  */</font>
06279 
06280 <font class="keyword">static</font> <font class="keywordtype">int</font> safe_read (<font class="keywordtype">int</font> desc, <font class="keywordtype">char</font> *ptr, <font class="keywordtype">int</font> len)<font class="keyword"></font>
06281 <font class="keyword"></font>{
06282   <font class="keywordtype">int</font> left = len;
06283 
06284   <font class="keywordflow">while</font> (left &gt; 0)
06285     {
06286 <font class="preprocessor"># if defined (WIN32) || defined (OS2) &amp;&amp; defined (__IBMC__)</font>
06287 <font class="preprocessor"></font>          <font class="comment">/*@-compdef@*/</font> <font class="comment">/* ptr is an out parameter */</font>
06288       <font class="keywordtype">int</font> nchars = _read (desc, ptr, (<font class="keywordtype">unsigned</font>) left);
06289           <font class="comment">/*@=compdef@*/</font>
06290 <font class="preprocessor"># else</font>
06291 <font class="preprocessor"></font>      ssize_t nchars = <a class="code" href="lex_yy_c.html#a109">read</a> (desc, ptr, size_fromInt (left));
06292 <font class="preprocessor"># endif</font>
06293 <font class="preprocessor"></font>
06294       <font class="keywordflow">if</font> (nchars &lt; 0)
06295         {
06296 <font class="preprocessor">#ifdef EINTR</font>
06297 <font class="preprocessor"></font>          <font class="keywordflow">if</font> (errno == EINTR)
06298             <font class="keywordflow">continue</font>;
06299 <font class="preprocessor">#endif</font>
06300 <font class="preprocessor"></font>          <font class="keywordflow">return</font> (<font class="keywordtype">int</font>) nchars;
06301         }
06302 
06303       <font class="keywordflow">if</font> (nchars == 0) {
06304         <font class="keywordflow">break</font>;
06305       }
06306 
06307       ptr += nchars;
06308       left -= nchars;
06309     }
06310 
06311   <font class="keywordflow">return</font> len - left;
06312 }
06313 
06314 <font class="comment">/* Initialize PMARK to remember the current position of PFILE.  */</font>
06315 
06316 <font class="keywordtype">void</font>
06317 parseSetMark (<font class="keyword">struct</font> parse_marker *pmark, cppReader *pfile)<font class="keyword"></font>
06318 <font class="keyword"></font>{
06319   cppBuffer *pbuf = cppReader_getBuffer (pfile);
06320 
06321   pmark-&gt;next = pbuf-&gt;marks;
06322   <font class="comment">/*@-temptrans@*/</font>
06323   pbuf-&gt;marks = pmark;
06324   <font class="comment">/*@=temptrans@*/</font>
06325 
06326   pmark-&gt;buf = pbuf;
06327   pmark-&gt;position = pbuf-&gt;cur - pbuf-&gt;buf;
06328 }
06329 
06330 <font class="comment">/* Cleanup PMARK - we no longer need it.  */</font>
06331 
06332 <font class="keywordtype">void</font> parseClearMark (<font class="keyword">struct</font> parse_marker *pmark)<font class="keyword"></font>
06333 <font class="keyword"></font>{
06334   <font class="keyword">struct </font>parse_marker **pp = &amp;pmark-&gt;buf-&gt;marks;
06335 
06336   <font class="keywordflow">for</font> (; ; pp = &amp;(*pp)-&gt;next)
06337     {
06338       llassert (*pp != NULL);
06339       <font class="keywordflow">if</font> (*pp == pmark) <font class="keywordflow">break</font>;
06340     }
06341 
06342   *pp = pmark-&gt;next;
06343 }
06344 
06345 <font class="comment">/* Backup the current position of PFILE to that saved in PMARK.  */</font>
06346 
06347 <font class="keywordtype">void</font>
06348 parseGotoMark (<font class="keyword">struct</font> parse_marker *pmark, cppReader *pfile)<font class="keyword"></font>
06349 <font class="keyword"></font>{
06350   cppBuffer *pbuf = cppReader_getBuffer (pfile);
06351 
06352   <font class="keywordflow">if</font> (pbuf != pmark-&gt;buf)
06353     {
06354       cpp_setLocation (pfile);
06355       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (cstring_makeLiteral (<font class="stringliteral">"Internal error parseGotoMark"</font>));
06356     }
06357 
06358   llassert (pbuf-&gt;buf != NULL);
06359   pbuf-&gt;cur = pbuf-&gt;buf + pmark-&gt;position;
06360 }
06361 
06362 <font class="comment">/* Reset PMARK to point to the current position of PFILE.  (Same</font>
06363 <font class="comment">   as parseClearMark (PMARK), parseSetMark (PMARK, PFILE) but faster.  */</font>
06364 
06365 <font class="keywordtype">void</font>
06366 parseMoveMark (<font class="keyword">struct</font> parse_marker *pmark, cppReader *pfile)<font class="keyword"></font>
06367 <font class="keyword"></font>{
06368   cppBuffer *pbuf = cppReader_getBuffer (pfile);
06369 
06370   <font class="keywordflow">if</font> (pbuf != pmark-&gt;buf)
06371     {
06372       cpp_setLocation (pfile);
06373       <a class="code" href="llerror_c.html#a48">llfatalerror</a> (cstring_makeLiteral (<font class="stringliteral">"Internal error parseMoveMark"</font>));
06374     }
06375 
06376   pmark-&gt;position = pbuf-&gt;cur - pbuf-&gt;buf;
06377 }
06378 
<a name="l06379"></a><a class="code" href="cpplib_c.html#a145">06379</a> <font class="keywordtype">void</font> <a class="code" href="cpplib_c.html#a145">cppReader_initializeReader</a> (cppReader *pfile)<font class="keyword"></font>
06380 <font class="keyword"></font>{
06381   <font class="keyword">struct </font>cppOptions *opts = CPPOPTIONS (pfile);
06382   <font class="keywordtype">char</font> *xp;
06383 
06384   <font class="comment">/* The code looks at the defaults through this pointer, rather than through</font>
06385 <font class="comment">     the constant structure above.  This pointer gets changed if an environment</font>
06386 <font class="comment">     variable specifies other defaults.  */</font>
06387 
06388   <font class="keyword">struct </font><a class="code" href="struct_default_include.html">default_include</a> *include_defaults = include_defaults_array;
06389 
06390   <font class="comment">/* Add dirs from CPATH after dirs from -I.  */</font>
06391   <font class="comment">/* There seems to be confusion about what CPATH should do,</font>
06392 <font class="comment">     so for the moment it is not documented.  */</font>
06393   <font class="comment">/* Some people say that CPATH should replace the standard include dirs,</font>
06394 <font class="comment">     but that seems pointless: it comes before them, so it overrides them</font>
06395 <font class="comment">     anyway.  */</font>
06396 
06397   xp = (<font class="keywordtype">char</font> *) getenv (<font class="stringliteral">"CPATH"</font>);
06398 
06399   <font class="keywordflow">if</font> (xp != 0 &amp;&amp; ! opts-&gt;no_standard_includes)
06400     {
06401       path_include (pfile, xp);
06402     }
06403 
06404   <font class="comment">/* Now that dollars_in_ident is known, initialize is_idchar.  */</font>
06405   initialize_char_syntax (opts);
06406 
06407   <font class="comment">/* CppReader_Install __LINE__, etc.  Must follow initialize_char_syntax</font>
06408 <font class="comment">     and option processing.  */</font>
06409 
06410   initialize_builtins (pfile);
06411 
06412   <font class="comment">/* Do standard #defines and assertions</font>
06413 <font class="comment">     that identify system and machine type.  */</font>
06414 
06415   <font class="keywordflow">if</font> (!opts-&gt;inhibit_predefs) {
06416     <font class="keywordtype">char</font> *p = (<font class="keywordtype">char</font> *) dmalloc (strlen (predefs) + 1);
06417     strcpy (p, predefs);
06418 
06419     <font class="keywordflow">while</font> (*p)
06420       {
06421         <font class="keywordtype">char</font> *q;
06422 
06423         <font class="keywordflow">while</font> (*p == <font class="charliteral">' '</font> || *p == <font class="charliteral">'\t'</font>)
06424           {
06425             p++;
06426           }
06427 
06428         <font class="comment">/* Handle -D options.  */</font>
06429         <font class="keywordflow">if</font> (p[0] == <font class="charliteral">'-'</font> &amp;&amp; p[1] == <font class="charliteral">'D'</font>)
06430           {
06431             q = &amp;p[2];
06432 
06433             <font class="keywordflow">while</font> (*p &amp;&amp; *p != <font class="charliteral">' '</font> &amp;&amp; *p != <font class="charliteral">'\t'</font>)
06434               {
06435                 p++;
06436               }
06437 
06438             <font class="keywordflow">if</font> (*p != 0)
06439               {
06440                 *p++= 0;
06441               }
06442 
06443             <font class="keywordflow">if</font> (opts-&gt;debug_output)
06444               {
06445                 output_line_command (pfile, 0, same_file);
06446               }
06447 
06448             <a class="code" href="cpplib_c.html#a109">cppReader_define</a> (pfile, q);
06449 
06450             <font class="keywordflow">while</font> (*p == <font class="charliteral">' '</font> || *p == <font class="charliteral">'\t'</font>)
06451               {
06452                 p++;
06453               }
06454           }
06455         <font class="keywordflow">else</font>
06456           {
06457             abort ();
06458           }
06459       }
06460 
06461     <a class="code" href="general_c.html#a0">sfree</a> (p);
06462   }
06463 
06464   opts-&gt;done_initializing = 1;
06465 
06466   { <font class="comment">/* Read the appropriate environment variable and if it exists</font>
06467 <font class="comment">       replace include_defaults with the listed path.  */</font>
06468     <font class="keywordtype">char</font> *epath = 0;
06469 <font class="preprocessor">#ifdef __CYGWIN32__</font>
06470 <font class="preprocessor"></font>  <font class="keywordtype">char</font> *win32epath;
06471   <font class="keywordtype">int</font> win32_buf_size = 0; <font class="comment">/* memory we need to allocate */</font>
06472 <font class="preprocessor">#endif</font>
06473 <font class="preprocessor"></font>
06474   <font class="keywordflow">if</font> (opts-&gt;cplusplus)
06475     {
06476       epath = getenv (<font class="stringliteral">"CPLUS_INCLUDE_PATH"</font>);
06477     }
06478   <font class="keywordflow">else</font>
06479     {
06480       epath = getenv (<font class="stringliteral">"C_INCLUDE_PATH"</font>);
06481     }
06482 
06483   <font class="comment">/*</font>
06484 <font class="comment">  ** If the environment var for this language is set,</font>
06485 <font class="comment">  ** add to the default list of include directories.</font>
06486 <font class="comment">  */</font>
06487 
06488     <font class="keywordflow">if</font> (epath != NULL) {
06489       <font class="keywordtype">char</font> *nstore = (<font class="keywordtype">char</font> *) dmalloc (strlen (epath) + 2);
06490       <font class="keywordtype">int</font> num_dirs;
06491       <font class="keywordtype">char</font> *startp, *endp;
06492 
06493 <font class="preprocessor">#ifdef __CYGWIN32__</font>
06494 <font class="preprocessor"></font>      <font class="comment">/* if we have a posix path list, convert to win32 path list */</font>
06495       <font class="keywordflow">if</font> (cygwin32_posix_path_list_p (epath))
06496         {
06497           win32_buf_size = cygwin32_posix_to_win32_path_list_buf_size (epath);
06498           win32epath = (<font class="keywordtype">char</font> *) dmalloc <font class="comment">/*@i4@*/</font> (win32_buf_size);
06499           cygwin32_posix_to_win32_path_list (epath, win32epath);
06500           epath = win32epath;
06501         }
06502 <font class="preprocessor">#endif</font>
06503 <font class="preprocessor"></font>      <font class="keywordflow">for</font> (num_dirs = 1, startp = epath; *startp; startp++)
06504         {
06505           <font class="keywordflow">if</font> (*startp == PATH_SEPARATOR)
06506             num_dirs++;
06507         }
06508 
06509       <font class="comment">/*@-sizeoftype@*/</font>
06510       include_defaults
06511         = (<font class="keyword">struct </font><a class="code" href="struct_default_include.html">default_include</a> *) dmalloc ((num_dirs
06512                                                * sizeof (struct <a class="code" href="struct_default_include.html">default_include</a>))
06513                                               + sizeof (include_defaults_array));
06514       <font class="comment">/*@=sizeoftype@*/</font>
06515 
06516       startp = endp = epath;
06517       num_dirs = 0;
06518       <font class="keywordflow">while</font> (1) {
06519         <font class="comment">/* Handle cases like c:/usr/lib:d:/gcc/lib */</font>
06520         <font class="keywordflow">if</font> ((*endp == PATH_SEPARATOR) || *endp == 0)
06521           {
06522             strncpy (nstore, startp, size_fromInt (endp - startp));
06523             <font class="keywordflow">if</font> (endp == startp)
06524               {
06525                 strcpy (nstore, <font class="stringliteral">"."</font>);
06526               }
06527             <font class="keywordflow">else</font>
06528               {
06529                 nstore[endp-startp] = <font class="charliteral">'\0'</font>;
06530               }
06531 
06532             include_defaults[num_dirs].fname = cstring_fromCharsNew (nstore);
06533             include_defaults[num_dirs].cplusplus = opts-&gt;cplusplus;
06534             include_defaults[num_dirs].cxx_aware = 1;
06535             num_dirs++;
06536 
06537             <font class="keywordflow">if</font> (*endp == <font class="charliteral">'\0'</font>)
06538               {
06539                 <font class="keywordflow">break</font>;
06540               }
06541             endp = startp = endp + 1;
06542           }
06543         <font class="keywordflow">else</font>
06544           {
06545             endp++;
06546           }
06547       }
06548       <font class="comment">/* Put the usual defaults back in at the end.  */</font>
06549       memcpy ((<font class="keywordtype">char</font> *) &amp;include_defaults[num_dirs],
06550               (<font class="keywordtype">char</font> *) include_defaults_array,
06551               <font class="keyword">sizeof</font> (include_defaults_array));
06552 
06553       <a class="code" href="general_c.html#a0">sfree</a> (nstore);
06554       <font class="comment">/*@-branchstate@*/</font> } <font class="comment">/*@=branchstate@*/</font>
06555   }
06556 
06557   cppReader_appendIncludeChain (pfile, opts-&gt;before_system,
06558                                 opts-&gt;last_before_system);
06559   opts-&gt;first_system_include = opts-&gt;before_system;
06560 
06561   <font class="comment">/* Unless -fnostdinc,</font>
06562 <font class="comment">     tack on the standard include file dirs to the specified list */</font>
06563   <font class="keywordflow">if</font> (!opts-&gt;no_standard_includes) {
06564     <font class="keyword">struct </font><a class="code" href="struct_default_include.html">default_include</a> *p = include_defaults;
06565     <font class="keywordtype">char</font> *specd_prefix = opts-&gt;include_prefix;
06566     <font class="keywordtype">char</font> *default_prefix = <a class="code" href="general_c.html#a27">mstring_copy</a> (GCC_INCLUDE_DIR);
06567     <font class="keywordtype">int</font> default_len = 0;
06568 
06569         <font class="comment">/* Remove the `include' from /usr/local/lib/gcc.../include.  */</font>
06570         <font class="keywordflow">if</font> (default_prefix != NULL) {
06571     <font class="keywordflow">if</font> (!strcmp (default_prefix + strlen (default_prefix) - 8, <font class="stringliteral">"/include"</font>)) {
06572       default_len = strlen (default_prefix) - 7;
06573       default_prefix[default_len] = 0;
06574     }
06575         }
06576 
06577     <font class="comment">/* Search "translated" versions of GNU directories.</font>
06578 <font class="comment">       These have /usr/local/lib/gcc... replaced by specd_prefix.  */</font>
06579     <font class="keywordflow">if</font> (specd_prefix != 0 &amp;&amp; default_len != 0)
06580       <font class="keywordflow">for</font> (p = include_defaults; p-&gt;fname != NULL; p++) {
06581         <font class="comment">/* Some standard dirs are only for C++.  */</font>
06582         <font class="keywordflow">if</font> (!p-&gt;cplusplus
06583             || (opts-&gt;cplusplus &amp;&amp; !opts-&gt;no_standard_cplusplus_includes)) {
06584           <font class="comment">/* Does this dir start with the prefix?  */</font>
06585           <font class="keywordflow">if</font> (!strncmp (cstring_toCharsSafe (p-&gt;fname), default_prefix,
06586                         <a class="code" href="general_c.html#a33">size_fromInt</a> (default_len)))
06587             {
06588               <font class="comment">/* Yes; change prefix and add to search list.  */</font>
06589               <font class="keyword">struct </font>file_name_list *nlist
06590                 = (struct file_name_list *) dmalloc (sizeof (*nlist));
06591               size_t this_len = strlen (specd_prefix) + <a class="code" href="cstring_c.html#a30">cstring_length</a> (p-&gt;fname) - default_len;
06592               <font class="keywordtype">char</font> *str = (<font class="keywordtype">char</font> *) dmalloc (this_len + 1);
06593               strcpy (str, specd_prefix);
06594               strcat (str, cstring_toCharsSafe (p-&gt;fname) + default_len);
06595 
06596               nlist-&gt;next = NULL;
06597               nlist-&gt;fname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (str);
06598               nlist-&gt;control_macro = 0;
06599               nlist-&gt;c_system_include_path = !p-&gt;cxx_aware;
06600               nlist-&gt;got_name_map = 0;
06601 
06602               <a class="code" href="cpplib_c.html#a111">cppReader_addIncludeChain</a> (pfile, nlist);
06603               <font class="keywordflow">if</font> (opts-&gt;first_system_include == 0)
06604                 {
06605                   opts-&gt;first_system_include = nlist;
06606                 }
06607             }
06608         }
06609       }
06610 
06611     <font class="comment">/* Search ordinary names for GNU include directories.  */</font>
06612 
06613     <font class="keywordflow">for</font> (p = include_defaults; p-&gt;fname != NULL; p++)
06614       {
06615         <font class="comment">/* Some standard dirs are only for C++.  */</font>
06616         <font class="keywordflow">if</font> (!p-&gt;cplusplus
06617             || (opts-&gt;cplusplus &amp;&amp; !opts-&gt;no_standard_cplusplus_includes))
06618           {
06619             <font class="keyword">struct </font>file_name_list *nlist
06620               = (struct file_name_list *) dmalloc (sizeof (*nlist));
06621             nlist-&gt;control_macro = 0;
06622             nlist-&gt;c_system_include_path = !p-&gt;cxx_aware;
06623             nlist-&gt;fname = p-&gt;fname;
06624             nlist-&gt;got_name_map = 0;
06625             nlist-&gt;next = NULL;
06626 
06627             <a class="code" href="cpplib_c.html#a111">cppReader_addIncludeChain</a> (pfile, nlist);
06628 
06629             <font class="keywordflow">if</font> (opts-&gt;first_system_include == 0)
06630               {
06631                 opts-&gt;first_system_include = nlist;
06632               }
06633           }
06634       }
06635     <a class="code" href="general_c.html#a0">sfree</a> (default_prefix);
06636   }
06637 
06638   <font class="comment">/* Tack the after_include chain at the end of the include chain.  */</font>
06639   cppReader_appendIncludeChain (pfile, opts-&gt;after_include,
06640                                 opts-&gt;last_after_include);
06641 
06642   <font class="keywordflow">if</font> (opts-&gt;first_system_include == 0)
06643     {
06644       opts-&gt;first_system_include = opts-&gt;after_include;
06645     }
06646 
06647   <font class="comment">/* With -v, print the list of dirs to search.  */</font>
06648   <font class="keywordflow">if</font> (opts-&gt;verbose) {
06649     <font class="keyword">struct </font>file_name_list *p;
06650     fprintf (stderr, <font class="stringliteral">"#include \"...\" search starts here:\n"</font>);
06651 
06652     <font class="keywordflow">for</font> (p = opts-&gt;include; p != NULL; p = p-&gt;next) {
06653       <font class="keywordflow">if</font> (p == opts-&gt;first_bracket_include)
06654         fprintf (stderr, <font class="stringliteral">"#include &lt;...&gt; search starts here:\n"</font>);
06655 
06656       fprintf (stderr, <font class="stringliteral">" %s\n"</font>, cstring_toCharsSafe (p-&gt;fname));
06657     }
06658     fprintf (stderr, <font class="stringliteral">"End of search list.\n"</font>);
06659   }
06660 }
06661 
<a name="l06662"></a><a class="code" href="cpplib_c.html#a146">06662</a> <font class="keywordtype">int</font> <a class="code" href="cpplib_c.html#a146">cppReader_startProcess</a> (cppReader *pfile, cstring fname)<font class="keyword"></font>
06663 <font class="keyword"></font>{
06664   cppBuffer *fp;
06665   <font class="keywordtype">int</font> f;
06666   <font class="keyword">struct </font>cppOptions *opts = CPPOPTIONS (pfile);
06667 
06668   fp = cppReader_pushBuffer (pfile, NULL, 0);
06669 
06670   <font class="keywordflow">if</font> (fp == NULL)
06671     {
06672       <font class="keywordflow">return</font> 0;
06673     }
06674 
06675   <font class="keywordflow">if</font> (opts-&gt;in_fname == NULL)
06676     {
06677       opts-&gt;in_fname = cstring_makeLiteralTemp (<font class="stringliteral">""</font>);
06678     }
06679 
06680   fp-&gt;fname = opts-&gt;in_fname;
06681   fp-&gt;nominal_fname = fp-&gt;fname;
06682   fp-&gt;lineno = 0;
06683 
06684   <font class="comment">/* Copy the entire contents of the main input file into</font>
06685 <font class="comment">     the stacked input buffer previously allocated for it.  */</font>
06686 
06687   <font class="keywordflow">if</font> (cstring_isEmpty (fname))
06688     {
06689       fname = cstring_makeLiteralTemp (<font class="stringliteral">""</font>);
06690       f = 0;
06691     }
06692   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((f = open (cstring_toCharsSafe (fname), O_RDONLY, 0666)) &lt; 0)
06693     {
06694       <a class="code" href="cpperror_c.html#a7">cppReader_pfatalWithName</a> (pfile, fname);
06695     }
06696   <font class="keywordflow">else</font>
06697     {
06698       ;
06699     }
06700 
06701   <font class="keywordflow">if</font> (finclude (pfile, f, fname, 0, NULL))
06702     {
06703       output_line_command (pfile, 0, same_file);
06704     }
06705 
06706   <font class="keywordflow">return</font> 1;
06707 }
06708 
06709 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@null@*/</font> cppBuffer *cppReader_getBuffer (cppReader *pfile)<font class="keyword"></font>
06710 <font class="keyword"></font>{
06711   <font class="keywordflow">return</font> pfile-&gt;buffer;
06712 }
06713 
<a name="l06714"></a><a class="code" href="cpplib_c.html#a147">06714</a> <font class="comment">/*@exposed@*/</font> cppBuffer *<a class="code" href="cpplib_c.html#a147">cppReader_getBufferSafe</a> (cppReader *pfile)<font class="keyword"></font>
06715 <font class="keyword"></font>{
06716   llassert (pfile-&gt;buffer != NULL);
06717   <font class="keywordflow">return</font> pfile-&gt;buffer;
06718 }
06719 
06720 <font class="comment">/*@exposed@*/</font> <font class="keywordtype">char</font> *cppLineBase (cppBuffer *buf)<font class="keyword"></font>
06721 <font class="keyword"></font>{
06722   llassert (buf-&gt;buf != NULL);
06723   <font class="keywordflow">return</font> (buf-&gt;buf + buf-&gt;line_base);
06724 }
06725 
<a name="l06726"></a><a class="code" href="cpplib_c.html#a148">06726</a> <font class="keywordtype">int</font> <a class="code" href="cpplib_c.html#a148">cppBufPeek</a> (cppBuffer *buf)<font class="keyword"></font>
06727 <font class="keyword"></font>{
06728   <font class="keywordflow">if</font> (buf-&gt;cur == NULL || buf-&gt;rlimit == NULL) {
06729     <font class="keywordflow">return</font> EOF;
06730   }
06731 
06732   <font class="keywordflow">if</font> (buf-&gt;cur &lt; buf-&gt;rlimit) {
06733     <font class="keywordflow">return</font> *(buf-&gt;cur);
06734   }
06735 
06736   <font class="keywordflow">return</font> EOF;
06737 }
06738 
06739 <font class="keywordtype">bool</font> cppBuffer_isMacro (cppBuffer *buf)<font class="keyword"></font>
06740 <font class="keyword"></font>{
06741   <font class="keywordflow">if</font> (buf != NULL)
06742     {
06743       <font class="keywordflow">return</font> (buf-&gt;cleanup == cppReader_macroCleanup);
06744     }
06745 
06746   <font class="keywordflow">return</font> FALSE;
06747 }
06748 
06749 <font class="comment">/*</font>
06750 <font class="comment">** Returns true if the macro should be checked, false</font>
06751 <font class="comment">** if it should be expanded normally.</font>
06752 <font class="comment">*/</font>
06753 
06754 <font class="keyword">static</font> <font class="keywordtype">bool</font> notparseable = FALSE;  <font class="comment">/* preceeded by @notparseable@ */</font>
06755 <font class="keyword">static</font> <font class="keywordtype">bool</font> notfunction = FALSE;   <font class="comment">/* preceeded by @notfunction@ */</font>
06756 <font class="keyword">static</font> <font class="keywordtype">bool</font> expectiter = FALSE;    <font class="comment">/* preceeded by @iter@ */</font>
06757 <font class="keyword">static</font> <font class="keywordtype">bool</font> expectenditer = FALSE; <font class="comment">/* second after @iter@ */</font>
06758 <font class="keyword">static</font> <font class="keywordtype">bool</font> expectfunction = FALSE;    <font class="comment">/* preceeded by @function@ */</font>
06759 <font class="keyword">static</font> <font class="keywordtype">bool</font> expectconstant = FALSE;   <font class="comment">/* preceeded by @constant@ */</font>
06760 <font class="keyword">static</font> <font class="keywordtype">bool</font> expectmacro = FALSE;   <font class="comment">/* preceeded by notfunction or notparseable */</font>
06761 
06762 <font class="keyword">static</font> <font class="keywordtype">void</font> cpp_setLocation (cppReader *pfile)<font class="keyword"></font>
06763 <font class="keyword"></font>{
06764   fileId fid;
06765   <font class="keywordtype">int</font> line;
06766 
06767   <font class="keywordflow">if</font> (pfile-&gt;buffer != NULL)
06768   {
06769   <font class="keywordflow">if</font> (cstring_isDefined (cppReader_getBuffer (pfile)-&gt;nominal_fname))
06770     {
06771       cstring fname = cppReader_getBuffer (pfile)-&gt;nominal_fname;
06772 
06773       <font class="keywordflow">if</font> (<a class="code" href="fileTable_c.html#a26">fileTable_exists</a> (context_fileTable (), fname))
06774           {
06775             fid = <a class="code" href="fileTable_c.html#a27">fileTable_lookup</a> (context_fileTable (), fname);
06776           }
06777       <font class="keywordflow">else</font>
06778         {
06779           fid = <a class="code" href="fileTable_c.html#a27">fileTable_lookup</a> (context_fileTable (),
06780                                   cppReader_getBuffer (pfile)-&gt;fname);
06781         }
06782     }
06783   <font class="keywordflow">else</font>
06784     {
06785       fid = <a class="code" href="fileTable_c.html#a27">fileTable_lookup</a> (context_fileTable (),
06786                               cppReader_getBuffer (pfile)-&gt;fname);
06787     }
06788 
06789   line = cppReader_getBuffer (pfile)-&gt;lineno;
06790   <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (g_currentloc);
06791   g_currentloc = <a class="code" href="fileloc_c.html#a34">fileloc_create</a> (fid, line, 1);
06792   }
06793   <font class="keywordflow">else</font>
06794     {
06795       <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (g_currentloc);
06796       g_currentloc = <a class="code" href="fileloc_c.html#a31">fileloc_createBuiltin</a> ();
06797     }
06798 }
06799 
06800 <font class="keyword">static</font> <font class="keywordtype">bool</font> cpp_shouldCheckMacro (cppReader *pfile, <font class="keywordtype">char</font> *p) <font class="comment">/*@*/</font>
06801 {
06802   <font class="keywordtype">bool</font> checkmacro = FALSE;
06803   <font class="keywordtype">bool</font> hasParams = FALSE;
06804   <font class="keywordtype">bool</font> noexpand = FALSE;
06805   cstring sname;
06806   <font class="keywordtype">char</font> c;
06807 
06808   cpp_setLocation (pfile);
06809 
06810   DPRINTF ((<font class="stringliteral">"Should check macro? %s"</font>, p));
06811 
06812   <font class="keywordflow">if</font> (expectiter || expectconstant || expectenditer)
06813     {
06814       <font class="keywordflow">if</font> (expectiter)
06815         {
06816           expectiter = FALSE;
06817           expectenditer = TRUE;
06818         }
06819       <font class="keywordflow">else</font>
06820         {
06821           expectiter = FALSE;
06822           expectconstant = FALSE;
06823           expectenditer = FALSE;
06824         }
06825 
06826       <font class="keywordflow">if</font> (notfunction || notparseable)
06827         {
06828           notfunction = FALSE;
06829           notparseable = FALSE;
06830           <font class="keywordflow">return</font> FALSE;
06831         }
06832       <font class="keywordflow">else</font>
06833         {
06834           <font class="keywordflow">return</font> TRUE;
06835         }
06836     }
06837 
06838   llassert (*p == <font class="charliteral">'#'</font>);
06839   p++;
06840 
06841   <font class="keywordflow">while</font> (*p == <font class="charliteral">' '</font> || *p == <font class="charliteral">'\t'</font>)
06842     {
06843       p++;
06844     }
06845 
06846   llassert (*p == <font class="charliteral">'d'</font>); <font class="comment">/* define starts */</font>
06847 
06848   p += 6;
06849 
06850   <font class="keywordflow">while</font> (*p == <font class="charliteral">' '</font> || *p == <font class="charliteral">'\t'</font>)
06851     {
06852       p++;
06853     }
06854 
06855   sname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (p);
06856   DPRINTF ((<font class="stringliteral">"Check macro: %s"</font>, sname));
06857 
06858   <font class="keywordflow">while</font> (((c = *p) != <font class="charliteral">' '</font>)
06859          &amp;&amp; c != <font class="charliteral">'\0'</font> &amp;&amp; c != <font class="charliteral">'('</font>
06860          &amp;&amp; c != <font class="charliteral">'\t'</font> &amp;&amp; c != <font class="charliteral">'\\'</font> &amp;&amp; c != <font class="charliteral">'\n'</font>
06861          &amp;&amp; !iscntrl (c))
06862     {
06863       p++;
06864     }
06865 
06866   hasParams = (c == <font class="charliteral">'('</font>);
06867   *p = <font class="charliteral">'\0'</font>;
06868 
06869 
06870   <font class="keywordflow">if</font> (notparseable)
06871     {
06872       notparseable = FALSE;
06873     }
06874   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (notfunction || <a class="code" href="fileloc_c.html#a48">fileloc_isStandardLib</a> (g_currentloc))
06875     {
06876       DPRINTF ((<font class="stringliteral">"Clear notfunction"</font>));
06877       notfunction = FALSE;
06878     }
06879   <font class="keywordflow">else</font>
06880     {
06881       <font class="keywordflow">if</font> (noexpand)
06882         {
06883           checkmacro = TRUE;
06884 
06885           <font class="keywordflow">if</font> (!expectenditer)
06886             {
06887               noexpand = FALSE;
06888             }
06889         }
06890       <font class="keywordflow">else</font>
06891         {
06892           <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a125">usymtab_existsReal</a> (sname))
06893             {
06894               uentry ue = usymtab_lookup (sname);
06895 
06896               DPRINTF ((<font class="stringliteral">"Lookup macro: %s"</font>, uentry_unparse (ue)));
06897 
06898               <font class="keywordflow">if</font> (fileloc_isPreproc (uentry_whereLast (ue)))
06899                 {
06900                   <font class="keywordflow">goto</font> macroDne;
06901                 }
06902               <font class="keywordflow">else</font>
06903                 {
06904                   <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a160">uentry_isSpecified</a> (ue))
06905                     {
06906                       checkmacro = <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_SPECMACROS);
06907                     }
06908                   <font class="keywordflow">else</font>
06909                     {
06910                       <font class="keywordflow">if</font> (hasParams)
06911                         {
06912                           checkmacro = <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_LIBMACROS)
06913                             || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_FCNMACROS);
06914                         }
06915                     }
06916                 }
06917             }
06918           <font class="keywordflow">else</font>
06919             {
06920             macroDne:
06921               DPRINTF ((<font class="stringliteral">"Macro doesn't exist: %s"</font>, bool_unparse (checkmacro)));
06922 
06923               <font class="keywordflow">if</font> (<a class="code" href="fileloc_c.html#a20">fileloc_isSystemFile</a> (g_currentloc)
06924                   &amp;&amp; <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_SYSTEMDIREXPAND))
06925                 {
06926                   ; <font class="comment">/* don't check this macro */</font>
06927                   DPRINTF ((<font class="stringliteral">"Don't check 1"</font>));
06928                 }
06929               <font class="keywordflow">else</font>
06930                 {
06931                   uentry le;
06932                   
06933                   <font class="keywordflow">if</font> (hasParams)
06934                     {
06935                       DPRINTF ((<font class="stringliteral">"Has params..."</font>));
06936 
06937                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_FCNMACROS))
06938                         {
06939                           <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (sname))
06940                             {
06941                               <font class="comment">/*</font>
06942 <font class="comment">                              ** only get here is macro is redefined</font>
06943 <font class="comment">                              ** error reported elsewhere</font>
06944 <font class="comment">                              */</font>
06945 
06946                               DPRINTF ((<font class="stringliteral">"It exists!"</font>));
06947                             }
06948                           <font class="keywordflow">else</font>
06949                             {
06950                               <font class="comment">/*</font>
06951 <font class="comment">                              ** We make it a forward function, since it might be declared elsewhere.</font>
06952 <font class="comment">                              ** After all headers have been processed, we should check the forward</font>
06953 <font class="comment">                              ** functions.</font>
06954 <font class="comment">                              */</font>
06955 
06956                               fileloc loc = <a class="code" href="fileloc_c.html#a29">fileloc_makePreproc</a> (g_currentloc);
06957 
06958                               <font class="comment">/* the line is off-by-one, since the newline was already read */</font>
06959                               decLine ();
06960 
06961                               <font class="keywordflow">if</font> (expectfunction)
06962                                 {
06963                                   expectfunction = FALSE;
06964                                 }
06965 
06966                               le = <a class="code" href="uentry_c.html#a107">uentry_makeForwardFunction</a> (sname,
06967                                                                typeId_invalid, loc);
06968 
06969                               <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
06970 
06971                               incLine ();
06972 
06973                               <font class="comment">/* Do not define here! */</font>
06974 
06975                               (<font class="keywordtype">void</font>) <a class="code" href="usymtab_c.html#a46">usymtab_addEntry</a> (le);
06976                             }
06977 
06978                           checkmacro = TRUE;
06979                           DPRINTF ((<font class="stringliteral">"Check: TRUE"</font>));
06980                         }
06981                       <font class="keywordflow">else</font> 
06982                         {
06983                           DPRINTF ((<font class="stringliteral">"Flag FCN_MACROS not set!"</font>));
06984                         }
06985                     }
06986                   <font class="keywordflow">else</font>
06987                     {
06988                       DPRINTF ((<font class="stringliteral">"No params"</font>));
06989 
06990                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_CONSTMACROS))
06991                         {
06992                           <font class="keywordtype">bool</font> nocontent = FALSE;
06993 
06994                           <font class="keywordflow">if</font> (c == <font class="charliteral">'\0'</font>)
06995                             {
06996                               nocontent = TRUE;
06997                             }
06998                           <font class="keywordflow">else</font>
06999                             {
07000                               <font class="keywordflow">if</font> (isspace (c))
07001                                 {
07002                                   <font class="keywordtype">char</font> *rest = p + 1;
07003 
07004                                   <font class="comment">/*</font>
07005 <font class="comment">                                  ** Check if there is nothing after the define.</font>
07006 <font class="comment">                                  */</font>
07007 
07008                                   <font class="keywordflow">while</font> ((*rest) != <font class="charliteral">'\0'</font> &amp;&amp; isspace (*rest))
07009                                     {
07010                                       rest++;
07011                                     }
07012 
07013                                   <font class="keywordflow">if</font> (*rest == <font class="charliteral">'\0'</font>)
07014                                     {
07015                                       nocontent = TRUE; <font class="comment">/* empty macro, don't check */</font>
07016                                     }
07017                                 }
07018                             }
07019 
07020                           <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (sname))
07021                             {
07022                               ;
07023                             }
07024                           <font class="keywordflow">else</font>
07025                             {
07026                               fileloc loc = <a class="code" href="fileloc_c.html#a29">fileloc_makePreproc</a> (g_currentloc);
07027                               DPRINTF ((<font class="stringliteral">"Make constant: %s"</font>, sname));
07028                               le = <a class="code" href="uentry_c.html#a85">uentry_makeConstant</a> (sname,
07029                                                         ctype_unknown, loc);
07030                               (<font class="keywordtype">void</font>) <a class="code" href="usymtab_c.html#a46">usymtab_addEntry</a> (le);
07031                             }
07032 
07033                           checkmacro = !nocontent;
07034                         }
07035                     }
07036                 }
07037 
07038               <font class="keywordflow">if</font> (checkmacro &amp;&amp; <a class="code" href="usymtab_c.html#a129">usymtab_existsType</a> (sname))
07039                 {
07040                   DPRINTF ((<font class="stringliteral">"Making false..."</font>));
07041                   decLine ();
07042                   <a class="code" href="llerror_c.html#a61">ppllerror</a> (message (<font class="stringliteral">"Specified type implemented as macro: %s"</font>, sname));
07043                   checkmacro = FALSE;
07044                   incLine ();
07045                 }
07046             }
07047         }
07048     }
07049 
07050   <font class="keywordflow">if</font> (!checkmacro)
07051     {
07052       <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (sname))
07053         {
07054           uentry ue = <a class="code" href="usymtab_c.html#a114">usymtab_lookupExpose</a> (sname);
07055           fileloc tloc = <a class="code" href="fileloc_c.html#a29">fileloc_makePreproc</a> (g_currentloc);
07056 
07057           <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (ue, tloc);
07058           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (tloc);
07059           <a class="code" href="uentry_c.html#a278">uentry_setUsed</a> (ue, fileloc_undefined);
07060         }
07061       <font class="keywordflow">else</font>
07062         {
07063           fileloc tloc = <a class="code" href="fileloc_c.html#a29">fileloc_makePreproc</a> (g_currentloc);
07064           uentry ue = <a class="code" href="uentry_c.html#a106">uentry_makeExpandedMacro</a> (sname, tloc);
07065           DPRINTF ((<font class="stringliteral">"Make expanded macro: %s"</font>, sname));
07066           DPRINTF ((<font class="stringliteral">"Not in symbol table: %s"</font>, sname));
07067           
07068           (<font class="keywordtype">void</font>) <a class="code" href="usymtab_c.html#a47">usymtab_addGlobalEntry</a> (ue);
07069           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (tloc);
07070         }
07071     }
07072 
07073   *p = c;
07074   DPRINTF ((<font class="stringliteral">"Returning: %s"</font>, bool_unparse (checkmacro)));
07075   <font class="keywordflow">return</font> checkmacro;
07076 }
07077 
07078 <font class="keyword">static</font> <font class="keyword">enum</font> cpp_token
07079 cpp_handleComment (cppReader *pfile, <font class="keyword">struct</font> parse_marker *smark)<font class="keyword"></font>
07080 <font class="keyword"></font>{
07081   cppBuffer *pbuf = cppReader_getBuffer (pfile);
07082   <font class="keywordtype">char</font> *start;
07083   <font class="keywordtype">int</font> len;
07084   <font class="keywordtype">bool</font> eliminateComment = FALSE;
07085 
07086   llassert (pbuf-&gt;buf != NULL);
07087 
07088   start = pbuf-&gt;buf + smark-&gt;position;
07089 
07090   llassert (pbuf-&gt;cur != NULL);
07091   len = pbuf-&gt;cur - start;
07092 
07093   <font class="keywordflow">if</font> (start[0] == <font class="charliteral">'*'</font>
07094       &amp;&amp; start[1] == <a class="code" href="context_c.html#a149">context_getCommentMarkerChar</a> ())
07095     {
07096       <font class="keywordtype">int</font> i;
07097       <font class="keywordtype">char</font> c = <font class="charliteral">' '</font>;
07098       <font class="keywordtype">char</font> *scomment = start + 2;
07099 
07100       start[0] = BEFORE_COMMENT_MARKER[0];
07101       start[1] = BEFORE_COMMENT_MARKER[1];
07102 
07103       llassert (start[len - 2] == <font class="charliteral">'*'</font>);
07104       start[len - 2] = AFTER_COMMENT_MARKER[0];
07105 
07106       llassert (start[len - 1] == <font class="charliteral">'/'</font>);
07107       start[len - 1] = AFTER_COMMENT_MARKER[1];
07108 
07109       cppReader_reserve(pfile, size_fromInt (1 + len));
07110       <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
07111 
07112       cpp_setLocation (pfile);
07113 
07114       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"ignore"</font>))
07115         {
07116           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS))
07117             {
07118               <a class="code" href="context_c.html#a42">context_enterSuppressRegion</a> ();
07119             }
07120         }
07121       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"end"</font>))
07122         {
07123           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS))
07124             {
07125               <a class="code" href="context_c.html#a47">context_exitSuppressRegion</a> ();
07126             }
07127         }
07128       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"notparseable"</font>))
07129         {
07130           notparseable = TRUE;
07131           expectmacro = TRUE;
07132           eliminateComment = TRUE;
07133         }
07134       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"notfunction"</font>))
07135         {
07136           notfunction = TRUE;
07137           expectmacro = TRUE;
07138           eliminateComment = TRUE;
07139         }
07140       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"iter"</font>))
07141         {
07142           expectiter = TRUE;
07143         }
07144       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"function"</font>))
07145         {
07146           expectfunction = TRUE;
07147         }
07148       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (scomment, <font class="stringliteral">"constant"</font>))
07149         {
07150           expectconstant = TRUE;
07151         }
07152       <font class="keywordflow">else</font>
07153         {
07154           <font class="keywordtype">char</font> sChar = *scomment;
07155 
07156           <font class="keywordflow">if</font> (sChar == <font class="charliteral">'='</font>
07157               || sChar == <font class="charliteral">'-'</font>
07158               || sChar == <font class="charliteral">'+'</font>)
07159             {
07160               <font class="keywordtype">char</font> *rest = scomment + 1;
07161 
07162               <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"commentchar"</font>))
07163                 {
07164                   eliminateComment = TRUE;
07165 
07166                   <font class="keywordflow">if</font> (sChar == <font class="charliteral">'='</font>)
07167                     {
07168                       <a class="code" href="llerror_c.html#a61">ppllerror</a> (cstring_makeLiteral
07169                                  (<font class="stringliteral">"Cannot restore commentchar"</font>));
07170                     }
07171                   <font class="keywordflow">else</font>
07172                     {
07173                       <font class="keywordtype">char</font> *next = scomment + 12; <font class="comment">/* strlen commentchar = 12 */</font>
07174 
07175                       <font class="keywordflow">if</font> (*next != <font class="charliteral">' '</font> &amp;&amp; *next != <font class="charliteral">'\t'</font> &amp;&amp; *next != <font class="charliteral">'\n'</font>)
07176                         {
07177                           ppllerror
07178                             (message
07179                              (<font class="stringliteral">"Syntactic commentchar comment is not followed by a "</font>
07180                               <font class="stringliteral">"whitespace character: %c"</font>,
07181                               *next));
07182                         }
07183                       <font class="keywordflow">else</font>
07184                         {
07185                           <font class="keywordtype">char</font> cchar = *(next + 1);
07186 
07187                           <font class="keywordflow">if</font> (cchar == <font class="charliteral">'\0'</font>)
07188                             {
07189                               ppllerror
07190                                 (cstring_makeLiteral
07191                                  (<font class="stringliteral">"Cannot set commentchar to NUL"</font>));
07192                             }
07193                           <font class="keywordflow">else</font>
07194                             {
07195                               <a class="code" href="context_c.html#a148">context_setCommentMarkerChar</a> (cchar);
07196                               <font class="comment">/* setComment = TRUE; */</font>
07197                             }
07198                         }
07199                     }
07200                 }
07201               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"namechecks"</font>))
07202                 {
07203                   <a class="code" href="context_c.html#a186">context_fileSetFlag</a> (FLG_NAMECHECKS,
07204                                        ynm_fromCodeChar (sChar));
07205                 }
07206               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"macroredef"</font>))
07207                 {
07208                   <a class="code" href="context_c.html#a186">context_fileSetFlag</a> (FLG_MACROREDEF,
07209                                        ynm_fromCodeChar (sChar));
07210                 }
07211               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"usevarargs"</font>))
07212                 {
07213                   <a class="code" href="context_c.html#a186">context_fileSetFlag</a> (FLG_USEVARARGS,
07214                                        ynm_fromCodeChar (sChar));
07215                 }
07216               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"nextlinemacros"</font>))
07217                 {
07218                   <a class="code" href="context_c.html#a186">context_fileSetFlag</a> (FLG_MACRONEXTLINE,
07219                                        ynm_fromCodeChar (sChar));
07220                 }
07221               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"allmacros"</font>)
07222                        || <a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"fcnmacros"</font>)
07223                        || <a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"constmacros"</font>))
07224                 {
07225                   flagcode fl;
07226 
07227                   <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"allmacros"</font>))
07228                     {
07229                       fl = FLG_ALLMACROS;
07230                     }
07231                   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (rest, <font class="stringliteral">"fcnmacros"</font>))
07232                     {
07233                       fl = FLG_FCNMACROS;
07234                     }
07235                   <font class="keywordflow">else</font>
07236                     {
07237                       llassert (mstring_equalPrefix (rest, <font class="stringliteral">"constmacros"</font>));
07238                       fl = FLG_CONSTMACROS;
07239                     }
07240 
07241 
07242                   <a class="code" href="context_c.html#a186">context_fileSetFlag</a> (fl, ynm_fromCodeChar (sChar));
07243                   notfunction = FALSE;
07244                 }
07245               <font class="keywordflow">else</font>
07246                 {
07247                   ;
07248                 }
07249             }
07250           <font class="keywordflow">else</font>
07251             {
07252               ;
07253             }
07254         }
07255 
07256       <font class="keywordflow">if</font> (eliminateComment)
07257         {
07258           <font class="keywordflow">goto</font> removeComment;
07259         }
07260 
07261       <font class="comment">/* Replaces comment char's in start with spaces */</font>
07262 
07263       <font class="keywordflow">for</font> (i = 2; i &lt; len - 2; i++)
07264         {
07265           <font class="keywordflow">if</font> (start[i] == BEFORE_COMMENT_MARKER[0]
07266               || start[i] == BEFORE_COMMENT_MARKER[1]
07267               || start[i] == <a class="code" href="context_c.html#a149">context_getCommentMarkerChar</a> ())
07268             {
07269               start[i] = <font class="charliteral">' '</font>;
07270             }
07271         }
07272 
07273       cppReader_putStrN (pfile, start, size_fromInt (len));
07274       parseClearMark (smark);
07275       <font class="keywordflow">return</font> CPP_COMMENT;
07276     }
07277   <font class="keywordflow">else</font>
07278     {
07279     removeComment:
07280       {
07281         <font class="keywordtype">int</font> i;
07282 
07283         <font class="comment">/*</font>
07284 <font class="comment">        ** Output the comment as all spaces so line/column</font>
07285 <font class="comment">        ** in output file is still correct.</font>
07286 <font class="comment">        */</font>
07287 
07288         <font class="keywordtype">char</font> c = <font class="charliteral">' '</font>;
07289         cstring lintcomment = cstring_undefined;
07290 
07291         <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_LINTCOMMENTS))
07292           {
07293             <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (start, <font class="stringliteral">"*NOTREACHED*/"</font>))
07294               {
07295                 lintcomment = cstring_makeLiteralTemp (<font class="stringliteral">"l_notreach"</font>);
07296               }
07297             <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (start, <font class="stringliteral">"*PRINTFLIKE*/"</font>))
07298               {
07299                 lintcomment = cstring_makeLiteralTemp (<font class="stringliteral">"l_printfli"</font>);
07300               }
07301             <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (start, <font class="stringliteral">"*FALLTHROUGH*/"</font>))
07302               {
07303                 lintcomment = cstring_makeLiteralTemp (<font class="stringliteral">"l_fallthrou"</font>);
07304               }
07305             <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (start, <font class="stringliteral">"*ARGSUSED*/"</font>))
07306               {
07307                 lintcomment = cstring_makeLiteralTemp (<font class="stringliteral">"l_argsus"</font>);
07308               }
07309             <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a39">mstring_equalPrefix</a> (start, <font class="stringliteral">"*FALLTHRU*/"</font>))
07310               {
07311                 lintcomment = cstring_makeLiteralTemp (<font class="stringliteral">"l_fallth"</font>);
07312               }
07313             <font class="keywordflow">else</font>
07314               {
07315                 lintcomment = cstring_undefined;
07316               }
07317           }
07318         <font class="keywordflow">else</font>
07319           {
07320             lintcomment = cstring_undefined;
07321           }
07322 
07323         <font class="keywordflow">if</font> (cstring_isDefined (lintcomment))
07324           {
07325             c = BEFORE_COMMENT_MARKER[0];
07326             start[0] = BEFORE_COMMENT_MARKER[1];
07327 
07328             llassert (cstring_length (lintcomment) == len - 3);
07329 
07330             <font class="keywordflow">for</font> (i = 1; i &lt; len - 2; i++)
07331               {
07332                 start[i] = <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (lintcomment, i);
07333               }
07334             
07335             start[len - 2] = AFTER_COMMENT_MARKER[0];
07336             start[len - 1] = AFTER_COMMENT_MARKER[1];
07337           }
07338         <font class="keywordflow">else</font>
07339           {
07340             <font class="comment">/* Replaces  char's in start with spaces */</font>
07341             <font class="keywordflow">for</font> (i = 0; i &lt; len; i++)
07342               {
07343                 <font class="keywordflow">if</font> (start[i] == <font class="charliteral">'/'</font>
07344                     &amp;&amp; i &lt; len - 1
07345                     &amp;&amp; start[i + 1] == <font class="charliteral">'*'</font>) {
07346                   cppReader_warning 
07347                     (pfile,
07348                      <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Start comment inside comment"</font>));
07349                 }
07350                 
07351                 <font class="keywordflow">if</font> (start[i] != <font class="charliteral">'\n'</font>)
07352                   {
07353                     start[i] = <font class="charliteral">' '</font>;
07354                   }
07355               }
07356           }
07357 
07358         cppReader_reserve (pfile, size_fromInt (1 + len));
07359         <a class="code" href="cpplib_c.html#a16">cppReader_putCharQ</a> (pfile, c);
07360         cppReader_putStrN (pfile, start, size_fromInt (len));
07361         parseClearMark (smark);
07362         <font class="keywordflow">return</font> CPP_COMMENT;
07363       }
07364     }
07365 }
07366 
07367 <font class="keyword">static</font> <font class="keywordtype">int</font> cpp_openIncludeFile (<font class="keywordtype">char</font> *filename)<font class="keyword"></font>
07368 <font class="keyword"></font>{
07369   <font class="keywordtype">int</font> res = open (filename, O_RDONLY, 0666);
07370 
07371   <font class="keywordflow">if</font> (res 
07372       &amp;&amp; !<a class="code" href="fileTable_c.html#a26">fileTable_exists</a> (context_fileTable (),
07373                             <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (filename)))
07374     {
07375       DPRINTF ((<font class="stringliteral">"Add header: %s"</font>, filename));
07376       (<font class="keywordtype">void</font>) <a class="code" href="fileTable_c.html#a16">fileTable_addHeaderFile</a> (context_fileTable (),
07377                                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (filename));
07378     }
07379 
07380   <font class="keywordflow">return</font> res;
07381 }
07382 
07383 <font class="keyword">static</font> <font class="keywordtype">bool</font> cpp_skipIncludeFile (cstring fname)<font class="keyword"></font>
07384 <font class="keyword"></font>{
07385   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a65">context_isSystemDir</a> (fname))
07386     {
07387       DPRINTF ((<font class="stringliteral">"System dir: %s"</font>, fname));
07388 
07389       <font class="keywordflow">if</font> (<a class="code" href="lcllib_c.html#a7">lcllib_isSkipHeader</a> (fname))
07390         {
07391           DPRINTF ((<font class="stringliteral">"Skip include TRUE: %s"</font>, fname));
07392           <font class="keywordflow">return</font> TRUE;
07393         }
07394       
07395       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_SKIPSYSHEADERS))
07396         {
07397           DPRINTF ((<font class="stringliteral">"Skip include TRUE: %s"</font>, fname));
07398           <font class="keywordflow">return</font> TRUE;
07399         }
07400     }
07401 
07402   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_SINGLEINCLUDE))
07403     {
07404       fname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (removePreDirs (cstring_toCharsSafe (fname)));
07405 
07406 <font class="preprocessor"># if defined (WIN32) || defined (OS2)</font>
07407 <font class="preprocessor"></font>      cstring_replaceAll (fname, <font class="charliteral">'\\'</font>, <font class="charliteral">'/'</font>);
07408 <font class="preprocessor"># endif</font>
07409 <font class="preprocessor"></font>
07410       <font class="keywordflow">if</font> (<a class="code" href="fileTable_c.html#a26">fileTable_exists</a> (context_fileTable (), fname))
07411         {
07412           DPRINTF ((<font class="stringliteral">"Skip include TRUE: %s"</font>, fname));
07413           <font class="keywordflow">return</font> TRUE;
07414         }
07415     }
07416 
07417   DPRINTF ((<font class="stringliteral">"Skip include FALSE: %s"</font>, fname));
07418   <font class="keywordflow">return</font> FALSE;
07419 }
07420 
07421 <font class="keyword">static</font> <font class="keywordtype">int</font> cpp_peekN (cppReader *pfile, <font class="keywordtype">int</font> n)<font class="keyword"></font>
07422 <font class="keyword"></font>{
07423   cppBuffer *buf = cppReader_getBuffer (pfile);
07424 
07425   llassert (buf-&gt;cur != NULL);
07426 
07427   <font class="keywordflow">return</font> (buf-&gt;rlimit - buf-&gt;cur &gt;= (n)
07428           ? buf-&gt;cur[n]
07429           : EOF);
07430 }
07431 
<a name="l07432"></a><a class="code" href="cpplib_c.html#a149">07432</a> cppBuffer *<a class="code" href="cpplib_c.html#a149">cppBuffer_prevBuffer</a> (cppBuffer *buf)<font class="keyword"></font>
07433 <font class="keyword"></font>{
07434   <font class="keywordflow">return</font> buf + 1;
07435 }
07436 
07437 <font class="keywordtype">void</font> cppBuffer_forward (cppBuffer *buf, <font class="keywordtype">int</font> n)<font class="keyword"></font>
07438 <font class="keyword"></font>{
07439   llassert (buf-&gt;cur != NULL);
07440   buf-&gt;cur += n;
07441 }
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:40 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
