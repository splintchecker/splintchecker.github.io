<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cpphash.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:39 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>cpphash.c</h1><a href="cpphash_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** cpphash.c</font>
00026 <font class="comment">**</font>
00027 <font class="comment">** Pre-processor hash table.  Derived from gnu cpp.</font>
00028 <font class="comment">*/</font>
00029 
00030 <font class="comment">/* Part of CPP library.  (Macro hash table support.)</font>
00031 <font class="comment">   Copyright (C) 1986, 87, 89, 92-95, 1996 Free Software Foundation, Inc.</font>
00032 <font class="comment">   Written by Per Bothner, 1994.</font>
00033 <font class="comment">   Based on CCCP program by by Paul Rubin, June 1986</font>
00034 <font class="comment">   Adapted to ANSI C, Richard Stallman, Jan 1987</font>
00035 <font class="comment"></font>
00036 <font class="comment">This program is free software; you can redistribute it and/or modify it</font>
00037 <font class="comment">under the terms of the GNU General Public License as published by the</font>
00038 <font class="comment">Free Software Foundation; either version 2, or (at your option) any</font>
00039 <font class="comment">later version.</font>
00040 <font class="comment"></font>
00041 <font class="comment">This program is distributed in the hope that it will be useful,</font>
00042 <font class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00043 <font class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
00044 <font class="comment">GNU General Public License for more details.</font>
00045 <font class="comment"></font>
00046 <font class="comment">You should have received a copy of the GNU General Public License</font>
00047 <font class="comment">along with this program; if not, write to the Free Software</font>
00048 <font class="comment">Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</font>
00049 <font class="comment"></font>
00050 <font class="comment"> In other words, you are welcome to use, share and improve this program.</font>
00051 <font class="comment"> You are forbidden to forbid anyone else to use, share and improve</font>
00052 <font class="comment"> what you give them.   Help stamp out software-hoarding!  */</font>
00053 
00054 <font class="preprocessor"># include "lclintMacros.nf"</font>
00055 <font class="preprocessor"># include "llbasic.h"</font>
00056 <font class="preprocessor"># include &lt;string.h&gt;</font>
00057 <font class="preprocessor"># include "cpp.h"</font>
00058 <font class="preprocessor"># include "cpplib.h"</font>
00059 <font class="preprocessor"># include "cpphash.h"</font>
00060 
<a name="l00061"></a><a class="code" href="cpphash_c.html#a2">00061</a> <font class="keyword">typedef</font> <font class="comment">/*@only@*/</font> HASHNODE *o_HASHNODE;
00062 
00063 <font class="keyword">static</font> o_HASHNODE hashtab[CPP_HASHSIZE]; 
00064 <font class="keyword">static</font> o_HASHNODE ohashtab[CPP_HASHSIZE];
00065 
00066 <font class="keyword">static</font> <font class="keywordtype">void</font> HashNode_delete (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> HASHNODE *);
00067 
00068 <font class="comment">/* p_prev need not be defined, but isn't defined by HashNode_copy */</font>
00069 
00070 <font class="comment">/*@function static unsigned int hashStep (unsigned, char) modifies nothing ; @*/</font>
<a name="l00071"></a><a class="code" href="cpphash_c.html#a0">00071</a> <font class="preprocessor"># define hashStep(old, c) (((old) &lt;&lt; 2) + (unsigned int) (c))</font>
00072 <font class="preprocessor"></font>
00073 <font class="comment">/*@function static unsigned int makePositive (unsigned int) modifies nothing ; @*/</font>
<a name="l00074"></a><a class="code" href="cpphash_c.html#a1">00074</a> <font class="preprocessor"># define makePositive(v) ((v) &amp; 0x7fffffff) </font><font class="comment">/* make number positive */</font>
00075 
00076 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> HASHNODE *
00077    HashNode_copy (<font class="comment">/*@null@*/</font> HASHNODE *, 
00078                   <font class="comment">/*@dependent@*/</font> HASHNODE **p_hdr, 
00079                   <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <font class="comment">/*@special@*/</font> HASHNODE *p_prev) 
00080      <font class="comment">/*@*/</font> ;
00081 
<a name="l00082"></a><a class="code" href="cpphash_c.html#a7">00082</a> <font class="keywordtype">void</font> <a class="code" href="cpphash_c.html#a7">cppReader_saveHashtab</a> ()<font class="keyword"></font>
00083 <font class="keyword"></font>{
00084   <font class="keywordtype">int</font> i;
00085 
00086   <font class="keywordflow">for</font> (i = 0; i &lt; CPP_HASHSIZE; i++) 
00087     {
00088       ohashtab[i] = HashNode_copy (hashtab[i], &amp;ohashtab[i], NULL);
00089     }
00090 }
00091 
<a name="l00092"></a><a class="code" href="cpphash_c.html#a8">00092</a> <font class="keywordtype">void</font> <a class="code" href="cpphash_c.html#a8">cppReader_restoreHashtab</a> ()<font class="keyword"></font>
00093 <font class="keyword"></font>{
00094   <font class="keywordtype">int</font> i;
00095 
00096   <font class="keywordflow">for</font> (i = 0; i &lt; CPP_HASHSIZE; i++) {
00097     <font class="comment">/* HashNode_delete (hashtab[i]); */</font>
00098     hashtab[i] = HashNode_copy (ohashtab[i], &amp;hashtab[i], NULL);
00099   }  
00100 }
00101 
00102 <font class="keyword">static</font> <font class="keywordtype">void</font> HashNode_delete (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> HASHNODE *node)<font class="keyword"> </font>
00103 <font class="keyword"></font>{
00104   <font class="keywordflow">if</font> (node == NULL) 
00105     {
00106       ;
00107     } 
00108   <font class="keywordflow">else</font> 
00109     {
00110       HashNode_delete (node-&gt;next);
00111       
00112       <font class="keywordflow">if</font> (node-&gt;type == T_MACRO)
00113         {
00114           DEFINITION *d = node-&gt;value.defn;
00115           <font class="keyword">struct </font>reflist *ap, *nextap;
00116           
00117           <font class="keywordflow">for</font> (ap = d-&gt;pattern; ap != NULL; ap = nextap)
00118             {
00119               nextap = ap-&gt;next;
00120               <a class="code" href="general_c.html#a0">sfree</a> (ap);
00121             }
00122           
00123           <font class="keywordflow">if</font> (d-&gt;nargs &gt;= 0) 
00124             {
00125               <a class="code" href="general_c.html#a0">sfree</a> (d-&gt;args.argnames);
00126             }
00127           
00128           <a class="code" href="general_c.html#a0">sfree</a> (d);
00129         }
00130       
00131       <a class="code" href="cstring_c.html#a27">cstring_free</a> (node-&gt;name);
00132       <a class="code" href="general_c.html#a0">sfree</a> (node); 
00133     }
00134 }
00135 
00136 <font class="comment">/*@null@*/</font> HASHNODE *HashNode_copy (HASHNODE *node, HASHNODE **hdr, 
00137                                     <font class="comment">/*@dependent@*/</font> HASHNODE *prev)<font class="keyword"></font>
00138 <font class="keyword"></font>{
00139   <font class="keywordflow">if</font> (node == NULL) 
00140     {
00141       <font class="keywordflow">return</font> NULL;
00142     } 
00143   <font class="keywordflow">else</font> 
00144     {
00145       HASHNODE *res = dmalloc (<font class="keyword">sizeof</font> (*res));
00146       
00147       res-&gt;next = HashNode_copy (node-&gt;next, hdr, res);
00148       res-&gt;prev = prev;
00149       
00150       res-&gt;bucket_hdr = hdr;
00151       res-&gt;type = node-&gt;type;
00152       res-&gt;length = node-&gt;length;
00153       res-&gt;name = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (node-&gt;name);
00154       
00155       <font class="keywordflow">if</font> (node-&gt;type == T_MACRO)
00156         {
00157           DEFINITION *d = node-&gt;value.defn;
00158           DEFINITION *nd = dmalloc (<font class="keyword">sizeof</font> (*nd));
00159           
00160           res-&gt;value.defn = nd;
00161           nd-&gt;nargs = d-&gt;nargs;
00162           
00163           nd-&gt;length = d-&gt;length;
00164           nd-&gt;predefined = d-&gt;predefined;
00165           nd-&gt;expansion = d-&gt;expansion; 
00166           nd-&gt;line = d-&gt;line;
00167           nd-&gt;file = d-&gt;file; 
00168           
00169           <font class="keywordflow">if</font> (d-&gt;pattern != NULL) 
00170             {
00171               <font class="keyword">struct </font>reflist *ap, *nextap;
00172               <font class="keyword">struct </font>reflist **last = &amp;nd-&gt;pattern;
00173               
00174               <font class="keywordflow">for</font> (ap = d-&gt;pattern; ap != NULL; ap = nextap) 
00175                 {
00176                   <font class="keyword">struct </font>reflist *npattern = dmalloc (sizeof (*(nd-&gt;pattern)));
00177                   
00178                   nextap = ap-&gt;next;
00179                   
00180                   <font class="keywordflow">if</font> (ap == d-&gt;pattern) 
00181                     {
00182                       *last = npattern;
00183                       <font class="comment">/*@-branchstate@*/</font> 
00184                     } <font class="comment">/*@=branchstate@*/</font> <font class="comment">/* npattern is propagated through loop */</font>
00185                   
00186                   last = &amp;(npattern-&gt;next);
00187                   npattern-&gt;next = NULL; <font class="comment">/* will get filled in */</font>
00188                   npattern-&gt;stringify = d-&gt;pattern-&gt;stringify;
00189                   npattern-&gt;raw_before = d-&gt;pattern-&gt;raw_before;
00190                   npattern-&gt;raw_after = d-&gt;pattern-&gt;raw_after;
00191                   npattern-&gt;rest_args = d-&gt;pattern-&gt;rest_args;
00192                   npattern-&gt;argno = d-&gt;pattern-&gt;argno;
00193                   <font class="comment">/*@-mustfree@*/</font> 
00194                 }
00195               <font class="comment">/*@=mustfree@*/</font>
00196             } 
00197           <font class="keywordflow">else</font> 
00198             {
00199               nd-&gt;pattern = NULL;
00200             }
00201           
00202           <font class="keywordflow">if</font> (d-&gt;nargs &gt;= 0) 
00203             {
00204               llassert (d-&gt;args.argnames != NULL);
00205               
00206               nd-&gt;args.argnames = <a class="code" href="general_c.html#a27">mstring_copy</a> (d-&gt;args.argnames);
00207             } 
00208           <font class="keywordflow">else</font> 
00209             {
00210               <font class="comment">/*</font>
00211 <font class="comment">              ** This fix found by:</font>
00212 <font class="comment">              **</font>
00213 <font class="comment">              **    Date: Mon, 31 May 1999 15:10:50 +0900 (JST)</font>
00214 <font class="comment">              **    From: "N.Komazaki" &lt;koma@focs.sei.co.jp&gt;</font>
00215 <font class="comment">              */</font>
00216 
00218               nd-&gt;args.argnames = mstring_createEmpty ();
00219             }
00220         } 
00221       <font class="keywordflow">else</font> 
00222         {
00223           <font class="keywordflow">if</font> (node-&gt;type == T_CONST) 
00224             {
00225               res-&gt;value.ival = node-&gt;value.ival;
00226             } 
00227           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (node-&gt;type == T_PCSTRING) 
00228             {
00229               res-&gt;value.cpval = <a class="code" href="general_c.html#a27">mstring_copy</a> (node-&gt;value.cpval);
00230                   llassert (res-&gt;value.cpval != NULL);
00231             } 
00232           <font class="keywordflow">else</font> 
00233             {
00234               res-&gt;value = node-&gt;value;
00235             }
00236         }
00237       
00238       <font class="comment">/*@-uniondef@*/</font> <font class="comment">/*@-compdef@*/</font> <font class="comment">/* res-&gt;prev is not defined */</font>
00239       <font class="keywordflow">return</font> res;
00240       <font class="comment">/*@=uniondef@*/</font> <font class="comment">/*@=compdef@*/</font>
00241     }
00242 }
00243 
00244 <font class="comment">/* Return hash function on name.  must be compatible with the one</font>
00245 <font class="comment">   computed a step at a time, elsewhere  */</font>
00246 
00247 <font class="keywordtype">int</font>
<a name="l00248"></a><a class="code" href="cpphash_c.html#a9">00248</a> <a class="code" href="cpphash_c.html#a9">hashf</a> (<font class="keyword">const</font> <font class="keywordtype">char</font> *name, <font class="keywordtype">int</font> len, <font class="keywordtype">int</font> hashsize)<font class="keyword"></font>
00249 <font class="keyword"></font>{
00250   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> r = 0;
00251 
00252   <font class="keywordflow">while</font> (len-- != 0)
00253     {
00254       r = <a class="code" href="cpphash_c.html#a0">hashStep</a> (r, *name++);
00255     }
00256 
00257   <font class="keywordflow">return</font> (<font class="keywordtype">int</font>) (<a class="code" href="cpphash_c.html#a1">makePositive</a> (r) % hashsize);
00258 }
00259 
00260 <font class="comment">/*</font>
00261 <font class="comment">** Find the most recent hash node for name name (ending with first</font>
00262 <font class="comment">** non-identifier char) cppReader_installed by install</font>
00263 <font class="comment">**</font>
00264 <font class="comment">** If LEN is &gt;= 0, it is the length of the name.</font>
00265 <font class="comment">** Otherwise, compute the length by scanning the entire name.</font>
00266 <font class="comment">**</font>
00267 <font class="comment">** If HASH is &gt;= 0, it is the precomputed hash code.</font>
00268 <font class="comment">** Otherwise, compute the hash code.  </font>
00269 <font class="comment">*/</font>
00270 
<a name="l00271"></a><a class="code" href="cpphash_c.html#a10">00271</a> <font class="comment">/*@null@*/</font> HASHNODE *<a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (<font class="keywordtype">char</font> *name, <font class="keywordtype">int</font> len, <font class="keywordtype">int</font> hash)<font class="keyword"></font>
00272 <font class="keyword"></font>{
00273   <font class="keyword">const</font> <font class="keywordtype">char</font> *bp;
00274   HASHNODE *bucket;
00275 
00276   <font class="keywordflow">if</font> (len &lt; 0)
00277     {
00278       <font class="keywordflow">for</font> (bp = name; <a class="code" href="cpplib_c.html#a106">isIdentifierChar</a> (*bp); bp++) 
00279         {
00280           ;
00281         }
00282 
00283       len = bp - name;
00284     }
00285 
00286   <font class="keywordflow">if</font> (hash &lt; 0)
00287     {
00288       hash = <a class="code" href="cpphash_c.html#a9">hashf</a> (name, len, CPP_HASHSIZE);
00289     }
00290 
00291   bucket = hashtab[hash];
00292 
00293   <font class="keywordflow">while</font> (bucket != NULL) 
00294     {
00295       <font class="keywordflow">if</font> (bucket-&gt;length == len &amp;&amp; 
00296           <a class="code" href="cstring_c.html#a19">cstring_equalLen</a> (bucket-&gt;name, cstring_fromChars (name), len)) 
00297         {
00298           <font class="keywordflow">return</font> bucket;
00299         }
00300       
00301       bucket = bucket-&gt;next;
00302     }
00303 
00304   <font class="keywordflow">return</font> NULL;
00305 }
00306 
<a name="l00307"></a><a class="code" href="cpphash_c.html#a11">00307</a> <font class="comment">/*@null@*/</font> HASHNODE *<a class="code" href="cpphash_c.html#a11">cppReader_lookupExpand</a> (<font class="keywordtype">char</font> *name, <font class="keywordtype">int</font> len, <font class="keywordtype">int</font> hash)<font class="keyword"></font>
00308 <font class="keyword"></font>{
00309   HASHNODE *node = <a class="code" href="cpphash_c.html#a10">cppReader_lookup</a> (name, len, hash);
00310 
00311   DPRINTF ((<font class="stringliteral">"Lookup expand: %s"</font>, name));
00312 
00313   <font class="keywordflow">if</font> (node != NULL) 
00314     {
00315       <font class="keywordflow">if</font> (node-&gt;type == T_MACRO)
00316         {
00317           DEFINITION *defn = (DEFINITION *) node-&gt;value.defn;
00318         
00319           DPRINTF ((<font class="stringliteral">"Check macro..."</font>));
00320 
00321           <font class="keywordflow">if</font> (defn-&gt;noExpand) {
00322             DPRINTF ((<font class="stringliteral">"No expand!"</font>));
00323             <font class="keywordflow">return</font> NULL;
00324           }
00325         }
00326     }
00327   
00328   <font class="keywordflow">return</font> node;
00329 }
00330 
00331 <font class="comment">/*</font>
00332 <font class="comment"> * Delete a hash node.  Some weirdness to free junk from macros.</font>
00333 <font class="comment"> * More such weirdness will have to be added if you define more hash</font>
00334 <font class="comment"> * types that need it.</font>
00335 <font class="comment"> */</font>
00336 
00337 <font class="comment">/* Note that the DEFINITION of a macro is removed from the hash table</font>
00338 <font class="comment">   but its storage is not freed.  This would be a storage leak</font>
00339 <font class="comment">   except that it is not reasonable to keep undefining and redefining</font>
00340 <font class="comment">   large numbers of macros many times.</font>
00341 <font class="comment">   In any case, this is necessary, because a macro can be #undef'd</font>
00342 <font class="comment">   in the middle of reading the arguments to a call to it.</font>
00343 <font class="comment">   If #undef freed the DEFINITION, that would crash.  */</font>
00344 
00345 <font class="keywordtype">void</font>
<a name="l00346"></a><a class="code" href="cpphash_c.html#a12">00346</a> <a class="code" href="cpphash_c.html#a12">cppReader_deleteMacro</a> (HASHNODE *hp)<font class="keyword"></font>
00347 <font class="keyword"></font>{
00348   <font class="keywordflow">if</font> (hp-&gt;prev != NULL) 
00349     {
00350       <font class="comment">/*@-mustfree@*/</font>
00351       hp-&gt;prev-&gt;next = hp-&gt;next;
00352       <font class="comment">/*@=mustfree@*/</font>
00353       <font class="comment">/*@-branchstate@*/</font> 
00354     } <font class="comment">/*@=branchstate@*/</font> 
00355   
00356   <font class="keywordflow">if</font> (hp-&gt;next != NULL) 
00357     {
00358       hp-&gt;next-&gt;prev = hp-&gt;prev;
00359     }
00360   
00361   <font class="comment">/* make sure that the bucket chain header that</font>
00362 <font class="comment">     the deleted guy was on points to the right thing afterwards.  */</font>
00363   <font class="keywordflow">if</font> (hp == *hp-&gt;bucket_hdr) {
00364     *hp-&gt;bucket_hdr = hp-&gt;next;
00365   }
00366   
00367   <font class="keywordflow">if</font> (hp-&gt;type == T_MACRO)
00368     {
00369       DEFINITION *d = hp-&gt;value.defn;
00370       <font class="keyword">struct </font>reflist *ap, *nextap;
00371 
00372       <font class="keywordflow">for</font> (ap = d-&gt;pattern; ap != NULL; ap = nextap)
00373         {
00374           nextap = ap-&gt;next;
00375           <a class="code" href="general_c.html#a0">sfree</a> (ap);
00376         }
00377 
00378       <font class="keywordflow">if</font> (d-&gt;nargs &gt;= 0)
00379         {
00380           <a class="code" href="general_c.html#a0">sfree</a> (d-&gt;args.argnames);
00381         }
00382     }
00383 
00384   <font class="comment">/*@-dependenttrans@*/</font> <font class="comment">/*@-exposetrans@*/</font> <font class="comment">/*@-compdestroy@*/</font> 
00385   <a class="code" href="general_c.html#a0">sfree</a> (hp); 
00386   <font class="comment">/*@=dependenttrans@*/</font> <font class="comment">/*@=exposetrans@*/</font> <font class="comment">/*@=compdestroy@*/</font>
00387 }
00388 
00389 <font class="comment">/* Install a name in the main hash table, even if it is already there.</font>
00390 <font class="comment">     name stops with first non alphanumeric, except leading '#'.</font>
00391 <font class="comment">   caller must check against redefinition if that is desired.</font>
00392 <font class="comment">   cppReader_deleteMacro () removes things installed by install () in fifo order.</font>
00393 <font class="comment">   this is important because of the `defined' special symbol used</font>
00394 <font class="comment">   in #if, and also if pushdef/popdef directives are ever implemented.</font>
00395 <font class="comment"></font>
00396 <font class="comment">   If LEN is &gt;= 0, it is the length of the name.</font>
00397 <font class="comment">   Otherwise, compute the length by scanning the entire name.</font>
00398 <font class="comment"></font>
00399 <font class="comment">   If HASH is &gt;= 0, it is the precomputed hash code.</font>
00400 <font class="comment">   Otherwise, compute the hash code.  */</font>
00401 
<a name="l00402"></a><a class="code" href="cpphash_c.html#a13">00402</a> HASHNODE *<a class="code" href="cpphash_c.html#a13">cppReader_install</a> (<font class="keywordtype">char</font> *name, <font class="keywordtype">int</font> len, <font class="keyword">enum</font> node_type type, 
00403                              <font class="keywordtype">int</font> ivalue, <font class="keywordtype">char</font> *value, <font class="keywordtype">int</font> hash)<font class="keyword"></font>
00404 <font class="keyword"></font>{
00405   HASHNODE *hp;
00406   <font class="keywordtype">int</font> i, bucket;
00407   <font class="keywordtype">char</font> *p, *q;
00408 
00409   <font class="keywordflow">if</font> (len &lt; 0) {
00410     p = name;
00411 
00412     <font class="keywordflow">while</font> (<a class="code" href="cpplib_c.html#a106">isIdentifierChar</a> (*p))
00413       {
00414         p++;
00415       }
00416 
00417     len = p - name;
00418   }
00419 
00420   <font class="keywordflow">if</font> (hash &lt; 0) 
00421     {
00422       hash = <a class="code" href="cpphash_c.html#a9">hashf</a> (name, len, CPP_HASHSIZE);
00423     }
00424 
00425   i = <font class="keyword">sizeof</font> (*hp) + len + 1;
00426 
00427   
00428   hp = (HASHNODE *) dmalloc (size_fromInt (i));
00429   bucket = hash;
00430   hp-&gt;bucket_hdr = &amp;hashtab[bucket];
00431 
00432   hp-&gt;next = hashtab[bucket];
00433   hp-&gt;prev = NULL;
00434 
00435   <font class="keywordflow">if</font> (hp-&gt;next != NULL) 
00436     {
00437       hp-&gt;next-&gt;prev = hp;
00438     }
00439 
00440   hashtab[bucket] = hp;
00441 
00442   hp-&gt;type = type;
00443   hp-&gt;length = len;
00444 
00445   <font class="keywordflow">if</font> (hp-&gt;type == T_CONST)
00446     {
00447       hp-&gt;value.ival = ivalue;
00448       llassert (value == NULL);
00449     }
00450   <font class="keywordflow">else</font>
00451     {
00452       hp-&gt;value.cpval = value;
00453     }
00454   
00455   {
00456     <font class="keywordtype">char</font> *tmp = ((<font class="keywordtype">char</font> *) hp) + <font class="keyword">sizeof</font> (*hp);
00457     p = tmp;
00458     q = name;
00459 
00460     <font class="keywordflow">for</font> (i = 0; i &lt; len; i++)
00461       {
00462         *p++ = *q++;
00463       }
00464     
00465     tmp[len] = <font class="charliteral">'\0'</font>;
00466     hp-&gt;name = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (tmp);
00467   }
00468 
00469   <font class="comment">/*@-mustfree@*/</font> <font class="comment">/*@-uniondef@*/</font> <font class="comment">/*@-compdef@*/</font>
00470   <font class="keywordflow">return</font> hp;
00471   <font class="comment">/*@=mustfree@*/</font> <font class="comment">/*@=uniondef@*/</font> <font class="comment">/*@=compdef@*/</font>
00472 }
00473 
<a name="l00474"></a><a class="code" href="cpphash_c.html#a14">00474</a> HASHNODE *<a class="code" href="cpphash_c.html#a14">cppReader_installMacro</a> (<font class="keywordtype">char</font> *name, <font class="keywordtype">int</font> len, 
00475                                   <font class="keyword">struct</font> definition *defn, <font class="keywordtype">int</font> hash)<font class="keyword"></font>
00476 <font class="keyword"></font>{
00477   <font class="keywordflow">return</font> <a class="code" href="cpphash_c.html#a13">cppReader_install</a> (name, len, T_MACRO, 0, (<font class="keywordtype">char</font>  *) defn, hash);
00478 }
00479 
00480 <font class="keywordtype">void</font>
<a name="l00481"></a><a class="code" href="cpphash_c.html#a15">00481</a> <a class="code" href="cpphash_c.html#a15">cppReader_hashCleanup</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
00482 <font class="keyword"></font>{
00483   <font class="keywordtype">int</font> i;
00484 
00485   <font class="keywordflow">for</font> (i = CPP_HASHSIZE; --i &gt;= 0; )
00486     {
00487       <font class="keywordflow">while</font> (hashtab[i] != NULL)
00488         {
00489           <a class="code" href="cpphash_c.html#a12">cppReader_deleteMacro</a> (hashtab[i]);
00490         }
00491     }
00492 }
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:39 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
