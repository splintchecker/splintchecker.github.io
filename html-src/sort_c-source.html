<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sort.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:43 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>sort.c</h1><a href="sort_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** sort.c</font>
00026 <font class="comment">**</font>
00027 <font class="comment">** sort abstraction</font>
00028 <font class="comment">**</font>
00029 <font class="comment">**      NOTE: The structure of this module follows a similar one</font>
00030 <font class="comment">**            used in the previous LCL checker.  However, all other</font>
00031 <font class="comment">**            details are quite different.</font>
00032 <font class="comment">**</font>
00033 <font class="comment">**  AUTHOR:</font>
00034 <font class="comment">**      Yang Meng Tan,</font>
00035 <font class="comment">**         Massachusetts Institute of Technology</font>
00036 <font class="comment">*/</font>
00037 
00038 <font class="preprocessor"># include "lclintMacros.nf"</font>
00039 <font class="preprocessor"># include "llbasic.h"</font>
00040 <font class="preprocessor"># include "llgrammar.h"</font>
00041 <font class="preprocessor"># include "lclscan.h"</font>
00042 
00043 <font class="comment">/*@+ignorequals@*/</font>
00044 
00045 <font class="keyword">static</font> lsymbol newStructTag (<font class="keywordtype">void</font>) <font class="comment">/*@*/</font> ;
00046 <font class="keyword">static</font> lsymbol newEnumTag (<font class="keywordtype">void</font>) <font class="comment">/*@*/</font> ;
00047 <font class="keyword">static</font> lsymbol newUnionTag (<font class="keywordtype">void</font>) <font class="comment">/*@*/</font> ;
00048 
00049 <font class="comment">/*@constant static int MAXBUFFLEN; @*/</font>
<a name="l00050"></a><a class="code" href="sort_c.html#a0">00050</a> <font class="preprocessor"># define MAXBUFFLEN 1024</font>
00051 <font class="preprocessor"></font>
00052 <font class="comment">/*@constant static int DELTA; @*/</font>
<a name="l00053"></a><a class="code" href="sort_c.html#a1">00053</a> <font class="preprocessor"># define DELTA 100</font>
00054 <font class="preprocessor"></font>
00055 <font class="comment">/*@constant static int NOSORTHANDLE; @*/</font>
<a name="l00056"></a><a class="code" href="sort_c.html#a2">00056</a> <font class="preprocessor"># define NOSORTHANDLE 0</font>
00057 <font class="preprocessor"></font>
00058 <font class="comment">/*@constant static int HOFSORTHANDLE; @*/</font>
<a name="l00059"></a><a class="code" href="sort_c.html#a3">00059</a> <font class="preprocessor"># define HOFSORTHANDLE 1</font>
00060 <font class="preprocessor"></font>
00061 <font class="comment">/* local routines */</font>
00062 
00063 <font class="keyword">static</font> <font class="keywordtype">void</font> sort_addTupleMembers (sort p_tupleSort, sort p_strSort)  
00064    <font class="comment">/*@modifies internalState@*/</font> ;
00065 
00066 <font class="keyword">static</font> <font class="keywordtype">bool</font> sort_isNewEntry (sortNode p_s) <font class="comment">/*@*/</font> ;  
00067 
00068 <font class="keyword">static</font> sort sort_enterNew (<font class="comment">/*@special@*/</font> sortNode p_s) 
00069    <font class="comment">/*@uses p_s.kind, p_s.name, p_s.members@*/</font>
00070    <font class="comment">/*@releases p_s.members@*/</font>
00071    <font class="comment">/*@modifies internalState@*/</font> ;
00072 
00073 <font class="keyword">static</font> sort sort_enterGlobal (sortNode p_s) <font class="comment">/*@modifies internalState@*/</font> ;
00074 
00075 <font class="keyword">static</font> sort sort_enterNewForce (<font class="comment">/*@special@*/</font> sortNode p_s) 
00076    <font class="comment">/*@uses p_s.kind, p_s.name, p_s.members@*/</font>
00077    <font class="comment">/*@releases p_s.members@*/</font>
00078    <font class="comment">/*@modifies internalState@*/</font> ;
00079 
00080 <font class="keyword">static</font> <font class="keywordtype">void</font> genPtrOps (sort p_baseSort, sort p_ptrSort, sort p_arraySort);
00081 <font class="keyword">static</font> <font class="keywordtype">void</font> genArrOps (sort p_baseSort, sort p_arraySort, <font class="keywordtype">int</font> p_dim,
00082                        sort p_vecSort);
00083 <font class="keyword">static</font> <font class="keywordtype">void</font> genVecOps (sort p_baseSort, sort p_vecSort, <font class="keywordtype">int</font> p_dim);
00084 <font class="keyword">static</font> <font class="keywordtype">void</font> genTupleOps (sort p_tupleSort);
00085 <font class="keyword">static</font> <font class="keywordtype">void</font> genUnionOps (sort p_tupleSort);
00086 <font class="keyword">static</font> <font class="keywordtype">void</font> genStrOps (sort p_strSort, sort p_tupleSort);
00087 <font class="keyword">static</font> <font class="keywordtype">void</font> genEnumOps (sort p_enumSort);
00088 
00089 <font class="keyword">static</font> <font class="keywordtype">void</font> overloadPtrFcns (sort p_ptrSort);
00090 <font class="keyword">static</font> <font class="keywordtype">void</font> overloadIsSub (sort p_s, <font class="keywordtype">int</font> p_dim);
00091 <font class="keyword">static</font> <font class="keywordtype">void</font> overloadSizeof (sort p_domainSort);
00092 
00093 <font class="comment">/*@observer@*/</font> <font class="keyword">static</font> cstring sort_unparseKind (sortKind p_k) <font class="comment">/*@*/</font> ;
00094 
00095 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> cstring
00096   sort_unparseKindName (sortNode p_s) <font class="comment">/*@*/</font> ;
00097 
00098 <font class="keyword">static</font> lsymbol
00099   sortTag_toSymbol (<font class="keywordtype">char</font> *p_kind, ltoken p_tagid, <font class="comment">/*@out@*/</font> <font class="keywordtype">bool</font> *p_isNew);
00100 
00101 <font class="keyword">static</font> <font class="keywordtype">void</font> 
00102   overloadUnaryTok (<font class="comment">/*@only@*/</font> nameNode p_nn, 
00103                     sort p_domainSort, <font class="comment">/*@only@*/</font> ltoken p_range);
00104 <font class="keyword">static</font> <font class="keywordtype">void</font> 
00105   overloadUnary (<font class="comment">/*@only@*/</font> nameNode p_nn, 
00106                  sort p_domainSort, sort p_rangeSort);
00107 <font class="keyword">static</font> <font class="keywordtype">void</font> 
00108   overloadBinary (<font class="comment">/*@only@*/</font> nameNode p_nn, 
00109                   sort p_s, <font class="comment">/*@only@*/</font> ltoken p_dTok, sort p_rs);
00110 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> nameNode makeFieldOp (lsymbol p_field);
00111 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> nameNode makeArrowFieldOp (lsymbol p_field);
00112 
00113 <font class="preprocessor"># undef sp</font>
00114 <font class="preprocessor"></font><font class="keyword">static</font> lsymbol sp (lsymbol p_s1, lsymbol p_s2);
00115 <font class="keyword">static</font> <font class="keywordtype">void</font> sortError (ltoken p_t, sort p_oldsort, sortNode p_newnode);
00116 
00117 <font class="comment">/*@-namechecks@*/</font>
<a name="l00118"></a><a class="code" href="sort_c.html#a5">00118</a> sort sort_bool;
<a name="l00119"></a><a class="code" href="sort_c.html#a6">00119</a> sort sort_capBool;
<a name="l00120"></a><a class="code" href="sort_c.html#a7">00120</a> sort sort_int;
<a name="l00121"></a><a class="code" href="sort_c.html#a8">00121</a> sort sort_char;
<a name="l00122"></a><a class="code" href="sort_c.html#a9">00122</a> sort sort_float;
<a name="l00123"></a><a class="code" href="sort_c.html#a10">00123</a> sort sort_double;
<a name="l00124"></a><a class="code" href="sort_c.html#a11">00124</a> sort sort_cstring;
00125 <font class="comment">/*@=namechecks@*/</font>
00126 
00127 <font class="keyword">static</font> sort sort_void;
00128 <font class="keyword">static</font> sort char_obj_ptrSort;
00129 <font class="keyword">static</font> sort char_obj_ArrSort;
00130 
00131 <font class="comment">/* This is used to uniqueize sort names, for anonymous C types */</font>
00132 <font class="keyword">static</font> <font class="keywordtype">int</font> sortUID = 1;
00133 
00134 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> sortNode *sortTable = (sortNode *) 0;
00135 <font class="keyword">static</font> <font class="keywordtype">int</font> sortTableSize = 0;
00136 <font class="keyword">static</font> <font class="keywordtype">int</font> sortTableAlloc = 0;
00137 
00138 <font class="comment">/* Important to keep sorts in some order because importing routines</font>
00139 <font class="comment">for sorts rely on this order to ensure that when we encounter a sort</font>
00140 <font class="comment">S1 that is based on sort S2, S2 is before S1 in the imported file. */</font>
00141 
00142 <font class="keyword">static</font> <font class="keywordtype">bool</font> exporting = TRUE;
00143 
00144 <font class="keyword">static</font> lsymbol underscoreSymbol;
00145 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> ltoken intToken;
00146 
00147 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode arrayRefNameNode;
00148 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode ptr2arrayNameNode;
00149 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode deRefNameNode;
00150 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode nilNameNode;
00151 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode plusNameNode;
00152 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode minusNameNode;
00153 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode condNameNode;
00154 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode eqNameNode;
00155 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> nameNode neqNameNode;
00156 
00157 <font class="keyword">static</font> sortNode noSort;
00158 
00159 <font class="keyword">static</font> sortNode HOFSort =
00160 { 
00161   SRT_HOF, 
00162   HOFSORTHANDLE,
00163   lsymbol_undefined,
00164   lsymbol_undefined,
00165   FALSE, <font class="comment">/* was lsymbolNULL */</font>
00166   NOSORTHANDLE,
00167   NOSORTHANDLE,
00168   smemberInfo_undefined,
00169   FALSE,
00170   FALSE,
00171   FALSE, 
00172   FALSE
00173 };
00174 
00175 <font class="keyword">static</font> ob_mstring sortKindName[] =
00176 {
00177   <font class="stringliteral">"FIRSTSORT"</font>, <font class="stringliteral">"NOSORT"</font>, <font class="stringliteral">"HOFSORT"</font>,
00178   <font class="stringliteral">"PRIMITIVE"</font>, <font class="stringliteral">"SYNONYM"</font>, <font class="stringliteral">"POINTER"</font>, <font class="stringliteral">"OBJ"</font>, <font class="stringliteral">"ARRAY"</font>, <font class="stringliteral">"VECTOR"</font>,
00179   <font class="stringliteral">"STRUCT"</font>, <font class="stringliteral">"TUPLE"</font>, <font class="stringliteral">"UNION"</font>, <font class="stringliteral">"UNIONVAL"</font>, <font class="stringliteral">"ENUM"</font>, <font class="stringliteral">"LASTSORT"</font>
00180 } ;
00181 
00182 <font class="keyword">static</font> <font class="keywordtype">void</font> smemberInfo_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> smemberInfo *mem)<font class="keyword"></font>
00183 <font class="keyword"></font>{
00184   <a class="code" href="general_c.html#a0">sfree</a> (mem);
00185 }
00186 
00187 <font class="keyword">static</font> <font class="keywordtype">void</font> sortNode_free (<font class="comment">/*@special@*/</font> sortNode sn)
00188    <font class="comment">/*@uses sn.members@*/</font>
00189    <font class="comment">/*@releases sn.members@*/</font>
00190 {
00191   smemberInfo_free (sn.members);
00192 }
00193 
00194 <font class="keywordtype">void</font>
<a name="l00195"></a><a class="code" href="sort_c.html#a64">00195</a> <a class="code" href="sort_c.html#a64">sort_destroyMod</a> (<font class="keywordtype">void</font>)
00196    <font class="comment">/*@globals killed sortTable, killed arrayRefNameNode,</font>
00197 <font class="comment">              killed ptr2arrayNameNode,killed deRefNameNode,</font>
00198 <font class="comment">              killed nilNameNode, killed plusNameNode,</font>
00199 <font class="comment">              killed minusNameNode, killed condNameNode,</font>
00200 <font class="comment">              killed eqNameNode, killed neqNameNode @*/</font>
00201 {
00202   <font class="keywordflow">if</font> (sortTable != NULL)  
00203     {
00204       <font class="keywordtype">int</font> i;
00205 
00206       <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
00207         {
00208           sortNode_free (sortTable[i]);
00209         }
00210 
00211       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (arrayRefNameNode);
00212       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (ptr2arrayNameNode);
00213       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (deRefNameNode);
00214       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (nilNameNode);
00215       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (plusNameNode);
00216       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (minusNameNode);
00217       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (condNameNode);
00218       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (eqNameNode);
00219       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (neqNameNode);
00220 
00221       <a class="code" href="general_c.html#a0">sfree</a> (sortTable);
00222       <font class="comment">/*@-branchstate@*/</font>
00223     }
00224 } <font class="comment">/*@=branchstate@*/</font>
00225 
00226 sort
<a name="l00227"></a><a class="code" href="sort_c.html#a65">00227</a> <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
00228 <font class="keyword"></font>{
00229   <font class="keywordflow">return</font> NOSORTHANDLE;
00230 }
00231 
00232 sort
<a name="l00233"></a><a class="code" href="sort_c.html#a66">00233</a> <a class="code" href="sort_c.html#a66">sort_makeHOFSort</a> (sort base)<font class="keyword"></font>
00234 <font class="keyword"></font>{
00235   sortNode outSort;
00236   sort handle;
00237 
00238   outSort.kind = SRT_HOF;
00239   outSort.name = <a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"_HOF_sort_%d"</font>, sortTableSize));
00240   outSort.tag = lsymbol_undefined;
00241   outSort.baseSort = base;
00242   outSort.objSort = NOSORTHANDLE;
00243   outSort.members = smemberInfo_undefined;
00244   outSort.export = exporting;
00245   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00246   outSort.mutable = FALSE;
00247   outSort.abstract = FALSE;
00248 
00249   llassert (sortTable != NULL);
00250 
00251   outSort.handle = handle = sortTableSize;
00252   sortTable[handle] = outSort;
00253 
00254   sortTableSize++;
00255   <font class="keywordflow">return</font> handle;
00256 }
00257 
00258 <font class="keyword">static</font> sort
00259 sort_construct (lsymbol name, sortKind kind, sort baseSort,
00260                 lsymbol tagName,
00261                 <font class="keywordtype">bool</font> mut, sort objSort, <font class="comment">/*@null@*/</font> smemberInfo *members)<font class="keyword"></font>
00262 <font class="keyword"></font>{
00263   sortNode outSort;
00264   sort handle;
00265 
00266   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00267 
00268   outSort.kind = kind;
00269   outSort.name = name;
00270   outSort.tag = tagName;
00271   outSort.realtag = TRUE; 
00272   outSort.baseSort = baseSort;
00273   outSort.objSort = objSort;
00274   outSort.members = members;
00275   outSort.mutable = mut;
00276   outSort.export = exporting;
00277   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00278   outSort.abstract = FALSE;
00279   outSort.handle = handle;
00280 
00281   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00282     {
00283       outSort.handle = handle = sort_enterNew (outSort);
00284       <font class="keywordflow">return</font> handle;
00285     }
00286   <font class="keywordflow">else</font>
00287     {
00288       llassert (sortTable != NULL);
00289 
00290       <font class="keywordflow">if</font> (sortTable[handle].kind != kind)
00291         {
00292           sortError (ltoken_undefined, handle, outSort);
00293           smemberInfo_free (outSort.members);
00294 
00295           <font class="keywordflow">return</font> handle;
00296         }
00297       <font class="keywordflow">else</font>
00298         {
00299           <font class="comment">/* evs --- added 11 Mar 1994</font>
00300 <font class="comment">          ** the new entry should supercede the old one, since</font>
00301 <font class="comment">          ** it could be a forward reference to a struct, etc.</font>
00302 <font class="comment">          */</font>
00303 
00304           sortTable[handle] = outSort;
00305           <font class="keywordflow">return</font> handle;
00306         }
00307     }
00308 }
00309 
00310 <font class="keyword">static</font> sort
00311   sort_constructAbstract (lsymbol name, <font class="keywordtype">bool</font> mut, sort baseSort)<font class="keyword"></font>
00312 <font class="keyword"></font>{
00313   sortNode outSort;
00314   sortKind kind;
00315   sort handle;
00316 
00317   <font class="keywordflow">if</font> (mut)
00318     kind = SRT_OBJ;
00319   <font class="keywordflow">else</font>
00320     kind = SRT_PRIM;
00321 
00322   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00323   outSort.kind = kind;
00324   outSort.name = name;
00325   outSort.tag = lsymbol_undefined;
00326   outSort.baseSort = baseSort;
00327   outSort.objSort = NOSORTHANDLE;
00328   outSort.members = smemberInfo_undefined;
00329   outSort.mutable = mut;
00330   outSort.export = exporting;
00331   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00332   outSort.abstract = TRUE;
00333   outSort.handle = handle;
00334 
00335   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00336     {
00337       outSort.handle = handle = sort_enterNew (outSort);
00338       <font class="comment">/* do not make sort operators. */</font>
00339     }
00340   <font class="keywordflow">else</font>
00341     {
00342       llassert (sortTable != NULL);
00343 
00344       <font class="keywordflow">if</font> (sortTable[handle].kind != kind)
00345         {
00346           sortError (ltoken_undefined, handle, outSort);
00347         }
00348 
00349       smemberInfo_free (outSort.members);
00350     }
00351 
00352   <font class="keywordflow">return</font> handle;
00353 }
00354 
00355 sort
<a name="l00356"></a><a class="code" href="sort_c.html#a69">00356</a> <a class="code" href="sort_c.html#a69">sort_makeSort</a> (<font class="comment">/*@unused@*/</font> ltoken t, lsymbol n)<font class="keyword"></font>
00357 <font class="keyword"></font>{
00358   <font class="comment">/*</font>
00359 <font class="comment">  ** Expects n to be a new sort.</font>
00360 <font class="comment">  ** Generate a sort with the given name.  Useful for LSL sorts. </font>
00361 <font class="comment">  */</font>
00362 
00363   sort handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (n);
00364 
00365   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00366     {
00367       sortNode outSort;
00368 
00369       outSort.handle = handle;      
00370       outSort.kind = SRT_PRIM;
00371       outSort.name = n;
00372       outSort.tag = lsymbol_undefined;
00373       outSort.baseSort = NOSORTHANDLE;
00374       outSort.objSort = NOSORTHANDLE;
00375       outSort.members = smemberInfo_undefined;
00376       outSort.export = exporting;
00377       outSort.mutable = FALSE;
00378       outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00379       outSort.abstract = FALSE;
00380 
00381       <font class="comment">/* Put into sort table, sort_enter checks for duplicates. */</font>
00382       outSort.handle = handle = sort_enterNew (outSort);
00383     }
00384   <font class="keywordflow">else</font>
00385     {
00386       <font class="comment">/* don't override old info */</font>
00387      ;
00388     }
00389 
00390   <font class="keywordflow">return</font> handle;
00391 }
00392 
00393 <font class="keyword">static</font> sort
00394 sort_makeSortNoOps (<font class="comment">/*@unused@*/</font> ltoken t, lsymbol n) <font class="comment">/*@modifies internalState@*/</font> 
00395 {
00396   sort handle;
00397   
00398   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (n);
00399 
00400   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00401     {
00402       sortNode outSort;
00403 
00404       outSort.handle = handle;
00405       outSort.kind = SRT_PRIM;
00406       outSort.name = n;
00407       outSort.tag = lsymbol_undefined;
00408       outSort.baseSort = NOSORTHANDLE;
00409       outSort.objSort = NOSORTHANDLE;
00410       outSort.members = smemberInfo_undefined;
00411       outSort.export = exporting;
00412       outSort.mutable = FALSE;
00413       outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00414       outSort.abstract = FALSE;
00415       <font class="comment">/* Put into sort table, sort_enter checks for duplicates. */</font>
00416       outSort.handle = handle = sort_enterNew (outSort);
00417     }                           <font class="comment">/* don't override old info */</font>
00418 
00419   <font class="keywordflow">return</font> handle;
00420 }
00421 
00422 <font class="keyword">static</font> sort
00423 sort_makeLiteralSort (ltoken t, lsymbol n) 
00424    <font class="comment">/*@modifies internalState@*/</font>
00425 {
00426   <font class="comment">/*</font>
00427 <font class="comment">  ** Like sort_makeSort, in addition, generate sizeof operator </font>
00428 <font class="comment">  ** t not currently used, may be useful for generating error msgs later </font>
00429 <font class="comment">  ** Also useful for abstract types, need sizeof operator.</font>
00430 <font class="comment">  */</font>
00431 
00432   sort handle = <a class="code" href="sort_c.html#a69">sort_makeSort</a> (t, n);
00433 
00434   overloadSizeof (handle);
00435   <font class="keywordflow">return</font> handle;
00436 }
00437 
00438 sort
<a name="l00439"></a><a class="code" href="sort_c.html#a72">00439</a> <a class="code" href="sort_c.html#a72">sort_makeSyn</a> (ltoken t, sort s, lsymbol n)<font class="keyword"></font>
00440 <font class="keyword"></font>{
00441   <font class="comment">/* make a synonym sort with name n that is == to sort s */</font>
00442   <font class="comment">/* expect n to be a new sort name */</font>
00443   sortNode outSort;
00444   sort handle;
00445   <font class="comment">/* must not clash with any LSL sorts */</font>
00446   lsymbol newname = sp (underscoreSymbol, n);
00447   
00448   <font class="keywordflow">if</font> (n == lsymbol_undefined)
00449     {
00450       llbuglit (<font class="stringliteral">"sort_makeSyn: synonym must have name"</font>);
00451     }
00452 
00453   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (newname);
00454 
00455   outSort.kind = SRT_SYN;
00456   outSort.name = newname;
00457   outSort.baseSort = s;
00458   outSort.objSort = NOSORTHANDLE;
00459   <font class="comment">/* info is not duplicated */</font>
00460   outSort.tag = lsymbol_undefined;
00461   outSort.members = smemberInfo_undefined;
00462   outSort.export = exporting;
00463   outSort.mutable = FALSE;
00464   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00465   outSort.abstract = FALSE;
00466   outSort.handle = handle;
00467 
00468   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00469     {
00470       outSort.handle = handle = sort_enterNew (outSort);
00471       <font class="comment">/* No operators to generate for synonyms */</font>
00472     }
00473   <font class="keywordflow">else</font>
00474     {
00475       llassert (sortTable != NULL);
00476       
00477       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_SYN)
00478         {
00479           sortError (t, handle, outSort);
00480         }
00481 
00482       smemberInfo_free (outSort.members);
00483     }
00484 
00485   <font class="keywordflow">return</font> handle;
00486 }
00487 
00488 sort
<a name="l00489"></a><a class="code" href="sort_c.html#a73">00489</a> <a class="code" href="sort_c.html#a73">sort_makeFormal</a> (sort insort)<font class="keyword"></font>
00490 <font class="keyword"></font>{
00491   sortNode s;
00492   sort sor, handle;
00493 
00494   sor = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (insort);
00495   handle = sor;
00496   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (sor);
00497 
00498   <font class="keywordflow">switch</font> (s.kind)
00499     {
00500     <font class="keywordflow">case</font> SRT_STRUCT:
00501       handle = <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken_undefined, sor);
00502       <font class="keywordflow">break</font>;
00503     <font class="keywordflow">case</font> SRT_UNION:
00504       handle = <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken_undefined, sor);
00505       <font class="keywordflow">break</font>;
00506     <font class="keywordflow">default</font>:
00507       <font class="keywordflow">break</font>;
00508     }
00509 
00510   <font class="keywordflow">return</font> handle;
00511 }
00512 
00513 sort
<a name="l00514"></a><a class="code" href="sort_c.html#a74">00514</a> <a class="code" href="sort_c.html#a74">sort_makeGlobal</a> (sort insort)<font class="keyword"></font>
00515 <font class="keyword"></font>{
00516   <font class="comment">/* Make a Obj if not an array or a struct */</font>
00517   sortNode s;
00518   sort sor, handle;
00519   sor = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (insort);
00520   handle = sor;
00521   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (sor);
00522 
00523   <font class="keywordflow">switch</font> (s.kind)
00524     {
00525     <font class="keywordflow">case</font> SRT_ARRAY:
00526     <font class="keywordflow">case</font> SRT_STRUCT:
00527     <font class="keywordflow">case</font> SRT_UNION:
00528     <font class="keywordflow">case</font> SRT_HOF:
00529     <font class="keywordflow">case</font> SRT_NONE:
00530       <font class="keywordflow">break</font>;
00531     <font class="keywordflow">case</font> SRT_VECTOR:
00532     <font class="keywordflow">case</font> SRT_TUPLE:
00533     <font class="keywordflow">case</font> SRT_UNIONVAL:
00534       llcontbuglit (<font class="stringliteral">"sort_makeGlobal: can't make vectors, tuples, or unionvals global"</font>);
00535       <font class="keywordflow">break</font>;
00536     <font class="keywordflow">default</font>:
00537       handle = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (sor);
00538       <font class="keywordflow">break</font>;
00539     }
00540   <font class="keywordflow">return</font> handle;
00541 }
00542 
00543 sort
<a name="l00544"></a><a class="code" href="sort_c.html#a75">00544</a> <a class="code" href="sort_c.html#a75">sort_makeObj</a> (sort sor)<font class="keyword"></font>
00545 <font class="keyword"></font>{
00546   sortNode baseSortNode, outSort;
00547   sort baseSort, handle;
00548   lsymbol name;
00549 
00550  <font class="comment">/* skip the synonym sort */</font>
00551   baseSort = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (sor);
00552   baseSortNode = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (baseSort);
00553   <font class="keywordflow">switch</font> (baseSortNode.kind)
00554     {
00555     <font class="keywordflow">case</font> SRT_HOF:
00556     <font class="keywordflow">case</font> SRT_NONE:
00557       <font class="keywordflow">return</font> baseSort;
00558     <font class="keywordflow">case</font> SRT_VECTOR:
00559       <font class="keywordflow">if</font> (baseSortNode.objSort != 0)
00560         <font class="keywordflow">return</font> baseSortNode.objSort;
00561       <font class="keywordflow">else</font>                      <font class="comment">/* must have well-defined objSort field */</font>
00562         {
00563           llcontbuglit (<font class="stringliteral">"sort_makeObj: Inconsistent vector reps:invalid objSort field"</font>);
00564           <font class="keywordflow">return</font> baseSort;
00565         }
00566     <font class="keywordflow">case</font> SRT_TUPLE:
00567     <font class="keywordflow">case</font> SRT_UNIONVAL:
00568      <font class="comment">/* need to map *_Struct_Tuple to *_Struct and *_Union_UnionVal to</font>
00569 <font class="comment">      *_Union, according to sort naming conventions */</font>
00570       <font class="keywordflow">if</font> (baseSortNode.baseSort != NOSORTHANDLE)
00571        <font class="comment">/* for tuples and unionvals, baseSort field keeps the map from</font>
00572 <font class="comment">          value sort to obj sort. */</font>
00573         <font class="keywordflow">return</font> baseSortNode.baseSort;
00574       <font class="keywordflow">else</font>                      <font class="comment">/* valid tuples and unionvals must have baseSort fields */</font>
00575         {
00576           llcontbuglit (<font class="stringliteral">"sort_makeObj: Inconsistent tuples or unionvals reps: invalid baseSort field"</font>);
00577           <font class="keywordflow">return</font> baseSort;
00578         }
00579     <font class="keywordflow">default</font>:
00580       name = sp (sp (underscoreSymbol, sort_getLsymbol (baseSort)),
00581                  <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Obj"</font>));
00582       handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00583 
00584       outSort.kind = SRT_OBJ;
00585       <font class="comment">/* must not clash with any LSL sorts */</font>
00586       outSort.name = name;
00587       outSort.tag = lsymbol_undefined;
00588       outSort.baseSort = baseSort;
00589       outSort.objSort = NOSORTHANDLE;
00590       outSort.members = smemberInfo_undefined;
00591       outSort.mutable = TRUE;
00592       outSort.export = exporting;
00593       outSort.abstract = FALSE;
00594       outSort.handle = handle;
00595       outSort.imported = TRUE;
00596 
00597       <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00598         {
00599           <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00600             {
00601               outSort.handle = handle = sort_enterNew (outSort);
00602             }
00603           <font class="keywordflow">else</font>
00604             {
00605               outSort.handle = handle = sort_enterNew (outSort);
00606             }
00607         }
00608       <font class="keywordflow">else</font>
00609         {
00610           llassert (sortTable != NULL);
00611 
00612           <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_OBJ)
00613             {
00614               sortError (ltoken_undefined, handle, outSort);
00615             }
00616 
00617           smemberInfo_free (outSort.members);
00618         }
00619 
00620       <font class="keywordflow">return</font> handle;
00621     }
00622 }
00623 
00624 sort
<a name="l00625"></a><a class="code" href="sort_c.html#a76">00625</a> <a class="code" href="sort_c.html#a76">sort_makePtr</a> (ltoken t, sort baseSort)<font class="keyword"></font>
00626 <font class="keyword"></font>{
00627   sortNode s, outSort;
00628   sort handle, arrayHandle;
00629   lsymbol name;
00630 
00631   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (baseSort);
00632 
00633   <font class="keywordflow">if</font> (s.kind == SRT_HOF)
00634     {
00635       <font class="keywordflow">return</font> baseSort;
00636     }
00637   <font class="keywordflow">if</font> (s.kind == SRT_NONE)
00638     {
00639       <font class="keywordflow">return</font> baseSort;
00640     }
00641 
00642   <font class="keywordflow">if</font> (s.kind != SRT_ARRAY &amp;&amp; s.kind != SRT_STRUCT &amp;&amp;
00643       s.kind != SRT_UNION)
00644     <font class="comment">/* &amp;&amp; s.kind != SRT_OBJ) */</font>
00645     <font class="comment">/* base is not an SRT_ARRAY, struct or union.  Need to insert a obj. */</font>
00646     baseSort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (baseSort);
00647   
00648   name = sp (sp (underscoreSymbol, sort_getLsymbol (baseSort)),
00649              <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Ptr"</font>));
00650   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00651   
00652   outSort.kind = SRT_PTR;
00653   outSort.name = name;
00654   outSort.tag = lsymbol_undefined;
00655   outSort.baseSort = baseSort;
00656   outSort.objSort = NOSORTHANDLE;
00657   outSort.members = smemberInfo_undefined;
00658   outSort.mutable = FALSE;
00659   outSort.export = exporting;
00660   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00661   outSort.abstract = FALSE;
00662   outSort.handle = handle;
00663   
00664   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00665     {
00666       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00667         {
00668           outSort.handle = handle = sort_enterNew (outSort);
00669           arrayHandle = <a class="code" href="sort_c.html#a78">sort_makeArr</a> (t, baseSort);
00670           genPtrOps (baseSort, handle, arrayHandle);
00671         }
00672       <font class="keywordflow">else</font>
00673         {
00674           outSort.handle = handle = sort_enterNew (outSort);
00675         }
00676     }
00677   <font class="keywordflow">else</font>
00678     {
00679       llassert (sortTable != NULL);
00680 
00681       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_PTR)
00682         {
00683           sortError (t, handle, outSort);
00684         }
00685       smemberInfo_free (outSort.members);
00686     }
00687   <font class="keywordflow">return</font> handle;
00688 }
00689 
00690 sort
<a name="l00691"></a><a class="code" href="sort_c.html#a77">00691</a> <a class="code" href="sort_c.html#a77">sort_makePtrN</a> (sort s, <font class="keywordtype">int</font> pointers)<font class="keyword"></font>
00692 <font class="keyword"></font>{
00693   llassert (pointers &gt;= 0);
00694 
00695   <font class="keywordflow">if</font> (pointers == 0)
00696     {
00697       <font class="keywordflow">return</font> s;
00698     }
00699   <font class="keywordflow">else</font>
00700     {
00701       <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a77">sort_makePtrN</a> (sort_makePtr (ltoken_undefined, s), 
00702                             pointers - 1);
00703     }
00704 }
00705 
00706 sort
<a name="l00707"></a><a class="code" href="sort_c.html#a78">00707</a> <a class="code" href="sort_c.html#a78">sort_makeArr</a> (ltoken t, sort baseSort)<font class="keyword"></font>
00708 <font class="keyword"></font>{
00709   sortNode s, outSort, old;
00710   sort handle, vecHandle;
00711   <font class="keywordtype">int</font> dim;
00712   lsymbol name;
00713 
00714   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (baseSort);
00715 
00716   <font class="keywordflow">if</font> (s.kind == SRT_HOF)
00717     <font class="keywordflow">return</font> baseSort;
00718   <font class="keywordflow">if</font> (s.kind == SRT_NONE)
00719     <font class="keywordflow">return</font> baseSort;
00720 
00721   <font class="keywordflow">if</font> (s.kind != SRT_ARRAY &amp;&amp; s.kind != SRT_STRUCT &amp;&amp;
00722       s.kind != SRT_UNION &amp;&amp; s.kind != SRT_OBJ)
00723    <font class="comment">/* base is not an array, struct or obj.  Need to insert a Obj. */</font>
00724     baseSort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (baseSort);
00725 
00726   name = sp (sp (underscoreSymbol, sort_getLsymbol (baseSort)),
00727              <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Arr"</font>));
00728   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00729 
00730  <font class="comment">/* must not clash with any LSL sorts */</font>
00731   outSort.name = name;
00732   outSort.kind = SRT_ARRAY;
00733   outSort.baseSort = baseSort;
00734   outSort.objSort = NOSORTHANDLE;
00735   outSort.members = smemberInfo_undefined;
00736   outSort.mutable = TRUE;
00737   outSort.export = exporting;
00738   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00739   outSort.abstract = FALSE;
00740   outSort.handle = handle;
00741   
00742   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00743     {
00744       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00745         {
00746           outSort.handle = handle = sort_enterNew (outSort);
00747 
00748           <font class="keywordflow">for</font> (old = outSort, dim = 0;
00749                old.kind == SRT_ARRAY;
00750                dim++, old = <a class="code" href="sort_c.html#a94">sort_lookup</a> (old.baseSort))
00751             {
00752               ;
00753             }
00754 
00755           vecHandle = <a class="code" href="sort_c.html#a79">sort_makeVec</a> (t, handle);
00756           genArrOps (baseSort, handle, dim, vecHandle);
00757         }
00758       <font class="keywordflow">else</font>
00759         {
00760           outSort.handle = handle = sort_enterNew (outSort);
00761         }
00762     }
00763   <font class="keywordflow">else</font>
00764     {
00765       llassert (sortTable != NULL);
00766 
00767       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_ARRAY)
00768         {
00769           sortError (t, handle, outSort);
00770         }
00771 
00772       smemberInfo_free (outSort.members);
00773     }
00774 
00775   <font class="keywordflow">return</font> handle;
00776 }
00777 
00778 sort
<a name="l00779"></a><a class="code" href="sort_c.html#a79">00779</a> <a class="code" href="sort_c.html#a79">sort_makeVec</a> (ltoken t, sort arraySort)<font class="keyword"></font>
00780 <font class="keyword"></font>{
00781   sortNode s, outSort, old;
00782   sort baseSort, handle, elementSort;
00783   <font class="keywordtype">int</font> dim;                      <font class="comment">/* array dimension count. */</font>
00784   lsymbol name;
00785 
00786   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (arraySort);
00787 
00788   <font class="keywordflow">if</font> (s.kind == SRT_HOF)
00789     <font class="keywordflow">return</font> arraySort;
00790   <font class="keywordflow">if</font> (s.kind == SRT_NONE)
00791     <font class="keywordflow">return</font> arraySort;
00792 
00793   <font class="keywordflow">if</font> (s.kind != SRT_ARRAY)
00794     {
00795       llbug (message (<font class="stringliteral">"sort_makeVec: only arrays can become vectors: given sort is %s"</font>,
00796                       sort_unparseKind (s.kind)));
00797     }
00798 
00799   <font class="keywordflow">if</font> (s.baseSort == NOSORTHANDLE)
00800     llbuglit (<font class="stringliteral">"sort_makeVec: arrays must have base (element) sort"</font>);
00801 
00802  <font class="comment">/* Vectors return "values", so make array elements values. */</font>
00803 
00804   baseSort = s.baseSort;
00805   elementSort = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (baseSort);
00806 
00807   name = sp (sp (underscoreSymbol, sort_getLsymbol (elementSort)),
00808              <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Vec"</font>));
00809   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00810 
00811   outSort.baseSort = elementSort;
00812   outSort.name = name;
00813   outSort.objSort = arraySort;
00814   outSort.kind = SRT_VECTOR;
00815   outSort.members = smemberInfo_undefined;
00816   outSort.mutable = FALSE;
00817   outSort.export = exporting;
00818   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00819   outSort.abstract = FALSE;
00820   outSort.handle = handle;
00821 
00822   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00823     {
00824       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00825         {
00826           outSort.handle = handle = sort_enterNew (outSort);
00827 
00828           <font class="keywordflow">for</font> (old = outSort, dim = 0;
00829                old.kind == SRT_VECTOR;
00830                dim++, old = <a class="code" href="sort_c.html#a94">sort_lookup</a> (old.baseSort))
00831             {
00832               ;
00833             }
00834 
00835           genVecOps (elementSort, handle, dim);
00836         }
00837       <font class="keywordflow">else</font>
00838         {
00839           outSort.handle = handle = sort_enterNew (outSort);
00840         }
00841     }
00842   <font class="keywordflow">else</font>
00843     {
00844       llassert (sortTable != NULL);
00845 
00846       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_VECTOR)
00847         {
00848           sortError (t, handle, outSort);
00849         }
00850 
00851       smemberInfo_free (outSort.members);
00852     }
00853 
00854   <font class="keywordflow">return</font> handle;
00855 }
00856 
00857 sort
<a name="l00858"></a><a class="code" href="sort_c.html#a80">00858</a> <a class="code" href="sort_c.html#a80">sort_makeVal</a> (sort sor)<font class="keyword"></font>
00859 <font class="keyword"></font>{
00860   sort retSort = sor;
00861   sortNode rsn, s;
00862 
00863   llassert (sortTable != NULL);
00864   s = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sor);
00865 
00866   <font class="keywordflow">switch</font> (s.kind)
00867     {
00868     <font class="keywordflow">case</font> SRT_PRIM:
00869     <font class="keywordflow">case</font> SRT_ENUM:
00870     <font class="keywordflow">case</font> SRT_PTR:
00871     <font class="keywordflow">case</font> SRT_TUPLE:
00872     <font class="keywordflow">case</font> SRT_UNIONVAL:
00873     <font class="keywordflow">case</font> SRT_VECTOR:
00874     <font class="keywordflow">case</font> SRT_HOF:
00875     <font class="keywordflow">case</font> SRT_NONE:
00876      <font class="comment">/* Do nothing for basic types and pointers. */</font>
00877       retSort = sor;
00878       <font class="keywordflow">break</font>;
00879     <font class="keywordflow">case</font> SRT_SYN:
00880       <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a80">sort_makeVal</a> (sortTable[sor].baseSort);
00881     <font class="keywordflow">case</font> SRT_OBJ:
00882      <font class="comment">/* Strip out the last Obj's */</font>
00883       <font class="keywordflow">if</font> (s.baseSort == NOSORTHANDLE)
00884         {
00885           llbuglit (<font class="stringliteral">"sort_makeVal: expecting a base sort for Obj"</font>);
00886         }
00887       retSort = s.baseSort;
00888       <font class="keywordflow">break</font>;
00889     <font class="keywordflow">case</font> SRT_ARRAY:
00890       retSort = <a class="code" href="sort_c.html#a79">sort_makeVec</a> (ltoken_undefined, sor);
00891       <font class="keywordflow">break</font>;
00892     <font class="keywordflow">case</font> SRT_STRUCT:
00893       retSort = <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken_undefined, sor);
00894       <font class="keywordflow">break</font>;
00895     <font class="keywordflow">case</font> SRT_UNION:
00896       retSort = <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken_undefined, sor);
00897       <font class="keywordflow">break</font>;
00898     <font class="keywordflow">default</font>:
00899       llbuglit (<font class="stringliteral">"sort_makeVal: invalid sort kind"</font>);
00900     }
00901   rsn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (retSort);
00902   <font class="keywordflow">if</font> (rsn.kind == SRT_NONE)
00903     {
00904       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sort_makeVal: invalid return sort kind: %d"</font>, (<font class="keywordtype">int</font>)rsn.kind));
00905     }
00906   <font class="keywordflow">return</font> retSort;
00907 }
00908 
00909 sort
<a name="l00910"></a><a class="code" href="sort_c.html#a81">00910</a> <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (ltoken t, lsymbol name)<font class="keyword"></font>
00911 <font class="keyword"></font>{
00912   sortNode outSort;
00913   sort handle;
00914 
00915   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00916 
00917   outSort.kind = SRT_PRIM;
00918   outSort.name = name;
00919   outSort.baseSort = NOSORTHANDLE;
00920   outSort.objSort = NOSORTHANDLE;
00921   outSort.members = smemberInfo_undefined;
00922   outSort.export = exporting;
00923   outSort.mutable = FALSE;
00924   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00925   outSort.abstract = TRUE;
00926   outSort.handle = handle;
00927 
00928   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00929     {
00930       outSort.handle = handle = sort_enterNew (outSort);
00931       overloadSizeof (handle);
00932     }
00933   <font class="keywordflow">else</font>
00934     {                           <font class="comment">/* complain */</font>
00935       llassert (sortTable != NULL);
00936 
00937       <font class="keywordflow">if</font> ((sortTable[handle].kind != SRT_PRIM) &amp;&amp;
00938           (sortTable[handle].abstract) &amp;&amp;
00939           (!sortTable[handle].mutable))
00940         {
00941           sortError (t, handle, outSort);
00942         }
00943 
00944       smemberInfo_free (outSort.members);
00945     }
00946 
00947   <font class="keywordflow">return</font> handle;
00948 }
00949 
00950 sort
<a name="l00951"></a><a class="code" href="sort_c.html#a82">00951</a> <a class="code" href="sort_c.html#a82">sort_makeMutable</a> (ltoken t, lsymbol name)<font class="keyword"></font>
00952 <font class="keyword"></font>{
00953   sort immutable_old, handle, baseSort;
00954   lsymbol objName;
00955 
00956   immutable_old = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00957 
00958  <font class="comment">/* First generate the value sort */</font>
00959   baseSort = <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (t, name);
00960 
00961   llassert (sortTable != NULL);
00962 
00963   <font class="comment">/* to prevent duplicate error messages */</font>
00964   <font class="keywordflow">if</font> (immutable_old != NOSORTHANDLE &amp;&amp;
00965       (sortTable[baseSort].kind != SRT_PRIM) &amp;&amp;
00966       (sortTable[baseSort].abstract) &amp;&amp;
00967       (!sortTable[baseSort].mutable))
00968     {
00969      <font class="comment">/* already complained */</font>
00970       handle = NOSORTHANDLE;
00971     }
00972   <font class="keywordflow">else</font>
00973     {                           <font class="comment">/* sort_makeImmutable must have succeeded */</font>
00974       sortNode outSort;
00975 
00976      <font class="comment">/* must not clash with any LSL sorts */</font>
00977       objName = sp (sp (underscoreSymbol, name),
00978                     <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Obj"</font>));
00979       handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (objName);
00980 
00981       outSort.kind = SRT_OBJ;
00982       outSort.name = objName;
00983       outSort.tag = lsymbol_undefined;
00984       outSort.baseSort = baseSort;
00985       outSort.objSort = NOSORTHANDLE;
00986       outSort.members = smemberInfo_undefined;
00987       outSort.mutable = TRUE;
00988       outSort.export = exporting;
00989       outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00990       outSort.abstract = TRUE;
00991       outSort.handle = handle;
00992 
00993       <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00994         {
00995           <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00996             {
00997               outSort.handle = handle = sort_enterNew (outSort);
00998             }
00999           <font class="keywordflow">else</font>
01000             {
01001               handle = sort_enterNew (outSort);
01002             }
01003         }
01004       <font class="keywordflow">else</font> 
01005         {
01006           llassert (sortTable != NULL);
01007 
01008           <font class="keywordflow">if</font> ((sortTable[handle].kind != SRT_OBJ) 
01009               &amp;&amp; sortTable[handle].abstract
01010               &amp;&amp; sortTable[handle].mutable)
01011             {
01012               sortError (t, handle, outSort);
01013             }
01014 
01015           smemberInfo_free (outSort.members);
01016         }
01017     }
01018   <font class="keywordflow">return</font> handle;
01019 }
01020 
01021 sort
<a name="l01022"></a><a class="code" href="sort_c.html#a83">01022</a> <a class="code" href="sort_c.html#a83">sort_makeStr</a> (ltoken opttagid)<font class="keyword"></font>
01023 <font class="keyword"></font>{
01024   sortNode outSort;
01025   sort handle;
01026   <font class="keywordtype">bool</font> isNewTag;
01027   lsymbol name;
01028 
01029   <font class="comment">/* must not clash with any LSL sorts, tag2sortname adds "_" prefix */</font>
01030   <font class="comment">/* isNewTag true means that the name generated is new */</font>
01031 
01032   <font class="keywordflow">if</font> (ltoken_isUndefined (opttagid))
01033     {
01034       opttagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, newStructTag ());
01035 
01036       outSort.realtag = FALSE;
01037     }
01038   <font class="keywordflow">else</font>
01039     {
01040       outSort.realtag = TRUE;
01041     }
01042   
01043   name = sortTag_toSymbol (<font class="stringliteral">"Struct"</font>, opttagid, &amp;isNewTag);
01044   
01045   llassert (sortTable != NULL);
01046   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01047   outSort.name = name;
01048   outSort.kind = SRT_STRUCT;
01049   outSort.tag = ltoken_getText (opttagid);
01050   outSort.baseSort = NOSORTHANDLE;
01051   outSort.objSort = NOSORTHANDLE;
01052   outSort.members = smemberInfo_undefined;
01053   outSort.export = exporting;
01054   outSort.mutable = TRUE;
01055   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01056   outSort.abstract = FALSE;
01057   outSort.handle = handle;
01058 
01059   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01060     {
01061       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01062         {
01063           outSort.handle = handle = sort_enterNew (outSort);
01064         }
01065       <font class="keywordflow">else</font>
01066         {
01067           outSort.handle = handle = sort_enterNewForce (outSort);
01068         }
01069     }
01070   <font class="keywordflow">else</font> 
01071     {
01072       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_STRUCT)
01073         {
01074           sortError (opttagid, handle, outSort);
01075         }
01076 
01077       smemberInfo_free (outSort.members);
01078     }
01079 
01080   <font class="keywordflow">return</font> handle;
01081 }
01082 
01083 <font class="keywordtype">bool</font>
<a name="l01084"></a><a class="code" href="sort_c.html#a84">01084</a> <a class="code" href="sort_c.html#a84">sort_updateStr</a> (sort strSort, <font class="comment">/*@only@*/</font> smemberInfo *info)<font class="keyword"></font>
01085 <font class="keyword"></font>{
01086   <font class="comment">/* expect strSort to be in sort table but not yet filled in */</font>
01087   <font class="comment">/* return TRUE if it is "new" */</font>
01088   sort tupleSort;
01089   sortNode sn;
01090   
01091   llassert (sortTable != NULL);
01092   sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (strSort);
01093 
01094   <font class="keywordflow">if</font> (sn.members == (smemberInfo *) 0)
01095     {
01096       sortTable[strSort].members = info;
01097       tupleSort = <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken_undefined, strSort);
01098       genStrOps (strSort, tupleSort);
01099       <font class="keywordflow">return</font> TRUE;
01100     }
01101   <font class="keywordflow">else</font>
01102     {
01103       smemberInfo_free (info);
01104       <font class="keywordflow">return</font> FALSE;
01105     }
01106 }
01107 
01108 sort
<a name="l01109"></a><a class="code" href="sort_c.html#a85">01109</a> <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken t, sort strSort)<font class="keyword"></font>
01110 <font class="keyword"></font>{
01111   sort handle;
01112   sortNode outSort, s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (strSort);
01113   lsymbol name;
01114 
01115   <font class="keywordflow">if</font> (s.kind != SRT_STRUCT)
01116     {
01117       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sort_makeTuple: Only structs can become tuples: given sort is %s"</font>,
01118                            sort_unparseKind (s.kind)));
01119     }
01120 
01121   name = sp (s.name, lsymbol_fromChars (<font class="stringliteral">"_Tuple"</font>));
01122   llassert (sortTable != NULL);
01123   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01124 
01125   outSort.kind = SRT_TUPLE;
01126   outSort.name = name;
01127   outSort.tag = s.tag;
01128   outSort.realtag = s.realtag;
01129   outSort.baseSort = strSort;
01130   outSort.objSort = NOSORTHANDLE;
01131   outSort.members = smemberInfo_undefined;
01132   outSort.export = exporting;
01133   outSort.abstract = FALSE;
01134   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01135   outSort.mutable = FALSE;
01136   outSort.handle = handle;
01137 
01138   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01139     {
01140       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01141         {
01142           outSort.handle = handle = sort_enterNew (outSort);
01143 
01144           sort_addTupleMembers (handle, strSort);
01145           genTupleOps (handle);
01146         }
01147       <font class="keywordflow">else</font>
01148         {
01149           outSort.handle = handle = sort_enterNew (outSort);
01150         }
01151     }
01152   <font class="keywordflow">else</font> 
01153     {
01154       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_TUPLE)
01155         {
01156           sortError (t, handle, outSort);
01157         }
01158 
01159       smemberInfo_free (outSort.members);
01160     }
01161 
01162   <font class="keywordflow">return</font> handle;
01163 }
01164 
01165 <font class="keyword">static</font> <font class="keywordtype">void</font>
01166 sort_addTupleMembers (sort tupleSort, sort strSort)<font class="keyword"></font>
01167 <font class="keyword"></font>{
01168   smemberInfo *mem, *tail = smemberInfo_undefined;
01169   smemberInfo *top = smemberInfo_undefined;
01170   smemberInfo *newinfo;
01171   
01172   <font class="comment">/* make sure it works for empty smemberInfo */</font>
01173   
01174   llassert (sortTable != NULL);
01175  
01176  <font class="keywordflow">for</font> (mem = sortTable[strSort].members;
01177        mem != smemberInfo_undefined; mem = mem-&gt;next)
01178     {
01179       newinfo = (smemberInfo *) dmalloc (<font class="keyword">sizeof</font> (*newinfo));
01180       newinfo-&gt;name = mem-&gt;name;
01181       newinfo-&gt;sort = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (mem-&gt;sort);
01182       newinfo-&gt;next = smemberInfo_undefined;
01183 
01184       <font class="keywordflow">if</font> (top == smemberInfo_undefined)
01185         {                       <font class="comment">/* start of iteration */</font>
01186           top = newinfo;
01187           tail = newinfo;
01188         }
01189       <font class="keywordflow">else</font>
01190         {
01191           llassert (tail != smemberInfo_undefined);
01192 
01193           tail-&gt;next = newinfo;
01194           tail = newinfo;
01195           <font class="comment">/*@-branchstate@*/</font> <font class="comment">/* tail is dependent */</font>
01196         } 
01197       <font class="comment">/*@=branchstate@*/</font>
01198     }
01199 
01200   sortTable[tupleSort].members = top;
01201 }
01202 
01203 <font class="keyword">static</font> 
01204 <font class="keywordtype">void</font> genTupleOps (sort tupleSort)<font class="keyword"></font>
01205 <font class="keyword"></font>{
01206   ltoken range, dom;
01207   sort fieldsort;
01208   smemberInfo *m;
01209   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> memCount;
01210   ltokenList domain = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
01211   sigNode signature;
01212   opFormUnion u;
01213   opFormNode opform;
01214   nameNode nn;
01215 
01216   memCount = 0;
01217   range = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (tupleSort));
01218 
01219   llassert (sortTable != NULL);
01220   <font class="keywordflow">for</font> (m = sortTable[tupleSort].members;
01221        m != smemberInfo_undefined; m = m-&gt;next)
01222     {
01223       fieldsort = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (m-&gt;sort);
01224       overloadUnary (makeFieldOp (m-&gt;name), tupleSort, fieldsort);
01225 
01226       dom = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT,
01227                                sort_getLsymbol (fieldsort));
01228       <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, dom);
01229       memCount++;
01230     }
01231 
01232   <font class="comment">/* For tuples only: [__, ...]: memSorts, ... -&gt; tupleSort */</font>
01233   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, range);
01234   u.middle = memCount;
01235 
01236   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_copy (ltoken_lbracked),
01237                            OPF_BMIDDLE, u, <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_rbracket));
01238 
01239   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01240   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, signature);
01241   
01242   <font class="comment">/*</font>
01243 <font class="comment">  ** should not be able to take sizeof (struct^) ...</font>
01244 <font class="comment">  */</font>
01245 }
01246 
01247 <font class="keyword">static</font> 
01248 <font class="keywordtype">void</font> genUnionOps (sort tupleSort)<font class="keyword"></font>
01249 <font class="keyword"></font>{
01250  <font class="comment">/* like genTupleOps but no constructor [ ...]: -&gt; unionSort */</font>
01251   smemberInfo *m;
01252   sort sort;
01253 
01254   llassert (sortTable != NULL);
01255   <font class="keywordflow">for</font> (m = sortTable[tupleSort].members;
01256        m != smemberInfo_undefined; m = m-&gt;next)
01257     {
01258      <font class="comment">/* Generate __.memName: strSort -&gt;memSortObj */</font>
01259       overloadUnary (makeFieldOp (m-&gt;name), tupleSort, m-&gt;sort);
01260      <font class="comment">/*    printf ("making __.%s: %s -&gt; %s\n", lsymbol_toChars (m-&gt;name),</font>
01261 <font class="comment">                sort_getName (tupleSort), sort_getName (m-&gt;sort)); */</font>
01262      <font class="comment">/* __-&gt;memName : Union_Ptr -&gt; memSortObj */</font>
01263       sort = <a class="code" href="sort_c.html#a76">sort_makePtr</a> (ltoken_undefined, tupleSort);
01264       overloadUnary (makeArrowFieldOp (m-&gt;name), sort, m-&gt;sort);
01265      <font class="comment">/*    printf ("making __-&gt;%s: %s -&gt; %s\n", lsymbol_toChars (m-&gt;name),</font>
01266 <font class="comment">                sort_getName (sort), sort_getName (m-&gt;sort)); */</font>
01267     }
01268 }
01269 
01270 <font class="keyword">static</font> 
01271 <font class="keywordtype">void</font> genStrOps (sort strSort, <font class="comment">/*@unused@*/</font> sort tupleSort)<font class="keyword"></font>
01272 <font class="keyword"></font>{
01273   smemberInfo *m;
01274   sort sort;
01275   
01276   llassert (sortTable != NULL);
01277   <font class="keywordflow">for</font> (m = sortTable[strSort].members;
01278        m != smemberInfo_undefined; m = m-&gt;next)
01279     {
01280      <font class="comment">/* Generate __.memName: strSort -&gt;memSortObj */</font>
01281       overloadUnary (makeFieldOp (m-&gt;name), strSort, m-&gt;sort);
01282       <font class="comment">/*    printf ("making __.%s: %s -&gt; %s\n", lsymbol_toChars (m-&gt;name),</font>
01283 <font class="comment">            sort_getName (strSort), sort_getName (m-&gt;sort)); */</font>
01284       <font class="comment">/* __-&gt;memName : Struct_Ptr -&gt; memSortObj */</font>
01285       sort = <a class="code" href="sort_c.html#a76">sort_makePtr</a> (ltoken_undefined, strSort);
01286       overloadUnary (makeArrowFieldOp (m-&gt;name), sort, m-&gt;sort);
01287       <font class="comment">/*    printf ("making __-&gt;%s: %s -&gt; %s\n", lsymbol_toChars (m-&gt;name),</font>
01288 <font class="comment">            sort_getName (sort), sort_getName (m-&gt;sort)); */</font>
01289     }
01290   <font class="comment">/* Generate fresh, trashed, modifies, unchanged: struct/union -&gt; bool */</font>
01291   <font class="comment">/* Generate __any, __pre, __post: nStruct -&gt; nTuple */</font>
01292   <font class="comment">/* Generate sizeof: strSort -&gt; int */</font>
01293   <font class="comment">/* overloadStateFcns (strSort, tupleSort); */</font>
01294 }
01295 
01296 sort
<a name="l01297"></a><a class="code" href="sort_c.html#a86">01297</a> <a class="code" href="sort_c.html#a86">sort_makeUnion</a> (ltoken opttagid)<font class="keyword"></font>
01298 <font class="keyword"></font>{
01299   sortNode outSort;
01300   sort handle;
01301   <font class="keywordtype">bool</font> isNewTag; 
01302   lsymbol name;
01303 
01304   <font class="comment">/* must not clash with any LSL sorts, tag2sortname adds "_" prefix */</font>
01305   <font class="comment">/* isNewTag true means that the name generated is new */</font>
01306 
01307   <font class="keywordflow">if</font> (ltoken_isUndefined (opttagid))
01308     {
01309       opttagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, newUnionTag ());
01310       outSort.realtag = FALSE;
01311     }
01312   <font class="keywordflow">else</font>
01313     outSort.realtag = TRUE;
01314 
01315   llassert (sortTable != NULL);
01316   name = sortTag_toSymbol (<font class="stringliteral">"Union"</font>, opttagid, &amp;isNewTag);
01317   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01318   outSort.name = name;
01319   outSort.kind = SRT_UNION;
01320   outSort.tag = ltoken_getText (opttagid);
01321   outSort.baseSort = NOSORTHANDLE;
01322   outSort.objSort = NOSORTHANDLE;
01323   outSort.members = smemberInfo_undefined;
01324   outSort.export = exporting;
01325   outSort.mutable = TRUE;
01326   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01327   outSort.abstract = FALSE;
01328   outSort.handle = handle;
01329   
01330   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01331     {
01332       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01333         {
01334           outSort.handle = handle = sort_enterNew (outSort);
01335         }
01336       <font class="keywordflow">else</font>
01337         {
01338           outSort.handle = handle = sort_enterNewForce (outSort);
01339         }
01340     }
01341   <font class="keywordflow">else</font> 
01342     {
01343       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_UNION)
01344         {
01345           sortError (opttagid, handle, outSort);
01346         }
01347 
01348       smemberInfo_free (outSort.members);
01349     }
01350 
01351   <font class="keywordflow">return</font> handle;
01352 }
01353 
01354 <font class="keywordtype">bool</font>
<a name="l01355"></a><a class="code" href="sort_c.html#a87">01355</a> <a class="code" href="sort_c.html#a87">sort_updateUnion</a> (sort unionSort, <font class="comment">/*@only@*/</font> smemberInfo *info)<font class="keyword"></font>
01356 <font class="keyword"></font>{
01357  <font class="comment">/* expect unionSort to be in sort table but not yet filled in */</font>
01358  <font class="comment">/* return TRUE if it is "new" */</font>
01359   sort uValSort;
01360   sortNode sn;
01361 
01362   llassert (sortTable != NULL);
01363 
01364   sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (unionSort);
01365 
01366   <font class="keywordflow">if</font> (sn.members == (smemberInfo *) 0)
01367     {
01368       sortTable[unionSort].members = info;
01369       uValSort = <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken_undefined, unionSort);
01370       <font class="comment">/* same as struct operations */</font>
01371       genStrOps (unionSort, uValSort);
01372       <font class="keywordflow">return</font> TRUE;
01373     }
01374   <font class="keywordflow">else</font>
01375     {
01376       smemberInfo_free (info);
01377       <font class="keywordflow">return</font> FALSE;
01378     }
01379 }
01380 
01381 sort
<a name="l01382"></a><a class="code" href="sort_c.html#a88">01382</a> <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken t, sort unionSort)<font class="keyword"></font>
01383 <font class="keyword"></font>{
01384   sort handle;
01385   sortNode outSort, s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (unionSort);
01386   lsymbol name;
01387 
01388   <font class="keywordflow">if</font> (s.kind != SRT_UNION)
01389     {
01390       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sort_makeUnion: only unions can become unionVals: given sort is: %s"</font>,
01391                            sort_unparseKind (s.kind)));
01392     }
01393 
01394   llassert (sortTable != NULL);
01395 
01396   name = sp (s.name, lsymbol_fromChars (<font class="stringliteral">"_UnionVal"</font>));
01397   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01398 
01399   outSort.kind = SRT_UNIONVAL;
01400   outSort.name = name;
01401   outSort.tag = s.tag;
01402   outSort.realtag = s.realtag;
01403   outSort.baseSort = unionSort;
01404   outSort.objSort = NOSORTHANDLE;
01405   outSort.members = smemberInfo_undefined;
01406   outSort.export = exporting;
01407   outSort.abstract = FALSE;
01408   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01409   outSort.mutable = FALSE;
01410   outSort.handle = handle;
01411 
01412   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01413     {
01414       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01415         {
01416           outSort.handle = handle = sort_enterNew (outSort);
01417 
01418           <font class="comment">/* Add members to the unionVal's. */</font>
01419           <font class="comment">/* same as structs and tuples */</font>
01420 
01421           sort_addTupleMembers (handle, unionSort);
01422           genUnionOps (handle);
01423         }
01424       <font class="keywordflow">else</font>
01425         {
01426           outSort.handle = handle = sort_enterNew (outSort);
01427         }
01428     }
01429   <font class="keywordflow">else</font> 
01430     {
01431       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_UNIONVAL)
01432         {
01433           sortError (t, handle, outSort);
01434         }
01435 
01436       smemberInfo_free (outSort.members);
01437     }
01438 
01439   <font class="keywordflow">return</font> handle;
01440 }
01441 
01442 <font class="keyword">static</font> lsymbol
01443 newEnumTag ()<font class="keyword"></font>
01444 <font class="keyword"></font>{
01445   <font class="keyword">static</font> <font class="keywordtype">int</font> ecount = 0;
01446 
01447   <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"e%s%de"</font>, context_moduleName (), ecount++)));
01448 }
01449 
01450 <font class="keyword">static</font> lsymbol
01451 newStructTag ()<font class="keyword"></font>
01452 <font class="keyword"></font>{
01453   <font class="keyword">static</font> <font class="keywordtype">int</font> ecount = 0;
01454 
01455   <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"s%s%ds"</font>, context_moduleName (), ecount++)));
01456 }
01457 
01458 <font class="keyword">static</font> lsymbol
01459 newUnionTag ()<font class="keyword"></font>
01460 <font class="keyword"></font>{
01461   <font class="keyword">static</font> <font class="keywordtype">int</font> ecount = 0;
01462 
01463   <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"u%s%du"</font>, context_moduleName (), ecount++)));
01464 }
01465 
01466 sort
<a name="l01467"></a><a class="code" href="sort_c.html#a89">01467</a> <a class="code" href="sort_c.html#a89">sort_makeEnum</a> (ltoken opttagid)<font class="keyword"></font>
01468 <font class="keyword"></font>{
01469   sortNode outSort;
01470   sort handle;
01471   <font class="keywordtype">bool</font> isNew;
01472   lsymbol name;
01473 
01474   llassert (sortTable != NULL);
01475 
01476   <font class="keywordflow">if</font> (ltoken_isUndefined (opttagid))
01477     {
01478       opttagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, newEnumTag ());
01479       outSort.realtag = FALSE;
01480     }
01481   <font class="keywordflow">else</font>
01482     outSort.realtag = TRUE;
01483   
01484   <font class="comment">/* must not clash with any LSL sorts, tag2sortname adds "_" prefix */</font>
01485 
01486   name = sortTag_toSymbol (<font class="stringliteral">"Enum"</font>, opttagid, &amp;isNew);
01487   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01488   outSort.name = name;
01489   outSort.kind = SRT_ENUM;
01490   outSort.tag = ltoken_getText (opttagid);
01491   outSort.baseSort = NOSORTHANDLE;
01492   outSort.objSort = NOSORTHANDLE;
01493   outSort.members = smemberInfo_undefined;
01494   outSort.export = exporting;
01495   outSort.mutable = FALSE;
01496   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01497   outSort.abstract = FALSE;
01498   outSort.handle = handle;
01499 
01500   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01501     {
01502       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01503         {
01504           outSort.handle = handle = sort_enterNew (outSort);
01505         }
01506       <font class="keywordflow">else</font>
01507         {
01508           outSort.handle = handle = sort_enterNewForce (outSort);
01509         }
01510     }
01511   <font class="keywordflow">else</font> 
01512     {
01513       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_ENUM)
01514         {
01515           sortError (opttagid, handle, outSort);
01516         }
01517 
01518       smemberInfo_free (outSort.members);
01519     }
01520 
01521   <font class="keywordflow">return</font> handle;
01522 }
01523 
01524 <font class="keywordtype">bool</font>
<a name="l01525"></a><a class="code" href="sort_c.html#a90">01525</a> <a class="code" href="sort_c.html#a90">sort_updateEnum</a> (sort enumSort, <font class="comment">/*@only@*/</font> smemberInfo *info)<font class="keyword"></font>
01526 <font class="keyword"></font>{
01527   <font class="comment">/*</font>
01528 <font class="comment">  ** Expect enumSort to be in sort table but not yet filled in.</font>
01529 <font class="comment">  ** Return TRUE if it is "new" </font>
01530 <font class="comment">  */</font>
01531 
01532   sortNode sn;
01533 
01534   llassert (sortTable != NULL);
01535 
01536   sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (enumSort);
01537   <font class="keywordflow">if</font> (sn.members == (smemberInfo *) 0)
01538     {
01539       sortTable[enumSort].members = info;
01540       genEnumOps (enumSort);
01541       <font class="keywordflow">return</font> TRUE;
01542     }
01543   <font class="keywordflow">else</font>
01544     {
01545       smemberInfo_free (info);
01546       <font class="keywordflow">return</font> FALSE;
01547     }
01548 }
01549 
01550 <font class="keyword">static</font> 
01551 <font class="keywordtype">void</font> genEnumOps (sort enumSort)<font class="keyword"></font>
01552 <font class="keyword"></font>{
01553   smemberInfo *ei;
01554   ltokenList domain = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
01555   ltoken range, mem;
01556   nameNode nn;
01557   sigNode signature;
01558 
01559   range = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (enumSort));
01560   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, range);
01561 
01562   llassert (sortTable != NULL);
01563 
01564   <font class="keywordflow">for</font> (ei = sortTable[enumSort].members;
01565        ei != (smemberInfo *) 0; ei = ei-&gt;next)
01566     {
01567       mem = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, ei-&gt;name);
01568       nn = <a class="code" href="abstract_c.html#a99">makeNameNodeId</a> (mem);
01569       <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, sigNode_copy (signature));
01570     }
01571 
01572   <a class="code" href="abstract_c.html#a234">sigNode_free</a> (signature);
01573   overloadSizeof (enumSort);
01574 }
01575 
01576 <font class="keyword">static</font> <font class="keywordtype">void</font>
01577 genPtrOps (<font class="comment">/*@unused@*/</font> sort baseSort, sort ptrSort, sort arraySort)<font class="keyword"></font>
01578 <font class="keyword"></font>{
01579   <font class="comment">/* Generate *__: xPtr -&gt; x */</font>
01580 
01581   <font class="comment">/* overloadUnary (deRefNameNode, ptrSort, baseSort); */</font>
01582 
01583   <font class="comment">/* Generate maxIndex, minIndex: xPtr -&gt; int */</font>
01584   <font class="comment">/* overloadUnaryTok (maxIndexNameNode, ptrSort, intToken); */</font>
01585   <font class="comment">/* overloadUnaryTok (minIndexNameNode, ptrSort, intToken); */</font>
01586 
01587   <font class="comment">/* Generate __[]: pointer -&gt; array  */</font>
01588   overloadUnary (nameNode_copySafe (ptr2arrayNameNode), ptrSort, arraySort);
01589 
01590   <font class="comment">/* Generate __+__, __-__: pointer, int -&gt; pointer  */</font>
01591   overloadBinary (nameNode_copySafe (plusNameNode), ptrSort, 
01592                   <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (intToken), ptrSort);
01593 
01594   overloadBinary (nameNode_copySafe (minusNameNode), ptrSort, 
01595                   <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (intToken), ptrSort);
01596 
01597   <font class="comment">/* Generate NIL: -&gt; xPtr */</font>
01598   <font class="comment">/* Generate __+__: int, pointer -&gt; pointer  */</font>
01599   <font class="comment">/* Generate __-__: pointer, pointer -&gt; int  */</font>
01600   overloadPtrFcns (ptrSort);
01601 }
01602 
01603 <font class="keyword">static</font> <font class="keywordtype">void</font>
01604 genArrOps (sort baseSort, sort arraySort, <font class="keywordtype">int</font> dim, <font class="comment">/*@unused@*/</font> sort vecSort)<font class="keyword"></font>
01605 <font class="keyword"></font>{
01606   <font class="comment">/* Generate __[__]: nArr, int -&gt; n */</font>
01607   overloadBinary (nameNode_copySafe (arrayRefNameNode), arraySort, 
01608                   <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (intToken), baseSort);
01609   
01610   <font class="comment">/* Generate maxIndex, minIndex: sort -&gt; int */</font>
01611   <font class="comment">/* overloadUnaryTok (maxIndexNameNode, arraySort, intToken); */</font>
01612   <font class="comment">/* overloadUnaryTok (minIndexNameNode, arraySort, intToken); */</font>
01613   
01614   <font class="comment">/* Generate isSub: arraySort, int, ... -&gt; bool */</font>
01615   overloadIsSub (arraySort, dim); 
01616   
01617   <font class="comment">/* Generate fresh, trashed, modifies, unchanged: array -&gt; bool  */</font>
01618   <font class="comment">/* Generate any, pre, post: array -&gt; vector */</font>
01619   
01620   <font class="comment">/* overloadStateFcns (arraySort, vecSort); */</font>
01621   <font class="comment">/* overloadObjFcns (arraySort); */</font>
01622 }
01623 
01624 <font class="comment">/*</font>
01625 <font class="comment">** overloadPtrFcns:</font>
01626 <font class="comment">**   generate NIL: -&gt; ptrSort</font>
01627 <font class="comment">**            __+__: int, ptrSort -&gt; ptrSort  </font>
01628 <font class="comment">**            __-__: ptrSort, ptrSort -&gt; int  </font>
01629 <font class="comment">*/</font>
01630 <font class="keyword">static</font> <font class="keywordtype">void</font>
01631 overloadPtrFcns (sort ptrSort)<font class="keyword"></font>
01632 <font class="keyword"></font>{
01633   ltokenList domain = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
01634   ltoken range;
01635   sigNode signature;
01636   
01637   <font class="comment">/* NIL: -&gt; ptrSort */</font>
01638   
01639   range = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (ptrSort));
01640   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, ltokenList_new (), <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (range));
01641   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nameNode_copySafe (nilNameNode), signature);
01642   
01643   <font class="comment">/* __+__: int, ptrSort -&gt; ptrSort  */</font>
01644   
01645   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, ltoken_copy (intToken));
01646   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, ltoken_copy (range));
01647 
01648   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, ltoken_copy (range));
01649   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nameNode_copySafe (plusNameNode), signature);
01650   
01651   <font class="comment">/* __-__: ptrSort, ptrSort -&gt; int  */</font>
01652 
01653   domain = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
01654   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, ltoken_copy (range));
01655   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, range);
01656   range = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (intToken);
01657   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, range);
01658   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nameNode_copySafe (minusNameNode), signature);
01659 }
01660 
01661 <font class="keyword">static</font> <font class="keywordtype">void</font>
01662 genVecOps (sort baseSort, sort vecSort, <font class="keywordtype">int</font> dim)<font class="keyword"></font>
01663 <font class="keyword"></font>{
01664   <font class="comment">/* Generate __[__]: vecSort, int -&gt; baseSort */</font>
01665 
01666   overloadBinary (nameNode_copySafe (arrayRefNameNode), vecSort, 
01667                   <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (intToken), baseSort);
01668 
01669   <font class="comment">/*          sizeof: vecSort -&gt; int */</font>
01670   <font class="comment">/* Generate isSub: vecSort, int, ... -&gt; bool */</font>
01671 
01672   overloadIsSub (vecSort, dim);
01673 }
01674 
01675 <font class="keyword">static</font> <font class="keywordtype">void</font>
01676 overloadIsSub (sort s, <font class="keywordtype">int</font> dim)<font class="keyword"></font>
01677 <font class="keyword"></font>{
01678   <font class="comment">/* Generate isSub: s, int, ... -&gt; bool */</font>
01679   <font class="keywordtype">int</font> j, i;
01680   ltoken dom, nulltok = ltoken_undefined;
01681   ltokenList domain;
01682   sigNode signature;
01683 
01684   <font class="keywordflow">for</font> (j = 1; j &lt;= dim; j++)
01685     {
01686       nameNode isSubNameNode = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*isSubNameNode));
01687 
01688       isSubNameNode-&gt;isOpId = TRUE;
01689       isSubNameNode-&gt;content.opid = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, 
01690                                                          lsymbol_fromChars (<font class="stringliteral">"isSub"</font>));
01691       dom = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (s));
01692 
01693       domain = <a class="code" href="ltokenList_c.html#a1">ltokenList_singleton</a> (dom);
01694 
01695       <font class="keywordflow">for</font> (i = 1; i &lt;= j; i++)
01696         {
01697           <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, ltoken_copy (intToken));
01698         }
01699 
01700       signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (nulltok, domain, ltoken_copy (ltoken_bool));
01701       <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, isSubNameNode, signature);
01702     }
01703 }
01704 
01705 <font class="keyword">static</font> <font class="keywordtype">void</font>
01706 overloadUnaryTok (<font class="comment">/*@only@*/</font> nameNode nn, sort domainSort, <font class="comment">/*@only@*/</font> ltoken range)<font class="keyword"></font>
01707 <font class="keyword"></font>{
01708   <font class="comment">/* Generate &lt;nn&gt;: domainSort -&gt; rangeTok */</font>
01709   sigNode signature;
01710   ltoken dom;
01711   ltokenList domain;
01712 
01713   dom = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (domainSort));
01714   domain = <a class="code" href="ltokenList_c.html#a1">ltokenList_singleton</a> (dom);
01715   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, range);
01716   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, signature);
01717 }
01718 
01719 <font class="keyword">static</font> <font class="keywordtype">void</font>
01720 overloadSizeof (sort domainSort)<font class="keyword"></font>
01721 <font class="keyword"></font>{
01722   nameNode sizeofNameNode = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*sizeofNameNode));
01723   
01724   sizeofNameNode-&gt;isOpId = TRUE;
01725   sizeofNameNode-&gt;content.opid = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, 
01726                                                       lsymbol_fromChars (<font class="stringliteral">"sizeof"</font>));
01727   
01728   overloadUnaryTok (sizeofNameNode, domainSort, ltoken_copy (intToken));
01729 }
01730 
01731 <font class="keyword">static</font> <font class="keywordtype">void</font>
01732 overloadUnary (<font class="comment">/*@only@*/</font> nameNode nn, sort domainSort, sort rangeSort)<font class="keyword"></font>
01733 <font class="keyword"></font>{
01734   ltoken range = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (rangeSort));
01735 
01736   overloadUnaryTok (nn, domainSort, range);
01737 }
01738 
01739 <font class="keyword">static</font> <font class="keywordtype">void</font>
01740 overloadBinary (<font class="comment">/*@only@*/</font> nameNode nn, sort s, <font class="comment">/*@only@*/</font> ltoken dTok, sort rs)<font class="keyword"></font>
01741 <font class="keyword"></font>{
01742   <font class="comment">/* Generate &lt;nn&gt;: s, dTok -&gt; rs */</font>
01743   sigNode signature;
01744   ltoken range, dom;
01745   ltokenList domain = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
01746 
01747   range = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (rs));
01748   dom = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, sort_getLsymbol (s));
01749   
01750   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, dom);
01751   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, dTok);
01752   
01753   signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, range);
01754       <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, signature);
01755 }
01756 
01757 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> nameNode
01758 makeFieldOp (lsymbol field)<font class="keyword"></font>
01759 <font class="keyword"></font>{
01760  <font class="comment">/* operator: __.&lt;field&gt; */</font>
01761   nameNode nn;
01762   opFormUnion u;
01763   opFormNode opform;
01764 
01765   u.id = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, field);
01766   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MSELECT, u, ltoken_undefined);
01767   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01768   <font class="keywordflow">return</font> nn;
01769 }
01770 
01771 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> nameNode
01772 makeArrowFieldOp (lsymbol field)<font class="keyword"></font>
01773 <font class="keyword"></font>{
01774  <font class="comment">/* operator: __-&gt;&lt;field&gt; */</font>
01775   nameNode nn;
01776   opFormUnion u;
01777   opFormNode opform;
01778 
01779   u.id = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, field);
01780   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MMAP, u, ltoken_undefined);
01781   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01782   <font class="keywordflow">return</font> nn;
01783 }
01784 
01785 <font class="keywordtype">void</font>
<a name="l01786"></a><a class="code" href="sort_c.html#a91">01786</a> <a class="code" href="sort_c.html#a91">sort_init</a> (<font class="keywordtype">void</font>) 
01787    <font class="comment">/*@globals undef noSort,</font>
01788 <font class="comment">              undef arrayRefNameNode,</font>
01789 <font class="comment">              undef ptr2arrayNameNode,</font>
01790 <font class="comment">              undef deRefNameNode,</font>
01791 <font class="comment">              undef nilNameNode,</font>
01792 <font class="comment">              undef plusNameNode,</font>
01793 <font class="comment">              undef minusNameNode,</font>
01794 <font class="comment">              undef condNameNode,</font>
01795 <font class="comment">              undef eqNameNode,</font>
01796 <font class="comment">              undef neqNameNode,</font>
01797 <font class="comment">              undef intToken; @*/</font>
01798 {
01799   <font class="comment">/* on alpha, declaration does not allocate storage */</font>
01800   opFormNode opform;
01801   opFormUnion u;
01802   underscoreSymbol = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_"</font>);
01803 
01804   <font class="comment">/*</font>
01805 <font class="comment">  ** commonly used data for generating operators </font>
01806 <font class="comment">  */</font>
01807   
01808   <a class="code" href="abstract_c.html#a266">lsymbol_setbool</a> (lsymbol_fromChars (<font class="stringliteral">"bool"</font>));
01809   intToken = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, lsymbol_fromChars (<font class="stringliteral">"int"</font>));
01810   
01811   <font class="comment">/*</font>
01812 <font class="comment">  ** __ \eq __: sort, sort -&gt; bool </font>
01813 <font class="comment">  */</font>
01814 
01815   u.anyop = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_eq);
01816   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01817   eqNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01818   
01819   <font class="comment">/*</font>
01820 <font class="comment">  ** __ \neq __: sort, sort -&gt; bool </font>
01821 <font class="comment">  */</font>
01822 
01823   u.anyop = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_neq);
01824   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01825   neqNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01826   
01827   <font class="comment">/*</font>
01828 <font class="comment">  **if __ then __ else __: bool, sort, sort -&gt; sort </font>
01829 <font class="comment">  */</font>
01830 
01831   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_IF, 
01832                            opFormUnion_createMiddle (0), ltoken_undefined);
01833   condNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01834   
01835   <font class="comment">/* operator: __[__]: arraySort, int -&gt; elementSort_Obj */</font>
01836   u.middle = 1;
01837   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_copy (ltoken_lbracked), OPF_BMMIDDLE, u,
01838                            <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_rbracket));
01839   arrayRefNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01840   
01841   <font class="comment">/* operator: __[]: ptrSort -&gt; arraySort */</font>
01842   u.middle = 0;
01843   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_copy (ltoken_lbracked), 
01844                            OPF_BMMIDDLE, u,
01845                            <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_rbracket));
01846   ptr2arrayNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01847   
01848   <font class="comment">/* operator: *__ */</font>
01849   u.anyop = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (LLT_MULOP, lsymbol_fromChars (<font class="stringliteral">"*"</font>));
01850   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_ANYOPM, u, ltoken_undefined);
01851   deRefNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01852   
01853   <font class="comment">/* operator: __ + __ */</font>
01854   u.anyop = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleOp, lsymbol_fromChars (<font class="stringliteral">"+"</font>));
01855   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01856   plusNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01857   
01858   <font class="comment">/* operator: __ - __ */</font>
01859   u.anyop = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleOp, lsymbol_fromChars (<font class="stringliteral">"-"</font>));
01860   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01861   minusNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01862   
01863   <font class="comment">/* operator: NIL */</font>
01864   nilNameNode = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*nilNameNode));
01865   nilNameNode-&gt;isOpId = TRUE;
01866   nilNameNode-&gt;content.opid = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, 
01867                                                  lsymbol_fromChars (<font class="stringliteral">"NIL"</font>));
01868 
01869   noSort.kind = SRT_NONE;
01870   noSort.name = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_unknown"</font>);;
01871   noSort.tag = lsymbol_undefined;
01872   noSort.baseSort = NOSORTHANDLE;
01873   noSort.objSort = NOSORTHANDLE;
01874   noSort.members = smemberInfo_undefined;
01875   noSort.export = FALSE;
01876   noSort.mutable = FALSE;
01877   noSort.abstract = FALSE;
01878   noSort.imported = FALSE;
01879   noSort.handle = NOSORTHANDLE;
01880   
01881   <font class="comment">/*</font>
01882 <font class="comment">  ** Store the null sort into table, and in the process initialize the sort table. </font>
01883 <font class="comment">  ** Must be the first sort_enter so NOSORTHANDLE is truly = 0. Similarly, </font>
01884 <font class="comment">  ** for HOFSORTHANDLE = 1.</font>
01885 <font class="comment">  */</font>
01886   
01887   noSort.handle = sort_enterGlobal (noSort);
01888   (<font class="keywordtype">void</font>) sort_enterGlobal (HOFSort); 
01889   
01890   <font class="comment">/* Other builtin sorts */</font>
01891   
01892   sort_bool = <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"bool"</font>));
01893   sort_capBool = sort_makeSortNoOps (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"Bool"</font>));
01894   
01895   llassert (sortTable != NULL);
01896 
01897   <font class="comment">/* make sort_Bool a synonym for sort_bool */</font>
01898   sortTable[sort_capBool].kind = SRT_SYN;
01899   sortTable[sort_capBool].baseSort = sort_bool;
01900   sortTable[sort_capBool].mutable = FALSE;
01901   sortTable[sort_capBool].abstract = TRUE;
01902   
01903   sort_int = sort_makeLiteralSort (ltoken_undefined, 
01904                                    lsymbol_fromChars (<font class="stringliteral">"int"</font>));
01905   sort_char = sort_makeLiteralSort (ltoken_undefined,
01906                                     lsymbol_fromChars (<font class="stringliteral">"char"</font>));
01907   sort_void = sort_makeLiteralSort (ltoken_undefined,
01908                                     lsymbol_fromChars (<font class="stringliteral">"void"</font>));
01909   
01910   <font class="comment">/* sort_cstring is char__Vec, for C strings eg: "xyz" */</font>
01911   char_obj_ptrSort = <a class="code" href="sort_c.html#a76">sort_makePtr</a> (ltoken_undefined, sort_char);
01912   char_obj_ArrSort = <a class="code" href="sort_c.html#a78">sort_makeArr</a> (ltoken_undefined, sort_char);
01913   
01914   sort_cstring = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (char_obj_ArrSort);
01915   sort_float = sort_makeLiteralSort (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"float"</font>));
01916   sort_double = sort_makeLiteralSort (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"double"</font>));
01917 }
01918 
01919 sort
<a name="l01920"></a><a class="code" href="sort_c.html#a92">01920</a> <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol name)<font class="keyword"></font>
01921 <font class="keyword"></font>{
01922   <font class="keywordtype">long</font> <font class="keywordtype">int</font> i;
01923 
01924   <font class="keywordflow">if</font> (name == lsymbol_undefined)
01925     {
01926       <font class="keywordflow">return</font> NOSORTHANDLE;
01927     }
01928 
01929   llassert (sortTable != NULL);
01930 
01931   <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
01932     {
01933       <font class="keywordflow">if</font> (sortTable[i].name == name)
01934         {
01935           <font class="keywordflow">return</font> i;
01936         }
01937     }
01938 
01939   <font class="keywordflow">return</font> NOSORTHANDLE;
01940 }
01941 
01942 <font class="keyword">static</font> <font class="keywordtype">bool</font>
01943 sort_isNewEntry (sortNode s)<font class="keyword"></font>
01944 <font class="keyword"></font>{
01945   <font class="keywordtype">int</font> i;
01946   
01947   <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
01948     {
01949       llassert (sortTable != NULL);
01950 
01951       <font class="keywordflow">if</font> (sortTable[i].kind == s.kind &amp;&amp; sortTable[i].name == s.name)
01952         {
01953           <font class="keywordflow">return</font> FALSE;
01954         }
01955     }
01956   <font class="keywordflow">return</font> TRUE;
01957 }
01958 
01959 <font class="keyword">static</font> sort
01960 sort_enterGlobal (sortNode s)<font class="keyword"></font>
01961 <font class="keyword"></font>{
01962   <font class="comment">/*@i@*/</font> <font class="keywordflow">return</font> (sort_enterNew (s));
01963 }
01964 
01965 <font class="keyword">static</font> sort
01966 sort_enterNew (sortNode s)<font class="keyword"></font>
01967 <font class="keyword"></font>{
01968   <font class="comment">/* This ensures that the argument sortNode is not entered into</font>
01969 <font class="comment">     the sort table more than once.  isNew flag will tell the</font>
01970 <font class="comment">     caller this info, and the caller will decide whether to generate</font>
01971 <font class="comment">     operators for this sort. */</font>
01972   <font class="keywordtype">long</font> <font class="keywordtype">int</font> i;
01973   
01974   <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
01975     {
01976       llassert (sortTable != NULL);
01977 
01978       <font class="keywordflow">if</font> (sortTable[i].kind == s.kind &amp;&amp; sortTable[i].name == s.name)
01979         {
01980           sortNode_free (s);
01981           <font class="keywordflow">return</font> i;
01982         }
01983     }
01984 
01985   <font class="keywordflow">if</font> (sortTableSize &gt;= sortTableAlloc)
01986     {
01987       sortNode *oldSortTable = sortTable;
01988 
01989       sortTableAlloc += DELTA;
01990       sortTable = (sortNode *) dmalloc (sortTableAlloc * <font class="keyword">sizeof</font> (*sortTable));
01991 
01992       <font class="keywordflow">if</font> (sortTableSize &gt; 0)
01993         {
01994           llassert (oldSortTable != NULL);      
01995           <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
01996             {
01997               sortTable[i] = oldSortTable[i];
01998             }
01999         }
02000 
02001       <a class="code" href="general_c.html#a0">sfree</a> (oldSortTable);
02002     }
02003 
02004   llassert (sortTable != NULL);
02005 
02006   s.handle = sortTableSize;
02007   sortTable[sortTableSize++] = s;
02008 
02009   <font class="comment">/*@-compdef@*/</font> 
02010   
02011   <font class="keywordflow">return</font> s.handle;
02012 } <font class="comment">/*=compdef@*/</font>
02013 
02014 <font class="keyword">static</font> sort sort_enterNewForce (sortNode s)<font class="keyword"></font>
02015 <font class="keyword"></font>{
02016   sort sor = sort_enterNew (s); 
02017 
02018   s.handle = sor;
02019   llassert (sortTable != NULL);
02020   sortTable[sor] = s;
02021   
02022   <font class="comment">/*@-globstate@*/</font> <font class="keywordflow">return</font> (sor); <font class="comment">/*@=globstate@*/</font>
02023 }
02024 
02025 <font class="keywordtype">void</font>
<a name="l02026"></a><a class="code" href="sort_c.html#a93">02026</a> <a class="code" href="sort_c.html#a93">sort_printStats</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
02027 <font class="keyword"></font>{
02028   <font class="comment">/* only for debugging */</font>
02029   printf (<font class="stringliteral">"sortTableSize = %d; sortTableAlloc = %d\n"</font>, sortTableSize,
02030           sortTableAlloc);
02031 }
02032 
02033 sortNode
<a name="l02034"></a><a class="code" href="sort_c.html#a94">02034</a> <a class="code" href="sort_c.html#a94">sort_lookup</a> (sort sor)<font class="keyword"></font>
02035 <font class="keyword"></font>{
02036   <font class="comment">/* ymtan: can sor be 0 ? */</font>
02037   <font class="comment">/* evs --- yup...0 should return noSort ? */</font>
02038   
02039   <font class="keywordflow">if</font> (sor &gt; 0U &amp;&amp; sor &lt; (<font class="keywordtype">unsigned</font>) sortTableSize)
02040     {
02041       llassert (sortTable != NULL);
02042       <font class="keywordflow">return</font> sortTable[sor];
02043     }
02044 
02045   llassert (sor == 0);
02046   <font class="keywordflow">return</font> noSort;
02047 }
02048 
02049 sortNode
<a name="l02050"></a><a class="code" href="sort_c.html#a95">02050</a> <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sort sor)<font class="keyword"></font>
02051 <font class="keyword"></font>{
02052   <font class="comment">/* ymtan: can sor be 0 ? */</font>
02053   <font class="keywordflow">if</font> (sor &gt; 0U &amp;&amp; sor &lt; (<font class="keywordtype">unsigned</font>) sortTableSize)
02054     {
02055       llassert (sortTable != NULL);
02056       <font class="keywordflow">return</font> (sortTable[sor]);
02057     }
02058   <font class="keywordflow">else</font>
02059     {
02060       <font class="keywordflow">return</font> noSort;
02061     }
02062 }
02063 
02064 <font class="keyword">static</font> cstring
02065 printEnumMembers (<font class="comment">/*@null@*/</font> smemberInfo *list)<font class="keyword"></font>
02066 <font class="keyword"></font>{
02067   cstring out = cstring_undefined;
02068   smemberInfo *m;
02069 
02070   <font class="keywordflow">for</font> (m = list; m != (smemberInfo *) 0; m = m-&gt;next)
02071     {
02072       out = <a class="code" href="cstring_c.html#a42">cstring_concat</a> (out, lsymbol_toString (m-&gt;name));
02073 
02074       <font class="keywordflow">if</font> (m-&gt;next != (smemberInfo *) 0)
02075         {
02076           out = <a class="code" href="cstring_c.html#a40">cstring_concatChars</a> (out, <font class="stringliteral">", "</font>);
02077         }
02078     }
02079   <font class="keywordflow">return</font> out;
02080 }
02081 
02082 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
02083 printStructMembers (<font class="comment">/*@null@*/</font> smemberInfo *list)<font class="keyword"></font>
02084 <font class="keyword"></font>{
02085   cstring ret = cstring_undefined;
02086   smemberInfo *m;
02087 
02088   <font class="keywordflow">for</font> (m = list; m != (smemberInfo *) 0; m = m-&gt;next)
02089     {
02090       ret = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q %s; "</font>,
02091                      ret, sort_unparse (m-&gt;sort), 
02092                      <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (m-&gt;name)));
02093     }
02094 
02095   <font class="keywordflow">return</font> ret;
02096 }
02097 
02098 <font class="comment">/*@only@*/</font> cstring
<a name="l02099"></a><a class="code" href="sort_c.html#a98">02099</a> <a class="code" href="sort_c.html#a98">sort_unparse</a> (sort s)<font class="keyword"></font>
02100 <font class="keyword"></font>{
02101  <font class="comment">/* printing routine for sorts */</font>
02102   sortNode sn;
02103   lsymbol name;
02104 
02105   sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02106   name = sn.name;
02107 
02108   <font class="keywordflow">switch</font> (sn.kind)
02109     {
02110     <font class="keywordflow">case</font> SRT_NONE:
02111       <font class="keywordflow">if</font> (name == lsymbol_undefined)
02112         {
02113           <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"_unknown"</font>);
02114         }
02115 
02116       <font class="keywordflow">return</font> (cstring_fromCharsNew (lsymbol_toChars (name)));
02117     <font class="keywordflow">case</font> SRT_HOF:
02118       <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"procedural"</font>);
02119     <font class="keywordflow">case</font> SRT_PRIM:
02120       <font class="keywordflow">return</font> (cstring_fromCharsNew (lsymbol_toChars (name)));
02121     <font class="keywordflow">case</font> SRT_SYN:
02122       <font class="keywordflow">return</font> (cstring_fromCharsNew (lsymbol_toChars (name)));
02123 
02124     <font class="keywordflow">case</font> SRT_PTR:
02125       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q *"</font>, sort_unparse (sort_makeVal (sn.baseSort))));
02126     <font class="keywordflow">case</font> SRT_OBJ:
02127       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj %q"</font>, sort_unparse (sn.baseSort)));
02128     <font class="keywordflow">case</font> SRT_ARRAY:
02129       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"array of %q"</font>, sort_unparse (sort_makeVal (sn.baseSort))));
02130     <font class="keywordflow">case</font> SRT_VECTOR:
02131       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"vector of %q"</font>, sort_unparse (sn.baseSort)));
02132     <font class="keywordflow">case</font> SRT_TUPLE:
02133       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02134         {
02135           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"struct %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02136         }
02137       <font class="keywordflow">else</font>
02138         {
02139           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"struct {%q}"</font>, printStructMembers (sn.members)));
02140         }
02141     <font class="keywordflow">case</font> SRT_UNIONVAL:
02142       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02143         {
02144           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"union %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02145         }
02146       <font class="keywordflow">else</font>
02147         {
02148           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"union {%q}"</font>, printStructMembers (sn.members)));
02149         }
02150     <font class="keywordflow">case</font> SRT_ENUM:
02151       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02152         {
02153           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"enum %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02154         }
02155       <font class="keywordflow">else</font>
02156         {
02157           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"enum {%q}"</font>, printEnumMembers (sn.members)));
02158         }
02159     <font class="keywordflow">case</font> SRT_STRUCT:
02160       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02161         {
02162           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj struct %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02163         }
02164       <font class="keywordflow">else</font>
02165         {
02166           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj struct {%q}"</font>, printStructMembers (sn.members)));
02167         }
02168     <font class="keywordflow">case</font> SRT_UNION:
02169       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02170         {
02171           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj union %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02172         }
02173       <font class="keywordflow">else</font>
02174         {
02175           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj union {%q}"</font>, printStructMembers (sn.members)));
02176         }
02177     <font class="keywordflow">default</font>:
02178       <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"illegal"</font>));
02179     }
02180 }
02181 
02182 <font class="keyword">static</font> lsymbol
02183 sp (lsymbol s1, lsymbol s2)<font class="keyword"></font>
02184 <font class="keyword"></font>{
02185   <font class="keywordtype">char</font> buff[MAXBUFFLEN];
02186   <font class="keywordtype">char</font> *name1Ptr;
02187   <font class="keywordtype">char</font> *name2Ptr;
02188   <font class="keywordtype">int</font> temp_length;
02189 
02190   name1Ptr = <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (s1);
02191   name2Ptr = <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (s2);
02192 
02193   <font class="keywordflow">if</font> (strlen (name1Ptr) + strlen (name2Ptr) + 1 &gt; MAXBUFFLEN)
02194     {
02195       temp_length = strlen (name1Ptr) + strlen (name2Ptr) + 1;
02196       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sp: name too long: %s%s"</font>, 
02197                            cstring_fromChars (name1Ptr), 
02198                            <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (name2Ptr)));
02199     }
02200 
02201   strcpy (&amp;buff[0], name1Ptr);
02202   strcat (&amp;buff[0], name2Ptr);
02203 
02204   <font class="keywordflow">return</font> <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (&amp;buff[0]);
02205 }
02206 
02207 <font class="keyword">static</font> lsymbol
02208 sortTag_toSymbol (<font class="keywordtype">char</font> *kind, ltoken tagid, <font class="comment">/*@out@*/</font> <font class="keywordtype">bool</font> *isNew)<font class="keyword"></font>
02209 <font class="keyword"></font>{
02210   <font class="comment">/* </font>
02211 <font class="comment">  ** kind could be struct, union or enum.  Create a unique sort</font>
02212 <font class="comment">  ** name based on the given info. But first check that tagid</font>
02213 <font class="comment">  ** has not been defined already. (ok if it is a forward decl) </font>
02214 <font class="comment">  **/</font>
02215 
02216   tagInfo to;
02217 
02218   <font class="keywordflow">if</font> (ltoken_isUndefined (tagid))
02219     {
02220       *isNew = TRUE;
02221       <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"_anon_%s%d"</font>, cstring_fromChars (kind), sortUID++)));
02222     }
02223   <font class="keywordflow">else</font>
02224     {
02225       to = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, ltoken_getText (tagid));
02226 
02227       <font class="keywordflow">if</font> (tagInfo_exists (to))
02228         {
02229           *isNew = FALSE;
02230         }
02231       <font class="keywordflow">else</font>
02232         {
02233           *isNew = TRUE;
02234         }
02235 
02236       <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"_%s_%s"</font>, 
02237                                          ltoken_unparse (tagid), 
02238                                          <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (kind))));
02239     }
02240 }
02241 
02242 <font class="comment">/*@constant int MAX_SORT_DEPTH@*/</font>
<a name="l02243"></a><a class="code" href="sort_c.html#a4">02243</a> <font class="preprocessor"># define MAX_SORT_DEPTH 10</font>
02244 <font class="preprocessor"></font>
02245 <font class="keyword">static</font> sort
02246 sort_getUnderlyingAux (sort s, <font class="keywordtype">int</font> depth)<font class="keyword"></font>
02247 <font class="keyword"></font>{
02248   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02249   
02250   <font class="keywordflow">if</font> (sn.kind == SRT_SYN)
02251     {
02252       <font class="keywordflow">if</font> (depth &gt; MAX_SORT_DEPTH)
02253         {
02254           llcontbug (message (<font class="stringliteral">"sort_getUnderlying: depth charge: %d"</font>, depth));
02255           <font class="keywordflow">return</font> s;
02256         }
02257       
02258       <font class="keywordflow">return</font> sort_getUnderlyingAux (sn.baseSort, depth + 1);
02259     }
02260   
02261   <font class="keywordflow">return</font> s;
02262 }
02263 
02264 sort
<a name="l02265"></a><a class="code" href="sort_c.html#a100">02265</a> <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (sort s)<font class="keyword"></font>
02266 <font class="keyword"></font>{
02267   <font class="keywordflow">return</font> sort_getUnderlyingAux (s, 0);
02268 }
02269 
02270 <font class="keyword">static</font> lsymbol
02271 underlyingSortName (sortNode sn)<font class="keyword"></font>
02272 <font class="keyword"></font>{
02273   <font class="keywordflow">if</font> (sn.kind == SRT_SYN)
02274     <font class="keywordflow">return</font> underlyingSortName (sort_quietLookup (sn.baseSort));
02275   <font class="keywordflow">return</font> sn.name;
02276 }
02277 
02278 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> sortNode
02279 underlyingSortNode (sortNode sn)<font class="keyword"></font>
02280 <font class="keyword"></font>{
02281   <font class="keywordflow">if</font> (sn.kind == SRT_SYN)
02282     {
02283       <font class="keywordflow">return</font> underlyingSortNode (sort_quietLookup (sn.baseSort));
02284     }
02285 
02286   <font class="keywordflow">return</font> sn;
02287 }
02288 
02289 <font class="keywordtype">bool</font>
<a name="l02290"></a><a class="code" href="sort_c.html#a103">02290</a> <a class="code" href="sort_c.html#a103">sort_mutable</a> (sort s)<font class="keyword"></font>
02291 <font class="keyword"></font>{
02292  <font class="comment">/* if s is not a valid sort, then returns false */</font>
02293   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02294   <font class="keywordflow">if</font> (sn.mutable)
02295     <font class="keywordflow">return</font> TRUE;
02296   <font class="keywordflow">return</font> FALSE;
02297 }
02298 
02299 <font class="keywordtype">bool</font>
<a name="l02300"></a><a class="code" href="sort_c.html#a104">02300</a> <a class="code" href="sort_c.html#a104">sort_setExporting</a> (<font class="keywordtype">bool</font> flag)<font class="keyword"></font>
02301 <font class="keyword"></font>{
02302   <font class="keywordtype">bool</font> old;
02303   old = exporting;
02304   exporting = flag;
02305   <font class="keywordflow">return</font> old;
02306 }
02307 
02308 <font class="comment">/*@observer@*/</font> <font class="keyword">static</font> cstring 
02309 sort_unparseKind (sortKind k)<font class="keyword"></font>
02310 <font class="keyword"></font>{
02311   <font class="keywordflow">if</font> (k &gt; SRT_FIRST &amp;&amp; k &lt; SRT_LAST)
02312     <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (sortKindName[(<font class="keywordtype">int</font>)k]));
02313   <font class="keywordflow">else</font>
02314     <font class="keywordflow">return</font> (cstring_makeLiteralTemp (<font class="stringliteral">"&lt;unknown sort kind&gt;"</font>));
02315 }
02316 
02317 <font class="keywordtype">bool</font>
<a name="l02318"></a><a class="code" href="sort_c.html#a105">02318</a> <a class="code" href="sort_c.html#a105">sort_isValidSort</a> (sort s)<font class="keyword"></font>
02319 <font class="keyword"></font>{
02320   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02321   sortKind k = sn.kind;
02322   <font class="keywordflow">if</font> (k != SRT_NONE &amp;&amp; k &gt; SRT_FIRST &amp;&amp; k &lt; SRT_LAST)
02323     <font class="keywordflow">return</font> TRUE;
02324   <font class="keywordflow">else</font>
02325     <font class="keywordflow">return</font> FALSE;
02326 }
02327 
02328 <font class="keywordtype">void</font>
<a name="l02329"></a><a class="code" href="sort_c.html#a106">02329</a> <a class="code" href="sort_c.html#a106">sort_dump</a> (FILE *f, <font class="keywordtype">bool</font> lco)<font class="keyword"></font>
02330 <font class="keyword"></font>{
02331   <font class="keywordtype">int</font> i;
02332   sortNode s;
02333   smemberInfo *mem;
02334 
02335   fprintf (f, <font class="stringliteral">"%s\n"</font>, BEGINSORTTABLE);
02336   llassert (sortTable != NULL);
02337 
02338   <font class="keywordflow">for</font> (i = 2; i &lt; sortTableSize; i++)
02339     {
02340       <font class="comment">/* skips 0 and 1, noSort and HOFSort */</font>
02341       s = sortTable[i];
02342       
02343       <font class="comment">/* if (lco &amp;&amp; !s.export) continue; */</font>
02344       <font class="comment">/* Difficult to keep track of where each op and sort belong to</font>
02345 <font class="comment">         which LCL type.  Easiest to export them all (even private sorts and</font>
02346 <font class="comment">         op's) but for checking imported modules, we only use LCL types and</font>
02347 <font class="comment">         variables to check, i.e., we don't rely on sorts and op's for such</font>
02348 <font class="comment">         checking. */</font>
02349       
02350       <font class="keywordflow">if</font> (s.kind == SRT_NONE)
02351         <font class="keywordflow">continue</font>;
02352       
02353       <font class="keywordflow">if</font> (lco)
02354         {
02355           fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02356         }
02357 
02358       <font class="keywordflow">if</font> (lsymbol_isDefined (s.name))
02359         {
02360           fprintf (f, <font class="stringliteral">"sort %s "</font>, lsymbol_toCharsSafe (s.name));
02361         }
02362       <font class="keywordflow">else</font>
02363         {
02364           llcontbug (message (<font class="stringliteral">"Invalid sort in sort_dump: sort %d; sortname: %s.  This may result from using .lcs files produced by an old version of LCLint.  Remove the .lcs files, and rerun LCLint."</font>,
02365                               i, lsymbol_toString (s.name)));
02366           fprintf (f, <font class="stringliteral">"sort _error_ "</font>);
02367         }
02368       
02369       <font class="keywordflow">if</font> (!lco &amp;&amp; !s.export)
02370         fprintf (f, <font class="stringliteral">"private "</font>);
02371 
02372       <font class="comment">/*@-loopswitchbreak@*/</font>
02373       <font class="keywordflow">switch</font> (s.kind)
02374         {
02375         <font class="keywordflow">case</font> SRT_HOF:
02376           fprintf (f, <font class="stringliteral">"hof nil nil\n"</font>);
02377           <font class="keywordflow">break</font>;
02378         <font class="keywordflow">case</font> SRT_PRIM:
02379           <font class="keywordflow">if</font> (s.abstract)
02380             fprintf (f, <font class="stringliteral">"immutable nil nil\n"</font>);
02381           <font class="keywordflow">else</font>
02382             fprintf (f, <font class="stringliteral">"primitive nil nil\n"</font>);
02383           <font class="keywordflow">break</font>;
02384         <font class="keywordflow">case</font> SRT_OBJ:
02385           <font class="keywordflow">if</font> (s.abstract)
02386             fprintf (f, <font class="stringliteral">"mutable %s nil\n"</font>,
02387                      lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02388           <font class="keywordflow">else</font>
02389             fprintf (f, <font class="stringliteral">"obj %s nil\n"</font>,
02390                      lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02391           <font class="keywordflow">break</font>;
02392         <font class="keywordflow">case</font> SRT_SYN:
02393           fprintf (f, <font class="stringliteral">"synonym %s nil\n"</font>,
02394                    lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02395           <font class="keywordflow">break</font>;
02396         <font class="keywordflow">case</font> SRT_PTR:
02397           fprintf (f, <font class="stringliteral">"ptr %s nil\n"</font>, lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02398           <font class="keywordflow">break</font>;
02399         <font class="keywordflow">case</font> SRT_ARRAY:
02400           fprintf (f, <font class="stringliteral">"arr %s nil\n"</font>,
02401                    lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02402           <font class="keywordflow">break</font>;
02403         <font class="keywordflow">case</font> SRT_VECTOR:
02404           fprintf (f, <font class="stringliteral">"vec %s %s\n"</font>,
02405                    lsymbol_toCharsSafe (sortTable[s.baseSort].name),
02406                    <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sortTable[s.objSort].name));
02407           <font class="keywordflow">break</font>;
02408         <font class="keywordflow">case</font> SRT_STRUCT:
02409           <font class="keywordflow">if</font> (s.tag == lsymbol_undefined)
02410             {
02411               <font class="comment">/* we need to make up a tag to prevent excessive</font>
02412 <font class="comment">                 growth of .lcs files when tags are overloaded</font>
02413 <font class="comment">                 */</font>
02414               llbuglit (<font class="stringliteral">"Struct has no tag"</font>);
02415             }
02416           <font class="keywordflow">else</font>
02417             fprintf (f, <font class="stringliteral">"str %s nil\n"</font>, lsymbol_toCharsSafe (s.tag));
02418 
02419           <font class="keywordflow">for</font> (mem = s.members;
02420                mem != smemberInfo_undefined; mem = mem-&gt;next)
02421             {
02422               <font class="keywordflow">if</font> (lco)
02423                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02424               fprintf (f, <font class="stringliteral">"sort %s strMem %s nil\n"</font>, lsymbol_toCharsSafe (mem-&gt;name),
02425                        <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sortTable[mem-&gt;sort].name));
02426             }
02427           <font class="keywordflow">if</font> (lco)
02428             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02429           fprintf (f, <font class="stringliteral">"sort strEnd nil nil nil\n"</font>);
02430           <font class="keywordflow">break</font>;
02431         <font class="keywordflow">case</font> SRT_UNION:
02432           <font class="keywordflow">if</font> (s.tag == lsymbol_undefined)
02433             llbuglit (<font class="stringliteral">"Union has no tag"</font>);
02434           <font class="keywordflow">else</font>
02435             fprintf (f, <font class="stringliteral">"union %s nil\n"</font>, lsymbol_toCharsSafe (s.tag));
02436           <font class="keywordflow">for</font> (mem = s.members;
02437                mem != smemberInfo_undefined; mem = mem-&gt;next)
02438             {
02439               <font class="keywordflow">if</font> (lco)
02440                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02441               fprintf (f, <font class="stringliteral">"sort %s unionMem %s nil\n"</font>, lsymbol_toCharsSafe (mem-&gt;name),
02442                        <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sortTable[mem-&gt;sort].name));
02443             }
02444           <font class="keywordflow">if</font> (lco)
02445             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02446           fprintf (f, <font class="stringliteral">"sort unionEnd nil nil nil\n"</font>);
02447           <font class="keywordflow">break</font>;
02448         <font class="keywordflow">case</font> SRT_ENUM:
02449           <font class="keywordflow">if</font> (s.tag == lsymbol_undefined)
02450             {
02451               llbuglit (<font class="stringliteral">"Enum has no tag"</font>);
02452             }
02453 
02454           fprintf (f, <font class="stringliteral">"enum %s nil\n"</font>, lsymbol_toCharsSafe (s.tag));
02455 
02456           <font class="keywordflow">for</font> (mem = s.members;
02457                mem != smemberInfo_undefined; mem = mem-&gt;next)
02458             {
02459               <font class="keywordflow">if</font> (lco)
02460                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02461               fprintf (f, <font class="stringliteral">"sort %s enumMem nil nil\n"</font>, lsymbol_toCharsSafe (mem-&gt;name));
02462             }
02463           <font class="keywordflow">if</font> (lco)
02464             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02465           fprintf (f, <font class="stringliteral">"sort enumEnd nil nil nil\n"</font>);
02466           <font class="keywordflow">break</font>;
02467         <font class="keywordflow">case</font> SRT_TUPLE:
02468           fprintf (f, <font class="stringliteral">"tup %s nil\n"</font>, lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02469           <font class="keywordflow">break</font>;
02470         <font class="keywordflow">case</font> SRT_UNIONVAL:
02471           fprintf (f, <font class="stringliteral">"unionval %s nil\n"</font>,
02472                    lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02473           <font class="keywordflow">break</font>;
02474         <font class="keywordflow">default</font>:
02475           fprintf (f, <font class="stringliteral">"sort_dump: unexpected sort: %d"</font>, (<font class="keywordtype">int</font>)s.kind);
02476         }                       <font class="comment">/* switch */</font>
02477       <font class="comment">/*@=loopswitchbreak@*/</font>
02478     }
02479 
02480   fprintf (f, <font class="stringliteral">"%s\n"</font>, SORTTABLEEND);
02481 }
02482 
02483 <font class="keyword">static</font> <font class="keywordtype">void</font>
02484 sort_loadOther (<font class="keywordtype">char</font> *kstr, lsymbol sname, sort bsort)<font class="keyword"></font>
02485 <font class="keyword"></font>{
02486   <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"synonym"</font>) == 0)
02487     {
02488       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_SYN, bsort, lsymbol_undefined,
02489                              FALSE, NOSORTHANDLE, smemberInfo_undefined);
02490     }
02491   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"mutable"</font>) == 0)
02492     {
02493       (<font class="keywordtype">void</font>) sort_constructAbstract (sname, TRUE, bsort);
02494     }
02495   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"obj"</font>) == 0)
02496     {
02497       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_OBJ, bsort, lsymbol_undefined,
02498                              TRUE, NOSORTHANDLE, smemberInfo_undefined);
02499     }
02500   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"ptr"</font>) == 0)
02501     {
02502       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_PTR, bsort, lsymbol_undefined,
02503                              FALSE, NOSORTHANDLE, smemberInfo_undefined);
02504     }
02505   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"arr"</font>) == 0)
02506     {
02507       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_ARRAY, bsort, lsymbol_undefined,
02508                              TRUE, NOSORTHANDLE, smemberInfo_undefined);
02509     }
02510   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"tup"</font>) == 0)
02511     {
02512       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_TUPLE, bsort, lsymbol_undefined,
02513                              FALSE, NOSORTHANDLE, smemberInfo_undefined);
02514     }
02515   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"unionval"</font>) == 0)
02516     {
02517       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_UNIONVAL, bsort, lsymbol_undefined,
02518                              FALSE, NOSORTHANDLE, smemberInfo_undefined);
02519     }
02520   <font class="keywordflow">else</font>
02521     {
02522       llbug (message (<font class="stringliteral">"Unhandled: %s"</font>, cstring_fromChars (kstr)));
02523     }
02524 }
02525 
02526 <font class="keyword">static</font> <font class="keywordtype">void</font>
02527 parseSortLine (<font class="keywordtype">char</font> *line, ltoken t, tsource * s,
02528                mapping *map, lsymbolList slist)<font class="keyword"></font>
02529 <font class="keyword"></font>{
02530   <font class="comment">/* caller expects that map and slist are updated */</font>
02531   <font class="comment">/* t and importfle are only used for error messages */</font>
02532   <font class="keyword">static</font> lsymbol strName = lsymbol_undefined;
02533   <font class="keyword">static</font> smemberInfo *strMemList = NULL;
02534   <font class="keyword">static</font> lsymbol unionName = lsymbol_undefined;
02535   <font class="keyword">static</font> smemberInfo *unionMemList = NULL;
02536   <font class="keyword">static</font> lsymbol enumName = lsymbol_undefined;
02537   <font class="keyword">static</font> smemberInfo *enumMemList = NULL;
02538   <font class="keyword">static</font> lsymbol tagName = lsymbol_undefined;
02539   
02540   <font class="keywordtype">char</font> *importfile = tsource_fileName (s);
02541   <font class="keywordtype">char</font> sostr[MAXBUFFLEN], kstr[10], basedstr[MAXBUFFLEN], objstr[MAXBUFFLEN];
02542   <font class="keywordtype">bool</font> tmp;
02543   tagInfo ti;
02544   lsymbol sname, bname, new_name, objName;
02545   sort objSort;
02546   <font class="keywordtype">char</font> *lineptr;
02547   <font class="keywordtype">int</font> col;                      <font class="comment">/* for keeping column number */</font>
02548   ltoken tagid;
02549   
02550   <font class="keywordflow">if</font> (sscanf (line, <font class="stringliteral">"sort %s %s %s %s"</font>, &amp;(sostr[0]), &amp;(kstr[0]),
02551               &amp;(basedstr[0]), &amp;(objstr[0])) != 4)
02552     {           
02553       <font class="comment">/* if this fails, can have weird errors */</font>
02554       <font class="comment">/* strEnd, unionEnd, enumEnd won't return 4 args */</font>
02555       lclplainerror 
02556         (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Imported file contains illegal sort declaration.   "</font>
02557                   <font class="stringliteral">"Skipping this line: \n%s\n"</font>,
02558                   fileloc_unparseRaw (cstring_fromChars (importfile), 
02559                                       tsource_thisLineNumber (s)), 
02560                   <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
02561       <font class="keywordflow">return</font>;
02562     }
02563   
02564   sname = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (sostr);
02565   <font class="keywordflow">if</font> (sname == <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"nil"</font>))
02566     {
02567       <font class="comment">/* No given sort name.  Use lsymbol_undefined and generate sort name</font>
02568 <font class="comment">         in sort building routines. */</font>
02569       sname = lsymbol_undefined;
02570       <a class="code" href="llerror_c.html#a54">lclerror</a> (t, message (<font class="stringliteral">"Illegal sort declaration in import file: %s:\n%s"</font>,
02571                             cstring_fromChars (importfile), 
02572                             <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
02573     }
02574   
02575   <font class="comment">/* Assume that when we encounter a sort S1 that is based on sort</font>
02576 <font class="comment">     S2, S2 is before S1 in the imported file.  sort table is a</font>
02577 <font class="comment">     linear list and we create base sorts before other sorts. */</font>
02578   
02579   bname = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (basedstr);
02580   <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"primitive"</font>) == 0)
02581     {
02582       new_name = <a class="code" href="symtable_c.html#a54">lsymbol_translateSort</a> (map, sname);
02583       (<font class="keywordtype">void</font>) sort_construct (new_name, SRT_PRIM, NOSORTHANDLE,
02584                              lsymbol_undefined, FALSE,
02585                              NOSORTHANDLE, smemberInfo_undefined);
02586     }
02587   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"strMem"</font>) == 0)
02588     {
02589       smemberInfo *mem = (smemberInfo *) dmalloc (<font class="keyword">sizeof</font> (*mem));
02590       mem-&gt;next = strMemList;
02591       mem-&gt;name = sname;
02592       mem-&gt;sortname = bname;
02593       mem-&gt;sort = NOSORTHANDLE;
02594       strMemList = mem;
02595     }
02596   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (sostr, <font class="stringliteral">"strEnd"</font>) == 0)
02597     {                           <font class="comment">/* now process it */</font>
02598       <font class="keywordflow">if</font> (strName != lsymbol_undefined &amp;&amp; strMemList != NULL)
02599         {
02600           sort asort = sort_construct (strName, SRT_STRUCT, NOSORTHANDLE, tagName,
02601                                   TRUE, NOSORTHANDLE, strMemList);
02602           
02603           <font class="keywordflow">if</font> (tagName != lsymbol_undefined)
02604             {
02605               tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, tagName);
02606 
02607               ti = (tagInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
02608               ti-&gt;sort = asort;
02609               ti-&gt;kind = TAG_STRUCT;
02610               ti-&gt;id = tagid;
02611               ti-&gt;imported = FALSE;
02612               
02613               (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a39">symtable_enterTagForce</a> (g_symtab, ti);
02614             }
02615         }
02616       <font class="keywordflow">else</font>
02617         {
02618           <font class="keywordflow">if</font> (strName == lsymbol_undefined)
02619             {
02620               <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%q: Imported file contains unexpected null struct sort"</font>,
02621                                fileloc_unparseRaw (cstring_fromChars (importfile), tsource_thisLineNumber (s))));
02622             }
02623           <font class="keywordflow">else</font>
02624             {
02625               <font class="comment">/*</font>
02626 <font class="comment">               ** no members -&gt; its a forward struct</font>
02627 <font class="comment">               */</font>
02628               
02629               <font class="keywordflow">if</font> (tagName != lsymbol_undefined)
02630                 {
02631                   tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, tagName);
02632                   (<font class="keywordtype">void</font>) <a class="code" href="abstract_c.html#a218">checkAndEnterTag</a> (TAG_FWDSTRUCT, tagid);
02633                 }
02634             }
02635         }
02636       strName = lsymbol_undefined;
02637       strMemList = NULL;
02638       tagName = lsymbol_undefined;
02639     }
02640   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"str"</font>) == 0)
02641     {
02642       <font class="keywordflow">if</font> (strName != lsymbol_undefined || strMemList != NULL)
02643         {
02644           <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%q: unexpected non-null struct sort or "</font>
02645                            <font class="stringliteral">"non-empty member list"</font>,
02646                            fileloc_unparseRaw (cstring_fromChars (importfile), 
02647                                                tsource_thisLineNumber (s))));
02648         }
02649       <font class="comment">/* see if a tag is associated with this sort */</font>
02650       <font class="keywordflow">if</font> (strcmp (basedstr, <font class="stringliteral">"nil"</font>) == 0)
02651         {
02652           <a class="code" href="llerror_c.html#a48">llfatalerror</a> (message (<font class="stringliteral">"%s: Struct missing tag.  Obsolete .lcs file, remove and rerun lcl."</font>,
02653                                  cstring_fromChars (importfile)));
02654           <font class="comment">/*</font>
02655 <font class="comment">            strName = sortTag_toSymbol ("Struct", nulltok, &amp;tmp);</font>
02656 <font class="comment">            tagName = lsymbol_undefined;</font>
02657 <font class="comment">            mapping_bind (map, sname, strName);</font>
02658 <font class="comment">            */</font>
02659         }
02660       <font class="keywordflow">else</font> <font class="comment">/* a tag exists */</font>
02661         {  <font class="comment">/* create tag in symbol table and add tagged sort in sort table */</font>
02662           tagName = bname;
02663           tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, bname);
02664 
02665           strName = sortTag_toSymbol (<font class="stringliteral">"Struct"</font>, tagid, &amp;tmp);
02666           ti = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, tagName);
02667 
02668           <font class="comment">/*</font>
02669 <font class="comment">          ** No error for redefining a tag in an import.</font>
02670 <font class="comment">          */</font>
02671         }
02672       <font class="comment">/* to be processed later in sort_import */</font>
02673       <a class="code" href="lsymbolList_c.html#a2">lsymbolList_addh</a> (slist, strName);
02674     }
02675   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"enumMem"</font>) == 0)
02676     {
02677       smemberInfo *mem = (smemberInfo *) dmalloc (<font class="keyword">sizeof</font> (*mem));
02678       mem-&gt;next = enumMemList;
02679       mem-&gt;sortname = enumName;
02680       mem-&gt;name = sname;
02681       mem-&gt;sort = NOSORTHANDLE;
02682       enumMemList = mem;
02683     }
02684   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (sostr, <font class="stringliteral">"enumEnd"</font>) == 0)
02685     {
02686       <font class="keywordflow">if</font> (enumName != lsymbol_undefined &amp;&amp; enumMemList != NULL)
02687         {
02688           sort asort = sort_construct (enumName, SRT_ENUM, NOSORTHANDLE, tagName,
02689                                        FALSE, NOSORTHANDLE, enumMemList);
02690           
02691           <font class="keywordflow">if</font> (tagName != lsymbol_undefined)
02692             {
02693               tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, tagName);
02694 
02695               ti = (tagInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
02696               ti-&gt;sort = asort;
02697               ti-&gt;kind = TAG_ENUM;
02698               ti-&gt;id = tagid;
02699               ti-&gt;imported = FALSE;
02700 
02701               (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a39">symtable_enterTagForce</a> (g_symtab, ti);
02702             }
02703         }
02704       <font class="keywordflow">else</font>
02705         {
02706           <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%q: unexpected null enum sort or empty member list"</font>,
02707                            fileloc_unparseRaw (cstring_fromChars (importfile), tsource_thisLineNumber (s))));
02708         }
02709       enumName = lsymbol_undefined;
02710       enumMemList = NULL;
02711       tagName = lsymbol_undefined;
02712     }
02713   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"enum"</font>) == 0)
02714     {
02715       <font class="keywordflow">if</font> (enumName != lsymbol_undefined || enumMemList != NULL)
02716         {
02717           <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%q: Unexpected non-null enum sort or "</font>
02718                            <font class="stringliteral">"non-empty member list"</font>,
02719                            fileloc_unparseRaw (cstring_fromChars (importfile), 
02720                                                tsource_thisLineNumber (s))));
02721         }
02722 
02723       <font class="comment">/* see if a tag is associated with this sort */</font>
02724       <font class="keywordflow">if</font> (strcmp (basedstr, <font class="stringliteral">"nil"</font>) == 0)
02725         {
02726           <a class="code" href="llerror_c.html#a48">llfatalerror</a> (message (<font class="stringliteral">"%s: Enum missing tag.  Obsolete .lcs file, "</font>
02727                                  <font class="stringliteral">"remove and rerun lcl."</font>,
02728                                  cstring_fromChars (importfile)));
02729         }
02730       <font class="keywordflow">else</font>
02731         {                       <font class="comment">/* a tag exists */</font>
02732           tagName = bname;
02733           tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, bname);
02734           enumName = sortTag_toSymbol (<font class="stringliteral">"Enum"</font>, tagid, &amp;tmp);
02735           ti = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, bname);
02736         }
02737     }
02738   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"unionMem"</font>) == 0)
02739     {
02740       smemberInfo *mem = (smemberInfo *) dmalloc (<font class="keyword">sizeof</font> (*mem));
02741       mem-&gt;next = unionMemList;
02742       mem-&gt;sortname = bname;
02743       mem-&gt;name = sname;
02744       mem-&gt;sort = NOSORTHANDLE;
02745       unionMemList = mem;
02746     }
02747   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (sostr, <font class="stringliteral">"unionEnd"</font>) == 0)
02748     {
02749       <font class="keywordflow">if</font> (unionName != lsymbol_undefined &amp;&amp; unionMemList != NULL)
02750         {
02751           sort asort = sort_construct (unionName, SRT_UNION, NOSORTHANDLE, tagName,
02752                                        FALSE, NOSORTHANDLE, unionMemList);
02753 
02754           <font class="keywordflow">if</font> (tagName != lsymbol_undefined)
02755             {
02756               tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, tagName);
02757 
02758               ti = (tagInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
02759               ti-&gt;sort = asort;
02760               ti-&gt;kind = TAG_UNION;
02761               ti-&gt;id = tagid;
02762               ti-&gt;imported = FALSE;
02763 
02764               (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a39">symtable_enterTagForce</a> (g_symtab, ti);
02765             }
02766         }
02767       <font class="keywordflow">else</font>
02768         {
02769           <font class="keywordflow">if</font> (unionName == lsymbol_undefined)
02770             {
02771               lclbug
02772                 (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Imported file contains unexpected null union sort"</font>,
02773                           fileloc_unparseRaw (cstring_fromChars (importfile), tsource_thisLineNumber (s))));
02774             }
02775           <font class="keywordflow">else</font>
02776             {
02777               <font class="comment">/*</font>
02778 <font class="comment">               ** no members -&gt; its a forward struct</font>
02779 <font class="comment">               */</font>
02780               
02781               <font class="keywordflow">if</font> (tagName != lsymbol_undefined)
02782                 {
02783                   tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, tagName);
02784 
02785                   (<font class="keywordtype">void</font>) <a class="code" href="abstract_c.html#a218">checkAndEnterTag</a> (TAG_FWDUNION, tagid);
02786                 }
02787             }
02788         }
02789 
02790       unionName = lsymbol_undefined;
02791       unionMemList = NULL;
02792       tagName = lsymbol_undefined;
02793     }
02794   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"union"</font>) == 0)
02795     {
02796       <font class="keywordflow">if</font> (unionName != lsymbol_undefined || unionMemList != NULL)
02797         {
02798           lclbug
02799             (message 
02800              (<font class="stringliteral">"%q: Unexpected non-null union sort or non-empty "</font>
02801               <font class="stringliteral">"member list"</font>,
02802               <a class="code" href="fileloc_c.html#a40">fileloc_unparseRaw</a> (cstring_fromChars (importfile), tsource_thisLineNumber (s))));
02803         }
02804       <font class="comment">/* see if a tag is associated with this sort */</font>
02805       <font class="keywordflow">if</font> (strcmp (basedstr, <font class="stringliteral">"nil"</font>) == 0)
02806         {
02807           llfatalerror
02808             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s: Union missing tag.  Obsolete .lcs file, "</font>
02809                       <font class="stringliteral">"remove and rerun lcl."</font>,
02810               cstring_fromChars (importfile)));
02811         }
02812       <font class="keywordflow">else</font>
02813         {                       <font class="comment">/* a tag exists */</font>
02814           tagName = bname;
02815           tagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, bname);
02816 
02817           unionName = sortTag_toSymbol (<font class="stringliteral">"Union"</font>, tagid, &amp;tmp);
02818           ti = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, bname);
02819         }
02820       <a class="code" href="lsymbolList_c.html#a2">lsymbolList_addh</a> (slist, unionName);
02821     }
02822   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"immutable"</font>) == 0)
02823     {
02824       (<font class="keywordtype">void</font>) sort_constructAbstract (sname, FALSE, NOSORTHANDLE);
02825     }
02826   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"hof"</font>) == 0)
02827     {
02828       (<font class="keywordtype">void</font>) sort_construct (sname, SRT_HOF, NOSORTHANDLE, lsymbol_undefined,
02829                              FALSE, NOSORTHANDLE, smemberInfo_undefined);
02830     }
02831   <font class="keywordflow">else</font>
02832     {
02833       sort bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, bname));
02834 
02835       <font class="keywordflow">if</font> (sort_isNoSort (bsort))
02836         {
02837           lineptr = strchr (line, <font class="charliteral">' '</font>); <font class="comment">/* go past "sort" */</font>
02838           llassert (lineptr != NULL);
02839           lineptr = strchr (lineptr + 1, <font class="charliteral">' '</font>);  <font class="comment">/* go past sostr */</font>
02840           llassert (lineptr != NULL);
02841           lineptr = strchr (lineptr + 1, <font class="charliteral">' '</font>);  <font class="comment">/* go past kstr */</font>
02842           llassert (lineptr != NULL);
02843           col = 5 + lineptr - line;     <font class="comment">/* 5 for initial "%LCL "*/</font>
02844 
02845           llbug 
02846             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Imported file contains unknown base sort: %s"</font>,
02847                       fileloc_unparseRawCol (cstring_fromChars (importfile), 
02848                                              tsource_thisLineNumber (s), col),
02849                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toCharsSafe (bname))));
02850         }
02851       
02852       <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"vec"</font>) == 0)
02853         {                       
02854           objName = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (objstr);
02855           objSort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, objName));
02856           (<font class="keywordtype">void</font>) sort_construct (sname, SRT_VECTOR, bsort, lsymbol_undefined,
02857                                  FALSE, objSort, smemberInfo_undefined);
02858         }
02859       <font class="keywordflow">else</font>
02860         {
02861           sort_loadOther (kstr, sname, bsort);
02862         }
02863     } 
02864 }
02865 
02866 <font class="keywordtype">void</font>
<a name="l02867"></a><a class="code" href="sort_c.html#a109">02867</a> <a class="code" href="sort_c.html#a109">sort_import</a> (tsource *imported, ltoken tok, mapping * map)<font class="keyword"></font>
02868 <font class="keyword"></font>{
02869   <font class="comment">/* tok is only used for error message line number */</font>
02870   <font class="keywordtype">char</font> *buf, *importfile;
02871   tsource *lclsource;
02872   sort bsort;
02873   lsymbolList slist = <a class="code" href="lsymbolList_c.html#a0">lsymbolList_new</a> ();
02874 
02875   buf = <a class="code" href="source_c.html#a4">tsource_nextLine</a> (imported);
02876 
02877   llassert (buf != NULL);
02878 
02879   importfile = tsource_fileName (imported);
02880 
02881   <font class="keywordflow">if</font> (!<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCLSortTable"</font>))
02882     {
02883       lclsource = <a class="code" href="lclscan_c.html#a12">LCLScanSource</a> ();
02884 
02885       <a class="code" href="llerror_c.html#a56">lclfatalerror</a> (tok, message (<font class="stringliteral">"Expecting \"%%LCLSortTable\" line "</font>
02886                                    <font class="stringliteral">"in import file %s:\n%s"</font>,
02887                                    cstring_fromChars (importfile), 
02888                                    <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (buf)));
02889       
02890     }
02891 
02892   <font class="keywordflow">for</font> (;;)
02893     {
02894       buf = <a class="code" href="source_c.html#a4">tsource_nextLine</a> (imported);
02895 
02896       llassert (buf != NULL);
02897 
02898       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCLSortTableEnd"</font>))
02899         {
02900           <font class="keywordflow">break</font>;
02901         }
02902       <font class="keywordflow">else</font>
02903         { <font class="comment">/* a good line, remove %LCL from line first */</font>
02904           <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCL"</font>))
02905             {
02906               parseSortLine (buf + 4, tok, imported, map, slist);
02907             }
02908           <font class="keywordflow">else</font>
02909             {
02910               lclsource = <a class="code" href="lclscan_c.html#a12">LCLScanSource</a> ();
02911               lclfatalerror
02912                 (tok, 
02913                  <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Expecting '%%LCL' prefix in import file %s:\n%s\n"</font>,
02914                           cstring_fromChars (importfile), 
02915                           <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (buf)));
02916             }
02917         }
02918     }
02919 
02920   <font class="comment">/* now process the smemberInfo in the sort List */</font>
02921   lsymbolList_elements (slist, s)<font class="keyword"></font>
02922 <font class="keyword">    </font>{
02923       <font class="keywordflow">if</font> (s != lsymbol_undefined)
02924         {
02925           sort sor;
02926           sortNode sn;
02927 
02928           sor = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (s);
02929           sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sor);
02930           
02931           <font class="keywordflow">switch</font> (sn.kind)
02932             {
02933             <font class="keywordflow">case</font> SRT_ENUM:
02934               {                 <font class="comment">/* update the symbol table with members of enum */</font>
02935                 varInfo vi;
02936                 smemberInfo *mlist = sn.members;
02937                 <font class="keywordflow">for</font> (; mlist != NULL; mlist = mlist-&gt;next)
02938                   {
02939                     <font class="comment">/* check that enumeration constants are unique */</font>
02940                     vi = <a class="code" href="symtable_c.html#a50">symtable_varInfo</a> (g_symtab, mlist-&gt;name);
02941                     <font class="keywordflow">if</font> (!varInfo_exists (vi))
02942                       { <font class="comment">/* put info into symbol table */</font>
02943                         vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
02944                         vi-&gt;id = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (NOTTOKEN, mlist-&gt;name);
02945                         vi-&gt;kind = VRK_ENUM;
02946                         vi-&gt;sort = sor;
02947                         vi-&gt;export = TRUE;
02948 
02949                         (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
02950                         <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
02951                       }
02952                     <font class="keywordflow">else</font>
02953                       {
02954                         lclplainerror 
02955                           (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s: enum member %s of %s has already been declared"</font>,
02956                                     cstring_fromChars (importfile), 
02957                                     <a class="code" href="lsymbol_c.html#a15">lsymbol_toString</a> (mlist-&gt;name),
02958                                     <a class="code" href="lsymbol_c.html#a15">lsymbol_toString</a> (sn.name)));
02959                       }
02960                   }
02961                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02962               }
02963             <font class="keywordflow">case</font> SRT_STRUCT:
02964             <font class="keywordflow">case</font> SRT_UNION:
02965               {
02966                 smemberInfo *mlist = sn.members;
02967 
02968                 <font class="keywordflow">for</font> (; mlist != NULL; mlist = mlist-&gt;next)
02969                   {
02970                     bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, mlist-&gt;sortname));
02971                     <font class="keywordflow">if</font> (sort_isNoSort (bsort))
02972                       {
02973                         <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%s: member %s of %s has unknown sort\n"</font>,
02974                                          cstring_fromChars (importfile), 
02975                                          <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (mlist-&gt;name)),
02976                                          <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (sn.name))));
02977                       }
02978                     <font class="keywordflow">else</font>
02979                       {
02980                         mlist-&gt;sort = bsort;
02981                       }
02982                   }
02983                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02984               }
02985             <font class="keywordflow">default</font>:
02986               <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%s: %s has unexpected sort kind %s"</font>,
02987                                cstring_fromChars (importfile), 
02988                                <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (sn.name)),
02989                                sort_unparseKind (sn.kind)));
02990             }
02991         }
02992     } end_lsymbolList_elements;
02993   
02994   <font class="comment">/* list and sorts in it are not used anymore */</font>
02995   <a class="code" href="lsymbolList_c.html#a3">lsymbolList_free</a> (slist);
02996 }
02997 
02998 <font class="keywordtype">bool</font>
<a name="l02999"></a><a class="code" href="sort_c.html#a110">02999</a> <a class="code" href="sort_c.html#a110">sort_equal</a> (sort *s1, sort *s2)<font class="keyword"></font>
03000 <font class="keyword"></font>{
03001   sort syn1, syn2;
03002   <font class="keywordflow">if</font> ((s1 != 0) &amp;&amp; (s2 != 0))
03003     {
03004       <font class="keywordflow">if</font> ((*s1) == (*s2))
03005         <font class="keywordflow">return</font> TRUE;
03006      <font class="comment">/* handle synonym sorts */</font>
03007       syn1 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (*s1);
03008       syn2 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (*s2);
03009       <font class="keywordflow">if</font> (syn1 == syn2)
03010         <font class="keywordflow">return</font> TRUE;
03011      <font class="comment">/* makes bool and Bool equal */</font>
03012     }
03013   <font class="keywordflow">return</font> FALSE;
03014 }
03015 
03016 <font class="keywordtype">bool</font>
<a name="l03017"></a><a class="code" href="sort_c.html#a111">03017</a> <a class="code" href="sort_c.html#a111">sort_compatible</a> (sort s1, sort s2)<font class="keyword"></font>
03018 <font class="keyword"></font>{
03019   sort syn1, syn2;
03020  <font class="comment">/* later: might consider "char" and enum types the same as "int" */</font>
03021   <font class="keywordflow">if</font> (s1 == s2)
03022     <font class="keywordflow">return</font> TRUE;
03023  <font class="comment">/* handle synonym sorts */</font>
03024   syn1 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s1);
03025   syn2 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s2);
03026   <font class="keywordflow">if</font> (syn1 == syn2)
03027     <font class="keywordflow">return</font> TRUE;
03028   <font class="comment">/* makes bool and Bool equal */</font>
03029   <font class="keywordflow">return</font> FALSE;
03030 }
03031 
03032 <font class="keywordtype">bool</font>
<a name="l03033"></a><a class="code" href="sort_c.html#a112">03033</a> <a class="code" href="sort_c.html#a112">sort_compatible_modulo_cstring</a> (sort s1, sort s2)<font class="keyword"></font>
03034 <font class="keyword"></font>{
03035  <font class="comment">/* like sort_compatible but also handles special cstring inits,</font>
03036 <font class="comment">    allows the following 2 cases:</font>
03037 <font class="comment">     char c[] = "abc"; (LHS: char_Obj_Arr, RHS = char_Vec)</font>
03038 <font class="comment">                       (c as implicitly coerced into c^)</font>
03039 <font class="comment">     char *d = "abc";  (LHS: char_Obj_Ptr, RHS = char_Vec)</font>
03040 <font class="comment">                       (d as implicitly coerced into d[]^)</font>
03041 <font class="comment">                       */</font>
03042   sort syn1, syn2;
03043   <font class="keywordflow">if</font> (<a class="code" href="sort_c.html#a111">sort_compatible</a> (s1, s2))
03044     <font class="keywordflow">return</font> TRUE;
03045   syn1 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s1);
03046   syn2 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s2);
03047   <font class="keywordflow">if</font> (sort_cstring == syn2 &amp;&amp;
03048       (syn1 == char_obj_ptrSort || syn1 == char_obj_ArrSort))
03049     <font class="keywordflow">return</font> TRUE;
03050   <font class="keywordflow">return</font> FALSE;
03051 }
03052 
03053 lsymbol
<a name="l03054"></a><a class="code" href="sort_c.html#a113">03054</a> <a class="code" href="sort_c.html#a113">sort_getLsymbol</a> (sort sor)<font class="keyword"></font>
03055 <font class="keyword"></font>{
03056  <font class="comment">/*  sortNode sn = sort_lookup (sor); */</font>
03057   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sor);
03058   <font class="keywordflow">return</font> sn.name;
03059 }
03060 
03061 <font class="comment">/* a few handy routines for debugging */</font>
03062 
<a name="l03063"></a><a class="code" href="sort_c.html#a114">03063</a> <font class="keywordtype">char</font> *<a class="code" href="sort_c.html#a114">sort_getName</a> (sort s)<font class="keyword"></font>
03064 <font class="keyword"></font>{
03065   <font class="keywordflow">return</font> (<a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sort_getLsymbol (s)));
03066 }
03067 
03068 <font class="comment">/*@exposed@*/</font> cstring
<a name="l03069"></a><a class="code" href="sort_c.html#a115">03069</a> <a class="code" href="sort_c.html#a115">sort_unparseName</a> (sort s)<font class="keyword"></font>
03070 <font class="keyword"></font>{
03071     <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (sort_getName (s)));
03072 }
03073 
03074 <font class="keyword">static</font> <font class="keywordtype">void</font>
03075 sortError (ltoken t, sort oldsort, sortNode newnode)<font class="keyword"></font>
03076 <font class="keyword"></font>{
03077   sortNode old = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (oldsort);
03078 
03079   <font class="keywordflow">if</font> ((old.kind &lt;= SRT_FIRST || old.kind &gt;= SRT_LAST) ||
03080       (newnode.kind &lt;= SRT_FIRST || newnode.kind &gt;= SRT_LAST))
03081     {
03082       llbuglit (<font class="stringliteral">"sortError: illegal sort kind"</font>);
03083     }
03084 
03085   llassert (sortTable != NULL);
03086 
03087   <a class="code" href="llerror_c.html#a54">lclerror</a> (t, message (<font class="stringliteral">"Sort %s defined as %s cannot be redefined as %s"</font>,
03088                         cstring_fromChars (lsymbol_toChars (newnode.name)),
03089                         sort_unparseKindName (sortTable[oldsort]),
03090                         sort_unparseKindName (newnode)));
03091 }
03092 
03093 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> cstring
03094   sort_unparseKindName (sortNode s)<font class="keyword"></font>
03095 <font class="keyword"></font>{
03096   <font class="keywordflow">switch</font> (s.kind)
03097     {
03098     <font class="keywordflow">case</font> SRT_NONE:
03099       <font class="keywordflow">return</font> <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (sortKindName[(<font class="keywordtype">int</font>)s.kind]);
03100     <font class="keywordflow">default</font>:
03101       <font class="keywordflow">if</font> (s.abstract)
03102         {
03103           <font class="keywordflow">if</font> (s.mutable)
03104             {
03105               <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"MUTABLE"</font>);
03106             }
03107           <font class="keywordflow">else</font>
03108             {
03109               <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"IMMUTABLE"</font>);
03110             }
03111         }
03112       <font class="keywordflow">else</font>
03113         <font class="keywordflow">return</font> <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (sortKindName[(<font class="keywordtype">int</font>)s.kind]);
03114     }
03115   
03116   BADEXIT;
03117 }
03118 
03119 sort
<a name="l03120"></a><a class="code" href="sort_c.html#a116">03120</a> <a class="code" href="sort_c.html#a116">sort_fromLsymbol</a> (lsymbol sortid)<font class="keyword"></font>
03121 <font class="keyword"></font>{
03122  <font class="comment">/* like sort_lookupName but creates sort if not already present */</font>
03123   sort sort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (sortid);
03124   <font class="keywordflow">if</font> (sort == NOSORTHANDLE)
03125     sort = <a class="code" href="sort_c.html#a69">sort_makeSort</a> (ltoken_undefined, sortid);
03126   <font class="keywordflow">return</font> sort;
03127 }
03128 
03129 <font class="keywordtype">bool</font>
<a name="l03130"></a><a class="code" href="sort_c.html#a117">03130</a> <a class="code" href="sort_c.html#a117">sort_isHOFSortKind</a> (sort s)<font class="keyword"></font>
03131 <font class="keyword"></font>{
03132   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
03133   <font class="keywordflow">if</font> (sn.kind == SRT_HOF)
03134     <font class="keywordflow">return</font> TRUE;
03135   <font class="keywordflow">return</font> FALSE;
03136 }
03137 
03138 <font class="comment">/*</font>
03139 <font class="comment">** returns TRUE iff s has State operators (', ~, ^)</font>
03140 <font class="comment">*/</font>
03141 
03142 <font class="keyword">static</font> <font class="keywordtype">bool</font>
03143 sort_hasStateFcns (sort s)<font class="keyword"></font>
03144 <font class="keyword"></font>{
03145   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
03146   sortKind kind = sn.kind;
03147 
03148   <font class="keywordflow">if</font> (kind == SRT_SYN)
03149     {
03150       <font class="keywordflow">return</font> (sort_hasStateFcns (sn.baseSort));
03151     }
03152 
03153   <font class="keywordflow">return</font> ((kind == SRT_PTR) ||
03154           (kind == SRT_OBJ) ||
03155           (kind == SRT_ARRAY) ||
03156           (kind == SRT_STRUCT) ||
03157           (kind == SRT_UNION));
03158 }
03159 
03160 
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:43 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
