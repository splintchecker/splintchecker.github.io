<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>symtable.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:45 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>symtable.c</h1><a href="symtable_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** symtable.c</font>
00026 <font class="comment">**</font>
00027 <font class="comment">** Symbol table abstraction</font>
00028 <font class="comment">**</font>
00029 <font class="comment">**  AUTHORS:</font>
00030 <font class="comment">**</font>
00031 <font class="comment">**      Gary Feldman, Technical Languages and Environments, DECspec project</font>
00032 <font class="comment">**      Steve Garland,</font>
00033 <font class="comment">**         Massachusetts Institute of Technology</font>
00034 <font class="comment">**      Joe Wild, Technical Languages and Environments, DECspec project</font>
00035 <font class="comment">**      Yang Meng Tan,</font>
00036 <font class="comment">**         Massachusetts Institute of Technology</font>
00037 <font class="comment">**</font>
00038 <font class="comment">**  CREATION DATE:</font>
00039 <font class="comment">**</font>
00040 <font class="comment">**      20 January 1991</font>
00041 <font class="comment">*/</font>
00042 
00043 <font class="preprocessor"># include "lclintMacros.nf"</font>
00044 <font class="preprocessor"># include "llbasic.h"</font>
00045 <font class="preprocessor"># include "gram.h"</font>
00046 <font class="preprocessor"># include "lclscan.h"</font>
00047 <font class="preprocessor"># include "lclsyntable.h"</font>
00048 <font class="preprocessor"># include "lslparse.h"</font>
00049 
00050 <font class="comment">/*@+ignorequals@*/</font>
00051 
00052 <font class="keyword">static</font> <font class="keywordtype">bool</font> isBlankLine (<font class="keywordtype">char</font> *p_line);
00053 <font class="keyword">static</font> <font class="keywordtype">bool</font> inImport = FALSE;
00054 
00055 <font class="comment">/*@constant static int MAXBUFFLEN;@*/</font>
<a name="l00056"></a><a class="code" href="symtable_c.html#a0">00056</a> <font class="preprocessor"># define MAXBUFFLEN 512</font>
00057 <font class="preprocessor"></font><font class="comment">/*@constant static int DELTA;@*/</font>
<a name="l00058"></a><a class="code" href="symtable_c.html#a1">00058</a> <font class="preprocessor"># define DELTA 100</font>
00059 <font class="preprocessor"></font>
00060 <font class="keyword">static</font> <font class="keywordtype">void</font> symHashTable_dump (symHashTable * p_t, FILE * p_f, <font class="keywordtype">bool</font> p_lco);
00061 
00062 <font class="keyword">static</font> <font class="keywordtype">void</font> tagInfo_free (<font class="comment">/*@only@*/</font> tagInfo p_tag);
00063 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> scopeInfo symtable_scopeInfo (symtable p_stable);
00064 
00065 <font class="keyword">static</font> <font class="keywordtype">void</font> symtable_dumpId (symtable p_stable, FILE *p_f, <font class="keywordtype">bool</font> p_lco);
00066 <font class="keyword">static</font> lsymbol nameNode2key (nameNode p_n);
00067 
<a name="l00068"></a><a class="code" href="symtable_c.html#a69">00068</a> <font class="keyword">typedef</font> <font class="keyword">enum</font>
00069 {
00070   SYMK_FCN, SYMK_SCOPE, SYMK_TYPE, SYMK_VAR
00071 } symKind;
00072 
<a name="l00073"></a><a class="code" href="struct_idTableEntry.html">00073</a> <font class="keyword">typedef</font> <font class="keyword">struct</font>
00074 <font class="keyword"></font>{
<a name="l00075"></a><a class="code" href="struct_idTableEntry.html#m0">00075</a>   symKind kind;
00076   <font class="keyword">union</font>
00077 <font class="keyword">  </font>{
<a name="l00078"></a><a class="code" href="struct_idTableEntry.html#m1">00078</a>     <font class="comment">/*@only@*/</font> fctInfo fct;
<a name="l00079"></a><a class="code" href="struct_idTableEntry.html#m2">00079</a>     <font class="comment">/*@only@*/</font> scopeInfo scope;
<a name="l00080"></a><a class="code" href="struct_idTableEntry.html#m3">00080</a>     <font class="comment">/*@only@*/</font> typeInfo type;
<a name="l00081"></a><a class="code" href="struct_idTableEntry.html#m4">00081</a>     <font class="comment">/*@only@*/</font> varInfo var;
00082   } info;
00083 } <a class="code" href="struct_idTableEntry.html">idTableEntry</a>;
00084 
<a name="l00085"></a><a class="code" href="struct__idTable.html">00085</a> <font class="keyword">typedef</font> <font class="keyword">struct </font><a class="code" href="struct__idTable.html">_idTable</a>
00086 {
<a name="l00087"></a><a class="code" href="struct__idTable.html#m0">00087</a>   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> size;
<a name="l00088"></a><a class="code" href="struct__idTable.html#m1">00088</a>   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> allocated;
<a name="l00089"></a><a class="code" href="struct__idTable.html#m2">00089</a>   <font class="comment">/*@relnull@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *entries;
<a name="l00090"></a><a class="code" href="struct__idTable.html#m3">00090</a>   <font class="keywordtype">bool</font> exporting;
00091 } <a class="code" href="struct__idTable.html">idTable</a>;
00092 
<a name="l00093"></a><a class="code" href="struct__symtableStruct.html">00093</a> <font class="keyword">struct </font><a class="code" href="struct__symtableStruct.html">_symtableStruct</a>
00094 {
<a name="l00095"></a><a class="code" href="struct__symtableStruct.html#m0">00095</a>   <a class="code" href="struct__idTable.html">idTable</a> *<a class="code" href="struct__idTable.html">idTable</a>;             <font class="comment">/* data is idTableEntry */</font>
<a name="l00096"></a><a class="code" href="struct__symtableStruct.html#m1">00096</a>   symHashTable *hTable;         <font class="comment">/* data is htData */</font>
<a name="l00097"></a><a class="code" href="struct__symtableStruct.html#m2">00097</a>   mapping *type2sort;           <font class="comment">/* maps LCL type symbol to LSL sort */</font>
00098 } ;
00099 
00100 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> ltoken idTableEntry_getId (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *p_x);
00101 <font class="keyword">static</font> <font class="comment">/*@out@*/</font> <font class="comment">/*@exposed@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *nextFree (<a class="code" href="struct__idTable.html">idTable</a> * p_st);
00102 <font class="keyword">static</font> <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *symtable_lookup (<a class="code" href="struct__idTable.html">idTable</a> * p_st, lsymbol p_id);
00103 <font class="keyword">static</font> <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *symtable_lookupInScope (<a class="code" href="struct__idTable.html">idTable</a> * p_st, lsymbol p_id);
00104 
00105 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> <a class="code" href="struct__idTable.html">idTable</a> *symtable_newIdTable (<font class="keywordtype">void</font>);
00106 <font class="keyword">static</font> <font class="keywordtype">void</font> idTableEntry_free (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> p_x);
00107 
00108 <font class="comment">/* Local implementatio of hash table */</font>
00109 
00110 <font class="keyword">static</font> <font class="keywordtype">bool</font> allowed_redeclaration = FALSE;
00111 <font class="keyword">static</font> symbolKey htData_key (htData *p_x);
00112 
00113 <font class="keyword">static</font> <font class="keywordtype">void</font> symHashTable_free (<font class="comment">/*@only@*/</font> symHashTable *p_h);
00114 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> symHashTable *symHashTable_create (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> p_size);
00115 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> <font class="comment">/*@exposed@*/</font> htData *
00116   symHashTable_get (symHashTable * p_t, symbolKey p_key, infoKind p_kind, 
00117                  <font class="comment">/*@null@*/</font> nameNode p_n);
00118 <font class="keyword">static</font> <font class="keywordtype">bool</font> symHashTable_put (symHashTable *p_t, <font class="comment">/*@only@*/</font> htData *p_data);
00119 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@null@*/</font> htData *
00120   symHashTable_forcePut (symHashTable * p_t, <font class="comment">/*@only@*/</font> htData *p_data);
00121 <font class="comment">/* static unsigned int symHashTable_count (symHashTable * t); */</font>
00122 
00123 <font class="keyword">static</font> <font class="keywordtype">void</font> idTable_free (<font class="comment">/*@only@*/</font> <a class="code" href="struct__idTable.html">idTable</a> *p_st);
00124 
<a name="l00125"></a><a class="code" href="symtable_c.html#a29">00125</a> <font class="keywordtype">void</font> <a class="code" href="symtable_c.html#a29">varInfo_free</a> (<font class="comment">/*@only@*/</font> varInfo v)<font class="keyword"></font>
00126 <font class="keyword"></font>{
00127   <a class="code" href="general_c.html#a0">sfree</a> (v);
00128 }
00129 
00130 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> varInfo varInfo_copy (varInfo v)<font class="keyword"></font>
00131 <font class="keyword"></font>{
00132   varInfo ret = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*ret));
00133 
00134   ret-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (v-&gt;id);
00135   ret-&gt;sort = v-&gt;sort;
00136   ret-&gt;kind = v-&gt;kind;
00137   ret-&gt;export = v-&gt;export;
00138 
00139   <font class="keywordflow">return</font> ret;
00140 }
00141 
<a name="l00142"></a><a class="code" href="symtable_c.html#a31">00142</a> <font class="keywordtype">void</font> <a class="code" href="symtable_c.html#a31">symtable_free</a> (symtable stable)<font class="keyword"></font>
00143 <font class="keyword"></font>{
00144   <font class="comment">/* symtable_printStats (stable); */</font>
00145 
00146   idTable_free (stable-&gt;<a class="code" href="struct__idTable.html">idTable</a>);
00147   symHashTable_free (stable-&gt;hTable);
00148   <a class="code" href="mapping_c.html#a3">mapping_free</a> (stable-&gt;type2sort);
00149   <a class="code" href="general_c.html#a0">sfree</a> (stable);
00150 }
00151 
00152 <font class="keyword">static</font> <font class="keywordtype">void</font> idTable_free (<a class="code" href="struct__idTable.html">idTable</a> *st)<font class="keyword"></font>
00153 <font class="keyword"></font>{
00154   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i;
00155 
00156   <font class="keywordflow">for</font> (i = 0; i &lt; st-&gt;size; i++)
00157     {
00158       idTableEntry_free (st-&gt;entries[i]);
00159     }
00160 
00161   <a class="code" href="general_c.html#a0">sfree</a> (st-&gt;entries);
00162   <a class="code" href="general_c.html#a0">sfree</a> (st);
00163 }
00164 
00165 <font class="keyword">static</font> <font class="keywordtype">void</font> fctInfo_free (<font class="comment">/*@only@*/</font> fctInfo f)<font class="keyword"></font>
00166 <font class="keyword"></font>{
00167   <a class="code" href="abstract_c.html#a219">signNode_free</a> (f-&gt;signature);
00168   <a class="code" href="pairNodeList_c.html#a4">pairNodeList_free</a> (f-&gt;globals);
00169   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (f-&gt;id);
00170   <a class="code" href="general_c.html#a0">sfree</a> (f);
00171 }
00172 
00173 <font class="keyword">static</font> <font class="keywordtype">void</font> typeInfo_free (<font class="comment">/*@only@*/</font> typeInfo t)<font class="keyword"></font>
00174 <font class="keyword"></font>{
00175   <a class="code" href="general_c.html#a0">sfree</a> (t);
00176 }
00177 
00178 <font class="keyword">static</font> <font class="keywordtype">void</font> scopeInfo_free (<font class="comment">/*@only@*/</font> scopeInfo s)<font class="keyword"></font>
00179 <font class="keyword"></font>{
00180   <a class="code" href="general_c.html#a0">sfree</a> (s);
00181 }
00182 
00183 <font class="keyword">static</font> <font class="keywordtype">void</font> idTableEntry_free (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> x)<font class="keyword"></font>
00184 <font class="keyword"></font>{
00185   <font class="keywordflow">switch</font> (x.kind)
00186     {
00187     <font class="keywordflow">case</font> SYMK_FCN:
00188       fctInfo_free (x.info.fct);
00189       <font class="keywordflow">break</font>;
00190     <font class="keywordflow">case</font> SYMK_SCOPE:
00191       scopeInfo_free (x.info.scope);
00192       <font class="keywordflow">break</font>;
00193     <font class="keywordflow">case</font> SYMK_TYPE:
00194       typeInfo_free (x.info.type);
00195       <font class="keywordflow">break</font>;
00196     <font class="keywordflow">case</font> SYMK_VAR:
00197       <a class="code" href="symtable_c.html#a29">varInfo_free</a> (x.info.var);
00198       <font class="keywordflow">break</font>;
00199     }
00200 }
00201 
00202 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> ltoken idTableEntry_getId (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *x)<font class="keyword"></font>
00203 <font class="keyword"></font>{
00204   <font class="keywordflow">switch</font> (x-&gt;kind)
00205     {
00206     <font class="keywordflow">case</font> SYMK_FCN:
00207       <font class="keywordflow">return</font> (x-&gt;info.fct-&gt;id);
00208     <font class="keywordflow">case</font> SYMK_SCOPE:
00209       <font class="keywordflow">return</font> ltoken_undefined;
00210     <font class="keywordflow">case</font> SYMK_TYPE:
00211       <font class="keywordflow">return</font> (x-&gt;info.type-&gt;id);
00212     <font class="keywordflow">case</font> SYMK_VAR:
00213       <font class="keywordflow">return</font> (x-&gt;info.var-&gt;id);
00214     }
00215 
00216   BADBRANCH;
00217 }
00218 
00219 <font class="comment">/*@only@*/</font> symtable
<a name="l00220"></a><a class="code" href="symtable_c.html#a35">00220</a> <a class="code" href="symtable_c.html#a35">symtable_new</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
00221 <font class="keyword"></font>{
00222   symtable stable = (symtable) dmalloc (<font class="keyword">sizeof</font> (*stable));
00223   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
00224   
00225   stable-&gt;idTable = symtable_newIdTable ();
00226   stable-&gt;hTable = symHashTable_create (HT_MAXINDEX);
00227   stable-&gt;type2sort = <a class="code" href="mapping_c.html#a4">mapping_create</a> ();
00228   
00229   <font class="comment">/* add builtin synonym:  Bool -&gt; bool */</font>
00230   
00231   <a class="code" href="mapping_c.html#a6">mapping_bind</a> (stable-&gt;type2sort, lsymbol_getBool (), <a class="code" href="abstract_c.html#a267">lsymbol_getbool</a> ());
00232 
00233   <font class="comment">/*</font>
00234 <font class="comment">  ** done by symtable_newIdTable</font>
00235 <font class="comment">  ** st-&gt;allocated = 0;</font>
00236 <font class="comment">  ** st-&gt;entries = (idTableEntry *) 0;</font>
00237 <font class="comment">  ** st-&gt;exporting = TRUE;</font>
00238 <font class="comment">  */</font>
00239 
00240   <font class="comment">/* this is global scope */</font>
00241   e = nextFree (stable-&gt;<a class="code" href="struct__idTable.html">idTable</a>);
00242   e-&gt;kind = SYMK_SCOPE;
00243   (e-&gt;info).scope = (scopeInfo) dmalloc (<font class="keyword">sizeof</font> (*((e-&gt;info).scope)));
00244   (e-&gt;info).scope-&gt;kind = SPE_GLOBAL;
00245   
00246   <font class="keywordflow">return</font> stable;
00247 }
00248 
00249 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> <a class="code" href="struct__idTable.html">idTable</a> *symtable_newIdTable (<font class="keywordtype">void</font>)<font class="keyword"></font>
00250 <font class="keyword"></font>{
00251   <a class="code" href="struct__idTable.html">idTable</a> *st = (<a class="code" href="struct__idTable.html">idTable</a> *) dmalloc (<font class="keyword">sizeof</font> (*st));
00252 
00253   st-&gt;size = 0;
00254   st-&gt;allocated = 0;
00255   st-&gt;entries = (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0;
00256   st-&gt;exporting = TRUE;
00257   
00258   <font class="comment">/* this was being done twice!</font>
00259 <font class="comment">     e = nextFree (st);</font>
00260 <font class="comment">     e-&gt;kind = SYMK_SCOPE;</font>
00261 <font class="comment">     (e-&gt;info).scope.kind = globScope;</font>
00262 <font class="comment">     */</font>
00263 
00264   <font class="keywordflow">return</font> st;
00265 }
00266 
00267 <font class="keyword">static</font> lsymbol
00268 nameNode2key (nameNode n)<font class="keyword"></font>
00269 <font class="keyword"></font>{
00270   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> ret;
00271 
00272   <font class="keywordflow">if</font> (n-&gt;isOpId)
00273     {
00274       ret =  ltoken_getText (n-&gt;content.opid);
00275     }
00276   <font class="keywordflow">else</font>
00277     {
00278       <font class="comment">/* use opForm's key as its Identifier */</font>
00279       llassert (n-&gt;content.opform != NULL);
00280       ret = (n-&gt;content.opform)-&gt;key;
00281     }
00282 
00283   <font class="keywordflow">return</font> ret;
00284 }
00285 
00286 <font class="comment">/*</font>
00287 <font class="comment">** requires: nameNode n is already in st.</font>
00288 <font class="comment">*/</font>
00289 
00290 <font class="keyword">static</font> <font class="keywordtype">bool</font>
00291 htData_insertSignature (htData *d, <font class="comment">/*@owned@*/</font> sigNode oi)<font class="keyword"></font>
00292 <font class="keyword"></font>{
00293   sigNodeSet set = d-&gt;content.op-&gt;signatures;
00294 
00295   
00296   <font class="keywordflow">if</font> (oi != (sigNode) 0)
00297     {
00298       <font class="keywordflow">return</font> (<a class="code" href="sigNodeSet_c.html#a4">sigNodeSet_insert</a> (set, oi));
00299     }
00300   <font class="keywordflow">return</font> FALSE;
00301 }
00302 
00303 <font class="keywordtype">void</font>
<a name="l00304"></a><a class="code" href="symtable_c.html#a37">00304</a> <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (symtable st, <font class="comment">/*@only@*/</font> <font class="comment">/*@notnull@*/</font> nameNode n, 
00305                   <font class="comment">/*@owned@*/</font> sigNode oi)<font class="keyword"></font>
00306 <font class="keyword"></font>{
00307   <font class="comment">/*</font>
00308 <font class="comment">  ** Operators are overloaded, we allow entering opInfo more than once,</font>
00309 <font class="comment">  ** even if it's the same signature. </font>
00310 <font class="comment">  **</font>
00311 <font class="comment">  ** Assumes all sorts are already entered into the symbol table </font>
00312 <font class="comment">  */</font>
00313 
00314   symHashTable *ht = st-&gt;hTable;
00315   htData *d;
00316   lsymbol id;
00317 
00318   
00319   
00320   id = nameNode2key (n);
00321 
00322   d = symHashTable_get (ht, id, IK_OP, n);
00323   
00324   <font class="keywordflow">if</font> (d == (htData *) 0)
00325     {                           <font class="comment">/* first signature of this operator */</font>
00326       opInfo op = (opInfo) dmalloc (<font class="keyword">sizeof</font> (*op));
00327       htData *nd = (htData *) dmalloc (<font class="keyword">sizeof</font> (*nd));
00328 
00329       op-&gt;name = n;
00330 
00331       <font class="keywordflow">if</font> (oi != (sigNode) 0)
00332         {
00333           op-&gt;signatures = <a class="code" href="sigNodeSet_c.html#a2">sigNodeSet_singleton</a> (oi);
00334           ht-&gt;count++;
00335         }
00336       <font class="keywordflow">else</font>
00337         {
00338           op-&gt;signatures = <a class="code" href="sigNodeSet_c.html#a1">sigNodeSet_new</a> ();
00339           <a class="code" href="abstract_c.html#a103">sigNode_markOwned</a> (oi);
00340         }
00341 
00342       nd-&gt;kind = IK_OP;
00343       nd-&gt;content.op = op;
00344       (<font class="keywordtype">void</font>) symHashTable_put (ht, nd);
00345     }
00346   <font class="keywordflow">else</font>
00347     {
00348       
00349       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (n);  <font class="comment">/*&lt;&lt;&lt;??? */</font>
00350 
00351       <font class="keywordflow">if</font> (htData_insertSignature (d, oi))
00352         {
00353           ht-&gt;count++;
00354         }
00355     }
00356 }
00357 
00358 <font class="keywordtype">bool</font>
<a name="l00359"></a><a class="code" href="symtable_c.html#a38">00359</a>   <a class="code" href="symtable_c.html#a38">symtable_enterTag</a> (symtable st, tagInfo ti)<font class="keyword"></font>
00360 <font class="keyword"></font>{
00361   <font class="comment">/* put ti only if it is not already in symtable */</font>
00362   symHashTable *ht = st-&gt;hTable;
00363   htData *d;
00364   symbolKey key = ltoken_getText (ti-&gt;id);
00365 
00366   d = symHashTable_get (ht, key, IK_TAG, (nameNode) 0);
00367   <font class="keywordflow">if</font> (d == (htData *) 0)
00368     {
00369       d = (htData *) dmalloc (<font class="keyword">sizeof</font> (*d));
00370       d-&gt;kind = IK_TAG;
00371       d-&gt;content.tag = ti;
00372       d-&gt;content.tag-&gt;imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00373       (<font class="keywordtype">void</font>) symHashTable_put (ht, d);
00374       <font class="keywordflow">return</font> TRUE;
00375     }
00376   <font class="keywordflow">else</font>
00377     {
00378       <font class="keywordflow">if</font> (d-&gt;content.tag-&gt;imported)
00379         {
00380           d-&gt;content.tag = ti;
00381           d-&gt;content.tag-&gt;imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00382           <font class="keywordflow">return</font> TRUE;
00383         }
00384       <font class="keywordflow">else</font>
00385         {
00386           tagInfo_free (ti);
00387           <font class="keywordflow">return</font> FALSE;
00388         }
00389     }
00390 }
00391 
00392 <font class="keywordtype">bool</font>
<a name="l00393"></a><a class="code" href="symtable_c.html#a39">00393</a> <a class="code" href="symtable_c.html#a39">symtable_enterTagForce</a> (symtable st, tagInfo ti)<font class="keyword"></font>
00394 <font class="keyword"></font>{
00395  <font class="comment">/* put ti, force-put if necessary */</font>
00396   symHashTable *ht = st-&gt;hTable;
00397   htData *d;
00398   symbolKey key = ltoken_getText (ti-&gt;id);
00399 
00400   d = symHashTable_get (ht, key, IK_TAG, (nameNode) 0);
00401 
00402   <font class="keywordflow">if</font> (d == (htData *) 0)
00403     {
00404       d = (htData *) dmalloc (<font class="keyword">sizeof</font> (*d));
00405       
00406       d-&gt;kind = IK_TAG;
00407       d-&gt;content.tag = ti;
00408       d-&gt;content.tag-&gt;imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00409       (<font class="keywordtype">void</font>) symHashTable_put (ht, d);
00410       <font class="keywordflow">return</font> TRUE;
00411     }
00412   <font class="keywordflow">else</font>
00413     {
00414             
00415       d-&gt;kind = IK_TAG;
00416       d-&gt;content.tag = ti;
00417       d-&gt;content.tag-&gt;imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00418       <font class="comment">/* interpret return data later, htData * */</font>
00419       <font class="comment">/*@i@*/</font> (<font class="keywordtype">void</font>) symHashTable_forcePut (ht, d);
00420       <font class="keywordflow">return</font> FALSE;
00421     }
00422 }
00423 
00424 <font class="comment">/*@null@*/</font> opInfo
<a name="l00425"></a><a class="code" href="symtable_c.html#a40">00425</a> <a class="code" href="symtable_c.html#a40">symtable_opInfo</a> (symtable st, <font class="comment">/*@notnull@*/</font> nameNode n)<font class="keyword"></font>
00426 <font class="keyword"></font>{
00427   symHashTable *ht = st-&gt;hTable;
00428   lsymbol i = nameNode2key (n);
00429 
00430   htData *d;
00431   d = symHashTable_get (ht, i, IK_OP, n);
00432   <font class="keywordflow">if</font> (d == (htData *) 0)
00433     {
00434       <font class="keywordflow">return</font> (opInfo)NULL;
00435     }
00436 
00437   <font class="keywordflow">return</font> (d-&gt;content.op);
00438 }
00439 
00440 <font class="comment">/*@null@*/</font> tagInfo
<a name="l00441"></a><a class="code" href="symtable_c.html#a41">00441</a> <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (symtable st, lsymbol i)<font class="keyword"></font>
00442 <font class="keyword"></font>{
00443   symHashTable *ht = st-&gt;hTable;
00444   htData *d;
00445   d = symHashTable_get (ht, i, IK_TAG, 0);
00446 
00447   <font class="keywordflow">if</font> (d == (htData *) 0)
00448     {
00449       <font class="keywordflow">return</font> (tagInfo) NULL;
00450     }
00451 
00452   <font class="keywordflow">return</font> (d-&gt;content.tag);
00453 }
00454 
00455 <font class="keywordtype">void</font>
<a name="l00456"></a><a class="code" href="symtable_c.html#a42">00456</a>   <a class="code" href="symtable_c.html#a42">symtable_enterScope</a> (symtable stable, scopeInfo si)<font class="keyword"></font>
00457 <font class="keyword"></font>{
00458   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00459   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e = nextFree (st);
00460   <font class="keywordflow">if</font> (si-&gt;kind == SPE_GLOBAL)
00461     llbuglit (<font class="stringliteral">"symtable_enterScope: SPE_GLOBAL"</font>);
00462   e-&gt;kind = SYMK_SCOPE;
00463   (e-&gt;info).scope = si;
00464 }
00465 
00466 <font class="keywordtype">void</font>
<a name="l00467"></a><a class="code" href="symtable_c.html#a43">00467</a> <a class="code" href="symtable_c.html#a43">symtable_exitScope</a> (symtable stable)<font class="keyword"></font>
00468 <font class="keyword"></font>{
00469   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00470   <font class="keywordtype">int</font> n;
00471 
00472   <font class="keywordflow">if</font> (st-&gt;entries != NULL)
00473     {
00474       <font class="keywordflow">for</font> (n = st-&gt;size - 1; (st-&gt;entries[n]).kind != SYMK_SCOPE; n--)
00475         {
00476           ;
00477         }
00478     }
00479   <font class="keywordflow">else</font>
00480     {
00481       llcontbuglit (<font class="stringliteral">"symtable_exitScope: no scope to exit"</font>);
00482       n = 0;
00483     }
00484 
00485   st-&gt;size = n;
00486 }
00487 
00488 <font class="keywordtype">bool</font>
<a name="l00489"></a><a class="code" href="symtable_c.html#a44">00489</a> <a class="code" href="symtable_c.html#a44">symtable_enterFct</a> (symtable stable, fctInfo fi)<font class="keyword"></font>
00490 <font class="keyword"></font>{
00491   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00492   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
00493   <font class="keywordtype">bool</font> redecl = FALSE;
00494 
00495   <font class="keywordflow">if</font> (!allowed_redeclaration &amp;&amp;
00496       symtable_lookup (st, ltoken_getText (fi-&gt;id)) != (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0)
00497     {
00498       <a class="code" href="llerror_c.html#a58">lclRedeclarationError</a> (fi-&gt;id);
00499       redecl = TRUE;
00500     }
00501   
00502   e = nextFree (st);
00503   e-&gt;kind = SYMK_FCN;
00504   fi-&gt;export = st-&gt;exporting;   <font class="comment">/* &amp;&amp; !fi-&gt;private; */</font>
00505   (e-&gt;info).fct = fi;
00506 
00507   <font class="keywordflow">return</font> redecl;
00508 }
00509 
00510 <font class="keywordtype">void</font>
<a name="l00511"></a><a class="code" href="symtable_c.html#a45">00511</a> <a class="code" href="symtable_c.html#a45">symtable_enterType</a> (symtable stable, <font class="comment">/*@only@*/</font> typeInfo ti)<font class="keyword"></font>
00512 <font class="keyword"></font>{
00513   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00514   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
00515   <font class="keywordtype">bool</font> insertp = TRUE;
00516   scopeKind k = (symtable_scopeInfo (stable))-&gt;kind;
00517 
00518   <font class="comment">/* symtable_disp (stable); */</font>
00519 
00520   <font class="keywordflow">if</font> (k != SPE_GLOBAL &amp;&amp; k != SPE_INVALID)      <font class="comment">/* fixed for LCLint */</font>
00521     {
00522       llbug (message (<font class="stringliteral">"%q: symtable_enterType: expect global scope. (type: %s)"</font>,
00523                       ltoken_unparseLoc (ti-&gt;id),
00524                       ltoken_getRawString (ti-&gt;id)));
00525     }
00526 
00527   <font class="keywordflow">if</font> (!allowed_redeclaration &amp;&amp;
00528       symtable_lookup (st, ltoken_getText (ti-&gt;id)) != (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0)
00529     {
00530      <font class="comment">/* ignore if Bool is re-entered */</font>
00531       <font class="keywordflow">if</font> (ltoken_getText (ti-&gt;id) == <a class="code" href="abstract_c.html#a268">lsymbol_getBool</a> () ||
00532           ltoken_getText (ti-&gt;id) == <a class="code" href="abstract_c.html#a267">lsymbol_getbool</a> ())
00533         {
00534           insertp = FALSE;
00535         }
00536       <font class="keywordflow">else</font>
00537         {
00538           <a class="code" href="llerror_c.html#a58">lclRedeclarationError</a> (ti-&gt;id);
00539         }
00540     }
00541   <font class="keywordflow">if</font> (insertp)
00542     {
00543       <font class="comment">/* make sure it is a type TYPEDEF_NAME; */</font>
00544       
00545       <font class="keywordflow">if</font> (ltoken_getCode (ti-&gt;id) != LLT_TYPEDEF_NAME)
00546         {
00547           <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"symtable_enterType: gets a simpleId, expect a type: %s"</font>,
00548                            ltoken_getRawString (ti-&gt;id)));
00549         }
00550       
00551       e = nextFree (st);
00552       e-&gt;kind = SYMK_TYPE;
00553       ti-&gt;export = st-&gt;exporting;<font class="comment">/* &amp;&amp; !ti-&gt;private; */</font>
00554       (e-&gt;info).type = ti;
00555       <a class="code" href="mapping_c.html#a6">mapping_bind</a> (stable-&gt;type2sort, ltoken_getText (ti-&gt;id),
00556                     <a class="code" href="sort_c.html#a113">sort_getLsymbol</a> (sort_makeVal (sort_getUnderlying (ti-&gt;basedOn))));
00557     }
00558   <font class="keywordflow">else</font>
00559     {
00560       typeInfo_free (ti);
00561     }
00562 }
00563 
00564 lsymbol
<a name="l00565"></a><a class="code" href="symtable_c.html#a46">00565</a> <a class="code" href="symtable_c.html#a46">lsymbol_sortFromType</a> (symtable s, lsymbol <font class="keyword">typename</font>)<font class="keyword"></font>
00566 <font class="keyword"></font>{
00567   lsymbol inter;
00568   lsymbol out;
00569   ltoken tok;
00570  <font class="comment">/* check the synonym table first */</font>
00571   <font class="keywordflow">if</font> (<a class="code" href="lclsyntable_c.html#a5">LCLIsSyn</a> (<font class="keyword">typename</font>))
00572     {
00573       tok = <a class="code" href="lclsyntable_c.html#a4">LCLGetTokenForSyn</a> (<font class="keyword">typename</font>);
00574       inter = ltoken_getText (tok);
00575      <font class="comment">/*    printf ("In lsymbol_sortFromType: %s -&gt; %s\n",</font>
00576 <font class="comment">                lsymbol_toChars (typename), lsymbol_toChars (inter)); */</font>
00577     }
00578   <font class="keywordflow">else</font>
00579     {
00580       inter = <font class="keyword">typename</font>;
00581     }
00582 
00583   <font class="comment">/* now map LCL type to sort */</font>
00584   out = <a class="code" href="mapping_c.html#a5">mapping_find</a> (s-&gt;type2sort, inter);
00585   
00586   <font class="keywordflow">if</font> (out == lsymbol_undefined)
00587     {
00588       <font class="keywordflow">return</font> inter;
00589     }
00590 
00591   <font class="keywordflow">return</font> out;
00592 }
00593 
00594 <font class="comment">/* really temp! */</font>
00595 
00596 <font class="comment">/*</font>
00597 <font class="comment">** returns true is vi is a redeclaration</font>
00598 <font class="comment">*/</font>
00599 
00600 <font class="keywordtype">bool</font>
<a name="l00601"></a><a class="code" href="symtable_c.html#a47">00601</a> <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (symtable stable, <font class="comment">/*@temp@*/</font> varInfo vi)<font class="keyword"></font>
00602 <font class="keyword"></font>{
00603   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00604   <font class="keywordtype">bool</font> insertp = TRUE;
00605   <font class="keywordtype">bool</font> redecl = FALSE;
00606 
00607   
00608   <font class="comment">/* symtable_disp (symtab); */</font>
00609   
00610   <font class="keywordflow">if</font> (!allowed_redeclaration &amp;&amp;
00611       (symtable_lookupInScope (st, ltoken_getText (vi-&gt;id)) != (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0))
00612     {
00613       <font class="keywordflow">if</font> (ltoken_getText (vi-&gt;id) == <a class="code" href="abstract_c.html#a270">lsymbol_getTRUE</a> () ||
00614           ltoken_getText (vi-&gt;id) == <a class="code" href="abstract_c.html#a269">lsymbol_getFALSE</a> ())
00615         {
00616           insertp = FALSE;
00617         }
00618       <font class="keywordflow">else</font>
00619         {
00620           <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a127">usymtab_existsEither</a> (ltoken_getRawString (vi-&gt;id)))
00621             {
00622                       <a class="code" href="llerror_c.html#a58">lclRedeclarationError</a> (vi-&gt;id);
00623               redecl = TRUE;
00624             }
00625           <font class="keywordflow">else</font>
00626             {
00627               llbuglit (<font class="stringliteral">"redeclared somethingerother?!"</font>);
00628             }
00629         }
00630     }
00631 
00632   <font class="keywordflow">if</font> (insertp)
00633     {
00634       <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e = nextFree (st);
00635 
00636       e-&gt;kind = SYMK_VAR;
00637       vi-&gt;export = st-&gt;exporting &amp;&amp;     <font class="comment">/* !vi.private &amp;&amp; */</font>
00638         (vi-&gt;kind == VRK_VAR || vi-&gt;kind == VRK_CONST || vi-&gt;kind == VRK_ENUM);
00639       (e-&gt;info).var = varInfo_copy (vi);
00640     }
00641   
00642     <font class="keywordflow">return</font> (redecl);
00643 }
00644 
00645 <font class="keywordtype">bool</font>
<a name="l00646"></a><a class="code" href="symtable_c.html#a48">00646</a> <a class="code" href="symtable_c.html#a48">symtable_exists</a> (symtable stable, lsymbol i)<font class="keyword"></font>
00647 <font class="keyword"></font>{
00648   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00649   <font class="keywordflow">return</font> symtable_lookup (st, i) != (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0;
00650 }
00651 
00652 <font class="comment">/*@null@*/</font> typeInfo
<a name="l00653"></a><a class="code" href="symtable_c.html#a49">00653</a> <a class="code" href="symtable_c.html#a49">symtable_typeInfo</a> (symtable stable, lsymbol i)<font class="keyword"></font>
00654 <font class="keyword"></font>{
00655   <a class="code" href="struct__idTable.html">idTable</a> *st;
00656   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
00657 
00658   st = stable-&gt;idTable;
00659   e = symtable_lookup (st, i);
00660 
00661   <font class="keywordflow">if</font> (e == (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0 || e-&gt;kind != SYMK_TYPE)
00662     {
00663       <font class="keywordflow">return</font> (typeInfo) NULL;
00664     }
00665 
00666   <font class="keywordflow">return</font> (e-&gt;info).type;
00667 }
00668 
00669 <font class="comment">/*@null@*/</font> varInfo
<a name="l00670"></a><a class="code" href="symtable_c.html#a50">00670</a> <a class="code" href="symtable_c.html#a50">symtable_varInfo</a> (symtable stable, lsymbol i)<font class="keyword"></font>
00671 <font class="keyword"></font>{
00672   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00673   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
00674 
00675   e = symtable_lookup (st, i);
00676 
00677   <font class="keywordflow">if</font> (e == (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0 || e-&gt;kind != SYMK_VAR)
00678     {
00679       <font class="keywordflow">return</font> (varInfo) NULL;
00680     }
00681 
00682   <font class="keywordflow">return</font> (e-&gt;info).var;
00683 }
00684 
00685 <font class="comment">/*@null@*/</font> varInfo
<a name="l00686"></a><a class="code" href="symtable_c.html#a51">00686</a> <a class="code" href="symtable_c.html#a51">symtable_varInfoInScope</a> (symtable stable, lsymbol id)<font class="keyword"></font>
00687 <font class="keyword"></font>{
00688   <font class="comment">/* if current scope is a SPE_QUANT, can go beyond current scope */</font>
00689   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00690   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e2 = (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0;
00691   <font class="keywordtype">int</font> n;
00692   
00693   <font class="keywordflow">for</font> (n = st-&gt;size - 1; n &gt;= 0; n--)
00694     {
00695       ltoken tok;
00696 
00697       e2 = &amp;(st-&gt;entries[n]);
00698       
00699       <font class="keywordflow">if</font> (e2-&gt;kind == SYMK_SCOPE &amp;&amp; e2-&gt;info.scope-&gt;kind != SPE_QUANT)
00700         {
00701           <font class="keywordflow">return</font> (varInfo) NULL;
00702         }
00703 
00704       tok = idTableEntry_getId (e2);
00705 
00706       <font class="keywordflow">if</font> (e2-&gt;kind == SYMK_VAR &amp;&amp; ltoken_getText (tok) == id)
00707         {
00708           <font class="keywordflow">return</font> (e2-&gt;info).var;
00709         }
00710     }
00711 
00712   <font class="keywordflow">return</font> (varInfo) NULL;
00713 }
00714 
00715 scopeInfo
00716 symtable_scopeInfo (symtable stable)<font class="keyword"></font>
00717 <font class="keyword"></font>{
00718   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00719   <font class="keywordtype">int</font> n;
00720   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
00721 
00722   <font class="keywordflow">for</font> (n = st-&gt;size - 1; n &gt;= 0; n--)
00723     {
00724       e = &amp;(st-&gt;entries[n]);
00725       <font class="keywordflow">if</font> (e-&gt;kind == SYMK_SCOPE)
00726         <font class="keywordflow">return</font> (e-&gt;info).scope;
00727     }
00728 
00729   <a class="code" href="llerror_c.html#a44">lclfatalbug</a> (<font class="stringliteral">"symtable_scopeInfo: not found"</font>);
00730   BADEXIT;
00731 }
00732 
00733 <font class="keywordtype">void</font>
<a name="l00734"></a><a class="code" href="symtable_c.html#a52">00734</a> <a class="code" href="symtable_c.html#a52">symtable_export</a> (symtable stable, <font class="keywordtype">bool</font> yesNo)<font class="keyword"></font>
00735 <font class="keyword"></font>{
00736   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
00737   st-&gt;exporting = yesNo;
00738   (<font class="keywordtype">void</font>) <a class="code" href="sort_c.html#a104">sort_setExporting</a> (yesNo);
00739 }
00740 
00741 <font class="keyword">static</font> <font class="keywordtype">void</font>
00742 symHashTable_dump (symHashTable * t, FILE * f, <font class="keywordtype">bool</font> lco)<font class="keyword"></font>
00743 <font class="keyword"></font>{
00744   <font class="comment">/* like symHashTable_dump2 but for output to .lcs file */</font>
00745   <font class="keywordtype">int</font> i, size;
00746   bucket *b;
00747   htEntry *entry;
00748   htData *d;
00749   ltoken tok;
00750   sigNodeSet sigs;
00751   
00752   <font class="keywordflow">for</font> (i = 0; i &lt;= HT_MAXINDEX; i++)
00753     {
00754             b = t-&gt;buckets[i];
00755 
00756       <font class="keywordflow">for</font> (entry = b; entry != NULL; entry = entry-&gt;next)
00757         {
00758           d = entry-&gt;data;
00759 
00760           <font class="keywordflow">switch</font> (d-&gt;kind)
00761             {
00762             <font class="keywordflow">case</font> IK_SORT:
00763               <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00764             <font class="keywordflow">case</font> IK_OP:
00765               {
00766                 <font class="keywordtype">char</font> *name = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (nameNode_unparse (d-&gt;content.op-&gt;name));
00767                 sigs = d-&gt;content.op-&gt;signatures;
00768                 size = sigNodeSet_size (sigs);
00769 
00770                 
00771                 sigNodeSet_elements (sigs, x)<font class="keyword"></font>
00772 <font class="keyword">                  </font>{
00773                     cstring s = <a class="code" href="abstract_c.html#a102">sigNode_unparse</a> (x);
00774 
00775                     <font class="keywordflow">if</font> (lco)
00776                       {
00777                         fprintf (f, <font class="stringliteral">"%%LCL"</font>);
00778                       }
00779 
00780                     fprintf (f, <font class="stringliteral">"op %s %s\n"</font>, name, cstring_toCharsSafe (s));
00781                     <a class="code" href="cstring_c.html#a27">cstring_free</a> (s);
00782                   } end_sigNodeSet_elements;
00783 
00784                 <a class="code" href="general_c.html#a0">sfree</a> (name);
00785                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00786               }
00787             <font class="keywordflow">case</font> IK_TAG:
00788               tok = d-&gt;content.tag-&gt;id;
00789               
00790               <font class="keywordflow">if</font> (!ltoken_isUndefined (tok))
00791                 {
00792                   cstring s = <a class="code" href="symtable_c.html#a64">tagKind_unparse</a> (d-&gt;content.tag-&gt;kind);
00793 
00794                   <font class="keywordflow">if</font> (lco)
00795                     {
00796                       fprintf (f, <font class="stringliteral">"%%LCL"</font>);
00797                     }
00798 
00799                   fprintf (f, <font class="stringliteral">"tag %s %s\n"</font>, ltoken_getTextChars (tok), 
00800                            <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (s));
00801                   <a class="code" href="cstring_c.html#a27">cstring_free</a> (s);
00802                 }
00803               <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00804             }
00805         }
00806     }
00807 }
00808 
00809 <font class="keywordtype">void</font>
<a name="l00810"></a><a class="code" href="symtable_c.html#a53">00810</a> <a class="code" href="symtable_c.html#a53">symtable_dump</a> (symtable stable, FILE * f, <font class="keywordtype">bool</font> lco)<font class="keyword"></font>
00811 <font class="keyword"></font>{
00812   symHashTable *ht = stable-&gt;hTable;
00813 
00814 
00815   fprintf (f, <font class="stringliteral">"%s\n"</font>, BEGINSYMTABLE);
00816    
00817   symHashTable_dump (ht, f, lco);
00818    
00819   symtable_dumpId (stable, f, lco);
00820   
00821   fprintf (f, <font class="stringliteral">"%s\n"</font>, SYMTABLEEND);
00822   }
00823 
00824 lsymbol
<a name="l00825"></a><a class="code" href="symtable_c.html#a54">00825</a> <a class="code" href="symtable_c.html#a54">lsymbol_translateSort</a> (mapping * m, lsymbol s)<font class="keyword"></font>
00826 <font class="keyword"></font>{
00827   lsymbol res = <a class="code" href="mapping_c.html#a5">mapping_find</a> (m, s);
00828   <font class="keywordflow">if</font> (res == lsymbol_undefined)
00829     <font class="keywordflow">return</font> s;
00830   <font class="keywordflow">return</font> res;
00831 }
00832 
00833 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> lslOp
00834   lslOp_renameSorts (mapping *map,<font class="comment">/*@returned@*/</font> <font class="comment">/*@null@*/</font> lslOp op)<font class="keyword"></font>
00835 <font class="keyword"></font>{
00836   sigNode sign;
00837 
00838   <font class="keywordflow">if</font> (op != (lslOp) 0)
00839     {
00840       ltokenList domain;
00841       ltoken range;
00842 
00843       sign = op-&gt;signature;
00844       range = sign-&gt;range;
00845       domain = sign-&gt;domain;
00846 
00847       ltokenList_elements (domain, dt)<font class="keyword"></font>
00848 <font class="keyword">        </font>{
00849           ltoken_setText (dt, 
00850                           lsymbol_translateSort (map, ltoken_getText (dt)));
00851         } end_ltokenList_elements;
00852 
00853       <font class="comment">/*@-onlytrans@*/</font> <font class="comment">/* A memory leak... */</font>
00854       op-&gt;signature = <a class="code" href="abstract_c.html#a101">makesigNode</a> (sign-&gt;tok, domain, range);
00855       <font class="comment">/*@=onlytrans@*/</font>
00856     }
00857 
00858   <font class="keywordflow">return</font> op;
00859 }
00860 
00861 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> signNode
00862   signNode_fromsigNode (sigNode s)<font class="keyword"></font>
00863 <font class="keyword"></font>{
00864   signNode sign;
00865   sortList slist;
00866   
00867   <font class="keywordflow">if</font> (s == (sigNode) 0)
00868     {
00869       <font class="keywordflow">return</font> (signNode) 0;
00870     }
00871   
00872   sign = (signNode) dmalloc (<font class="keyword">sizeof</font> (*sign));
00873   slist = <a class="code" href="sortList_c.html#a0">sortList_new</a> ();
00874   sign-&gt;tok = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (s-&gt;tok);
00875   sign-&gt;key = s-&gt;key;
00876   sign-&gt;range = <a class="code" href="sort_c.html#a69">sort_makeSort</a> (ltoken_undefined, ltoken_getText (s-&gt;range));
00877 
00878   ltokenList_elements (s-&gt;domain, dt)<font class="keyword"></font>
00879 <font class="keyword">    </font>{
00880       <a class="code" href="sortList_c.html#a2">sortList_addh</a> (slist, sort_makeSort (ltoken_undefined, ltoken_getText (dt)));
00881     } end_ltokenList_elements;
00882 
00883   sign-&gt;domain = slist;
00884   <font class="keywordflow">return</font> sign;
00885 }
00886 
00887 
00892 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> pairNodeList
00893 parseGlobals (<font class="keywordtype">char</font> *line, tsource *srce)<font class="keyword"></font>
00894 <font class="keyword"></font>{
00895   pairNodeList plist = <a class="code" href="pairNodeList_c.html#a0">pairNodeList_new</a> ();
00896   pairNode p;
00897   <font class="keywordtype">int</font> semi_index;
00898   <font class="keywordtype">char</font> *lineptr, sostr[MAXBUFFLEN], gstr[MAXBUFFLEN];
00899 
00900   <font class="comment">/* line is not all blank */</font>
00901   <font class="comment">/* expected format: "sort1 g1; sort2 g2; sort3 g3;" */</font>
00902   lineptr = line;
00903   
00904   <font class="keywordflow">while</font> (!isBlankLine (lineptr))
00905     {
00906       <font class="keywordflow">if</font> (sscanf (lineptr, <font class="stringliteral">"%s %s"</font>, &amp;(sostr[0]), gstr) != 2)
00907         {
00908           lclplainerror 
00909             (message 
00910              (<font class="stringliteral">"%q: Imported file contains illegal function global declaration.\n"</font>
00911               <font class="stringliteral">"Skipping rest of the line: %s (%s)"</font>,
00912               <a class="code" href="fileloc_c.html#a40">fileloc_unparseRaw</a> (cstring_fromChars (tsource_fileName (srce)), 
00913                                   tsource_thisLineNumber (srce)), 
00914               <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line), 
00915               <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lineptr)));
00916           <font class="keywordflow">return</font> plist;
00917         }
00918       
00919       p = (pairNode) dmalloc (<font class="keyword">sizeof</font> (*p));
00920       
00921       <font class="comment">/* Note: remove the ";" separator at the end of gstr */</font>
00922       semi_index = <a class="code" href="general_c.html#a34">size_toInt</a> (strlen (gstr));
00923       gstr[semi_index - 1] = <font class="charliteral">'\0'</font>;
00924 
00925       p-&gt;tok = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (NOTTOKEN, lsymbol_fromChars (gstr));
00926       p-&gt;sort = <a class="code" href="sort_c.html#a69">sort_makeSort</a> (ltoken_undefined, lsymbol_fromChars (sostr));
00927 
00928       <a class="code" href="pairNodeList_c.html#a2">pairNodeList_addh</a> (plist, p);
00929       lineptr = strchr (lineptr, <font class="charliteral">';'</font>);  <font class="comment">/* go pass the next; */</font>
00930 
00931       llassert (lineptr != NULL);
00932       lineptr = lineptr + 1;
00933     }
00934 
00935   <font class="keywordflow">return</font> plist;
00936 }
00937 
00938 <font class="keyword">static</font> <font class="keywordtype">bool</font>
00939 isBlankLine (<font class="keywordtype">char</font> *line)<font class="keyword"></font>
00940 <font class="keyword"></font>{
00941   <font class="keywordtype">int</font> i;
00942 
00943   <font class="keywordflow">if</font> (line == NULL) <font class="keywordflow">return</font> TRUE;
00944 
00945   <font class="keywordflow">for</font> (i = 0; line[i] != <font class="charliteral">'\0'</font>; i++)
00946     {
00947       <font class="keywordflow">if</font> (line[i] == <font class="charliteral">' '</font>)
00948         <font class="keywordflow">continue</font>;
00949       <font class="keywordflow">if</font> (line[i] == <font class="charliteral">'\t'</font>)
00950         <font class="keywordflow">continue</font>;
00951       <font class="keywordflow">if</font> (line[i] == <font class="charliteral">'\n'</font>)
00952         <font class="keywordflow">return</font> TRUE;
00953       <font class="keywordflow">return</font> FALSE;
00954     }
00955   <font class="keywordflow">return</font> TRUE;
00956 }
00957 
<a name="l00958"></a><a class="code" href="symtable_c.html#a5">00958</a> <font class="keyword">typedef</font> <font class="comment">/*@only@*/</font> fctInfo o_fctInfo;
00959 
00960 <font class="keyword">static</font> <font class="keywordtype">void</font>
00961 parseLine (<font class="keywordtype">char</font> *line, tsource *srce, mapping * map)<font class="keyword"></font>
00962 <font class="keyword"></font>{
00963   <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> o_fctInfo *savedFcn = NULL;
00964   <font class="keywordtype">char</font> *lineptr, *lineptr2, *cimportfile = tsource_fileName (srce);
00965   cstring importfile = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (cimportfile);
00966   <font class="keywordtype">char</font> namestr[MAXBUFFLEN], kstr[20], sostr[MAXBUFFLEN];
00967   sort bsort, nullSort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
00968   <font class="keywordtype">int</font> col = 0;
00969   fileloc imploc = fileloc_undefined;
00970 
00971   
00972   <font class="keywordflow">if</font> (inImport)
00973     {
00974       imploc = <a class="code" href="fileloc_c.html#a32">fileloc_createImport</a> (importfile, tsource_thisLineNumber (srce));
00975     }
00976   
00977   <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"op"</font>))
00978     {
00979       lslOp op;
00980 
00981       lineptr = strchr (line, <font class="charliteral">'o'</font>);     <font class="comment">/* remove any leading blanks */</font>
00982       llassert (lineptr != NULL);
00983       lineptr = strchr (lineptr, <font class="charliteral">' '</font>);  <font class="comment">/* go past "op" */</font>
00984       llassert (lineptr != NULL);
00985 
00986       <font class="comment">/* add a newline to the end of the line since parseOpLine expects it */</font>
00987       lineptr2 = strchr (lineptr, <font class="charliteral">'\0'</font>);
00988 
00989       <font class="keywordflow">if</font> (lineptr2 != 0)
00990         {
00991           *lineptr2 = <font class="charliteral">'\n'</font>;
00992           *(lineptr2 + 1) = <font class="charliteral">'\0'</font>;
00993         }
00994 
00995       llassert (cimportfile != NULL);
00996       op = <a class="code" href="lslparse_c.html#a4">parseOpLine</a> (cimportfile, lineptr + 1);
00997       
00998       <font class="keywordflow">if</font> (op == (lslOp) 0)
00999         {
01000           lclplainerror
01001             (message
01002              (<font class="stringliteral">"%q: Imported file contains illegal operator declaration:\n "</font>
01003               <font class="stringliteral">"skipping this line: %s"</font>,
01004               <a class="code" href="fileloc_c.html#a40">fileloc_unparseRaw</a> (importfile, tsource_thisLineNumber (srce)), 
01005               <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01006           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01007           <font class="keywordflow">return</font>;
01008         }
01009 
01010             op = lslOp_renameSorts (map, op);
01011 
01012       llassert (op != NULL);
01013       llassert (op-&gt;name != NULL);
01014 
01015       <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, op-&gt;name, 
01016                         sigNode_copy (op-&gt;signature));
01017           <font class="comment">/*@-mustfree@*/</font> } <font class="comment">/*@=mustfree@*/</font>
01018   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"type"</font>))
01019     {
01020       typeInfo ti;
01021 
01022       <font class="keywordflow">if</font> (sscanf (line, <font class="stringliteral">"type %s %s %s"</font>, namestr, sostr, kstr) != 3)
01023         {
01024           lclplainerror 
01025             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: illegal type declaration:\n skipping this line: %s"</font>,
01026                       fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01027                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01028           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01029           <font class="keywordflow">return</font>;
01030         }
01031       
01032       ti = (typeInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
01033       ti-&gt;id = <a class="code" href="ltoken_c.html#a35">ltoken_createFull</a> (LLT_TYPEDEF_NAME, lsymbol_fromChars (namestr),
01034                                     importfile, tsource_thisLineNumber (srce), col);
01035 
01036       bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, lsymbol_fromChars (sostr)));
01037 
01038       <font class="keywordflow">if</font> (sort_isNoSort (bsort))
01039         {
01040           lineptr = strchr (line, <font class="charliteral">' '</font>); <font class="comment">/* go past "type" */</font>
01041           llassert (lineptr != NULL);
01042           lineptr = strchr (lineptr + 1, <font class="charliteral">' '</font>);  <font class="comment">/* go past namestr */</font>
01043           llassert (lineptr != NULL);
01044           col = 5 + lineptr - line;     <font class="comment">/* 5 for initial "%LCL "*/</font>
01045 
01046           <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%q: Imported files contains unknown base sort"</font>,
01047                            fileloc_unparseRawCol (importfile, tsource_thisLineNumber (srce), col)));
01048 
01049           bsort = nullSort;
01050         }
01051       ti-&gt;basedOn = bsort;
01052 
01053       <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"exposed"</font>) == 0)
01054         {
01055           ti-&gt;abstract = FALSE;
01056           ti-&gt;modifiable = TRUE;
01057         }
01058       <font class="keywordflow">else</font>
01059         {
01060           ti-&gt;abstract = TRUE;
01061           <font class="keywordflow">if</font> (strcmp (kstr, <font class="stringliteral">"mutable"</font>) == 0)
01062             ti-&gt;modifiable = TRUE;
01063           <font class="keywordflow">else</font>
01064             ti-&gt;modifiable = FALSE;
01065         }
01066       ti-&gt;export = TRUE;
01067       
01068       <font class="comment">/* </font>
01069 <font class="comment">      ** sort of a hack to get imports to work...</font>
01070 <font class="comment">      */</font>
01071       
01072       <font class="keywordflow">if</font> (inImport)
01073         {
01074           cstring cnamestr = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (namestr);
01075 
01076           <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a128">usymtab_existsGlobEither</a> (cnamestr))
01077             {
01078               (<font class="keywordtype">void</font>) usymtab_addEntry 
01079                 (<a class="code" href="uentry_c.html#a112">uentry_makeDatatype</a> (cnamestr, ctype_unknown,
01080                                       ti-&gt;abstract ? ynm_fromBool (ti-&gt;modifiable) : MAYBE,
01081                                       ti-&gt;abstract ? YES : NO,
01082                                       <a class="code" href="fileloc_c.html#a5">fileloc_copy</a> (imploc)));
01083             }
01084         }
01085 
01086       <a class="code" href="symtable_c.html#a45">symtable_enterType</a> (g_symtab, ti);
01087     }
01088   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"var"</font>))
01089     {
01090       varInfo vi;
01091 
01092       <font class="keywordflow">if</font> (sscanf (line, <font class="stringliteral">"var %s %s"</font>, namestr, sostr) != 2)
01093         {
01094           lclplainerror
01095             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Imported file contains illegal variable declaration.  "</font>
01096                       <font class="stringliteral">"Skipping this line."</font>, 
01097                       fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce))));
01098           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01099           <font class="keywordflow">return</font>;
01100         }
01101 
01102       vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
01103       bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, lsymbol_fromChars (sostr)));
01104       lineptr = strchr (line, <font class="charliteral">' '</font>);     <font class="comment">/* go past "var" */</font>
01105       llassert (lineptr != NULL);
01106       lineptr = strchr (lineptr + 1, <font class="charliteral">' '</font>);      <font class="comment">/* go past namestr */</font>
01107       llassert (lineptr != NULL);
01108       col = 5 + lineptr - line; <font class="comment">/* 5 for initial "%LCL "*/</font>
01109 
01110       <font class="keywordflow">if</font> (sort_isNoSort (bsort))
01111         {
01112           <a class="code" href="llerror_c.html#a55">lclplainerror</a> (message (<font class="stringliteral">"%q: Imported file contains unknown base sort"</font>,
01113                                   fileloc_unparseRawCol (importfile, tsource_thisLineNumber (srce), col)));
01114           bsort = nullSort;
01115         }
01116 
01117       vi-&gt;id = <a class="code" href="ltoken_c.html#a35">ltoken_createFull</a> (simpleId, lsymbol_fromChars (namestr),
01118                                   importfile, tsource_thisLineNumber (srce), col);
01119       vi-&gt;sort = bsort;
01120       vi-&gt;kind = VRK_VAR;
01121       vi-&gt;export = TRUE;
01122       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
01123       <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
01124 
01125       <font class="keywordflow">if</font> (inImport)
01126         {
01127           cstring cnamestr = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (namestr);
01128 
01129           <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a128">usymtab_existsGlobEither</a> (cnamestr))
01130             {
01131               
01132               (<font class="keywordtype">void</font>) usymtab_supEntrySref 
01133                 (<a class="code" href="uentry_c.html#a99">uentry_makeVariable</a> (cnamestr, ctype_unknown, 
01134                                       fileloc_copy (imploc), 
01135                                       FALSE));
01136             }
01137         }
01138     }
01139   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"const"</font>))
01140     {
01141       varInfo vi;
01142 
01143       <font class="keywordflow">if</font> (sscanf (line, <font class="stringliteral">"const %s %s"</font>, namestr, sostr) != 2)
01144         {
01145           <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%q: Imported file contains illegal constant declaration: %s"</font>,
01146                            fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01147                            <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01148           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01149           <font class="keywordflow">return</font>;
01150         }
01151 
01152       vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
01153       bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, lsymbol_fromChars (sostr)));
01154       lineptr = strchr (line, <font class="charliteral">' '</font>);     <font class="comment">/* go past "var" */</font>
01155       llassert (lineptr != NULL);
01156       lineptr = strchr (lineptr + 1, <font class="charliteral">' '</font>);      <font class="comment">/* go past namestr */</font>
01157       llassert (lineptr != NULL);
01158       
01159       col = 5 + lineptr - line; <font class="comment">/* 5 for initial "%LCL "*/</font>
01160 
01161       <font class="keywordflow">if</font> (sort_isNoSort (bsort))
01162         {
01163           <a class="code" href="llerror_c.html#a55">lclplainerror</a> (message (<font class="stringliteral">"%q: Imported file contains unknown base sort"</font>,
01164                                   fileloc_unparseRawCol (importfile, tsource_thisLineNumber (srce), col)));
01165           bsort = nullSort;
01166         }
01167 
01168       vi-&gt;id = <a class="code" href="ltoken_c.html#a35">ltoken_createFull</a> (simpleId, lsymbol_fromChars (namestr),
01169                                     importfile, tsource_thisLineNumber (srce), col);
01170       vi-&gt;sort = bsort;
01171       vi-&gt;kind = VRK_CONST;
01172       vi-&gt;export = TRUE;
01173       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
01174       <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
01175       
01176       <font class="keywordflow">if</font> (inImport)
01177         {
01178           cstring cnamestr = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (namestr);
01179           
01180           <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a128">usymtab_existsGlobEither</a> (cnamestr))
01181             {
01182                       
01183               (<font class="keywordtype">void</font>) <a class="code" href="usymtab_c.html#a46">usymtab_addEntry</a> (uentry_makeConstant (cnamestr,
01184                                                             ctype_unknown,
01185                                                             fileloc_copy (imploc)));
01186             }
01187         }
01188       <font class="comment">/* must check for "fcnGlobals" before "fcn" */</font>
01189     }
01190   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"fcnGlobals"</font>))
01191     {
01192       pairNodeList globals;
01193       lineptr = strchr (line, <font class="charliteral">'f'</font>);     <font class="comment">/* remove any leading blanks */</font>
01194       llassert (lineptr != NULL);
01195       lineptr = strchr (lineptr, <font class="charliteral">' '</font>);  <font class="comment">/* go past "fcnGlobals" */</font>
01196       llassert (lineptr != NULL);
01197 
01198      <font class="comment">/* a quick check for empty fcnGlobals */</font>
01199       <font class="keywordflow">if</font> (!isBlankLine (lineptr))
01200         {
01201           globals = parseGlobals (lineptr, srce);
01202           <font class="comment">/* should ensure that each global in an imported function</font>
01203 <font class="comment">             corresponds to some existing global.  Since only</font>
01204 <font class="comment">             "correctly processed" .lcs files are imported, this is</font>
01205 <font class="comment">             true as an invariant. */</font>
01206         }
01207       <font class="keywordflow">else</font>
01208         {
01209           globals = <a class="code" href="pairNodeList_c.html#a0">pairNodeList_new</a> ();
01210         }
01211       
01212       <font class="comment">/* check that they exist, store them on fctInfo */</font>
01213 
01214       <font class="keywordflow">if</font> (savedFcn != NULL)
01215         {
01216           <a class="code" href="pairNodeList_c.html#a4">pairNodeList_free</a> ((*savedFcn)-&gt;globals);
01217           (*savedFcn)-&gt;globals = globals;  <font class="comment">/* evs, moved inside if predicate */</font>
01218 
01219           (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a44">symtable_enterFct</a> (g_symtab, *savedFcn);
01220           savedFcn = NULL;
01221         }
01222       <font class="keywordflow">else</font>
01223         {
01224           lclplainerror 
01225             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Unexpected function globals.  "</font>
01226                       <font class="stringliteral">"Skipping this line: \n%s"</font>,
01227                       fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01228                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01229           savedFcn = NULL;
01230           <a class="code" href="pairNodeList_c.html#a4">pairNodeList_free</a> (globals);
01231         }
01232     }
01233   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"fcn"</font>))
01234     {
01235       lslOp op;
01236       lslOp op2; 
01237 
01238       <font class="keywordflow">if</font> (savedFcn != (fctInfo *) 0)
01239         {
01240           lclplainerror 
01241             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: illegal function declaration.  Skipping this line:\n%s"</font>,
01242                       fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01243                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01244           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01245           <font class="keywordflow">return</font>;
01246         }
01247 
01248       savedFcn = (fctInfo *) dmalloc (<font class="keyword">sizeof</font> (*savedFcn));
01249 
01250       lineptr = strchr (line, <font class="charliteral">'f'</font>);     <font class="comment">/* remove any leading blanks */</font>
01251       llassert (lineptr != NULL);
01252       lineptr = strchr (lineptr, <font class="charliteral">' '</font>);  <font class="comment">/* go past "fcn" */</font>
01253       llassert (lineptr != NULL);
01254 
01255       <font class="comment">/* add a newline to the end of the line since parseOpLine expects it */</font>
01256 
01257       lineptr2 = strchr (lineptr, <font class="charliteral">'\0'</font>);
01258 
01259       <font class="keywordflow">if</font> (lineptr2 != 0)
01260         {
01261           *lineptr2 = <font class="charliteral">'\n'</font>;
01262           *(lineptr2 + 1) = <font class="charliteral">'\0'</font>;
01263         }
01264 
01265       op = <a class="code" href="lslparse_c.html#a4">parseOpLine</a> (cimportfile, lineptr + 1);
01266 
01267       <font class="keywordflow">if</font> (op == (lslOp) 0)
01268         {
01269           <a class="code" href="llerror_c.html#a55">lclplainerror</a> (message (<font class="stringliteral">"%q: illegal function declaration: %s"</font>,
01270                                   fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01271                                   <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01272           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01273           <font class="keywordflow">return</font>;
01274         }
01275         
01276       op2 = lslOp_renameSorts (map, op);
01277 
01278       llassert (op2 != NULL);
01279 
01280       <font class="keywordflow">if</font> ((op-&gt;name != NULL) &amp;&amp; op-&gt;name-&gt;isOpId)
01281         {
01282           (*savedFcn) = (fctInfo) dmalloc (<font class="keyword">sizeof</font> (**savedFcn));
01283           (*savedFcn)-&gt;id = op-&gt;name-&gt;content.opid;
01284           (*savedFcn)-&gt;signature = signNode_fromsigNode (op2-&gt;signature);
01285           (*savedFcn)-&gt;globals = <a class="code" href="pairNodeList_c.html#a0">pairNodeList_new</a> ();
01286           (*savedFcn)-&gt;export = TRUE;
01287           
01288           <font class="keywordflow">if</font> (inImport)
01289             {
01290               <font class="comment">/* 27 Jan 1995 --- added this to be undefined namestr bug */</font>
01291               cstring fname = <a class="code" href="ltoken_c.html#a38">ltoken_unparse</a> ((*savedFcn)-&gt;id);
01292               
01293               <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a128">usymtab_existsGlobEither</a> (fname))
01294                 {
01295                                   (<font class="keywordtype">void</font>) <a class="code" href="usymtab_c.html#a46">usymtab_addEntry</a> (uentry_makeFunction
01296                                            (fname, ctype_unknown, 
01297                                             typeId_invalid, globSet_new (),
01298                                             sRefSet_undefined, 
01299                                             <a class="code" href="fileloc_c.html#a5">fileloc_copy</a> (imploc)));
01300                 }
01301             }
01302         }
01303       <font class="keywordflow">else</font>
01304         {
01305           <a class="code" href="llerror_c.html#a55">lclplainerror</a> (message (<font class="stringliteral">"%q: unexpected function name: %s"</font>,
01306                                   fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01307                                   <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01308         }
01309     }
01310   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"enumConst"</font>))
01311     {
01312       varInfo vi;
01313 
01314       <font class="keywordflow">if</font> (sscanf (line, <font class="stringliteral">"enumConst %s %s"</font>, namestr, sostr) != 2)
01315         {
01316           lclplainerror 
01317             (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Illegal enum constant declaration.  "</font>
01318                       <font class="stringliteral">"Skipping this line:\n%s"</font>,
01319                       fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01320                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01321           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01322           <font class="keywordflow">return</font>;
01323         }
01324       
01325       vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
01326       bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, lsymbol_fromChars (sostr)));
01327       lineptr = strchr (line, <font class="charliteral">' '</font>);     <font class="comment">/* go past "var" */</font>
01328       llassert (lineptr != NULL);
01329       lineptr = strchr (lineptr + 1, <font class="charliteral">' '</font>);      <font class="comment">/* go past namestr */</font>
01330       llassert (lineptr != NULL);
01331 
01332       col = 5 + lineptr - line; <font class="comment">/* 5 for initial "%LCL "*/</font>
01333       <font class="keywordflow">if</font> (sort_isNoSort (bsort))
01334         {
01335           <a class="code" href="llerror_c.html#a55">lclplainerror</a> (message (<font class="stringliteral">"%q: unknown base sort\n"</font>,
01336                                   fileloc_unparseRawCol (importfile, tsource_thisLineNumber (srce), col)));
01337           bsort = nullSort;
01338         }
01339 
01340       vi-&gt;id = <a class="code" href="ltoken_c.html#a35">ltoken_createFull</a> (simpleId, lsymbol_fromChars (namestr),
01341                                     importfile, tsource_thisLineNumber (srce), col);
01342                         
01343       vi-&gt;sort = bsort;
01344       vi-&gt;kind = VRK_ENUM;
01345       vi-&gt;export = TRUE;
01346       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
01347       <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
01348 
01349       <font class="keywordflow">if</font> (inImport)
01350         {
01351           cstring cnamestr = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (namestr);
01352           <font class="keywordflow">if</font> (!<a class="code" href="usymtab_c.html#a127">usymtab_existsEither</a> (cnamestr))
01353             {
01354                       (<font class="keywordtype">void</font>) <a class="code" href="usymtab_c.html#a46">usymtab_addEntry</a> (uentry_makeConstant (cnamestr, ctype_unknown,
01355                                                             fileloc_copy (imploc)));
01356             }
01357         }
01358     }
01359   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (line, <font class="stringliteral">"tag"</font>))
01360     {
01361      <font class="comment">/* do nothing, sort processing already handles this */</font>
01362     }
01363   <font class="keywordflow">else</font>
01364     {
01365       lclplainerror 
01366         (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q: Unknown symbol declaration.  Skipping this line:\n%s"</font>,
01367                   fileloc_unparseRaw (importfile, tsource_thisLineNumber (srce)), 
01368                   <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (line)));
01369     }
01370 
01371     <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (imploc);
01372 }
01373 
01374 <font class="keywordtype">void</font>
<a name="l01375"></a><a class="code" href="symtable_c.html#a59">01375</a> <a class="code" href="symtable_c.html#a59">symtable_import</a> (tsource *imported, ltoken tok, mapping * map)<font class="keyword"></font>
01376 <font class="keyword"></font>{
01377   <font class="keywordtype">char</font> *buf, *importfile;
01378   tsource *lclsource;
01379   <font class="keywordtype">int</font> old_lsldebug;
01380   <font class="keywordtype">bool</font> old_inImport = inImport;
01381 
01382   buf = <a class="code" href="source_c.html#a4">tsource_nextLine</a> (imported);
01383   importfile = tsource_fileName (imported);
01384 
01385   llassert (buf != NULL);
01386 
01387   <font class="keywordflow">if</font> (!<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCLSymbolTable"</font>))
01388     {
01389       lclsource = <a class="code" href="lclscan_c.html#a12">LCLScanSource</a> ();
01390       <a class="code" href="llerror_c.html#a56">lclfatalerror</a> (tok, 
01391                      message (<font class="stringliteral">"Expecting '%%LCLSymbolTable' line in import file %s:\n%s\n"</font>,
01392                               cstring_fromChars (importfile), 
01393                               <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (buf)));
01394     }
01395 
01396   old_lsldebug = lsldebug;
01397   lsldebug = 0;
01398   allowed_redeclaration = TRUE;
01399   inImport = TRUE;
01400 
01401   <font class="keywordflow">for</font> (;;)
01402     {
01403       buf = <a class="code" href="source_c.html#a4">tsource_nextLine</a> (imported);
01404       llassert (buf != NULL);
01405 
01406       
01407       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCLSymbolTableEnd"</font>))
01408         {
01409           <font class="keywordflow">break</font>;
01410         }
01411       <font class="keywordflow">else</font>
01412         {                       <font class="comment">/* a good line, remove %LCL from line first */</font>
01413           <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCL"</font>))
01414             {
01415               parseLine (buf + 4, imported, map);
01416             }
01417           <font class="keywordflow">else</font>
01418             {
01419               lclsource = <a class="code" href="lclscan_c.html#a12">LCLScanSource</a> ();
01420               lclfatalerror 
01421                 (tok,
01422                  <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Expecting '%%LCL' prefix in import file %s:\n%s\n"</font>,
01423                           cstring_fromChars (importfile), 
01424                           <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (buf)));
01425             }
01426         }
01427     }
01428 
01429   <font class="comment">/* restore old value */</font>
01430   inImport = old_inImport;
01431   lsldebug = old_lsldebug;
01432   allowed_redeclaration = FALSE;
01433   }
01434 
01435 <font class="keyword">static</font> <font class="keywordtype">void</font>
01436 symtable_dumpId (symtable stable, FILE *f, <font class="keywordtype">bool</font> lco)<font class="keyword"></font>
01437 <font class="keyword"></font>{
01438   <a class="code" href="struct__idTable.html">idTable</a> *st = stable-&gt;idTable;
01439   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i;
01440   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *se;
01441   fctInfo fi;
01442   typeInfo ti;
01443   varInfo vi;
01444 
01445   <font class="keywordflow">for</font> (i = 1; i &lt; st-&gt;size; i++)
01446     {
01447       <font class="comment">/* 2/22/93 I think there is a off-by-1 error, 0 entry is never used */</font>
01448       se = st-&gt;entries + i;
01449       llassert (se != NULL);
01450       
01451       
01452       <font class="comment">/*@-loopswitchbreak@*/</font>
01453       <font class="keywordflow">switch</font> (se-&gt;kind)
01454         {
01455         <font class="keywordflow">case</font> SYMK_FCN:
01456           {
01457             cstring tmp;
01458             
01459             fi = (se-&gt;info).fct;
01460             
01461             <font class="keywordflow">if</font> (lco)
01462               {
01463                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
01464               }
01465 
01466             <font class="keywordflow">if</font> (!lco &amp;&amp; !fi-&gt;export)
01467               {
01468                 fprintf (f, <font class="stringliteral">"spec "</font>);
01469               }
01470             
01471             tmp = <a class="code" href="abstract_c.html#a220">signNode_unparse</a> (fi-&gt;signature);
01472             fprintf (f, <font class="stringliteral">"fcn %s %s \n"</font>, ltoken_getTextChars (fi-&gt;id), 
01473                      <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (tmp));
01474             <a class="code" href="cstring_c.html#a27">cstring_free</a> (tmp);
01475             
01476             tmp = <a class="code" href="pairNodeList_c.html#a3">pairNodeList_unparse</a> (fi-&gt;globals);
01477             fprintf (f, <font class="stringliteral">"%%LCLfcnGlobals %s\n"</font>, cstring_toCharsSafe (tmp));
01478             <a class="code" href="cstring_c.html#a27">cstring_free</a> (tmp);
01479             <font class="keywordflow">break</font>;
01480           }
01481         <font class="keywordflow">case</font> SYMK_SCOPE:
01482           <font class="keywordflow">if</font> (lco)
01483             {
01484               <font class="keywordflow">break</font>;
01485             }
01486 
01487           <font class="comment">/*@-switchswitchbreak@*/</font>
01488           <font class="keywordflow">switch</font> ((se-&gt;info).scope-&gt;kind)
01489             {
01490             <font class="keywordflow">case</font> SPE_GLOBAL:
01491               fprintf (f, <font class="stringliteral">"Global scope\n"</font>);
01492               <font class="keywordflow">break</font>;
01493             <font class="keywordflow">case</font> SPE_ABSTRACT:
01494               fprintf (f, <font class="stringliteral">"Abstract type scope\n"</font>);
01495               <font class="keywordflow">break</font>;
01496             <font class="keywordflow">case</font> SPE_FCN:
01497               fprintf (f, <font class="stringliteral">"Function scope\n"</font>);
01498               <font class="keywordflow">break</font>;
01499              <font class="comment">/* a let scope can only occur in a function scope, should not push</font>
01500 <font class="comment">                a new scope, so symtable_lookupInScope works properly</font>
01501 <font class="comment">                   case letScope:</font>
01502 <font class="comment">                     fprintf (f, "Let scope\n");</font>
01503 <font class="comment">                     break; */</font>
01504             <font class="keywordflow">case</font> SPE_QUANT:
01505               fprintf (f, <font class="stringliteral">"Quantifier scope\n"</font>);
01506               <font class="keywordflow">break</font>;
01507             <font class="keywordflow">case</font> SPE_CLAIM:
01508               fprintf (f, <font class="stringliteral">"Claim scope\n"</font>);
01509               <font class="keywordflow">break</font>;
01510             <font class="keywordflow">case</font> SPE_INVALID:
01511               <font class="keywordflow">break</font>;
01512             }
01513           <font class="keywordflow">break</font>;
01514         <font class="keywordflow">case</font> SYMK_TYPE:
01515           ti = (se-&gt;info).type;
01516           <font class="keywordflow">if</font> (lco)
01517             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
01518           <font class="keywordflow">if</font> (!lco &amp;&amp; !ti-&gt;export)
01519             fprintf (f, <font class="stringliteral">"spec "</font>);
01520           fprintf (f, <font class="stringliteral">"type %s %s"</font>,
01521                    ltoken_getTextChars (ti-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (ti-&gt;basedOn));
01522           <font class="keywordflow">if</font> (ti-&gt;abstract)
01523             {
01524               <font class="keywordflow">if</font> (ti-&gt;modifiable)
01525                 fprintf (f, <font class="stringliteral">" mutable\n"</font>);
01526               <font class="keywordflow">else</font>
01527                 fprintf (f, <font class="stringliteral">" immutable\n"</font>);
01528             }
01529           <font class="keywordflow">else</font>
01530             fprintf (f, <font class="stringliteral">" exposed\n"</font>);
01531           <font class="keywordflow">break</font>;
01532         <font class="keywordflow">case</font> SYMK_VAR:
01533 
01534           vi = (se-&gt;info).var;
01535           <font class="keywordflow">if</font> (lco)
01536             {
01537               fprintf (f, <font class="stringliteral">"%%LCL"</font>);
01538             }
01539 
01540           <font class="keywordflow">if</font> (!lco &amp;&amp; !vi-&gt;export)
01541             {
01542               fprintf (f, <font class="stringliteral">"spec "</font>);
01543             }
01544           <font class="keywordflow">switch</font> (vi-&gt;kind)
01545             {
01546             <font class="keywordflow">case</font> VRK_CONST:
01547               fprintf (f, <font class="stringliteral">"const %s %s\n"</font>,
01548                        ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01549               <font class="keywordflow">break</font>;
01550             <font class="keywordflow">case</font> VRK_VAR:
01551               fprintf (f, <font class="stringliteral">"var %s %s\n"</font>,
01552                        ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01553               <font class="keywordflow">break</font>;
01554             <font class="keywordflow">case</font> VRK_ENUM:
01555               fprintf (f, <font class="stringliteral">"enumConst %s %s\n"</font>,
01556                        ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01557               <font class="keywordflow">break</font>;
01558             <font class="keywordflow">default</font>:
01559               <font class="keywordflow">if</font> (lco)
01560                 {
01561                   <font class="keywordflow">switch</font> (vi-&gt;kind)
01562                     {
01563                     <font class="keywordflow">case</font> VRK_GLOBAL:
01564                       fprintf (f, <font class="stringliteral">"global %s %s\n"</font>, ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01565                       <font class="keywordflow">break</font>;
01566                     <font class="keywordflow">case</font> VRK_PRIVATE:   <font class="comment">/* for private vars within function */</font>
01567                       fprintf (f, <font class="stringliteral">"local %s %s\n"</font>,
01568                                ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01569                       <font class="keywordflow">break</font>;
01570                     <font class="keywordflow">case</font> VRK_LET:
01571                       fprintf (f, <font class="stringliteral">"let %s %s\n"</font>,
01572                                ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01573                       <font class="keywordflow">break</font>;
01574                     <font class="keywordflow">case</font> VRK_PARAM:
01575                       fprintf (f, <font class="stringliteral">"param %s %s\n"</font>,
01576                                ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01577                       <font class="keywordflow">break</font>;
01578                     <font class="keywordflow">case</font> VRK_QUANT:
01579                       fprintf (f, <font class="stringliteral">"quant %s %s\n"</font>,
01580                                ltoken_getTextChars (vi-&gt;id), <a class="code" href="sort_c.html#a114">sort_getName</a> (vi-&gt;sort));
01581                       <font class="keywordflow">break</font>;
01582                     BADDEFAULT;
01583                     }
01584                   <font class="comment">/*@=loopswitchbreak@*/</font>
01585                   <font class="comment">/*@=switchswitchbreak@*/</font>
01586                 }
01587             }
01588         }
01589     }
01590 }
01591 
01592 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@out@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *
01593 nextFree (<a class="code" href="struct__idTable.html">idTable</a> * st)<font class="keyword"></font>
01594 <font class="keyword"></font>{
01595   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *ret;
01596   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> n = st-&gt;size;
01597 
01598   <font class="keywordflow">if</font> (n &gt;= st-&gt;allocated)
01599     {
01600       <font class="comment">/*</font>
01601 <font class="comment">      ** this loses with the garbage collector</font>
01602 <font class="comment">      ** (and realloc is notoriously dangerous)</font>
01603 <font class="comment">      **</font>
01604 <font class="comment">      ** st-&gt;entries = (idTableEntry *) LSLMoreMem (st-&gt;entries, (n + DELTA) </font>
01605 <font class="comment">      **                                * sizeof (idTableEntry));</font>
01606 <font class="comment">      **</font>
01607 <font class="comment">      ** instead, we copy the symtable...</font>
01608 <font class="comment">      */</font>
01609       
01610       <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *oldentries = st-&gt;entries;
01611       <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i;
01612       
01613       st-&gt;entries = dmalloc ((n+DELTA) * <font class="keyword">sizeof</font> (*st-&gt;entries));
01614       
01615       <font class="keywordflow">for</font> (i = 0; i &lt; n; i++)
01616         {
01617           st-&gt;entries[i] = oldentries[i];
01618         }
01619       
01620       <a class="code" href="general_c.html#a0">sfree</a> (oldentries);
01621       
01622       st-&gt;allocated = n + DELTA;
01623     }
01624   
01625   ret = &amp;(st-&gt;entries[st-&gt;size]);
01626   st-&gt;size++;
01627   <font class="keywordflow">return</font> ret;
01628 }
01629 
01630 
01631 <font class="keyword">static</font> <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *
01632   symtable_lookup (<a class="code" href="struct__idTable.html">idTable</a> *st, lsymbol id)<font class="keyword"></font>
01633 <font class="keyword"></font>{
01634   <font class="keywordtype">int</font> n;
01635   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
01636 
01637   <font class="keywordflow">for</font> (n = st-&gt;size - 1; n &gt;= 0; n--)
01638     {
01639       e = &amp;(st-&gt;entries[n]);
01640 
01641       <font class="comment">/*@-loopswitchbreak@*/</font>
01642       <font class="keywordflow">switch</font> (e-&gt;kind)
01643         {
01644         <font class="keywordflow">case</font> SYMK_SCOPE: 
01645           <font class="keywordflow">break</font>;
01646         <font class="keywordflow">case</font> SYMK_FCN:
01647           <font class="keywordflow">if</font> (ltoken_getText (e-&gt;info.fct-&gt;id) == id) <font class="keywordflow">return</font> e;
01648           <font class="keywordflow">break</font>;
01649         <font class="keywordflow">case</font> SYMK_TYPE:
01650           <font class="keywordflow">if</font> (ltoken_getText (e-&gt;info.type-&gt;id) == id) <font class="keywordflow">return</font> e;
01651           <font class="keywordflow">break</font>;
01652         <font class="keywordflow">case</font> SYMK_VAR:
01653           <font class="keywordflow">if</font> (ltoken_getText (e-&gt;info.var-&gt;id) == id) <font class="keywordflow">return</font> e;
01654           <font class="keywordflow">break</font>;
01655         BADDEFAULT;
01656         }
01657       <font class="comment">/*@=loopswitchbreak@*/</font>
01658     }
01659 
01660   <font class="keywordflow">return</font> (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0;
01661 }
01662 
01663 
01664 <font class="keyword">static</font> <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *
01665   symtable_lookupInScope (<a class="code" href="struct__idTable.html">idTable</a> *st, lsymbol id)<font class="keyword"></font>
01666 <font class="keyword"></font>{
01667   <font class="keywordtype">int</font> n;
01668   <a class="code" href="struct_idTableEntry.html">idTableEntry</a> *e;
01669   <font class="keywordflow">for</font> (n = st-&gt;size - 1; n &gt;= 0; n--)
01670     {
01671       e = &amp;(st-&gt;entries[n]);
01672       <font class="keywordflow">if</font> (e-&gt;kind == SYMK_SCOPE)
01673         <font class="keywordflow">break</font>;
01674       <font class="keywordflow">if</font> (ltoken_getText (e-&gt;info.fct-&gt;id) == id)
01675         {
01676           <font class="keywordflow">return</font> e;
01677         }
01678     }
01679   <font class="keywordflow">return</font> (<a class="code" href="struct_idTableEntry.html">idTableEntry</a> *) 0;
01680 }
01681 
01682 <font class="comment">/* hash table implementation */</font>
01683 
01684 <font class="keyword">static</font> symbolKey
01685 htData_key (htData * x)<font class="keyword"></font>
01686 <font class="keyword"></font>{
01687   <font class="comment">/* assume x points to a valid htData struct */</font>
01688   <font class="keywordflow">switch</font> (x-&gt;kind)
01689     {
01690     <font class="keywordflow">case</font> IK_SORT:
01691       <font class="keywordflow">return</font> x-&gt;content.sort;
01692     <font class="keywordflow">case</font> IK_OP:
01693       {                         <font class="comment">/* get the textSym of the token */</font>
01694         nameNode n = (x-&gt;content.op)-&gt;name;
01695 
01696         <font class="keywordflow">if</font> (n-&gt;isOpId)
01697           {
01698             <font class="keywordflow">return</font> ltoken_getText (n-&gt;content.opid);
01699           }
01700         <font class="keywordflow">else</font>
01701           {
01702             llassert (n-&gt;content.opform != NULL);
01703             <font class="keywordflow">return</font> (n-&gt;content.opform)-&gt;key;
01704           }
01705       }
01706     <font class="keywordflow">case</font> IK_TAG:
01707       <font class="keywordflow">return</font> ltoken_getText ((x-&gt;content).tag-&gt;id);
01708     }
01709   BADEXIT;
01710 }
01711 
01712 <font class="keyword">static</font> <font class="keywordtype">void</font> htData_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> htData *d)<font class="keyword"></font>
01713 <font class="keyword"></font>{
01714   <font class="keywordflow">if</font> (d != NULL)
01715     {
01716       <font class="keywordflow">switch</font> (d-&gt;kind)
01717         {
01718         <font class="keywordflow">case</font> IK_SORT:
01719           <font class="keywordflow">break</font>;
01720         <font class="keywordflow">case</font> IK_OP:
01721           <font class="comment">/* nameNode_free (d-&gt;content.op-&gt;name);*/</font>
01722           <a class="code" href="sigNodeSet_c.html#a8">sigNodeSet_free</a> (d-&gt;content.op-&gt;signatures);
01723           <font class="keywordflow">break</font>;
01724         <font class="keywordflow">case</font> IK_TAG:
01725           {
01726             <font class="keywordflow">switch</font> (d-&gt;content.tag-&gt;kind)
01727               {
01728               <font class="keywordflow">case</font> TAG_STRUCT:
01729               <font class="keywordflow">case</font> TAG_UNION:
01730               <font class="keywordflow">case</font> TAG_FWDSTRUCT:
01731               <font class="keywordflow">case</font> TAG_FWDUNION:
01732                 <font class="comment">/*</font>
01733 <font class="comment">                 ** no: stDeclNodeList_free (d-&gt;content.tag-&gt;content.decls);</font>
01734 <font class="comment">                 **     it is dependent!</font>
01735 <font class="comment">                 */</font>
01736                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01737               <font class="keywordflow">case</font> TAG_ENUM:
01738                 
01739                 <font class="comment">/* no: ltokenList_free (d-&gt;content.tag-&gt;content.enums);</font>
01740 <font class="comment">                 **     it is dependent!</font>
01741 <font class="comment">                 */</font>
01742                 
01743                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01744               }
01745           }
01746         }
01747       
01748       <a class="code" href="general_c.html#a0">sfree</a> (d);
01749     }
01750 }
01751 
01752 <font class="keyword">static</font> <font class="keywordtype">void</font> bucket_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> bucket *b)<font class="keyword"></font>
01753 <font class="keyword"></font>{
01754   <font class="keywordflow">if</font> (b != NULL)
01755     {
01756       bucket_free (b-&gt;next);
01757       htData_free (b-&gt;data);
01758       <a class="code" href="general_c.html#a0">sfree</a> (b);
01759     }
01760 }
01761 
01762 <font class="keyword">static</font> <font class="keywordtype">void</font> symHashTable_free (<font class="comment">/*@only@*/</font> symHashTable *h)<font class="keyword"></font>
01763 <font class="keyword"></font>{
01764   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i;
01765 
01766   <font class="keywordflow">for</font> (i = 0; i &lt; h-&gt;size; i++)
01767     {
01768       bucket_free (h-&gt;buckets[i]);
01769     }
01770 
01771   <a class="code" href="general_c.html#a0">sfree</a> (h-&gt;buckets);
01772   <a class="code" href="general_c.html#a0">sfree</a> (h);
01773 }      
01774       
01775 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> symHashTable *
01776 symHashTable_create (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> size)<font class="keyword"></font>
01777 <font class="keyword"></font>{
01778   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i;
01779   symHashTable *t = (symHashTable *) dmalloc (<font class="keyword">sizeof</font> (*t));
01780   
01781   t-&gt;buckets = (bucket **) dmalloc ((size + 1) * <font class="keyword">sizeof</font> (*t-&gt;buckets));
01782   t-&gt;count = 0;
01783   t-&gt;size = size;
01784 
01785   <font class="keywordflow">for</font> (i = 0; i &lt;= size; i++)
01786     {
01787       t-&gt;buckets[i] = (bucket *) NULL;
01788     }
01789 
01790   <font class="keywordflow">return</font> t;
01791 }
01792 
01793 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> <font class="comment">/*@exposed@*/</font> htData *
01794 symHashTable_get (symHashTable *t, symbolKey key, infoKind kind, <font class="comment">/*@null@*/</font> nameNode n)<font class="keyword"></font>
01795 <font class="keyword"></font>{
01796   bucket *b;
01797   htEntry *entry;
01798   htData *d;
01799 
01800   b = t-&gt;buckets[MASH (key, kind)];
01801   <font class="keywordflow">if</font> (b == (bucket *) 0)
01802     {
01803       <font class="keywordflow">return</font> ((htData *) 0);
01804     }
01805   
01806   <font class="keywordflow">for</font> (entry = (htEntry *) b; entry != NULL; entry = entry-&gt;next)
01807     {
01808       d = entry-&gt;data;
01809 
01810       <font class="keywordflow">if</font> (d-&gt;kind == kind &amp;&amp; htData_key (d) == key)
01811         <font class="keywordflow">if</font> (kind != IK_OP || <a class="code" href="abstract_c.html#a211">sameNameNode</a> (n, d-&gt;content.op-&gt;name))
01812           {
01813             <font class="keywordflow">return</font> d;
01814           }
01815     }
01816   <font class="keywordflow">return</font> ((htData *) 0);
01817 }
01818 
01819 <font class="keyword">static</font> <font class="keywordtype">bool</font>
01820 symHashTable_put (symHashTable *t, <font class="comment">/*@only@*/</font> htData *data)<font class="keyword"></font>
01821 <font class="keyword"></font>{
01822   <font class="comment">/* if key is already taken, don't insert, return FALSE</font>
01823 <font class="comment">     else insert it and return TRUE. */</font>
01824   symbolKey key;
01825   htData *oldd;
01826   infoKind kind;
01827   nameNode name;
01828 
01829   key = htData_key (data);
01830   kind = data-&gt;kind;
01831 
01832   <font class="keywordflow">if</font> (kind == IK_OP &amp;&amp; (!data-&gt;content.op-&gt;name-&gt;isOpId))
01833     {
01834       name = data-&gt;content.op-&gt;name;
01835     }
01836   <font class="keywordflow">else</font>
01837     {
01838       name = (nameNode) 0;
01839     }
01840   
01841   oldd = symHashTable_get (t, key, kind, name);
01842 
01843   <font class="keywordflow">if</font> (oldd == (htData *) 0)
01844     {
01845       <font class="comment">/*@-deparrays@*/</font>
01846       bucket *new_entry = (bucket *) dmalloc (<font class="keyword">sizeof</font> (*new_entry));
01847       bucket *b = (t-&gt;buckets[MASH (key, kind)]);
01848       htEntry *entry = (htEntry *) b;
01849       <font class="comment">/*@=deparrays@*/</font>
01850 
01851       new_entry-&gt;data = data;
01852       new_entry-&gt;next = entry;
01853       t-&gt;buckets[MASH (key, kind)] = new_entry;
01854       t-&gt;count++;
01855 
01856       <font class="keywordflow">return</font> TRUE;
01857     }
01858   <font class="keywordflow">else</font>
01859     {
01860       htData_free (data);
01861     }
01862 
01863   <font class="keywordflow">return</font> FALSE;
01864 }
01865 
01866 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> <font class="comment">/*@exposed@*/</font> <font class="comment">/*@null@*/</font> htData *
01867   symHashTable_forcePut (symHashTable *t, <font class="comment">/*@only@*/</font> htData *data)<font class="keyword"></font>
01868 <font class="keyword"></font>{
01869   <font class="comment">/* Put data in, return old value */</font>
01870   symbolKey key;
01871   bucket *b;
01872   htData *oldd;
01873   htEntry *entry, *new_entry;
01874   infoKind kind;
01875   nameNode name;
01876 
01877   key = htData_key (data);
01878   kind = data-&gt;kind;
01879 
01880   <font class="keywordflow">if</font> (kind == IK_OP &amp;&amp; (!data-&gt;content.op-&gt;name-&gt;isOpId))
01881     {
01882       name = data-&gt;content.op-&gt;name;
01883     }
01884   <font class="keywordflow">else</font>
01885     {
01886       name = (nameNode) 0;
01887     }
01888 
01889   oldd = symHashTable_get (t, key, kind, name);
01890 
01891   <font class="keywordflow">if</font> (oldd == (htData *) 0)
01892     {
01893       new_entry = (htEntry *) dmalloc (<font class="keyword">sizeof</font> (*new_entry));
01894 
01895       <font class="comment">/*@-deparrays@*/</font>
01896       b = t-&gt;buckets[MASH (key, kind)];
01897       <font class="comment">/*@=deparrays@*/</font>
01898 
01899       entry = b;
01900       new_entry-&gt;data = data;
01901       new_entry-&gt;next = entry;
01902       t-&gt;buckets[MASH (key, kind)] = new_entry;
01903       t-&gt;count++;
01904 
01905       <font class="keywordflow">return</font> NULL;
01906     }
01907   <font class="keywordflow">else</font>
01908     {                           <font class="comment">/* modify in place */</font>
01909       *oldd = *data;            <font class="comment">/* copy new info over to old info */</font>
01910 
01911       <font class="comment">/* dangerous: if the data is the same, don't free it */</font>
01912       <font class="keywordflow">if</font> (data != oldd)   
01913         {
01914           <a class="code" href="general_c.html#a0">sfree</a> (data); 
01915         <font class="comment">/*@-branchstate@*/</font> 
01916         } 
01917       <font class="comment">/*@=branchstate@*/</font>
01918 
01919       <font class="keywordflow">return</font> oldd;
01920     }
01921 }
01922 
01923 <font class="preprocessor">#if 0</font>
01924 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>
01925 symHashTable_count (symHashTable * t)<font class="keyword"></font>
01926 <font class="keyword"></font>{
01927   <font class="keywordflow">return</font> (t-&gt;count);
01928 }
01929 
01930 <font class="preprocessor">#endif</font>
01931 <font class="preprocessor"></font>
01932 <font class="keyword">static</font> <font class="keywordtype">void</font>
01933 symHashTable_printStats (symHashTable * t)<font class="keyword"></font>
01934 <font class="keyword"></font>{
01935   <font class="keywordtype">int</font> i, bucketCount, setsize, sortCount, opCount, tagCount;
01936   <font class="keywordtype">int</font> sortTotal, opTotal, tagTotal;
01937   bucket *b;
01938   htEntry *entry;
01939   htData *d;
01940 
01941   sortTotal = 0;
01942   opTotal = 0;
01943   tagTotal = 0;
01944   sortCount = 0;
01945   opCount = 0;
01946   tagCount = 0;
01947 
01948   <font class="comment">/* for debugging only */</font>
01949   printf (<font class="stringliteral">"\n Printing symHashTable stats ... \n"</font>);
01950   <font class="keywordflow">for</font> (i = 0; i &lt;= HT_MAXINDEX; i++)
01951     {
01952       b = t-&gt;buckets[i];
01953       bucketCount = 0;
01954       <font class="keywordflow">for</font> (entry = b; entry != NULL; entry = entry-&gt;next)
01955         {
01956           d = entry-&gt;data;
01957           bucketCount++;
01958           <font class="keywordflow">switch</font> (d-&gt;kind)
01959             {
01960             <font class="keywordflow">case</font> IK_SORT:
01961               sortCount++;
01962               <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01963             <font class="keywordflow">case</font> IK_OP:
01964               {
01965                 cstring name = <a class="code" href="abstract_c.html#a100">nameNode_unparse</a> (d-&gt;content.op-&gt;name);
01966                 cstring sigs = <a class="code" href="sigNodeSet_c.html#a5">sigNodeSet_unparse</a> (d-&gt;content.op-&gt;signatures);
01967                 opCount++;
01968                 <font class="comment">/* had a tt? */</font>
01969                 setsize = sigNodeSet_size (d-&gt;content.op-&gt;signatures);
01970                 printf (<font class="stringliteral">"       Op (%d): %s %s\n"</font>, setsize, 
01971                         cstring_toCharsSafe (name), 
01972                         <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (sigs));
01973                 <a class="code" href="cstring_c.html#a27">cstring_free</a> (name);
01974                 <a class="code" href="cstring_c.html#a27">cstring_free</a> (sigs);
01975                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01976               }
01977             <font class="keywordflow">case</font> IK_TAG:
01978               tagCount++;
01979               <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
01980             }
01981         }
01982       <font class="keywordflow">if</font> (bucketCount &gt; 0)
01983         {
01984           printf (<font class="stringliteral">"   Bucket %d has count = %d; opCount = %d; sortCount = %d; tagCount = %d\n"</font>, i, bucketCount, opCount, sortCount, tagCount);
01985           sortTotal += sortCount;
01986           tagTotal += tagCount;
01987           opTotal += opCount;
01988         }
01989     }
01990   printf (<font class="stringliteral">"SymHashTable has total count = %d, opTotal = %d, sortTotal = %d, tagTotal = %d :\n"</font>, t-&gt;count, opTotal, sortTotal, tagTotal);
01991 
01992 }
01993 
01994 <font class="keywordtype">void</font>
<a name="l01995"></a><a class="code" href="symtable_c.html#a63">01995</a> <a class="code" href="symtable_c.html#a63">symtable_printStats</a> (symtable s)<font class="keyword"></font>
01996 <font class="keyword"></font>{
01997   symHashTable_printStats (s-&gt;hTable);
01998  <font class="comment">/* for debugging only */</font>
01999   printf (<font class="stringliteral">"idTable size = %d; allocated = %d\n"</font>,
02000           s-&gt;idTable-&gt;size, s-&gt;idTable-&gt;allocated);
02001 }
02002 
02003 <font class="comment">/*@only@*/</font> cstring
<a name="l02004"></a><a class="code" href="symtable_c.html#a64">02004</a> <a class="code" href="symtable_c.html#a64">tagKind_unparse</a> (tagKind k)<font class="keyword"></font>
02005 <font class="keyword"></font>{
02006   <font class="keywordflow">switch</font> (k)
02007     {
02008     <font class="keywordflow">case</font> TAG_STRUCT:
02009     <font class="keywordflow">case</font> TAG_FWDSTRUCT:
02010       <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"struct"</font>);
02011     <font class="keywordflow">case</font> TAG_UNION:
02012     <font class="keywordflow">case</font> TAG_FWDUNION:
02013       <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"union"</font>);
02014     <font class="keywordflow">case</font> TAG_ENUM:
02015       <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"enum"</font>);
02016     }
02017   BADEXIT;
02018 }
02019 
02020 <font class="keyword">static</font> <font class="keywordtype">void</font> tagInfo_free (<font class="comment">/*@only@*/</font> tagInfo tag)<font class="keyword"></font>
02021 <font class="keyword"></font>{
02022   <a class="code" href="general_c.html#a0">sfree</a> (tag);
02023 }
02024 
02025 <font class="comment">/*@observer@*/</font> sigNodeSet 
<a name="l02026"></a><a class="code" href="symtable_c.html#a65">02026</a>   <a class="code" href="symtable_c.html#a65">symtable_possibleOps</a> (symtable tab, nameNode n)<font class="keyword"></font>
02027 <font class="keyword"></font>{
02028   opInfo oi = <a class="code" href="symtable_c.html#a40">symtable_opInfo</a> (tab, n);
02029   
02030   <font class="keywordflow">if</font> (opInfo_exists (oi))
02031     {
02032       <font class="keywordflow">return</font> (oi-&gt;signatures);
02033     }
02034 
02035   <font class="keywordflow">return</font> sigNodeSet_undefined;
02036 }
02037 
02038 <font class="keywordtype">bool</font>
<a name="l02039"></a><a class="code" href="symtable_c.html#a66">02039</a> <a class="code" href="symtable_c.html#a66">symtable_opExistsWithArity</a> (symtable tab, nameNode n, <font class="keywordtype">int</font> arity)<font class="keyword"></font>
02040 <font class="keyword"></font>{
02041   opInfo oi = <a class="code" href="symtable_c.html#a40">symtable_opInfo</a> (tab, n);
02042 
02043   <font class="keywordflow">if</font> (opInfo_exists (oi))
02044     {
02045       sigNodeSet sigs = oi-&gt;signatures;
02046       sigNodeSet_elements (sigs, sig)<font class="keyword"></font>
02047 <font class="keyword">      </font>{
02048         <font class="keywordflow">if</font> (ltokenList_size (sig-&gt;domain) == arity)
02049           <font class="keywordflow">return</font> TRUE;
02050       } end_sigNodeSet_elements;
02051     }
02052   <font class="keywordflow">return</font> FALSE;
02053 }
02054 
02055 <font class="keyword">static</font> <font class="keywordtype">bool</font>
02056 domainMatches (ltokenList domain, sortSetList argSorts)<font class="keyword"></font>
02057 <font class="keyword"></font>{
02058   <font class="comment">/* expect their length to match */</font>
02059   <font class="comment">/* each domain sort in op must be an element of</font>
02060 <font class="comment">     the corresponding set in argSorts. */</font>
02061   <font class="keywordtype">bool</font> matched = TRUE;
02062   sort s;
02063 
02064   <a class="code" href="sortSetList_c.html#a3">sortSetList_reset</a> (argSorts);
02065   ltokenList_elements (domain, dom)<font class="keyword"></font>
02066 <font class="keyword">    </font>{
02067       s = <a class="code" href="sort_c.html#a116">sort_fromLsymbol</a> (ltoken_getText (dom));
02068       <font class="keywordflow">if</font> (!(<a class="code" href="sortSet_c.html#a5">sortSet_member</a> (sortSetList_current (argSorts), s)))
02069         {
02070           <font class="comment">/*      printf ("   mismatched element is: %s in %s\n", ltoken_getTextChars (*dom),</font>
02071 <font class="comment">                  sortSet_unparse (sortSetList_current (argSorts))); */</font>
02072           matched = FALSE;
02073           <font class="keywordflow">break</font>;
02074         }
02075       <a class="code" href="sortSetList_c.html#a4">sortSetList_advance</a> (argSorts);
02076   } end_ltokenList_elements;
02077 
02078   <font class="keywordflow">return</font> matched;
02079 }
02080 
02081 <font class="comment">/*@only@*/</font> lslOpSet
<a name="l02082"></a><a class="code" href="symtable_c.html#a68">02082</a>   <a class="code" href="symtable_c.html#a68">symtable_opsWithLegalDomain</a> (symtable tab, <font class="comment">/*@temp@*/</font> <font class="comment">/*@null@*/</font> nameNode n,
02083                                sortSetList argSorts, sort qual)<font class="keyword"></font>
02084 <font class="keyword"></font>{
02085  <font class="comment">/* handles nil qual */</font>
02086   lslOpSet ops = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
02087   lslOp op;
02088   sort rangeSort;
02089   opInfo oi;
02090 
02091   llassert (n != NULL);
02092   oi = <a class="code" href="symtable_c.html#a40">symtable_opInfo</a> (tab, n);
02093 
02094   <font class="keywordflow">if</font> (opInfo_exists (oi))
02095     {
02096       sigNodeSet sigs = oi-&gt;signatures;
02097 
02098       sigNodeSet_elements (sigs, sig)<font class="keyword"></font>
02099 <font class="keyword">        </font>{
02100           <font class="keywordflow">if</font> (ltokenList_size (sig-&gt;domain) == sortSetList_size (argSorts))
02101             {
02102               rangeSort = <a class="code" href="abstract_c.html#a224">sigNode_rangeSort</a> (sig);
02103               
02104               <font class="keywordflow">if</font> ((qual == 0) || (<a class="code" href="sort_c.html#a110">sort_equal</a> (&amp;rangeSort, &amp;qual)))
02105                 {
02106                   <font class="keywordflow">if</font> (domainMatches (sig-&gt;domain, argSorts))
02107                     {
02108                       op = (lslOp) dmalloc (<font class="keyword">sizeof</font> (*op));
02109                       
02110                       <font class="comment">/* each domain sort in op must be an element of</font>
02111 <font class="comment">                         the corresponding set in argSorts. */</font>
02112                       op-&gt;signature = sig;
02113                       op-&gt;name = <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (n);
02114                       (<font class="keywordtype">void</font>) <a class="code" href="lslOpSet_c.html#a4">lslOpSet_insert</a> (ops, op);
02115                     }
02116                 }
02117             }
02118         } end_sigNodeSet_elements;
02119     }
02120   <font class="keywordflow">return</font> ops;
02121 }
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:45 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
