<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>usymtab_interface.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:46 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>usymtab_interface.c</h1><a href="usymtab_interface_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** usymtab_interface.c</font>
00026 <font class="comment">**</font>
00027 <font class="comment">** Grammar interface to symtab.</font>
00028 <font class="comment">**</font>
00029 <font class="comment">** The LCLint parser will build symbol tables for abstract types and</font>
00030 <font class="comment">** function declarations.</font>
00031 <font class="comment">**</font>
00032 <font class="comment">*/</font>
00033 
00034 <font class="preprocessor"># include "lclintMacros.nf"</font>
00035 <font class="preprocessor"># include "llbasic.h"</font>
00036 <font class="preprocessor"># include "gram.h"</font>
00037 <font class="preprocessor"># include "lclscan.h"</font>
00038 <font class="preprocessor"># include "lclsyntable.h"</font>
00039 <font class="preprocessor"># include "lslparse.h"</font>
00040 <font class="preprocessor"># include "usymtab_interface.h"</font>
00041 <font class="preprocessor"># include "structNames.h"</font>
00042 
00043 <font class="keyword">static</font> <font class="keywordtype">void</font> 
00044   declareFcnAux (fcnNode p_f, <font class="comment">/*@only@*/</font> qtype p_qt, ctype p_ct, typeId p_tn, 
00045                  <font class="keywordtype">bool</font> p_priv, <font class="keywordtype">bool</font> p_spec);
00046 
00047 <font class="keyword">static</font> uentryList paramNodeList_toUentryList (paramNodeList p_p);
00048 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> cstring getVarName (<font class="comment">/*@null@*/</font> typeExpr p_x);
00049 <font class="keyword">static</font> qtype convertLclTypeSpecNode (<font class="comment">/*@null@*/</font> lclTypeSpecNode p_n);
00050 <font class="keyword">static</font> ctype convertTypeExpr (ctype p_c, <font class="comment">/*@null@*/</font> typeExpr p_x);
00051 <font class="keyword">static</font> ctype convertCTypeExpr (ctype p_c, <font class="comment">/*@null@*/</font> typeExpr p_x);
00052 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> sRef fixTermNode (termNode p_n, fcnNode p_f, uentryList p_cl);
00053 <font class="keyword">static</font> sRefSet fixModifies (fcnNode p_f, uentryList p_cl);
00054 
00055 <font class="keyword">static</font> uentryList
00056   convertuentryList (stDeclNodeList x)<font class="keyword"></font>
00057 <font class="keyword"></font>{
00058   uentryList fl = <a class="code" href="uentryList_c.html#a0">uentryList_new</a> ();
00059 
00060   
00061   stDeclNodeList_elements (x, i)<font class="keyword"></font>
00062 <font class="keyword">  </font>{
00063     declaratorNodeList d = i-&gt;declarators;
00064     qtype q = convertLclTypeSpecNode (i-&gt;lcltypespec);
00065 
00066     declaratorNodeList_elements (d, j)<font class="keyword"></font>
00067 <font class="keyword">    </font>{
00068       idDecl id;
00069 
00070       qtype_setType (q, convertTypeExpr (qtype_getType (q), j-&gt;type));
00071       id = <a class="code" href="idDecl_c.html#a0">idDecl_create</a> (cstring_copy (getVarName (j-&gt;type)), <a class="code" href="qtype_c.html#a14">qtype_copy</a> (q));
00072       fl = <a class="code" href="uentryList_c.html#a4">uentryList_add</a> (fl, uentry_makeIdVariable (id));
00073       <a class="code" href="idDecl_c.html#a1">idDecl_free</a> (id);
00074     } end_declaratorNodeList_elements;
00075 
00076     <a class="code" href="qtype_c.html#a1">qtype_free</a> (q);
00077   } end_stDeclNodeList_elements;
00078 
00079   
00080   <font class="keywordflow">return</font> (fl);
00081 }
00082 
00083 <font class="keyword">static</font> uentryList
00084   convert_uentryList (paramNodeList x)<font class="keyword"></font>
00085 <font class="keyword"></font>{
00086   uentryList p = uentryList_undefined;
00087   <font class="keywordtype">bool</font> first_one = TRUE;
00088 
00089   
00090   paramNodeList_elements (x, i)<font class="keyword"></font>
00091 <font class="keyword">  </font>{
00092     <font class="keywordflow">if</font> (i != (paramNode) 0)
00093       {
00094         <font class="keywordflow">if</font> (paramNode_isElipsis (i))
00095           {
00096             first_one = FALSE;
00097             p = <a class="code" href="uentryList_c.html#a4">uentryList_add</a> (p, uentry_makeElipsisMarker ());
00098           }
00099         <font class="keywordflow">else</font>
00100           {
00101             qtype q = convertLclTypeSpecNode (i-&gt;type);
00102             typeExpr t = i-&gt;paramdecl;
00103             
00104             qtype_setType (q, convertTypeExpr (qtype_getType (q), t));
00105             
00106             <font class="comment">/* note: has to be like this to hack around void  ???? still */</font> 
00107 
00108             <font class="keywordflow">if</font> (first_one)
00109               {
00110                 <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a51">ctype_isVoid</a> (qtype_getType (q)))
00111                   {
00112                     llassert (uentryList_isUndefined (p));
00113                     <a class="code" href="qtype_c.html#a1">qtype_free</a> (q);
00114                     <font class="keywordflow">return</font> (p);
00115                   }
00116                 
00117                 first_one = FALSE;
00118               }
00119             
00120             <font class="comment">/*</font>
00121 <font class="comment">            ** don't do qualifiers here, will get errors later</font>
00122 <font class="comment">            */</font>
00123 
00124             p = <a class="code" href="uentryList_c.html#a4">uentryList_add</a> (p, uentry_makeUnnamedVariable (qtype_getType (q)));
00125             <a class="code" href="qtype_c.html#a1">qtype_free</a> (q);
00126           }
00127       }
00128     <font class="keywordflow">else</font>
00129       {
00130         llbug (cstring_makeLiteral (<font class="stringliteral">"convertuentryList: null paramNode"</font>));
00131       }
00132   } end_paramNodeList_elements;
00133   
00134   <font class="keywordflow">if</font> (first_one)
00135     {
00136       llassert (uentryList_isUndefined (p));
00137       
00138       p = uentryList_makeMissingParams ();
00139     }
00140 
00141   <font class="keywordflow">return</font> p;
00142 }
00143 
00144 <font class="comment">/*</font>
00145 <font class="comment">** convertTypeExpr</font>
00146 <font class="comment">**</font>
00147 <font class="comment">** modify c with pointer, array, function</font>
00148 <font class="comment">**</font>
00149 <font class="comment">** (based on printTypeExpr2 from abstract.c)</font>
00150 <font class="comment">**</font>
00151 <font class="comment">*/</font>
00152 
00153 <font class="keyword">static</font> ctype
00154 convertTypeExpr (ctype c, typeExpr x)<font class="keyword"></font>
00155 <font class="keyword"></font>{
00156   <font class="keywordflow">if</font> (x == (typeExpr) 0)
00157     {
00158       <font class="keywordflow">return</font> c;
00159     }
00160   
00161   <font class="keywordflow">switch</font> (x-&gt;kind)
00162     {
00163     <font class="keywordflow">case</font> TEXPR_BASE:
00164       <font class="keywordflow">return</font> (c);
00165     <font class="keywordflow">case</font> TEXPR_PTR:
00166       <font class="keywordflow">return</font> (convertTypeExpr (ctype_makePointer (c), x-&gt;content.pointer));
00167     <font class="keywordflow">case</font> TEXPR_ARRAY:
00168       <font class="keywordflow">return</font> (convertTypeExpr (ctype_makeArray (c), x-&gt;content.array.elementtype));
00169     <font class="keywordflow">case</font> TEXPR_FCN:
00170       {
00171         ctype rv = convertTypeExpr (c, x-&gt;content.function.returntype);
00172         uentryList p = paramNodeList_toUentryList (x-&gt;content.function.args);
00173         
00174         <font class="keywordflow">if</font> (x-&gt;content.function.returntype != NULL
00175             &amp;&amp; x-&gt;content.function.returntype-&gt;wrapped == 1 
00176             &amp;&amp; <a class="code" href="ctype_c.html#a100">ctype_isPointer</a> (rv))
00177           {
00178             rv = <a class="code" href="ctype_c.html#a38">ctype_baseArrayPtr</a> (rv);
00179           }
00180 
00181         <font class="keywordflow">return</font> (<a class="code" href="ctype_c.html#a44">ctype_makeParamsFunction</a> (rv, p));
00182       }
00183     <font class="keywordflow">default</font>:
00184       {
00185         <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"convertTypeExpr: unknown typeExprKind: %d"</font>,
00186                              (<font class="keywordtype">int</font>) x-&gt;kind));
00187       }
00188     }
00189 
00190   BADEXIT;
00191 }
00192 
00193 <font class="keyword">static</font> 
00194 ctype convertCTypeExpr (ctype c, typeExpr x)<font class="keyword"></font>
00195 <font class="keyword"></font>{
00196   <font class="keywordflow">if</font> (x == (typeExpr) 0)
00197     {
00198       <font class="keywordflow">return</font> c;
00199     }
00200 
00201   <font class="keywordflow">switch</font> (x-&gt;kind)
00202     {
00203     <font class="keywordflow">case</font> TEXPR_BASE:     <font class="keywordflow">return</font> (c);
00204     <font class="keywordflow">case</font> TEXPR_PTR:  <font class="keywordflow">return</font> (convertCTypeExpr (ctype_makePointer (c), 
00205                                                  x-&gt;content.pointer));
00206     <font class="keywordflow">case</font> TEXPR_ARRAY:    <font class="keywordflow">return</font> (convertCTypeExpr (ctype_makeArray (c), 
00207                                                  x-&gt;content.array.elementtype));
00208     <font class="keywordflow">case</font> TEXPR_FCN:
00209       {
00210         ctype rv = convertCTypeExpr (c, x-&gt;content.function.returntype);
00211         uentryList p = convert_uentryList (x-&gt;content.function.args);
00212 
00213         <font class="keywordflow">return</font> (<a class="code" href="ctype_c.html#a44">ctype_makeParamsFunction</a> (rv, p));
00214       }
00215     <font class="keywordflow">default</font>:
00216       {
00217         <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"convertCTypeExpr: unknown typeExprKind: %d"</font>, (<font class="keywordtype">int</font>) x-&gt;kind));
00218       }
00219     }
00220   BADEXIT;
00221 }
00222 
00223 <font class="comment">/*</font>
00224 <font class="comment">** convertLclTypeSpecNode</font>
00225 <font class="comment">**</font>
00226 <font class="comment">** LclTypeSpecNode --&gt; ctype</font>
00227 <font class="comment">** this is the base type only!</font>
00228 <font class="comment">*/</font>
00229 
00230 <font class="comment">/*</font>
00231 <font class="comment">** convertLeaves</font>
00232 <font class="comment">**</font>
00233 <font class="comment">** for now, assume only last leaf is relevant.</font>
00234 <font class="comment">** this should be a safe assumption in general???</font>
00235 <font class="comment">*/</font>
00236 
00237 <font class="keyword">static</font> ctype
00238   convertLeaves (ltokenList f)<font class="keyword"></font>
00239 <font class="keyword"></font>{
00240   ctype c = ctype_unknown;
00241   
00242   <a class="code" href="ltokenList_c.html#a5">ltokenList_reset</a> (f);
00243   
00244   ltokenList_elements (f, current)<font class="keyword"></font>
00245 <font class="keyword">    </font>{
00246       <font class="keywordflow">switch</font> (ltoken_getCode (current))
00247         {
00248         <font class="keywordflow">case</font> LLT_TYPEDEF_NAME:
00249           {
00250             cstring tn = ltoken_getRawString (current);
00251 
00252             <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a130">usymtab_existsTypeEither</a> (tn))
00253               {
00254                 c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (uentry_getAbstractType 
00255                                    (usymtab_lookupEither (tn)), c);
00256               }
00257             <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (tn, <font class="stringliteral">"bool"</font>))
00258               {
00259                 <font class="comment">/*</font>
00260 <font class="comment">                ** Bogus...keep consistent with old lcl builtin.</font>
00261 <font class="comment">                */</font>
00262                 c = ctype_bool;
00263               }
00264             <font class="keywordflow">else</font>
00265               {
00266                 fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (current);
00267 
00268                 voptgenerror (FLG_UNRECOG, 
00269                               message (<font class="stringliteral">"Unrecognized type: %s"</font>, tn), loc);
00270                 <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
00271                 
00272                 usymtab_supEntry 
00273                   (uentry_makeDatatype 
00274                    (tn, ctype_unknown, MAYBE, NO, <a class="code" href="fileloc_c.html#a28">fileloc_getBuiltin</a> ()));
00275                 
00276               }
00277             <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00278           }
00279         <font class="keywordflow">case</font> LLT_CHAR:
00280           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (ctype_char, c);
00281           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00282           
00283         <font class="keywordflow">case</font> LLT_DOUBLE:
00284           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (ctype_double, c);
00285           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00286         <font class="keywordflow">case</font> LLT_FLOAT:     
00287           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (ctype_float, c);
00288           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00289         <font class="keywordflow">case</font> LLT_CONST:    
00290         <font class="keywordflow">case</font> LLT_VOLATILE: 
00291           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00292         <font class="keywordflow">case</font> LLT_INT:      
00293           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (ctype_int, c);
00294           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00295         <font class="keywordflow">case</font> LLT_LONG:  
00296           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (c, ctype_lint); 
00297           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00298         <font class="keywordflow">case</font> LLT_SHORT:    
00299           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (c, ctype_sint);
00300           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00301         <font class="keywordflow">case</font> LLT_SIGNED:    
00302           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (c, ctype_int); 
00303           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00304         <font class="keywordflow">case</font> LLT_UNSIGNED:  
00305           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (c, ctype_uint);
00306           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00307         <font class="keywordflow">case</font> LLT_UNKNOWN:   
00308           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (ctype_unknown, c);
00309           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00310         <font class="keywordflow">case</font> LLT_VOID:      
00311           c = <a class="code" href="ctype_c.html#a132">ctype_combine</a> (ctype_void, c); 
00312           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00313         <font class="keywordflow">case</font> LLT_ENUM:
00314           llcontbug (cstring_makeLiteral (<font class="stringliteral">"convertLeaves: enum"</font>));
00315           c = ctype_int; 
00316           <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00317         <font class="keywordflow">default</font>:
00318           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"convertLeaves: bad token: %q"</font>, 
00319                                ltoken_unparseCodeName (current)));
00320         }
00321     } end_ltokenList_elements;
00322 
00323   <font class="keywordflow">return</font> c;
00324 }
00325 
00326 <font class="keyword">static</font> enumNameList
00327   convertEnumList (ltokenList enums)<font class="keyword"></font>
00328 <font class="keyword"></font>{
00329   enumNameList el = <a class="code" href="enumNameList_c.html#a0">enumNameList_new</a> ();
00330 
00331   <font class="keywordflow">if</font> (ltokenList_isDefined (enums))
00332     {
00333       ltokenList_elements (enums, i)<font class="keyword"></font>
00334 <font class="keyword">        </font>{
00335           enumNameList_addh 
00336             (el, enumName_create (cstring_copy (ltoken_unparse (i))));
00337         } end_ltokenList_elements;
00338     }
00339 
00340   <font class="keywordflow">return</font> el;
00341 }
00342 
00343 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> qtype 
00344   convertLclTypeSpecNode (<font class="comment">/*@null@*/</font> lclTypeSpecNode n)<font class="keyword"></font>
00345 <font class="keyword"></font>{
00346   
00347   <font class="keywordflow">if</font> (n != (lclTypeSpecNode) 0)
00348     {
00349       qtype result;
00350       
00351       <font class="keywordflow">switch</font> (n-&gt;kind)
00352         {
00353         <font class="keywordflow">case</font> LTS_CONJ:
00354           {
00355             qtype c1 = convertLclTypeSpecNode (n-&gt;content.conj-&gt;a);
00356             qtype c2 = convertLclTypeSpecNode (n-&gt;content.conj-&gt;b);
00357 
00358             <font class="comment">/*</font>
00359 <font class="comment">            ** Is it explicit?</font>
00360 <font class="comment">            */</font>
00361 
00362             <font class="keywordflow">if</font> (<a class="code" href="fileloc_c.html#a47">fileloc_isLib</a> (g_currentloc)
00363                 || <a class="code" href="fileloc_c.html#a16">fileloc_isStandardLibrary</a> (g_currentloc))
00364               {
00365                 result = <a class="code" href="qtype_c.html#a6">qtype_mergeImplicitAlt</a> (c1, c2);
00366               }
00367             <font class="keywordflow">else</font>
00368               {
00369                 result = <a class="code" href="qtype_c.html#a7">qtype_mergeAlt</a> (c1, c2);
00370               }
00371             
00372             <font class="keywordflow">break</font>;
00373           }
00374         <font class="keywordflow">case</font> LTS_TYPE:
00375           llassert (n-&gt;content.type != NULL);
00376           result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (convertLeaves (n-&gt;content.type-&gt;ctypes));
00377           <font class="keywordflow">break</font>;
00378         <font class="keywordflow">case</font> LTS_STRUCTUNION:
00379           {
00380             strOrUnionNode sn;
00381             cstring cn = cstring_undefined;
00382 
00383             sn = n-&gt;content.structorunion;
00384 
00385             llassert (sn != (strOrUnionNode) 0);
00386 
00387             <font class="keywordflow">if</font> (!ltoken_isUndefined (sn-&gt;opttagid))
00388               {
00389                 cn = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (sn-&gt;opttagid));
00390               }
00391             <font class="keywordflow">else</font>
00392               {
00393                 cn = <a class="code" href="structNames_c.html#a13">fakeTag</a> ();
00394               }
00395 
00396             <font class="keywordflow">switch</font> (sn-&gt;kind)
00397               {
00398               <font class="keywordflow">case</font> SU_STRUCT:
00399                 <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a131">usymtab_existsStructTag</a> (cn))
00400                   {
00401                     
00402                     result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (uentry_getAbstractType
00403                                            (usymtab_lookupStructTag (cn)));
00404                     <a class="code" href="cstring_c.html#a27">cstring_free</a> (cn);
00405                   }
00406                 <font class="keywordflow">else</font>
00407                   {
00408                     uentryList fl = convertuentryList (sn-&gt;structdecls);
00409                     ctype ct;
00410 
00411                                     ct = <a class="code" href="ctype_c.html#a88">ctype_createStruct</a> (cstring_copy (cn), fl);
00412 
00413                     <font class="comment">/*</font>
00414 <font class="comment">                    ** If it was a forward declaration, this could add it to</font>
00415 <font class="comment">                    ** the table.  Need to check if it exists again...</font>
00416 <font class="comment">                    */</font>
00417 
00418                     <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a131">usymtab_existsStructTag</a> (cn))
00419                       {
00420                         result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (uentry_getAbstractType
00421                                                (usymtab_lookupStructTag (cn)));
00422                       }
00423                     <font class="keywordflow">else</font>
00424                       {
00425                         fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (n-&gt;content.structorunion-&gt;tok);
00426                         uentry ue = <a class="code" href="uentry_c.html#a120">uentry_makeStructTag</a> (cn, ct, loc);
00427 
00428                         result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (usymtab_supTypeEntry (ue));
00429                       }
00430                         
00431                     <a class="code" href="cstring_c.html#a27">cstring_free</a> (cn);
00432                   }
00433                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00434               <font class="keywordflow">case</font> SU_UNION:
00435                 <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a132">usymtab_existsUnionTag</a> (cn))
00436                   {
00437                     
00438                     result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (uentry_getAbstractType
00439                                            (usymtab_lookupUnionTag (cn)));
00440                     <a class="code" href="cstring_c.html#a27">cstring_free</a> (cn);
00441                   }
00442                 <font class="keywordflow">else</font>
00443                   {
00444                     uentryList fl;
00445                     ctype ct;
00446                     
00447                     fl = convertuentryList (sn-&gt;structdecls);
00448                     ct = <a class="code" href="ctype_c.html#a90">ctype_createUnion</a> (cstring_copy (cn), fl);
00449 
00450                     <font class="comment">/*</font>
00451 <font class="comment">                    ** If it was a forward declaration, this could add it to</font>
00452 <font class="comment">                    ** the table.  Need to check if it exists again...</font>
00453 <font class="comment">                    */</font>
00454 
00455                     
00456                     
00457                     <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a132">usymtab_existsUnionTag</a> (cn))
00458                       {
00459                         
00460                         result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (uentry_getAbstractType
00461                                                (usymtab_lookupUnionTag (cn)));
00462                       }
00463                     <font class="keywordflow">else</font>
00464                       {
00465                         fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (n-&gt;content.structorunion-&gt;tok);
00466                         uentry ue = <a class="code" href="uentry_c.html#a121">uentry_makeUnionTag</a> (cn, ct, loc);
00467 
00468                         result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (usymtab_supTypeEntry (ue));
00469                       }
00470                         
00471                     <a class="code" href="cstring_c.html#a27">cstring_free</a> (cn);
00472                   }
00473                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
00474               BADDEFAULT
00475               }
00476             <font class="keywordflow">break</font>;
00477           }
00478         <font class="keywordflow">case</font> LTS_ENUM:
00479           {
00480             enumSpecNode e = n-&gt;content.enumspec;
00481             enumNameList el;
00482             cstring ename;
00483             <font class="keywordtype">bool</font> first = TRUE;
00484             ctype ta;
00485             ctype cet;
00486 
00487             llassert (e != NULL);
00488             el = convertEnumList (e-&gt;enums);
00489 
00490             <font class="keywordflow">if</font> (!ltoken_isUndefined (e-&gt;opttagid))      <font class="comment">/* named enumerator */</font>
00491               {
00492                 ename = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (e-&gt;opttagid));
00493               }
00494             <font class="keywordflow">else</font>
00495               {
00496                 ename = <a class="code" href="structNames_c.html#a13">fakeTag</a> ();
00497               }
00498 
00499             cet = <a class="code" href="ctype_c.html#a116">ctype_createEnum</a> (ename, el);
00500             
00501             <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a133">usymtab_existsEnumTag</a> (ename))
00502               {
00503                 ta = <a class="code" href="uentry_c.html#a221">uentry_getAbstractType</a> (usymtab_lookupEnumTag (ename));
00504               }
00505             <font class="keywordflow">else</font>
00506               { 
00507                 fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (e-&gt;tok);
00508                 uentry ue = <a class="code" href="uentry_c.html#a122">uentry_makeEnumTag</a> (ename, cet, loc);
00509 
00510                 ta = <a class="code" href="usymtab_c.html#a55">usymtab_supTypeEntry</a> (ue);
00511               }
00512 
00513             enumNameList_elements (el, en)<font class="keyword"></font>
00514 <font class="keyword">              </font>{
00515                 uentry ue;
00516                 fileloc loc;
00517 
00518                 <font class="keywordflow">if</font> (first)
00519                   {
00520                     <a class="code" href="ltokenList_c.html#a5">ltokenList_reset</a> (e-&gt;enums);
00521                     first = FALSE;
00522                   }
00523                 <font class="keywordflow">else</font>
00524                   {
00525                     <a class="code" href="ltokenList_c.html#a7">ltokenList_advance</a> (e-&gt;enums);
00526                   }
00527 
00528                 loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (ltokenList_current (e-&gt;enums));
00529                 ue = <a class="code" href="uentry_c.html#a42">uentry_makeSpecEnumConstant</a> (en, cet, loc);
00530 
00531                 <font class="comment">/*</font>
00532 <font class="comment">                ** Can't check name here, might not have</font>
00533 <font class="comment">                ** type yet.  Will check in .lh file?</font>
00534 <font class="comment">                */</font>
00535                 
00536                 ue = <a class="code" href="usymtab_c.html#a54">usymtab_supGlobalEntryReturn</a> (ue);
00537                 
00538                 <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> ())
00539                   {
00540                     <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (ue, loc);
00541                   }
00542               } end_enumNameList_elements;
00543             
00544             result = <a class="code" href="qtype_c.html#a0">qtype_create</a> (ta);
00545           }
00546           <font class="keywordflow">break</font>;
00547         <font class="keywordflow">default</font>:
00548           {
00549             <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"convertLclTypeSpecNode: unknown lclTypeSpec kind: %d"</font>,
00550                                  (<font class="keywordtype">int</font>) n-&gt;kind));
00551           }
00552         }
00553       
00554       result = <a class="code" href="qtype_c.html#a4">qtype_addQualList</a> (result, n-&gt;quals);
00555 
00556       <font class="keywordflow">if</font> (n-&gt;pointers &gt; 0)
00557         {
00558           <a class="code" href="qtype_c.html#a13">qtype_adjustPointers</a> (n-&gt;pointers, result);
00559         }
00560 
00561       <font class="keywordflow">return</font> result;
00562     }
00563   <font class="keywordflow">else</font>
00564     {
00565       llcontbug (cstring_makeLiteral (<font class="stringliteral">"convertLclTypeSpecNode: null"</font>));
00566       <font class="keywordflow">return</font> <a class="code" href="qtype_c.html#a2">qtype_unknown</a> (); 
00567     }
00568   BADEXIT;
00569 } 
00570 
00571 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> multiVal
00572   literalValue (ctype ct, ltoken lit)<font class="keyword"></font>
00573 <font class="keyword"></font>{
00574   cstring text = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (ltoken_getText (lit)));
00575   <font class="keywordtype">char</font> first;
00576 
00577   <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a30">cstring_length</a> (text) &gt; 0)
00578     {
00579       first = <a class="code" href="cstring_c.html#a1">cstring_firstChar</a> (text);
00580     }
00581   <font class="keywordflow">else</font>
00582     {
00583       <font class="keywordflow">return</font> <a class="code" href="multiVal_c.html#a0">multiVal_unknown</a> ();
00584     }
00585 
00586   
00587   <font class="keywordflow">if</font> <font class="comment">/*@-usedef@*/</font> (first == <font class="charliteral">'\"'</font>) <font class="comment">/*@=usedef@*/</font>
00588     {
00589       <font class="keywordtype">int</font> len = <a class="code" href="cstring_c.html#a30">cstring_length</a> (text) - 2;
00590       <font class="keywordtype">char</font> *val = <a class="code" href="general_c.html#a29">mstring_create</a> (len);
00591       
00592       llassert (cstring_lastChar (text) == <font class="charliteral">'\"'</font>);
00593       strncpy (val, cstring_toCharsSafe (text) + 1, <a class="code" href="general_c.html#a33">size_fromInt</a> (len));
00594       <font class="keywordflow">return</font> (<a class="code" href="multiVal_c.html#a5">multiVal_makeString</a> (cstring_fromCharsO (val)));
00595     }
00596 
00597   <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a78">ctype_isDirectInt</a> (ct) || <a class="code" href="ctype_c.html#a100">ctype_isPointer</a> (ct))
00598     {
00599       <font class="keywordtype">long</font> val = 0;
00600      
00601       <font class="keywordflow">if</font> (sscanf (cstring_toCharsSafe (text), <font class="stringliteral">"%ld"</font>, &amp;val) == 1)
00602         {
00603           <font class="keywordflow">return</font> <a class="code" href="multiVal_c.html#a2">multiVal_makeInt</a> (val);
00604         }
00605     }
00606 
00607   <font class="keywordflow">return</font> <a class="code" href="multiVal_c.html#a0">multiVal_unknown</a> ();
00608 }
00609 
00610 
00611 <font class="comment">/*</font>
00612 <font class="comment">** declareConstant</font>
00613 <font class="comment">**</font>
00614 <font class="comment">** unfortunately, because the abstract types are different, this</font>
00615 <font class="comment">** cannot be easily subsumed into declareVar.</font>
00616 <font class="comment">*/</font>
00617 
00618 <font class="keywordtype">void</font>
<a name="l00619"></a><a class="code" href="usymtab_interface_c.html#a13">00619</a> <a class="code" href="usymtab_interface_c.html#a13">doDeclareConstant</a> (constDeclarationNode c, <font class="keywordtype">bool</font> priv)<font class="keyword"></font>
00620 <font class="keyword"></font>{
00621   lclTypeSpecNode t;
00622   ctype ctx;
00623   qtype qt;
00624   
00625   <font class="keywordflow">if</font> (c == (constDeclarationNode) 0)
00626     {
00627       <font class="keywordflow">return</font>;
00628     }
00629 
00630   t = c-&gt;type;
00631   qt = convertLclTypeSpecNode (t);
00632 
00633   ctx = qtype_getType (qt);
00634 
00635   initDeclNodeList_elements (c-&gt;decls, i)<font class="keyword"></font>
00636 <font class="keyword">    </font>{
00637       ctype ct = convertTypeExpr (ctx, i-&gt;declarator-&gt;type);
00638       cstring s = getVarName (i-&gt;declarator-&gt;type);
00639 
00640       <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a49">ctype_isFunction</a> (ct))
00641         {
00642           fcnNode fcn = <a class="code" href="abstract_c.html#a156">fcnNode_fromDeclarator</a> (lclTypeSpecNode_copy (t), 
00643                                                 <a class="code" href="abstract_c.html#a131">declaratorNode_copy</a> (i-&gt;declarator));
00644 
00645           <font class="comment">/* FALSE == unspecified function, only a declaration */</font>
00646 
00647           <a class="code" href="usymtab_interface_c.html#a20">doDeclareFcn</a> (fcn, typeId_invalid, priv, FALSE);
00648           <a class="code" href="abstract_c.html#a236">fcnNode_free</a> (fcn);
00649         }
00650       <font class="keywordflow">else</font>
00651         {
00652           uentry ue;
00653           fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (i-&gt;declarator-&gt;id);
00654 
00655           <font class="keywordflow">if</font> (i-&gt;value != (termNode)0 &amp;&amp;
00656               i-&gt;value-&gt;kind == TRM_LITERAL)
00657             {
00658               ue = <a class="code" href="uentry_c.html#a84">uentry_makeConstantAux</a> (s, ct, loc, priv, 
00659                                            literalValue (ct, i-&gt;value-&gt;literal));
00660             }
00661           <font class="keywordflow">else</font>
00662             {
00663               ue = <a class="code" href="uentry_c.html#a84">uentry_makeConstantAux</a> (s, ct, loc, priv, multiVal_unknown ());
00664             }
00665 
00666                   <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (ue, qtype_getQuals (qt));
00667 
00668           
00669           <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> () &amp;&amp; !priv)
00670             {
00671               <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (ue, loc);
00672             }
00673 
00674           <a class="code" href="usymtab_c.html#a61">usymtab_supGlobalEntry</a> (ue);
00675         }
00676     } end_initDeclNodeList_elements;
00677 
00678   <a class="code" href="qtype_c.html#a1">qtype_free</a> (qt);
00679 }
00680 
00681 <font class="keyword">static</font> cstring
00682 getVarName (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
00683 <font class="keyword"></font>{
00684   cstring s = cstring_undefined;
00685 
00686   <font class="keywordflow">if</font> (x != (typeExpr) 0)
00687     {
00688       <font class="keywordflow">switch</font> (x-&gt;kind)
00689         {
00690         <font class="keywordflow">case</font> TEXPR_BASE:
00691           s = ltoken_getRawString (x-&gt;content.base);
00692           <font class="keywordflow">break</font>;
00693         <font class="keywordflow">case</font> TEXPR_PTR:
00694           s = getVarName (x-&gt;content.pointer);
00695           <font class="keywordflow">break</font>;
00696         <font class="keywordflow">case</font> TEXPR_ARRAY:
00697           s = getVarName (x-&gt;content.array.elementtype);
00698           <font class="keywordflow">break</font>;
00699         <font class="keywordflow">case</font> TEXPR_FCN:
00700           s = getVarName (x-&gt;content.function.returntype);
00701           <font class="keywordflow">break</font>;
00702         <font class="keywordflow">default</font>:
00703           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"getVarName: unknown typeExprKind: %d"</font>, (<font class="keywordtype">int</font>) x-&gt;kind));
00704         }
00705     }
00706 
00707   <font class="keywordflow">return</font> s;
00708 }
00709 
00710 <font class="keywordtype">void</font>
<a name="l00711"></a><a class="code" href="usymtab_interface_c.html#a14">00711</a> <a class="code" href="usymtab_interface_c.html#a14">doDeclareVar</a> (varDeclarationNode v, <font class="keywordtype">bool</font> priv)<font class="keyword"></font>
00712 <font class="keyword"></font>{
00713   lclTypeSpecNode t;
00714   qtype c;
00715 
00716   <font class="keywordflow">if</font> (v == (varDeclarationNode) 0)
00717     {
00718       <font class="keywordflow">return</font>;
00719     }
00720 
00721   t = v-&gt;type;
00722   c = convertLclTypeSpecNode (t);
00723 
00724   initDeclNodeList_elements (v-&gt;decls, i)<font class="keyword"></font>
00725 <font class="keyword">    </font>{
00726       ctype ct = convertTypeExpr (qtype_getType (c), i-&gt;declarator-&gt;type);
00727       cstring s = getVarName (i-&gt;declarator-&gt;type);
00728 
00729       qtype_setType (c, ct);
00730 
00731       <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a49">ctype_isFunction</a> (ct))
00732         {
00733           fcnNode fcn;
00734 
00735                   
00736           fcn = <a class="code" href="abstract_c.html#a156">fcnNode_fromDeclarator</a> (lclTypeSpecNode_copy (t), 
00737                                         <a class="code" href="abstract_c.html#a131">declaratorNode_copy</a> (i-&gt;declarator));
00738 
00739           <font class="comment">/* FALSE == unspecified function, only a declaration */</font>
00740           declareFcnAux (fcn, qtype_unknown (), ct,
00741                          typeId_invalid, priv, FALSE);
00742           <a class="code" href="abstract_c.html#a236">fcnNode_free</a> (fcn);
00743         }
00744       <font class="keywordflow">else</font>
00745         {
00746           fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (i-&gt;declarator-&gt;id);
00747           uentry le = <a class="code" href="uentry_c.html#a99">uentry_makeVariable</a> (s, ct, loc, priv);
00748           
00749           <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (le, qtype_getQuals (c));
00750           
00751           <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a88">uentry_isCheckedUnknown</a> (le))
00752             {
00753               <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_IMPCHECKEDSTRICTSPECGLOBALS))
00754                 {
00755                   <a class="code" href="uentry_c.html#a97">uentry_setCheckedStrict</a> (le);
00756                 }
00757               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_IMPCHECKEDSPECGLOBALS))
00758                 {
00759                   <a class="code" href="uentry_c.html#a95">uentry_setChecked</a> (le);
00760                 }
00761               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_IMPCHECKMODSPECGLOBALS))
00762                 {
00763                   <a class="code" href="uentry_c.html#a96">uentry_setCheckMod</a> (le);
00764                 }
00765               <font class="keywordflow">else</font>
00766                 {
00767                   ; <font class="comment">/* okay */</font>
00768                 }
00769             }
00770 
00771           <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> () &amp;&amp; !priv)
00772             {
00773               <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (le, loc);
00774             }
00775 
00776           <font class="keywordflow">if</font> (<a class="code" href="abstract_c.html#a242">initDeclNode_isRedeclaration</a> (i))
00777             {
00778               <a class="code" href="usymtab_c.html#a140">usymtab_replaceEntry</a> (le);
00779             }
00780           <font class="keywordflow">else</font>
00781             {
00782               le = <a class="code" href="usymtab_c.html#a53">usymtab_supEntrySrefReturn</a> (le);
00783             }
00784         }
00785     } end_initDeclNodeList_elements;
00786 
00787   <a class="code" href="qtype_c.html#a1">qtype_free</a> (c);
00788 }
00789 
00790 <font class="keyword">static</font> globSet
00791 processGlob (<font class="comment">/*@returned@*/</font> globSet globs, varDeclarationNode v)<font class="keyword"></font>
00792 <font class="keyword"></font>{
00793   <font class="keywordflow">if</font> (v == (varDeclarationNode) 0)
00794     {
00795       <font class="keywordflow">return</font> globs;
00796     }
00797 
00798   <font class="keywordflow">if</font> (v-&gt;isSpecial)
00799     {
00800       globs = <a class="code" href="globSet_c.html#a2">globSet_insert</a> (globs, v-&gt;sref);
00801     }
00802   <font class="keywordflow">else</font>
00803     {
00804       lclTypeSpecNode t = v-&gt;type;
00805       qtype qt = convertLclTypeSpecNode (t);
00806       ctype c = qtype_getType (qt);
00807       cstring s;      
00808 
00809       initDeclNodeList_elements (v-&gt;decls, i)<font class="keyword"></font>
00810 <font class="keyword">        </font>{
00811           ctype ct;
00812           uentry ue;
00813           qualList quals = qtype_getQuals (qt);
00814           
00815           s = getVarName (i-&gt;declarator-&gt;type);
00816           ue = <a class="code" href="usymtab_c.html#a117">usymtab_lookupGlobSafe</a> (s);
00817           
00818           <font class="keywordflow">if</font> (uentry_isInvalid (ue))
00819             {
00820               ; <font class="comment">/* error already reported */</font> 
00821             }
00822           <font class="keywordflow">else</font>
00823             {
00824               <font class="keywordflow">if</font> (uentry_isPriv (ue))
00825                 {
00826                   globs = <a class="code" href="globSet_c.html#a2">globSet_insert</a> (globs, sRef_makeSpecState ());
00827                 }
00828               <font class="keywordflow">else</font>
00829                 {
00830                   uentry ce = <a class="code" href="uentry_c.html#a270">uentry_copy</a> (ue);
00831                   ctype lt = <a class="code" href="uentry_c.html#a197">uentry_getType</a> (ce);
00832                   fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (i-&gt;declarator-&gt;id);
00833                   
00834                   ct = convertTypeExpr (c, i-&gt;declarator-&gt;type);
00835                   
00836                   <font class="keywordflow">if</font> (!<a class="code" href="ctype_c.html#a96">ctype_match</a> (lt, ct))
00837                     {
00838                       (<font class="keywordtype">void</font>) gentypeerror
00839                         (lt, exprNode_undefined,
00840                          ct, exprNode_undefined,
00841                          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Global type mismatch %s (%t, %t)"</font>,
00842                                   s, lt, ct), 
00843                          loc);
00844                     }
00845                   
00846                   <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (ce, quals);
00847                   globs = <a class="code" href="globSet_c.html#a2">globSet_insert</a> (globs,
00848                                           sRef_copy (uentry_getSref (ce)));
00849                   <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
00850                   <a class="code" href="uentry_c.html#a238">uentry_free</a> (ce);
00851                 }
00852             }
00853         } end_initDeclNodeList_elements;
00854 
00855       <a class="code" href="qtype_c.html#a1">qtype_free</a> (qt);
00856     }
00857 
00858   <font class="keywordflow">return</font> globs;
00859 }
00860 
00861 <font class="keyword">static</font> <font class="keywordtype">void</font>
00862 declareAbstractType (abstractNode n, <font class="keywordtype">bool</font> priv)<font class="keyword"></font>
00863 <font class="keyword"></font>{
00864   cstring tn;
00865   fileloc loc;
00866   uentry ue;
00867   usymId uid;
00868   abstBodyNode ab;
00869 
00870   <font class="keywordflow">if</font> (n == (abstractNode) 0)
00871     {
00872       <font class="keywordflow">return</font>;
00873     }
00874 
00875   
00876   tn = ltoken_getRawString (n-&gt;name);
00877 
00878   loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (n-&gt;tok);
00879   
00880   ue = <a class="code" href="uentry_c.html#a111">uentry_makeDatatypeAux</a> (tn, ctype_unknown, 
00881                                ynm_fromBool (n-&gt;isMutable), YES, loc, priv);
00882 
00883   <font class="keywordflow">if</font> (n-&gt;isRefCounted)
00884     {
00885       <a class="code" href="uentry_c.html#a52">uentry_setRefCounted</a> (ue);
00886     }
00887 
00888   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> () &amp;&amp; !priv)
00889     {
00890       <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (ue, loc);
00891     }
00892 
00893   uid = <a class="code" href="usymtab_c.html#a57">usymtab_supAbstractTypeEntry</a> (ue, <a class="code" href="context_c.html#a231">context_inLCLLib</a>() &amp;&amp; !priv);
00894   
00895 
00896   <font class="keywordflow">if</font> (!priv &amp;&amp; (ab = n-&gt;body) != (abstBodyNode) 0)
00897     {
00898       fcnNodeList ops = ab-&gt;fcns;
00899 
00900       <font class="keywordflow">if</font> (!fcnNodeList_isEmpty (ops))
00901         {
00902           fcnNodeList_elements (ops, i)<font class="keyword"></font>
00903 <font class="keyword">          </font>{
00904             <font class="keywordflow">if</font> (i-&gt;typespec == (lclTypeSpecNode) 0)
00905               {
00906                 cstring fname = ltoken_getRawString (i-&gt;name);
00907 
00908                 <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (fname))
00909                   {
00910                     uentry e = usymtab_lookup (fname);
00911                     fileloc floc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (i-&gt;declarator-&gt;id);
00912 
00913                     <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a108">uentry_isForward</a> (e))
00914                       {
00915                         usymtab_supEntry  
00916                           (uentry_makeTypeListFunction 
00917                            (fname, <a class="code" href="typeIdSet_c.html#a19">typeIdSet_insert</a> (uentry_accessType (e), uid), 
00918                             floc));
00919                       }
00920                     <font class="keywordflow">else</font>
00921                       {
00922                         usymtab_supEntry 
00923                           (uentry_makeSpecFunction 
00924                            (fname, <a class="code" href="uentry_c.html#a197">uentry_getType</a> (e),
00925                             <a class="code" href="typeIdSet_c.html#a19">typeIdSet_insert</a> (uentry_accessType (e), uid),
00926                             globSet_undefined,
00927                             sRefSet_undefined,
00928                             floc));
00929                         
00930                         <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> ())
00931                           {
00932                             llbuglit (<font class="stringliteral">"Jolly jeepers Wilma, it ain't dead after all!"</font>);
00933                           }
00934                       }
00935                   }
00936                 <font class="keywordflow">else</font>
00937                   {
00938                     usymtab_supEntry 
00939                       (<a class="code" href="uentry_c.html#a107">uentry_makeForwardFunction</a> (fname, uid, loc));
00940                   }
00941               }
00942             <font class="keywordflow">else</font>
00943               {
00944                 declareFcn (i, uid);
00945               }
00946           } end_fcnNodeList_elements;
00947         }
00948     }
00949 }
00950 
00951 <font class="keyword">static</font> <font class="keywordtype">void</font>
00952   declareExposedType (exposedNode n, <font class="keywordtype">bool</font> priv)<font class="keyword"></font>
00953 <font class="keyword"></font>{
00954   usymId uid;
00955   qtype c;
00956   cstring s;
00957 
00958   
00959   <font class="keywordflow">if</font> (n == (exposedNode) 0)
00960     {
00961       <font class="keywordflow">return</font>;
00962     }
00963 
00964   c = convertLclTypeSpecNode (n-&gt;type);
00965 
00966   declaratorInvNodeList_elements (n-&gt;decls, i)<font class="keyword"></font>
00967 <font class="keyword">  </font>{
00968     ctype realType = convertTypeExpr (qtype_getType (c), i-&gt;declarator-&gt;type);
00969     fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (i-&gt;declarator-&gt;id);
00970     uentry ue;
00971 
00972     s = getVarName (i-&gt;declarator-&gt;type);
00973 
00974     ue = <a class="code" href="uentry_c.html#a111">uentry_makeDatatypeAux</a> (s, realType, MAYBE, NO, loc, priv);
00975 
00976     <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (ue, qtype_getQuals (c));
00977     
00978     <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> () &amp;&amp; !priv)
00979       {
00980         <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (ue, loc);
00981       }
00982 
00983     uid = <a class="code" href="usymtab_c.html#a58">usymtab_supExposedTypeEntry</a> (ue, context_inLCLLib () &amp;&amp; !priv);
00984   } end_declaratorInvNodeList_elements;
00985 
00986   <a class="code" href="qtype_c.html#a1">qtype_free</a> (c);
00987 }
00988 
00989 <font class="comment">/*</font>
00990 <font class="comment">** ah...remember ye old days...</font>
00991 <font class="comment">**</font>
00992 <font class="comment">** wow...same thing in THREE symbol tables!  talk about space efficiency</font>
00993 <font class="comment">** (or as Joe Theory once said, its only a constant factor)</font>
00994 <font class="comment">*/</font>
00995 
00996 <font class="keywordtype">void</font>
<a name="l00997"></a><a class="code" href="usymtab_interface_c.html#a18">00997</a> <a class="code" href="usymtab_interface_c.html#a18">doDeclareType</a> (typeNode t, <font class="keywordtype">bool</font> priv)<font class="keyword"></font>
00998 <font class="keyword"></font>{
00999   
01000   <font class="keywordflow">if</font> (t != (typeNode) 0)
01001     {
01002       <font class="keywordflow">switch</font> (t-&gt;kind)
01003         {
01004         <font class="keywordflow">case</font> TK_ABSTRACT:
01005           declareAbstractType (t-&gt;content.abstract, priv);
01006           <font class="keywordflow">break</font>;
01007           
01008         <font class="keywordflow">case</font> TK_EXPOSED:
01009           declareExposedType (t-&gt;content.exposed, priv);
01010           <font class="keywordflow">break</font>;
01011           
01012         <font class="keywordflow">case</font> TK_UNION:
01013         <font class="keywordflow">default</font>:
01014           {
01015             <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"declareType ERROR: unknown kind: %q"</font>,
01016                                  cstring_fromCharsO (FormatInt ((<font class="keywordtype">int</font>)t-&gt;kind))));
01017           }
01018         }
01019     }
01020   
01021 }
01022 
01023 <font class="keyword">extern</font> <font class="keywordtype">void</font>
<a name="l01024"></a><a class="code" href="usymtab_interface_c.html#a19">01024</a> <a class="code" href="usymtab_interface_c.html#a19">declareIter</a> (iterNode iter)<font class="keyword"></font>
01025 <font class="keyword"></font>{
01026   fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (iter-&gt;name);
01027   uentry ue = 
01028     <a class="code" href="uentry_c.html#a115">uentry_makeIter</a> (ltoken_unparse (iter-&gt;name), 
01029                      ctype_makeFunction 
01030                      (ctype_void,
01031                       paramNodeList_toUentryList (iter-&gt;params)), 
01032                      <a class="code" href="fileloc_c.html#a5">fileloc_copy</a> (loc));
01033   
01034   <a class="code" href="usymtab_c.html#a50">usymtab_supEntry</a> (ue);
01035   usymtab_supEntry 
01036     (<a class="code" href="uentry_c.html#a117">uentry_makeEndIter</a> (ltoken_unparse (iter-&gt;name), loc));
01037 }
01038 
01039 <font class="comment">/*</font>
01040 <font class="comment">** declareFcn</font>
01041 <font class="comment">*/</font>
01042 
01043 <font class="keyword">static</font> <font class="keywordtype">void</font>
01044 declareFcnAux (fcnNode f, <font class="comment">/*@only@*/</font> qtype qt, ctype ct,
01045                typeId tn, <font class="keywordtype">bool</font> priv, <font class="keywordtype">bool</font> spec)<font class="keyword"></font>
01046 <font class="keyword"></font>{
01047   globalList globals;
01048   typeIdSet acct;
01049   sRefSet sl = sRefSet_undefined;
01050   globSet globlist = globSet_undefined;
01051   cstring s = getVarName (f-&gt;declarator-&gt;type);
01052   fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (f-&gt;declarator-&gt;id);
01053   uentryList args;
01054 
01055   <font class="comment">/*</font>
01056 <font class="comment">  ** type conversion generates args </font>
01057 <font class="comment">  */</font>
01058 
01059   <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a49">ctype_isFunction</a> (ct))
01060     {
01061       args = <a class="code" href="ctype_c.html#a40">ctype_argsFunction</a> (ct);
01062     }
01063   <font class="keywordflow">else</font>
01064     {
01065       llcontbug (message (<font class="stringliteral">"Not function: %s"</font>, ctype_unparse (ct)));
01066       args = uentryList_undefined;
01067     }
01068 
01069   
01070   fileloc_setColumnUndefined (loc);
01071 
01072   <font class="keywordflow">if</font> (spec)
01073     {
01074       globals = f-&gt;globals;
01075       
01076             sl = fixModifies (f, args);
01077 
01078       <font class="comment">/*</font>
01079 <font class="comment">      ** Bind let declarations in modifies list </font>
01080 <font class="comment">      */</font>
01081 
01082       varDeclarationNodeList_elements (globals, glob)<font class="keyword"></font>
01083 <font class="keyword">        </font>{
01084           globlist = processGlob (globlist, glob);
01085         } end_varDeclarationNodeList_elements;
01086       
01087       
01088       <font class="keywordflow">if</font> (f-&gt;checks != (lclPredicateNode) 0)
01089         <font class="comment">/* push stderr on globalList */</font>
01090         <font class="comment">/* modifies *stderr^ */</font>
01091         {
01092           uentry ue;
01093 
01094           <font class="keywordflow">if</font> (!(<a class="code" href="usymtab_c.html#a134">usymtab_existsVar</a> (cstring_makeLiteralTemp (<font class="stringliteral">"stderr"</font>))))
01095             {
01096               ctype tfile;
01097               
01098               llmsglit (<font class="stringliteral">"Global stderr implied by checks clause, "</font>
01099                         <font class="stringliteral">"not declared in initializations."</font>);
01100 
01101               tfile = <a class="code" href="usymtab_c.html#a119">usymtab_lookupType</a> (cstring_makeLiteralTemp (<font class="stringliteral">"FILE"</font>));
01102               
01103               <font class="keywordflow">if</font> (ctype_isUndefined (tfile))
01104                 {
01105                   llmsglit (<font class="stringliteral">"FILE datatype implied by checks clause not defined."</font>);
01106                   tfile = ctype_unknown;
01107                 }
01108               
01109               usymtab_supGlobalEntry 
01110                 (<a class="code" href="uentry_c.html#a99">uentry_makeVariable</a> (cstring_makeLiteralTemp (<font class="stringliteral">"stderr"</font>), 
01111                                      tfile, <a class="code" href="fileloc_c.html#a28">fileloc_getBuiltin</a> (), FALSE));
01112             }
01113           
01114           ue = <a class="code" href="usymtab_c.html#a116">usymtab_lookupGlob</a> (cstring_makeLiteralTemp (<font class="stringliteral">"stderr"</font>));
01115           
01116                   globlist = <a class="code" href="globSet_c.html#a2">globSet_insert</a> (globlist, sRef_copy (uentry_getSref (ue)));
01117           sl = <a class="code" href="sRefSet_c.html#a4">sRefSet_insert</a> (sl, sRef_buildPointer (uentry_getSref (ue)));
01118 
01119         }
01120     }
01121 
01122   <font class="keywordflow">if</font> (usymId_isInvalid (tn))
01123     {
01124       acct = <a class="code" href="context_c.html#a59">context_fileAccessTypes</a> ();
01125     }
01126   <font class="keywordflow">else</font>
01127     {
01128       acct = <a class="code" href="typeIdSet_c.html#a17">typeIdSet_single</a> (tn);
01129     }
01130   
01131   <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (s))
01132     {
01133       uentry l = usymtab_lookup (s);
01134       uentry ue;
01135 
01136       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a108">uentry_isForward</a> (l) || (<a class="code" href="fileloc_c.html#a47">fileloc_isLib</a> (uentry_whereSpecified (l))))
01137         {
01138           typeIdSet accessType;
01139 
01140           <font class="keywordflow">if</font> (uentry_isFunction (l))
01141             {
01142               accessType = <a class="code" href="typeIdSet_c.html#a26">typeIdSet_union</a> (uentry_accessType (l), 
01143                                             <a class="code" href="context_c.html#a59">context_fileAccessTypes</a> ());
01144             }
01145           <font class="keywordflow">else</font>
01146             {
01147               accessType = <a class="code" href="context_c.html#a59">context_fileAccessTypes</a> ();
01148             }
01149 
01150           <font class="keywordflow">if</font> (spec)
01151             {
01152               ue = <a class="code" href="uentry_c.html#a105">uentry_makeSpecFunction</a> (s, ct, accessType, globlist, sl, loc);
01153             }
01154           <font class="keywordflow">else</font>
01155             {
01156               <a class="code" href="sRefSet_c.html#a39">sRefSet_free</a> (sl);
01157               <a class="code" href="globSet_c.html#a8">globSet_free</a> (globlist);
01158 
01159               ue = <a class="code" href="uentry_c.html#a110">uentry_makeUnspecFunction</a> (s, ct, accessType, loc);
01160             }
01161 
01162           <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (ue, qtype_getQuals (qt));
01163 
01164           <a class="code" href="usymtab_c.html#a50">usymtab_supEntry</a> (ue);
01165         }
01166       <font class="keywordflow">else</font>
01167         {
01168           <font class="comment">/*</font>
01169 <font class="comment">          ** error reported by symtable already</font>
01170 <font class="comment">          **</font>
01171 <font class="comment">          ** llgenerror (message ("Function redeclared: %s (previous declaration: %s)", s,</font>
01172 <font class="comment">          **                  fileloc_unparse (uentry_whereSpecified (l))),</font>
01173 <font class="comment">          **          loc);</font>
01174 <font class="comment">          */</font>
01175 
01176           
01177           <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
01178           <a class="code" href="sRefSet_c.html#a39">sRefSet_free</a> (sl);
01179           <a class="code" href="globSet_c.html#a8">globSet_free</a> (globlist);
01180         }
01181     }
01182   <font class="keywordflow">else</font>
01183     {
01184       uentry le;
01185       
01186       <font class="keywordflow">if</font> (spec)
01187         {
01188           <font class="keywordflow">if</font> (priv)
01189             {
01190               le = <a class="code" href="uentry_c.html#a104">uentry_makePrivFunction2</a> (s, ct, acct, globlist, sl, loc);
01191             }
01192           <font class="keywordflow">else</font>
01193             {
01194               le = <a class="code" href="uentry_c.html#a105">uentry_makeSpecFunction</a> (s, ct, acct, globlist, sl, loc);
01195             }
01196         }
01197       <font class="keywordflow">else</font>
01198         {
01199           le = <a class="code" href="uentry_c.html#a110">uentry_makeUnspecFunction</a> (s, ct, acct, loc);
01200 
01201           <a class="code" href="sRefSet_c.html#a39">sRefSet_free</a> (sl);
01202           <a class="code" href="globSet_c.html#a8">globSet_free</a> (globlist);
01203         }
01204 
01205       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a231">context_inLCLLib</a> () &amp;&amp; !priv)
01206         {
01207           <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (le, loc);
01208         }      
01209 
01210       <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (le, qtype_getQuals (qt));
01211 
01212       <font class="keywordflow">switch</font> (f-&gt;special)
01213         {
01214         <font class="keywordflow">case</font> QU_UNKNOWN:     <font class="keywordflow">break</font>;
01215         <font class="keywordflow">case</font> QU_PRINTFLIKE:  <a class="code" href="uentry_c.html#a77">uentry_setPrintfLike</a> (le); <font class="keywordflow">break</font>;
01216         <font class="keywordflow">case</font> QU_SCANFLIKE:   <a class="code" href="uentry_c.html#a78">uentry_setScanfLike</a> (le); <font class="keywordflow">break</font>;
01217         <font class="keywordflow">case</font> QU_MESSAGELIKE: <a class="code" href="uentry_c.html#a79">uentry_setMessageLike</a> (le); <font class="keywordflow">break</font>;
01218         BADDEFAULT;
01219         }
01220 
01221       <a class="code" href="usymtab_c.html#a50">usymtab_supEntry</a> (le);
01222     }
01223 
01224   <a class="code" href="qtype_c.html#a1">qtype_free</a> (qt);
01225 }
01226 
01227 <font class="keyword">extern</font> <font class="keywordtype">void</font>
<a name="l01228"></a><a class="code" href="usymtab_interface_c.html#a20">01228</a> <a class="code" href="usymtab_interface_c.html#a20">doDeclareFcn</a> (fcnNode f, typeId tn, <font class="keywordtype">bool</font> priv, <font class="keywordtype">bool</font> spec)<font class="keyword"></font>
01229 <font class="keyword"></font>{
01230   qtype qt = convertLclTypeSpecNode (f-&gt;typespec);
01231   ctype ct = convertTypeExpr (qtype_getType (qt), f-&gt;declarator-&gt;type);
01232 
01233     declareFcnAux (f, qt, ct, tn, priv, spec);
01234 }
01235 
01236 <font class="comment">/*</font>
01237 <font class="comment">** is s is an argument to f, return its arg no.</font>
01238 <font class="comment">** otherwise, return 0</font>
01239 <font class="comment">*/</font>
01240 
01241 <font class="keyword">static</font> <font class="keywordtype">int</font>
01242 getParamNo (cstring s, fcnNode f)<font class="keyword"></font>
01243 <font class="keyword"></font>{
01244   <font class="comment">/* gasp, maybe should do run-time checks here */</font>
01245   paramNodeList params;
01246   typeExpr fd = f-&gt;declarator-&gt;type;
01247   
01248   <font class="comment">/* is this a bug in the LCL grammar? */</font>
01249 
01250   <font class="keywordflow">while</font> (fd != NULL &amp;&amp; (fd-&gt;kind == TEXPR_PTR || fd-&gt;kind == TEXPR_ARRAY))
01251     {
01252       <font class="keywordflow">if</font> (fd-&gt;kind == TEXPR_PTR)
01253         {
01254           fd = fd-&gt;content.pointer;
01255         }
01256       <font class="keywordflow">else</font>
01257         {
01258           <font class="comment">/*@-null@*/</font> fd = fd-&gt;content.array.elementtype; <font class="comment">/*@=null@*/</font>
01259          
01260           <font class="comment">/*</font>
01261 <font class="comment">          ** This is a bug in checking, that I should eventually fix.</font>
01262 <font class="comment">          ** Need some way of deleting the guard from the true branch,</font>
01263 <font class="comment">          ** but adding it back in the false branch...</font>
01264 <font class="comment">          */</font>
01265         }
01266     }
01267 
01268   llassert (fd != NULL);
01269 
01270   <font class="keywordflow">if</font> (fd-&gt;kind != TEXPR_FCN)
01271     {
01272       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"getParamNo: not a function: %q (%d)"</font>,
01273                            typeExpr_unparse (fd), (<font class="keywordtype">int</font>) fd-&gt;kind));
01274     }
01275 
01276   params = fd-&gt;content.function.args;
01277 
01278   <font class="keywordflow">if</font> (paramNodeList_empty (params))
01279     {
01280       <font class="keywordflow">return</font> -1;
01281     }
01282   <font class="keywordflow">else</font>
01283     {
01284       <font class="keywordtype">int</font> pno = 0;
01285 
01286       paramNodeList_elements (params, i)<font class="keyword"></font>
01287 <font class="keyword">        </font>{
01288           <font class="keywordflow">if</font> (i-&gt;paramdecl != (typeExpr) 0)     <font class="comment">/* handle (void) */</font>
01289             {
01290               <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (s, getVarName (i-&gt;paramdecl)))
01291                 {
01292                   <font class="keywordflow">return</font> pno;
01293                 }
01294             }
01295           pno++;
01296         } end_paramNodeList_elements;
01297       <font class="keywordflow">return</font> -1;
01298     }
01299 }
01300 
01301 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> <font class="comment">/*@observer@*/</font> termNode
01302 getLetDecl (cstring s, fcnNode f)<font class="keyword"></font>
01303 <font class="keyword"></font>{
01304   letDeclNodeList x = f-&gt;lets;
01305 
01306   letDeclNodeList_elements (x, i)<font class="keyword"></font>
01307 <font class="keyword">  </font>{
01308     <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (s, ltoken_getRawString (i-&gt;varid)))
01309       {
01310         <font class="keywordflow">if</font> (i-&gt;sortspec != NULL)
01311           {
01312             llbuglit (<font class="stringliteral">"getLetDecl: cannot return sort!"</font>);
01313           }
01314         <font class="keywordflow">else</font>
01315           {                     <font class="comment">/* is a termNode */</font>
01316             <font class="keywordflow">return</font> i-&gt;term;
01317           }
01318       }
01319   } end_letDeclNodeList_elements;
01320 
01321   <font class="keywordflow">return</font> (termNode) 0;
01322 }
01323 
01324 <font class="comment">/*</font>
01325 <font class="comment">** processTermNode --- based on printTermNode2</font>
01326 <font class="comment">*/</font>
01327 
01328 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> sRef 
01329   processTermNode (<font class="comment">/*@null@*/</font> opFormNode op, termNodeList args, 
01330                    fcnNode f, uentryList cl)<font class="keyword"></font>
01331 <font class="keyword"></font>{
01332   <font class="keywordflow">if</font> (op != (opFormNode) 0)
01333     {
01334       <font class="keywordflow">switch</font> (op-&gt;kind)
01335         {
01336         <font class="keywordflow">case</font> OPF_IF:
01337           llcontbuglit (<font class="stringliteral">"processTermNode: OPF_IF: not handled"</font>);
01338           <font class="keywordflow">break</font>;
01339         <font class="keywordflow">case</font> OPF_ANYOP:
01340           llcontbuglit (<font class="stringliteral">"processTermNode: OPF_ANYOP: not handled"</font>);
01341           <font class="keywordflow">break</font>;
01342         <font class="keywordflow">case</font> OPF_MANYOP:
01343           {
01344             <font class="keywordtype">int</font> size = termNodeList_size (args);
01345 
01346             <font class="keywordflow">if</font> (size == 1 
01347                 &amp;&amp; (cstring_equalLit (ltoken_getRawString (op-&gt;content.anyop), <font class="stringliteral">"'"</font>) ||
01348                     cstring_equalLit (ltoken_getRawString (op-&gt;content.anyop), <font class="stringliteral">"^"</font>)))
01349               {
01350                 <font class="keywordflow">return</font> (fixTermNode (termNodeList_head (args), f, cl));
01351               }
01352             <font class="keywordflow">else</font> 
01353               {
01354                 ;
01355               }
01356             <font class="keywordflow">break</font>;
01357           }
01358         <font class="keywordflow">case</font> OPF_ANYOPM:
01359           {
01360             <font class="keywordtype">int</font> size = termNodeList_size (args);
01361 
01362             <font class="keywordflow">if</font> (size == 1 
01363                 &amp;&amp; (cstring_equalLit (ltoken_getRawString (op-&gt;content.anyop), <font class="stringliteral">"*"</font>)))
01364               {
01365                 sRef ft;
01366                 sRef res;
01367 
01368                 ft = fixTermNode (termNodeList_head (args), f, cl);
01369                 res = <a class="code" href="sRef_c.html#a267">sRef_buildPointer</a> (ft);
01370                 <font class="keywordflow">return</font> (res);
01371               }
01372             <font class="keywordflow">else</font>
01373               {
01374                 ;
01375               }
01376             <font class="keywordflow">break</font>;
01377           }
01378         <font class="keywordflow">case</font> OPF_MANYOPM:
01379           llcontbuglit (<font class="stringliteral">"OPF_MANYOPM: not handled\n"</font>);
01380           <font class="keywordflow">break</font>;
01381         <font class="keywordflow">case</font> OPF_MIDDLE:
01382           llcontbuglit (<font class="stringliteral">"OPF_MIDDLE: not handled\n"</font>);
01383           <font class="keywordflow">break</font>;
01384         <font class="keywordflow">case</font> OPF_MMIDDLE:
01385           llcontbuglit (<font class="stringliteral">"OPF_MMIDDLE: not handled\n"</font>);
01386           <font class="keywordflow">break</font>;
01387         <font class="keywordflow">case</font> OPF_MIDDLEM:
01388           llcontbuglit (<font class="stringliteral">"OPF_MIDDLEM: not handled\n"</font>);
01389           <font class="keywordflow">break</font>;
01390         <font class="keywordflow">case</font> OPF_MMIDDLEM:
01391           llcontbuglit (<font class="stringliteral">"OPF_MMIDDLEM: not handled\n"</font>);
01392           <font class="keywordflow">break</font>;
01393         <font class="keywordflow">case</font> OPF_BMIDDLE:
01394           <font class="keywordflow">if</font> (op-&gt;content.middle == 1)
01395             llbug (message (<font class="stringliteral">"array fetch: [%q]"</font>,
01396                             termNodeList_unparse (args)));
01397           <font class="keywordflow">else</font>
01398             llcontbuglit (<font class="stringliteral">"OPF_BMIDDLE: bad\n"</font>);
01399           <font class="keywordflow">break</font>;
01400 
01401         <font class="keywordflow">case</font> OPF_BMMIDDLE:
01402           <font class="keywordflow">if</font> (op-&gt;content.middle &lt;= 1)
01403             {
01404               sRef arr = fixTermNode (termNodeList_head (args), f, cl);
01405               sRef ret;
01406 
01407               <font class="keywordflow">if</font> (op-&gt;content.middle == 1)
01408                 {
01409                   termNode t = (<a class="code" href="termNodeList_c.html#a5">termNodeList_reset</a> (args),
01410                                 <a class="code" href="termNodeList_c.html#a7">termNodeList_advance</a> (args),
01411                                 <a class="code" href="termNodeList_c.html#a10">termNodeList_current</a> (args));
01412                   
01413                   <font class="keywordflow">if</font> (t-&gt;kind == TRM_LITERAL)
01414                     {
01415                       <font class="keywordtype">int</font> i;
01416 
01417                       <font class="keywordflow">if</font> (sscanf 
01418                           (cstring_toCharsSafe 
01419                            (ltoken_getRawString (t-&gt;literal)),
01420                            <font class="stringliteral">"%d"</font>, &amp;i) == 1)
01421                         {
01422                           ret = <a class="code" href="sRef_c.html#a265">sRef_buildArrayFetchKnown</a> (arr, i);
01423                         }
01424                       <font class="keywordflow">else</font>
01425                         {
01426                           ret = <a class="code" href="sRef_c.html#a264">sRef_buildArrayFetch</a> (arr);
01427                         }
01428 
01429                       <font class="keywordflow">return</font> (ret);
01430                     }
01431                 }
01432                       
01433               <font class="comment">/* unknown index */</font>
01434 
01435               ret = <a class="code" href="sRef_c.html#a264">sRef_buildArrayFetch</a> (arr);
01436 
01437               <font class="keywordflow">return</font> (ret);
01438             }
01439           <font class="keywordflow">else</font> 
01440             {
01441               llcontbug (message (<font class="stringliteral">"op-&gt;content.middle = %d"</font>, 
01442                                   op-&gt;content.middle));
01443               <font class="keywordflow">break</font>;
01444             }
01445 
01446         <font class="keywordflow">case</font> OPF_BMIDDLEM:
01447           llcontbuglit (<font class="stringliteral">"OPF_BMIDDLEM not handled"</font>);
01448           <font class="keywordflow">break</font>; 
01449 
01450         <font class="keywordflow">case</font> OPF_BMMIDDLEM:
01451           llcontbuglit (<font class="stringliteral">"OPF_BMMIDDLEM not handled"</font>);
01452           <font class="keywordflow">break</font>;
01453 
01454         <font class="keywordflow">case</font> OPF_SELECT:
01455           llcontbug (message (<font class="stringliteral">"select: .%s"</font>, 
01456                               ltoken_getRawString (op-&gt;content.id)));
01457           <font class="keywordflow">break</font>; 
01458 
01459         <font class="keywordflow">case</font> OPF_MAP:
01460           llcontbug (message (<font class="stringliteral">"map: .%s"</font>, 
01461                               ltoken_getRawString (op-&gt;content.id)));
01462           <font class="keywordflow">break</font>;
01463 
01464         <font class="keywordflow">case</font> OPF_MSELECT:
01465           {
01466             sRef rec = fixTermNode (termNodeList_head (args), f, cl);
01467             sRef ret; 
01468             ctype ct = <a class="code" href="ctype_c.html#a27">ctype_realType</a> (sRef_deriveType (rec, cl));
01469             cstring fieldname = ltoken_getRawString (op-&gt;content.id);
01470 
01471             ct = <a class="code" href="ctype_c.html#a27">ctype_realType</a> (ct);
01472 
01473             <font class="comment">/*</font>
01474 <font class="comment">            ** does it correspond to a typedef struct field</font>
01475 <font class="comment">            **</font>
01476 <font class="comment">            ** (kind of kludgey, but there is no direct way to</font>
01477 <font class="comment">            **  tell if it is an lsl operator instead)</font>
01478 <font class="comment">            */</font>
01479             
01480             <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a122">ctype_isStructorUnion</a> (ct) &amp;&amp;
01481                 uentry_isValid 
01482                 (<a class="code" href="uentryList_c.html#a32">uentryList_lookupField</a> (ctype_getFields (ct), fieldname)))
01483               {
01484                 cstring fname = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (fieldname);
01485 
01486                 ret = <a class="code" href="sRef_c.html#a258">sRef_buildField</a> (rec, fname);
01487                 <a class="code" href="cstring_c.html#a26">cstring_markOwned</a> (fname);
01488               }
01489             <font class="keywordflow">else</font>
01490               {
01491                 ret = sRef_undefined;
01492               }
01493 
01494             <font class="keywordflow">return</font> ret;
01495           }
01496         <font class="keywordflow">case</font> OPF_MMAP: 
01497           {
01498             sRef rec = fixTermNode (termNodeList_head (args), f, cl);
01499             sRef ret = sRef_undefined;
01500             ctype ct = <a class="code" href="ctype_c.html#a27">ctype_realType</a> (sRef_deriveType (rec, cl));
01501             cstring fieldname = ltoken_getRawString (op-&gt;content.id);
01502 
01503             <font class="comment">/*</font>
01504 <font class="comment">            ** does it correspond to a typedef struct field</font>
01505 <font class="comment">            */</font>
01506             
01507             <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a100">ctype_isPointer</a> (ct))
01508               {
01509                 ctype ctb = <a class="code" href="ctype_c.html#a27">ctype_realType</a> (ctype_baseArrayPtr (ct));
01510 
01511                 <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a122">ctype_isStructorUnion</a> (ctb) &amp;&amp;
01512                     uentry_isValid (uentryList_lookupField
01513                                     (ctype_getFields (ctb), fieldname)))
01514                   {
01515                     cstring fname = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (fieldname);
01516 
01517                     ret = <a class="code" href="sRef_c.html#a329">sRef_buildArrow</a> (rec, fname);
01518                     <a class="code" href="cstring_c.html#a26">cstring_markOwned</a> (fname);
01519                   }
01520               }
01521 
01522             <font class="keywordflow">return</font> ret;
01523           }
01524         }
01525     }
01526 
01527   <font class="keywordflow">return</font> sRef_undefined;
01528 }
01529 
01530 <font class="comment">/*</font>
01531 <font class="comment">** fixModifies</font>
01532 <font class="comment">**</font>
01533 <font class="comment">** o replace anything in modifies that is bound with let with value</font>
01534 <font class="comment">** o replace spec variables with internal state </font>
01535 <font class="comment">** o replace paramaters with paramno identifiers</font>
01536 <font class="comment">** o replace globals with their usymid's</font>
01537 <font class="comment">** o make everything sRefs</font>
01538 <font class="comment">*/</font>
01539 
01540 <font class="keyword">static</font> <font class="comment">/*@exposed@*/</font> sRef fixTermNode (termNode n, fcnNode f, uentryList cl)<font class="keyword"></font>
01541 <font class="keyword"></font>{
01542   <font class="keywordflow">if</font> (n != (termNode) 0)
01543     {
01544       <font class="keywordflow">switch</font> (n-&gt;kind)
01545         {
01546         <font class="keywordflow">case</font> TRM_LITERAL:
01547           <font class="keywordflow">break</font>;
01548         <font class="keywordflow">case</font> TRM_CONST:
01549         <font class="keywordflow">case</font> TRM_VAR:
01550         <font class="keywordflow">case</font> TRM_ZEROARY:
01551           {
01552             cstring s = ltoken_getRawString (n-&gt;literal);
01553             termNode tl = getLetDecl (s, f);
01554 
01555             <font class="keywordflow">if</font> (tl != (termNode) 0)
01556               {
01557                 <font class="keywordflow">return</font> (fixTermNode (tl, f, cl));
01558               }
01559             <font class="keywordflow">else</font>
01560               {
01561                 <font class="keywordtype">int</font> i = getParamNo (s, f);
01562 
01563                 <font class="keywordflow">if</font> (i &lt; 0)
01564                   {
01565                     usymId usym = <a class="code" href="usymtab_c.html#a68">usymtab_getId</a> (s);
01566                     
01567                     <font class="keywordflow">if</font> (usymId_isInvalid (usym))
01568                       {
01569                         <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a127">usymtab_existsEither</a> (s))
01570                           {
01571                             <font class="keywordflow">return</font> <a class="code" href="sRef_c.html#a157">sRef_makeSpecState</a> ();
01572                           }
01573                         <font class="keywordflow">else</font>
01574                           {
01575                             llcontbuglit (<font class="stringliteral">"Invalid symbol in modifies list"</font>);
01576                             <font class="keywordflow">return</font> sRef_undefined;
01577                           }
01578                       }
01579                     <font class="keywordflow">else</font>
01580                       <font class="keywordflow">return</font> (<a class="code" href="sRef_c.html#a131">sRef_makeGlobal</a> (usym, ctype_unknown));
01581                   }
01582                 
01583                 <font class="keywordflow">else</font>
01584                   {
01585                     sRef p = <a class="code" href="sRef_c.html#a133">sRef_makeParam</a> (i, ctype_unknown);
01586 
01587                                     <font class="keywordflow">return</font> (p);
01588                   }
01589               }
01590           }
01591         <font class="keywordflow">case</font> TRM_APPLICATION:
01592           {
01593             nameNode nn = n-&gt;name;
01594 
01595             <font class="keywordflow">if</font> (nn != (nameNode) 0)
01596               {
01597                 <font class="keywordflow">if</font> (nn-&gt;isOpId)
01598                   {
01599                     <font class="comment">/* must we handle n-&gt;given ? skip for now */</font>
01600 
01601                     llfatalbug 
01602                       (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"fixTermNode: expect non-empty nameNode: "</font>
01603                                 <font class="stringliteral">"TRM_APPLICATION: %q"</font>,
01604                                 nameNode_unparse (nn)));
01605                   }
01606                 <font class="keywordflow">else</font>
01607                   {
01608                     sRef sr;
01609 
01610                     sr = processTermNode (nn-&gt;content.opform, n-&gt;args, f, cl);
01611                                     <font class="keywordflow">return</font> (sr);
01612                   }
01613               }
01614             
01615             <font class="keywordflow">return</font> sRef_undefined;
01616           }
01617         <font class="keywordflow">case</font> TRM_UNCHANGEDALL:      
01618         <font class="keywordflow">case</font> TRM_UNCHANGEDOTHERS:
01619         <font class="keywordflow">case</font> TRM_SIZEOF:
01620         <font class="keywordflow">case</font> TRM_QUANTIFIER:
01621           <font class="keywordflow">return</font> sRef_undefined;
01622         }
01623     }
01624 
01625   <font class="keywordflow">return</font> sRef_undefined;
01626 }
01627 
01628 <font class="keyword">static</font> 
01629 <font class="comment">/*@only@*/</font> sRefSet fixModifies (fcnNode f, uentryList cl)<font class="keyword"></font>
01630 <font class="keyword"></font>{
01631   <font class="keyword">static</font> <font class="keywordtype">bool</font> shownWarning = FALSE;
01632   modifyNode m = f-&gt;modify;
01633   sRefSet sl = <a class="code" href="sRefSet_c.html#a0">sRefSet_new</a> ();
01634 
01635   <font class="keywordflow">if</font> (m != (modifyNode) 0)
01636     {
01637       <font class="keywordflow">if</font> (m-&gt;hasStoreRefList)
01638         {
01639           storeRefNodeList srefs = m-&gt;list;
01640 
01641           storeRefNodeList_elements (srefs, i)<font class="keyword"></font>
01642 <font class="keyword">            </font>{
01643               <font class="keywordflow">if</font> (storeRefNode_isObj (i) || storeRefNode_isType (i))
01644                 {
01645                   <font class="keywordflow">if</font> (!shownWarning)
01646                     {
01647                       fileloc loc = <a class="code" href="fileloc_c.html#a22">fileloc_fromTok</a> (f-&gt;name);
01648                   
01649                       <a class="code" href="llerror_c.html#a21">llmsg</a> (message
01650                              (<font class="stringliteral">"%q: Warning: object and type modifications "</font>
01651                               <font class="stringliteral">"not understood by LCLint"</font>,
01652                               fileloc_unparse (loc)));
01653                       <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
01654                       shownWarning = TRUE;
01655                     }
01656                 }
01657               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (storeRefNode_isSpecial (i))
01658                 {
01659                   sl = <a class="code" href="sRefSet_c.html#a4">sRefSet_insert</a> (sl, i-&gt;content.ref);
01660                 }
01661               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (storeRefNode_isTerm (i))
01662                 {
01663                   sRef s = fixTermNode (i-&gt;content.term, f, cl);
01664 
01665                   <font class="keywordflow">if</font> (sRef_isKnown (s)) 
01666                     {
01667                       sl = <a class="code" href="sRefSet_c.html#a4">sRefSet_insert</a> (sl, s);
01668                     }
01669                 }
01670               <font class="keywordflow">else</font>
01671                 {
01672                   BADEXIT;
01673                 }
01674             } end_storeRefNodeList_elements;
01675           
01676         }
01677     }
01678 
01679   <font class="keywordflow">return</font> sl;
01680 }
01681 
01682 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
01683 paramNode_name (paramNode x)<font class="keyword"></font>
01684 <font class="keyword"></font>{
01685   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a137">typeExpr_name</a> (x-&gt;paramdecl));
01686 }
01687 
01688 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> uentry
01689 paramNode_toUentry (paramNode p)<font class="keyword"></font>
01690 <font class="keyword"></font>{
01691   <font class="keywordflow">if</font> (p != (paramNode) 0)
01692     {
01693       <font class="keywordflow">if</font> (p-&gt;kind == PELIPSIS)
01694         {
01695           <font class="keywordflow">return</font> <a class="code" href="uentry_c.html#a130">uentry_makeElipsisMarker</a> ();
01696         }
01697       <font class="keywordflow">else</font>
01698         {
01699           qtype ct = convertLclTypeSpecNode (p-&gt;type);
01700           ctype cr = convertTypeExpr (qtype_getType (ct), p-&gt;paramdecl);
01701           cstring pname = (p-&gt;paramdecl == (typeExpr)0) ? cstring_undefined 
01702                                                         : paramNode_name (p);
01703           uentry ue = <a class="code" href="uentry_c.html#a83">uentry_makeVariableParam</a> (pname, cr);
01704 
01705           <a class="code" href="uentry_c.html#a66">uentry_reflectQualifiers</a> (ue, qtype_getQuals (ct));
01706           <a class="code" href="qtype_c.html#a1">qtype_free</a> (ct);
01707           <font class="keywordflow">return</font> (ue);
01708         }
01709     }
01710   <font class="keywordflow">else</font>
01711     {
01712       llcontbuglit (<font class="stringliteral">"paramNode_toUentry: NULL"</font>);
01713       <font class="keywordflow">return</font> uentry_undefined;
01714     }
01715   BADEXIT;
01716 }
01717 
01718 <font class="keyword">static</font> uentryList
01719   paramNodeList_toUentryList (paramNodeList p)<font class="keyword"></font>
01720 <font class="keyword"></font>{
01721   uentryList cl = <a class="code" href="uentryList_c.html#a0">uentryList_new</a> ();
01722 
01723   <font class="keywordflow">if</font> (paramNodeList_isNull (p)) <font class="keywordflow">return</font> (cl);
01724 
01725   paramNodeList_elements (p, current)<font class="keyword"></font>
01726 <font class="keyword">    </font>{
01727       cl = <a class="code" href="uentryList_c.html#a4">uentryList_add</a> (cl, paramNode_toUentry (current));
01728     } end_paramNodeList_elements;
01729 
01730   <font class="keywordflow">return</font> cl;
01731 }
01732 
01733 
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:46 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
