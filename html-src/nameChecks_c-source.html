<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>nameChecks.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:43 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>nameChecks.c</h1><a href="nameChecks_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** nameChecks.c</font>
00026 <font class="comment">*/</font>
00027 
00028 <font class="preprocessor"># include "lclintMacros.nf"</font>
00029 <font class="preprocessor"># include "basic.h"</font>
00030 <font class="preprocessor"># include "nameChecks.h"</font>
00031 
00032 <font class="keyword">static</font> <font class="keywordtype">bool</font> checkCzechName (uentry p_ue, flagcode p_czechflag, <font class="keywordtype">bool</font> p_report)
00033   <font class="comment">/*@modifies p_ue, g_msgstream@*/</font> ;
00034 
00035 <font class="keyword">static</font> <font class="keywordtype">bool</font> checkSlovakName (uentry p_ue, flagcode p_slovakflag, <font class="keywordtype">bool</font> p_report)
00036   <font class="comment">/*@modifies p_ue, g_msgstream@*/</font> ;
00037 
00038 <font class="keyword">static</font> cstring czechPrefix (cstring name)<font class="keyword"></font>
00039 <font class="keyword"></font>{
00040   <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a6">cstring_beforeChar</a> (name, <font class="charliteral">'_'</font>));
00041 }
00042 
00043 <font class="keyword">static</font> cstring slovakPrefix (cstring name)<font class="keyword"></font>
00044 <font class="keyword"></font>{
00045   <font class="keywordtype">int</font> i = 0;
00046 
00047   cstring_chars (name, c)<font class="keyword"></font>
00048 <font class="keyword">    </font>{
00049       <font class="keywordflow">if</font> (isupper ((<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>) c))
00050         {
00051           <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a4">cstring_prefix</a> (name, i));
00052         }
00053       i++;
00054     } end_cstring_chars;
00055 
00056   <font class="keywordflow">return</font> cstring_undefined;
00057 }
00058 
00059 <font class="keyword">static</font> flagcode excludeCodes [] = 
00060  {
00061    FLG_MACROVARPREFIXEXCLUDE,
00062    FLG_TAGPREFIXEXCLUDE,
00063    FLG_ENUMPREFIXEXCLUDE,
00064    FLG_FILESTATICPREFIXEXCLUDE,
00065    FLG_GLOBPREFIXEXCLUDE,
00066    FLG_TYPEPREFIXEXCLUDE,
00067    FLG_EXTERNALPREFIXEXCLUDE,
00068    FLG_UNCHECKEDMACROPREFIXEXCLUDE,
00069    FLG_LOCALPREFIXEXCLUDE,
00070    INVALID_FLAG
00071    } ;
00072 
00073 <font class="comment">/*@iter excludeFlagCodes (yield flagcode code);@*/</font>
<a name="l00074"></a><a class="code" href="nameChecks_c.html#a0">00074</a> <font class="preprocessor"># define excludeFlagCodes(m_c) \</font>
00075 <font class="preprocessor">  { int m_i = 0; while (flagcode_isValid (excludeCodes[m_i])) \</font>
00076 <font class="preprocessor">      { flagcode m_c = excludeCodes[m_i]; m_i++; </font>
00077 <font class="preprocessor"></font>
<a name="l00078"></a><a class="code" href="nameChecks_c.html#a1">00078</a> <font class="preprocessor"># define end_excludeFlagCodes }}</font>
00079 <font class="preprocessor"></font>
00080 <font class="keyword">static</font> <font class="keywordtype">bool</font> matchPrefixChar (<font class="keywordtype">int</font> nc, <font class="keywordtype">int</font> pc)<font class="keyword"></font>
00081 <font class="keyword"></font>{
00082   <font class="keywordflow">if</font> (nc == pc)
00083     {
00084       <font class="keywordflow">return</font> TRUE;
00085     }
00086   <font class="keywordflow">else</font>
00087     {
00088       <font class="keywordflow">switch</font> (pc)
00089         {
00090         <font class="keywordflow">case</font> PFX_UPPERCASE: 
00091           <font class="keywordflow">return</font> isupper (nc);
00092         <font class="keywordflow">case</font> PFX_LOWERCASE:
00093           <font class="keywordflow">return</font> islower (nc);
00094         <font class="keywordflow">case</font> PFX_ANY:
00095           <font class="keywordflow">return</font> TRUE;
00096         <font class="keywordflow">case</font> PFX_DIGIT:
00097           <font class="keywordflow">return</font> isdigit (nc);
00098         <font class="keywordflow">case</font> PFX_NOTUPPER:
00099           <font class="keywordflow">return</font> !isupper (nc);
00100         <font class="keywordflow">case</font> PFX_NOTLOWER:
00101           <font class="keywordflow">return</font> !islower (nc);
00102         <font class="keywordflow">case</font> PFX_ANYLETTER:
00103           <font class="keywordflow">return</font> isalpha (nc);
00104         <font class="keywordflow">case</font> PFX_ANYLETTERDIGIT: 
00105           <font class="keywordflow">return</font> (isdigit (nc) || isalpha (nc));
00106         <font class="keywordflow">default</font>: <font class="keywordflow">return</font> FALSE;
00107         }
00108     }
00109 
00110   BADEXIT;
00111 }
00112 
00113 <font class="keyword">static</font> <font class="keywordtype">bool</font> matchPrefix (cstring name, cstring prefix)<font class="keyword"></font>
00114 <font class="keyword"></font>{
00115   <font class="keywordflow">if</font> (cstring_isUndefined (name)
00116       || cstring_isUndefined (prefix))
00117     {
00118       <font class="keywordflow">return</font> TRUE;
00119     }
00120   <font class="keywordflow">else</font>
00121     {
00122       <font class="keywordtype">int</font> namelen = <a class="code" href="cstring_c.html#a30">cstring_length</a> (name);
00123       <font class="keywordtype">int</font> last = (<font class="keywordtype">int</font>) <font class="charliteral">'\0'</font>;
00124       <font class="keywordtype">int</font> n = 1;
00125 
00126       cstring_chars (prefix, pc)<font class="keyword"></font>
00127 <font class="keyword">        </font>{
00128           <font class="keywordtype">int</font> nc;
00129 
00130           <font class="keywordflow">if</font> (pc == <font class="charliteral">'*'</font>)
00131             {
00132               n++;
00133 
00134               
00135               <font class="keywordflow">while</font> (n &lt;= namelen)
00136                 {
00137                   nc = (<font class="keywordtype">int</font>) <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (name, n);
00138 
00139                   <font class="keywordflow">if</font> (!matchPrefixChar (nc, last))
00140                     {
00141                       <font class="keywordflow">return</font> FALSE;
00142                     }
00143                   n++;
00144                 }
00145 
00146               <font class="keywordflow">return</font> TRUE;
00147             }
00148           <font class="keywordflow">else</font>
00149             {
00150               <font class="keywordflow">if</font> (n &gt; namelen)
00151                 {
00152                   <font class="keywordflow">if</font> ((<a class="code" href="cstring_c.html#a30">cstring_length</a> (prefix) &gt;= n + 1)
00153                       &amp;&amp; <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (prefix, n + 1) == <font class="charliteral">'*'</font>)
00154                     {
00155                       <font class="keywordflow">return</font> TRUE;
00156                     }
00157                   <font class="keywordflow">else</font>
00158                     {
00159                       <font class="keywordflow">return</font> FALSE;
00160                     }
00161                 }
00162               
00163               nc = (<font class="keywordtype">int</font>) <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (name, n);
00164               
00165               <font class="keywordflow">if</font> (!matchPrefixChar (nc, (<font class="keywordtype">int</font>) pc))
00166                 {
00167                   <font class="keywordflow">return</font> FALSE;
00168                 }
00169             }
00170         
00171           last = (<font class="keywordtype">int</font>) pc;
00172           n++;
00173         } end_cstring_chars;
00174 
00175       <font class="keywordflow">return</font> TRUE;
00176     }
00177 }
00178 
00179 <font class="keyword">static</font> flagcode
00180 namespaceExcluded (flagcode code) <font class="comment">/*@*/</font> 
00181 {
00182   <font class="keywordflow">switch</font> (code)
00183     {
00184     <font class="keywordflow">case</font> FLG_MACROVARPREFIXEXCLUDE:
00185       <font class="keywordflow">return</font> (FLG_MACROVARPREFIX);
00186     <font class="keywordflow">case</font> FLG_TAGPREFIXEXCLUDE:
00187       <font class="keywordflow">return</font> (FLG_TAGPREFIX);
00188     <font class="keywordflow">case</font> FLG_ENUMPREFIXEXCLUDE:
00189       <font class="keywordflow">return</font> (FLG_ENUMPREFIX);
00190     <font class="keywordflow">case</font> FLG_FILESTATICPREFIXEXCLUDE:
00191       <font class="keywordflow">return</font> (FLG_FILESTATICPREFIX);
00192     <font class="keywordflow">case</font> FLG_GLOBPREFIXEXCLUDE:
00193       <font class="keywordflow">return</font> (FLG_GLOBPREFIX);
00194     <font class="keywordflow">case</font> FLG_TYPEPREFIXEXCLUDE:
00195       <font class="keywordflow">return</font> (FLG_TYPEPREFIX);
00196     <font class="keywordflow">case</font> FLG_EXTERNALPREFIXEXCLUDE:
00197       <font class="keywordflow">return</font> (FLG_EXTERNALPREFIX);
00198     <font class="keywordflow">case</font> FLG_UNCHECKEDMACROPREFIXEXCLUDE:
00199       <font class="keywordflow">return</font> (FLG_UNCHECKEDMACROPREFIX);
00200     <font class="keywordflow">case</font> FLG_LOCALPREFIXEXCLUDE:
00201       <font class="keywordflow">return</font> (FLG_LOCALPREFIX);
00202     <font class="keywordflow">case</font> FLG_ITERPREFIXEXCLUDE:
00203       <font class="keywordflow">return</font> (FLG_ITERPREFIX);
00204     <font class="keywordflow">case</font> FLG_CONSTPREFIXEXCLUDE:
00205       <font class="keywordflow">return</font> (FLG_CONSTPREFIX);
00206     BADDEFAULT;
00207     }
00208 }
00209 
00210 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> cstring
00211 namespaceName (flagcode flag) <font class="comment">/*@*/</font>
00212 {
00213   <font class="keywordflow">switch</font> (flag)
00214     {
00215     <font class="keywordflow">case</font> FLG_MACROVARPREFIX: 
00216       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"macro variable"</font>);
00217     <font class="keywordflow">case</font> FLG_TAGPREFIX:  
00218       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"tag"</font>);
00219     <font class="keywordflow">case</font> FLG_ENUMPREFIX:  
00220       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"enum member"</font>);
00221     <font class="keywordflow">case</font> FLG_TYPEPREFIX:     
00222       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"user-defined type"</font>);
00223     <font class="keywordflow">case</font> FLG_FILESTATICPREFIX:
00224       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"file static"</font>);
00225     <font class="keywordflow">case</font> FLG_GLOBPREFIX: 
00226       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"global variable"</font>);
00227     <font class="keywordflow">case</font> FLG_EXTERNALPREFIX: 
00228       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"external"</font>);
00229     <font class="keywordflow">case</font> FLG_LOCALPREFIX: 
00230       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"local variable"</font>);
00231     <font class="keywordflow">case</font> FLG_CONSTPREFIX: 
00232       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"constant"</font>);
00233     <font class="keywordflow">case</font> FLG_ITERPREFIX: 
00234       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"iter"</font>);
00235     <font class="keywordflow">case</font> FLG_UNCHECKEDMACROPREFIX: 
00236       <font class="keywordflow">return</font> cstring_makeLiteralTemp (<font class="stringliteral">"unchecked macro"</font>);
00237     BADDEFAULT;
00238     }
00239 }
00240 
00241 <font class="keywordtype">void</font> 
<a name="l00242"></a><a class="code" href="nameChecks_c.html#a13">00242</a> <a class="code" href="nameChecks_c.html#a13">checkPrefix</a> (uentry ue)<font class="keyword"></font>
00243 <font class="keyword"></font>{
00244   cstring name = cstring_undefined;
00245   flagcode flag;
00246 
00247   <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a171">uentry_isExpandedMacro</a> (ue))
00248     {
00249       flag = FLG_UNCHECKEDMACROPREFIX;
00250     }
00251   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a128">uentry_isAnyTag</a> (ue))
00252     {
00253       flag = FLG_TAGPREFIX;
00254     }
00255   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (uentry_isEnumConstant (ue))
00256     {
00257       flag = FLG_ENUMPREFIX;
00258     }
00259   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (ue))
00260     {
00261       flag = FLG_TYPEPREFIX;
00262     }
00263   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a69">uentry_isFileStatic</a> (ue))
00264     {
00265       flag = FLG_FILESTATICPREFIX;
00266     }
00267   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a72">uentry_isGlobal</a> (ue))
00268     {
00269       flag = FLG_GLOBPREFIX;
00270     }
00271   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a159">uentry_isVariable</a> (ue))
00272     {
00273       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a173">uentry_isRefParam</a> (ue))
00274         {
00275           <font class="keywordflow">return</font>; <font class="comment">/* already checked param */</font>
00276         }
00277 
00278       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a235">context_inMacro</a> ())
00279         {
00280           <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a174">uentry_isAnyParam</a> (ue))
00281             {
00282               <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a98">uentry_isYield</a> (ue))
00283                 {
00284                   flag = FLG_MACROVARPREFIX;
00285                 }
00286               <font class="keywordflow">else</font>
00287                 {
00288                   flag = FLG_LOCALPREFIX;
00289                 }
00290             }
00291           <font class="keywordflow">else</font>
00292             {
00293               flag = FLG_MACROVARPREFIX;
00294             }
00295         }
00296       <font class="keywordflow">else</font>
00297         {
00298           flag = FLG_LOCALPREFIX;
00299         }
00300     }
00301   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (uentry_isConstant (ue))
00302     {
00303       flag = FLG_CONSTPREFIX;
00304     }
00305   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a184">uentry_isIter</a> (ue))
00306     {
00307       flag = FLG_ITERPREFIX;
00308     }
00309   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a70">uentry_isExported</a> (ue))
00310     {
00311       flag = FLG_EXTERNALPREFIX;
00312     }
00313   <font class="keywordflow">else</font>
00314     {
00315       llcontbug (message (<font class="stringliteral">"What is it: %q"</font>, uentry_unparseFull (ue)));
00316       <font class="keywordflow">return</font>;
00317     }
00318 
00319   <font class="keywordflow">if</font> (flag == FLG_TYPEPREFIX || flag == FLG_GLOBPREFIX
00320       || flag == FLG_ENUMPREFIX || flag == FLG_CONSTPREFIX)
00321     {
00322       <font class="keywordflow">if</font> (flag == FLG_ENUMPREFIX)
00323         {
00324           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (flag))
00325             {
00326               flag = FLG_CONSTPREFIX;
00327             }
00328         }
00329 
00330       <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (flag))
00331         {
00332           flag = FLG_EXTERNALPREFIX;
00333         }
00334     }
00335 
00336   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (flag))
00337     {
00338       name = <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue);
00339       
00340       
00341       <font class="keywordflow">if</font> (!matchPrefix (name, context_getString (flag)))
00342         {
00343           <font class="keywordflow">if</font> (optgenerror
00344               (flag,
00345                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %s name is not consistent with %s "</font>
00346                         <font class="stringliteral">"namespace prefix \"%s\""</font>,
00347                         uentry_ekindName (ue),
00348                         name,
00349                         namespaceName (flag),
00350                         <a class="code" href="context_c.html#a157">context_getString</a> (flag)),
00351                <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00352             {
00353               <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00354             }
00355         }
00356     }  
00357 
00358   <a class="code" href="nameChecks_c.html#a0">excludeFlagCodes</a> (code)<font class="keyword"></font>
00359 <font class="keyword">    </font>{
00360       <font class="keywordtype">bool</font> check = FALSE;
00361 
00362       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (code))
00363         {
00364           <font class="comment">/*@-loopswitchbreak@*/</font>
00365           <font class="keywordflow">switch</font> (code)
00366             {
00367             <font class="keywordflow">case</font> FLG_MACROVARPREFIXEXCLUDE:
00368               check = (flag != FLG_MACROVARPREFIX);
00369               <font class="keywordflow">break</font>;
00370             <font class="keywordflow">case</font> FLG_TAGPREFIXEXCLUDE:
00371               check = (flag != FLG_TAGPREFIX);
00372               <font class="keywordflow">break</font>;
00373             <font class="keywordflow">case</font> FLG_ENUMPREFIXEXCLUDE:
00374               check = (flag != FLG_ENUMPREFIX);
00375               <font class="keywordflow">break</font>;
00376             <font class="keywordflow">case</font> FLG_FILESTATICPREFIXEXCLUDE:
00377               check = (flag != FLG_FILESTATICPREFIX);
00378               <font class="keywordflow">break</font>;
00379             <font class="keywordflow">case</font> FLG_GLOBPREFIXEXCLUDE:
00380               check = (flag != FLG_GLOBPREFIX);
00381               <font class="keywordflow">break</font>;
00382             <font class="keywordflow">case</font> FLG_TYPEPREFIXEXCLUDE:
00383               check = (flag != FLG_TYPEPREFIX);
00384               <font class="keywordflow">break</font>;
00385             <font class="keywordflow">case</font> FLG_EXTERNALPREFIXEXCLUDE:
00386               check = (flag != FLG_EXTERNALPREFIX
00387                        &amp;&amp; flag != FLG_GLOBPREFIX
00388                        &amp;&amp; flag != FLG_TYPEPREFIX
00389                        &amp;&amp; flag != FLG_UNCHECKEDMACROPREFIX);
00390               <font class="keywordflow">break</font>;
00391             <font class="keywordflow">case</font> FLG_UNCHECKEDMACROPREFIXEXCLUDE:
00392               check = (flag != FLG_UNCHECKEDMACROPREFIX);
00393               <font class="keywordflow">break</font>;
00394             <font class="keywordflow">case</font> FLG_LOCALPREFIXEXCLUDE:
00395               check = (flag != FLG_LOCALPREFIX);
00396               <font class="keywordflow">break</font>;
00397             <font class="keywordflow">case</font> FLG_CONSTPREFIXEXCLUDE:
00398               check = (flag != FLG_CONSTPREFIX);
00399               <font class="keywordflow">break</font>;
00400             <font class="keywordflow">case</font> FLG_ITERPREFIXEXCLUDE:
00401               check = (flag != FLG_ITERPREFIX);
00402               <font class="keywordflow">break</font>;
00403             BADDEFAULT;
00404             }
00405           <font class="comment">/*@=loopswitchbreak@*/</font>
00406 
00407           <font class="keywordflow">if</font> (check)
00408             {
00409               flagcode rcode = namespaceExcluded (code);
00410               cstring pstring = <a class="code" href="context_c.html#a157">context_getString</a> (rcode);
00411 
00412               <font class="keywordflow">if</font> (cstring_isDefined (pstring))
00413                 {
00414                   <font class="keywordflow">if</font> (cstring_isUndefined (name))
00415                     {
00416                       name = <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue);
00417                     }
00418                   
00419                   <font class="keywordflow">if</font> (matchPrefix (name, context_getString (rcode)))
00420                     {
00421                       <font class="keywordflow">if</font> (optgenerror
00422                           (code,
00423                            message
00424                            (<font class="stringliteral">"%s %s name is not a %s (it is a %s), "</font>
00425                             <font class="stringliteral">"but matches the %s "</font>
00426                             <font class="stringliteral">"namespace prefix \"%s\""</font>,
00427                             <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00428                             name,
00429                             namespaceName (rcode),
00430                             namespaceName (flag),
00431                             namespaceName (rcode),
00432                             <a class="code" href="context_c.html#a157">context_getString</a> (rcode)),
00433                            <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00434                         {
00435                           <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00436                         }
00437                     }
00438                 }
00439             }
00440         } 
00441     } end_excludeFlagCodes ;
00442 
00443   <a class="code" href="cstring_c.html#a27">cstring_free</a> (name);
00444 }
00445 
00446 <font class="keyword">static</font> <font class="keywordtype">void</font>
00447 checkNationalName (uentry ue)<font class="keyword"></font>
00448 <font class="keyword"></font>{
00449   flagcode czechflag;
00450   flagcode slovakflag;
00451   flagcode czechoslovakflag;
00452   <font class="keywordtype">bool</font> gcf, gsf, gcsf;
00453 
00454   
00455   <font class="keywordflow">if</font> (uentry_isFunction (ue)
00456       || <a class="code" href="uentry_c.html#a184">uentry_isIter</a> (ue)
00457       || <a class="code" href="uentry_c.html#a185">uentry_isEndIter</a> (ue))
00458     {
00459       czechflag = FLG_CZECHFUNCTIONS;
00460       slovakflag = FLG_SLOVAKFUNCTIONS;
00461       czechoslovakflag = FLG_CZECHOSLOVAKFUNCTIONS;
00462     }
00463   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a171">uentry_isExpandedMacro</a> (ue))
00464     {
00465       czechflag = FLG_CZECHMACROS;
00466       slovakflag = FLG_SLOVAKMACROS;
00467       czechoslovakflag = FLG_CZECHOSLOVAKMACROS;
00468     }
00469   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a159">uentry_isVariable</a> (ue))
00470     {
00471       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a72">uentry_isGlobal</a> (ue) &amp;&amp; <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_GLOBPREFIX))
00472         {
00473           <font class="comment">/* prefix checks supercede national naming checks */</font>
00474           <font class="keywordflow">return</font>;
00475         }
00476 
00477       czechflag = FLG_CZECHVARS;
00478       slovakflag = FLG_SLOVAKVARS;
00479       czechoslovakflag = FLG_CZECHOSLOVAKVARS;
00480     }
00481   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (uentry_isConstant (ue))
00482     {
00483       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a72">uentry_isGlobal</a> (ue) &amp;&amp; <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_CONSTPREFIX))
00484         {
00485           <font class="comment">/* prefix checks supercede national naming checks */</font>
00486           <font class="keywordflow">return</font>;
00487         }
00488 
00489       czechflag = FLG_CZECHCONSTANTS;
00490       slovakflag = FLG_SLOVAKCONSTANTS;
00491       czechoslovakflag = FLG_CZECHOSLOVAKCONSTANTS;
00492     }
00493   <font class="keywordflow">else</font>
00494     {
00495       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a128">uentry_isAnyTag</a> (ue) || uentry_isEnumConstant (ue))
00496         {
00497           <font class="keywordflow">return</font>; <font class="comment">/* no errors for tags */</font>
00498         }
00499       
00500       llassert (uentry_isDatatype (ue));
00501 
00502       czechflag = FLG_CZECHTYPES;
00503       slovakflag = FLG_SLOVAKTYPES;
00504       czechoslovakflag = FLG_CZECHOSLOVAKTYPES;
00505     }
00506 
00507   gcf = <a class="code" href="context_c.html#a189">context_getFlag</a> (czechflag);
00508   gsf = <a class="code" href="context_c.html#a189">context_getFlag</a> (slovakflag);
00509   gcsf = <a class="code" href="context_c.html#a189">context_getFlag</a> (czechoslovakflag);
00510 
00511   <font class="keywordflow">if</font> (gcf || (uentry_isFunction (ue) 
00512               &amp;&amp; <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECH)))
00513     {
00514             (<font class="keywordtype">void</font>) checkCzechName (ue, czechflag, gcf);
00515     }
00516 
00517   <font class="keywordflow">if</font> (gsf || (uentry_isFunction (ue) 
00518               &amp;&amp; <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSSLOVAK)))
00519     {
00520       (<font class="keywordtype">void</font>) checkSlovakName (ue, slovakflag, gsf);
00521     }
00522 
00523   <font class="keywordflow">if</font> (gcsf)
00524     {
00525       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (ue))
00526         {
00527           <font class="comment">/* May not have either _'s or uppercase letter */</font>
00528           cstring name = <a class="code" href="uentry_c.html#a194">uentry_rawName</a> (ue);
00529           <font class="keywordtype">int</font> charno = 1;
00530 
00531           cstring_chars (name, c)<font class="keyword"></font>
00532 <font class="keyword">            </font>{
00533               <font class="keywordflow">if</font> (isupper ((<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>) c))
00534                 {
00535                   <font class="keywordflow">if</font> (optgenerror
00536                       (FLG_CZECHOSLOVAKTYPES,
00537                        message
00538                        (<font class="stringliteral">"%s %q name violates Czechoslovak naming convention.  "</font>
00539                         <font class="stringliteral">"Czechoslovak datatype names should not use uppercase "</font>
00540                         <font class="stringliteral">"letters."</font>,
00541                         <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00542                         <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
00543                        <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00544                     {
00545                       <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00546                     }
00547                   <font class="keywordflow">break</font>;
00548                 }
00549 
00550               <font class="keywordflow">if</font> (c == <font class="charliteral">'_'</font> &amp;&amp; charno != 2 &amp;&amp; charno != 3)
00551                 {
00552                   <font class="keywordflow">if</font> (optgenerror
00553                       (FLG_CZECHOSLOVAKTYPES,
00554                        <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q name violates Czechoslovak naming "</font>
00555                                 <font class="stringliteral">"convention.  Czechoslovak datatype names "</font>
00556                                 <font class="stringliteral">"should not use the _ charater."</font>,
00557                                 uentry_ekindName (ue),
00558                                 <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
00559                        <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00560                     {
00561                       <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00562                     }
00563                   <font class="keywordflow">break</font>;
00564                 }
00565               
00566               charno++;
00567             } end_cstring_chars;
00568         }
00569       <font class="keywordflow">else</font>
00570         {
00571           <font class="keywordtype">bool</font> okay = checkCzechName (ue, czechflag, FALSE);
00572           
00573           <font class="comment">/* still need to call, to set access */</font>
00574           okay |= checkSlovakName (ue, slovakflag, FALSE);
00575           
00576           <font class="keywordflow">if</font> (!okay)
00577             {
00578               <font class="keywordflow">if</font> (optgenerror
00579                   (czechoslovakflag,
00580                    <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q name is not consistent with Czechoslovak "</font>
00581                             <font class="stringliteral">"naming convention."</font>,
00582                             uentry_ekindName (ue),
00583                             <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
00584                    <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00585                 {
00586                   <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00587                 }
00588             }
00589         }
00590     }
00591 }
00592 
00593 <font class="keyword">static</font> <font class="keywordtype">bool</font> checkCzechName (uentry ue, flagcode czechflag, <font class="keywordtype">bool</font> report)<font class="keyword"></font>
00594 <font class="keyword"></font>{
00595   <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (ue))
00596     {
00597       <font class="comment">/*</font>
00598 <font class="comment">      ** Czech datatypes may not have _'s, except if there are 1 or 2 characters</font>
00599 <font class="comment">      ** before the only _.</font>
00600 <font class="comment">      */</font>
00601 
00602       cstring name = <a class="code" href="uentry_c.html#a194">uentry_rawName</a> (ue);
00603       <font class="keywordtype">int</font> charno = 1;
00604       
00605       cstring_chars (name, c)<font class="keyword"></font>
00606 <font class="keyword">        </font>{
00607           <font class="keywordflow">if</font> (c == <font class="charliteral">'_'</font> &amp;&amp; charno != 2 &amp;&amp; charno != 3)
00608             {
00609               <font class="keywordflow">if</font> (report)
00610                 {
00611                   <font class="keywordflow">if</font> (optgenerror
00612                       (FLG_CZECHTYPES,
00613                        message 
00614                        (<font class="stringliteral">"%s %q name violates Czech naming convention.  "</font>
00615                         <font class="stringliteral">"Czech datatype names should not use the _ charater."</font>,
00616                         <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00617                         <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
00618                        <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00619                     {
00620                       <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00621                     }
00622                 }
00623 
00624               <font class="keywordflow">return</font> FALSE;
00625             }
00626           
00627           charno++;
00628         } end_cstring_chars;
00629     }
00630   <font class="keywordflow">else</font>
00631     {
00632       typeIdSet acc = <a class="code" href="context_c.html#a59">context_fileAccessTypes</a> ();
00633       cstring pfx = czechPrefix (uentry_rawName (ue));
00634 
00635       <font class="keywordflow">if</font> (cstring_isEmpty (pfx))
00636         {
00637           <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a159">uentry_isVariable</a> (ue) || uentry_isConstant (ue))
00638             {
00639               ctype ct = <a class="code" href="uentry_c.html#a197">uentry_getType</a> (ue);
00640               
00641               <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a33">ctype_isAbstract</a> (ct)
00642                   &amp;&amp; <a class="code" href="context_c.html#a112">context_hasAccess</a> (ctype_typeId (ct)))
00643                 {
00644                   <font class="keywordflow">if</font> (report)
00645                     {
00646                       <font class="keywordflow">if</font> (optgenerror
00647                           (czechflag,
00648                            <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q name is not consistent with Czech "</font>
00649                                     <font class="stringliteral">"naming convention.  The name should "</font>
00650                                     <font class="stringliteral">"begin with %s_"</font>,
00651                                     uentry_ekindName (ue),
00652                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00653                                     <a class="code" href="ctype_c.html#a107">ctype_unparse</a> (ct)),
00654                            <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00655                         {
00656                           <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00657                         }
00658                     }
00659 
00660                   <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00661                   <font class="keywordflow">return</font> FALSE;
00662                 }
00663             }
00664           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (uentry_isFunction (ue) || <a class="code" href="uentry_c.html#a184">uentry_isIter</a> (ue))
00665             {
00666               <font class="keywordflow">if</font> (<a class="code" href="typeIdSet_c.html#a16">typeIdSet_isEmpty</a> (acc))
00667                 {
00668                   ; <font class="comment">/* okay - should not be czech name */</font>
00669                 }
00670               <font class="keywordflow">else</font>
00671                 {
00672                   <font class="keywordflow">if</font> (report)
00673                     {
00674                       <font class="keywordflow">if</font> (optgenerror
00675                           (czechflag,
00676                            <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q name is not consistent with Czech "</font>
00677                                     <font class="stringliteral">"naming convention.  Accessible types: %q"</font>,
00678                                     uentry_ekindName (ue),
00679                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00680                                     <a class="code" href="typeIdSet_c.html#a21">typeIdSet_unparse</a> (acc)),
00681                            <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00682                         {
00683                           <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00684                         }
00685                     }
00686 
00687                   <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00688                   <font class="keywordflow">return</font> FALSE;
00689                 }
00690             }
00691           <font class="keywordflow">else</font>
00692             {
00693               ;
00694             }
00695         }
00696       <font class="keywordflow">else</font>
00697         {
00698           <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a130">usymtab_existsTypeEither</a> (pfx))
00699             {
00700               ctype ct = <a class="code" href="usymtab_c.html#a120">usymtab_lookupAbstractType</a> (pfx);
00701               typeId tid;
00702               
00703               <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a31">ctype_isUA</a> (ct))
00704                 {
00705                   tid = <a class="code" href="ctype_c.html#a105">ctype_typeId</a> (ct);
00706                   
00707                   <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a32">ctype_isUser</a> (ct) || <a class="code" href="context_c.html#a112">context_hasAccess</a> (tid))
00708                     {
00709                       ;
00710                     }
00711                   <font class="keywordflow">else</font>
00712                     {
00713                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECH)
00714                           || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECHOSLOVAK))
00715                         {
00716                           <font class="keywordflow">if</font> (!<a class="code" href="uentry_c.html#a161">uentry_isVar</a> (ue))
00717                             {
00718                               <a class="code" href="uentry_c.html#a102">uentry_addAccessType</a> (ue, tid);
00719                             }
00720                         }
00721                       <font class="keywordflow">else</font>
00722                         {
00723                           <font class="keywordflow">if</font> (report)
00724                             {
00725                               <font class="keywordflow">if</font> (llgenhinterror
00726                                   (czechflag,
00727                                    message 
00728                                    (<font class="stringliteral">"%s %q name violates Czech naming "</font>
00729                                     <font class="stringliteral">"convention. Czech prefix %s names "</font>
00730                                     <font class="stringliteral">"an abstract type that is "</font>
00731                                     <font class="stringliteral">"not accessible."</font>,
00732                                     <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00733                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00734                                     pfx),
00735                                    cstring_makeLiteral 
00736                                    (<font class="stringliteral">"Use +accessczech to allow access to "</font>
00737                                     <font class="stringliteral">"type &lt;t&gt; in functions "</font>
00738                                     <font class="stringliteral">"named &lt;t&gt;_&lt;name&gt;."</font>), 
00739                                    <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00740                                 {
00741                                   <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00742                                 }
00743                             }
00744                           
00745                           <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00746                           <font class="keywordflow">return</font> FALSE;
00747                         }
00748                     }
00749                 }
00750               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a61">ctype_isManifestBool</a> (ct))
00751                 {
00752                   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a137">context_canAccessBool</a> ())
00753                     {
00754                       ;
00755                     }
00756                   <font class="keywordflow">else</font>
00757                     {
00758                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECH)
00759                           || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECHOSLOVAK))
00760                         {
00761                           <font class="keywordflow">if</font> (!<a class="code" href="uentry_c.html#a161">uentry_isVar</a> (ue))
00762                             {
00763                               tid = <a class="code" href="usymtab_c.html#a64">usymtab_getTypeId</a> (context_getBoolName ());
00764                               <a class="code" href="uentry_c.html#a102">uentry_addAccessType</a> (ue, tid);
00765                             }
00766                         }
00767                       <font class="keywordflow">else</font>
00768                         {
00769                           <font class="keywordflow">if</font> (report)
00770                             {
00771                               <font class="keywordflow">if</font> (llgenhinterror
00772                                   (czechflag,
00773                                    message
00774                                    (<font class="stringliteral">"%s %q name violates Czech naming "</font>
00775                                     <font class="stringliteral">"convention. Type bool is not accessible."</font>,
00776                                     <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00777                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
00778                                    cstring_makeLiteral 
00779                                    (<font class="stringliteral">"Use +accessczech to allow access to "</font>
00780                                     <font class="stringliteral">"type &lt;t&gt; in functions named &lt;t&gt;_&lt;name&gt;."</font>), 
00781                                    <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00782                                 {
00783                                   <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00784                                 }
00785                             }
00786                           
00787                           <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00788                           <font class="keywordflow">return</font> FALSE;
00789                         }
00790                     }
00791                 }
00792               <font class="keywordflow">else</font>
00793                 {
00794                   ;
00795                 }
00796             }
00797           <font class="keywordflow">else</font>
00798             {
00799               <font class="keywordflow">if</font> (cstring_equalLit (pfx, <font class="stringliteral">"int"</font>)
00800                   || cstring_equalLit (pfx, <font class="stringliteral">"char"</font>)
00801                   || cstring_equalLit (pfx, <font class="stringliteral">"short"</font>)
00802                   || cstring_equalLit (pfx, <font class="stringliteral">"long"</font>)
00803                   || cstring_equalLit (pfx, <font class="stringliteral">"unsigned"</font>)
00804                   || cstring_equalLit (pfx, <font class="stringliteral">"signed"</font>)
00805                   || cstring_equalLit (pfx, <font class="stringliteral">"float"</font>)
00806                   || cstring_equalLit (pfx, <font class="stringliteral">"double"</font>))
00807                 {
00808                   ; <font class="comment">/* built-in types */</font>
00809                 }
00810               <font class="keywordflow">else</font>
00811                 {
00812                   <font class="comment">/* no accessible types, could match module name */</font>
00813                   
00814                   <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (pfx, context_moduleName ()))
00815                     {
00816                       ;
00817                     }
00818                   <font class="keywordflow">else</font>
00819                     {
00820                       <font class="keywordflow">if</font> (report)
00821                         {
00822                           <font class="keywordflow">if</font> (optgenerror
00823                               (czechflag,
00824                                message 
00825                                (<font class="stringliteral">"%s %q name violates Czech naming convention.  "</font>
00826                                 <font class="stringliteral">"Czech prefix %s is not the name of a type."</font>,
00827                                 <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00828                                 <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00829                                 pfx),
00830                                <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00831                             {
00832                               <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00833                             }
00834                         }
00835 
00836                       <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);                     
00837                       <font class="keywordflow">return</font> FALSE;
00838                     }
00839                 }
00840             }
00841         }
00842       <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00843     }
00844 
00845   <font class="keywordflow">return</font> TRUE;
00846 }
00847 
00848 <font class="keyword">static</font> <font class="keywordtype">bool</font> checkSlovakName (uentry ue, flagcode slovakflag, <font class="keywordtype">bool</font> report)<font class="keyword"></font>
00849 <font class="keyword"></font>{
00850   <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (ue))
00851     {
00852       <font class="comment">/*</font>
00853 <font class="comment">      ** Slovak datatypes may not have uppercase letters.</font>
00854 <font class="comment">      */</font>
00855 
00856       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_SLOVAK))
00857         {
00858           cstring name = <a class="code" href="uentry_c.html#a194">uentry_rawName</a> (ue);
00859 
00860           cstring_chars (name, c)<font class="keyword"></font>
00861 <font class="keyword">            </font>{
00862               <font class="keywordflow">if</font> (isupper ((<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>) c))
00863                 {
00864                   <font class="keywordflow">if</font> (report)
00865                     {
00866                       <font class="keywordflow">if</font> (optgenerror
00867                           (FLG_SLOVAKTYPES,
00868                            message 
00869                            (<font class="stringliteral">"%s %q name violates Slovak naming convention.  "</font>
00870                             <font class="stringliteral">"Slovak datatype names should not use uppercase "</font>
00871                             <font class="stringliteral">"letters."</font>,
00872                             <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00873                             <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
00874                            <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00875                         {
00876                           <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00877                         }
00878                     }
00879                   <font class="keywordflow">return</font> FALSE;
00880                 }
00881             } end_cstring_chars;
00882         }
00883     }
00884   <font class="keywordflow">else</font>
00885     {
00886       typeIdSet acc = <a class="code" href="context_c.html#a59">context_fileAccessTypes</a> ();
00887       cstring pfx = slovakPrefix (uentry_rawName (ue));
00888       
00889       <font class="keywordflow">if</font> (cstring_isEmpty (pfx))
00890         {
00891           <font class="keywordflow">if</font> (<a class="code" href="typeIdSet_c.html#a16">typeIdSet_isEmpty</a> (acc))
00892             {
00893               ; <font class="comment">/* okay - should not be slovak name */</font>
00894             }
00895           <font class="keywordflow">else</font>
00896             {
00897               <font class="keywordflow">if</font> (uentry_isFunction (ue))
00898                 {
00899                   <font class="keywordflow">if</font> (report)
00900                     {
00901                       <font class="keywordflow">if</font> (optgenerror
00902                           (slovakflag,
00903                            <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q name is not consistent with Slovak "</font>
00904                                     <font class="stringliteral">"naming convention.  Accessible types: %q"</font>,
00905                                     uentry_ekindName (ue),
00906                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00907                                     <a class="code" href="typeIdSet_c.html#a21">typeIdSet_unparse</a> (acc)),
00908                            <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00909                         {
00910                           <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00911                         }
00912                     }
00913                   
00914                   <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00915                   <font class="keywordflow">return</font> FALSE;
00916                 }
00917               <font class="keywordflow">else</font>
00918                 {
00919                   ctype ct = <a class="code" href="uentry_c.html#a197">uentry_getType</a> (ue);
00920                   
00921                   <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a31">ctype_isUA</a> (ct))
00922                     {
00923                       <font class="keywordflow">if</font> (report)
00924                         {
00925                           <font class="keywordflow">if</font> (optgenerror
00926                               (slovakflag,
00927                                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q name is not consistent with "</font>
00928                                         <font class="stringliteral">"Slovak naming convention.  The "</font>
00929                                         <font class="stringliteral">"name should begin with %s followed "</font>
00930                                         <font class="stringliteral">"by an uppercase letter."</font>,
00931                                         uentry_ekindName (ue),
00932                                         <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00933                                         <a class="code" href="ctype_c.html#a107">ctype_unparse</a> (ct)),
00934                                <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00935                             {
00936                               <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00937                             }   
00938                         }
00939                       
00940                       <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00941                       <font class="keywordflow">return</font> FALSE;
00942                     }
00943                 }
00944             }
00945         }
00946       <font class="keywordflow">else</font>
00947         {
00948           <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a130">usymtab_existsTypeEither</a> (pfx))
00949             {
00950               ctype ct = <a class="code" href="usymtab_c.html#a120">usymtab_lookupAbstractType</a> (pfx);
00951               typeId tid;
00952               
00953               <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a31">ctype_isUA</a> (ct))
00954                 {
00955                   tid = <a class="code" href="ctype_c.html#a105">ctype_typeId</a> (ct);
00956                   
00957                   <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a32">ctype_isUser</a> (ct) || <a class="code" href="context_c.html#a112">context_hasAccess</a> (tid))
00958                     {
00959                       ;
00960                     }
00961                   <font class="keywordflow">else</font>
00962                     {
00963                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSSLOVAK)
00964                           || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECHOSLOVAK))
00965                         {
00966                           <font class="keywordflow">if</font> (!<a class="code" href="uentry_c.html#a161">uentry_isVar</a> (ue))
00967                             {
00968                               <a class="code" href="uentry_c.html#a102">uentry_addAccessType</a> (ue, tid);
00969                             }
00970                         }
00971                       <font class="keywordflow">else</font>
00972                         {
00973                           <font class="keywordflow">if</font> (report)
00974                             {
00975                               <font class="keywordflow">if</font> (llgenhinterror
00976                                   (slovakflag,
00977                                    message 
00978                                    (<font class="stringliteral">"%s %q name violates Slovak naming "</font>
00979                                     <font class="stringliteral">"convention. Slovak prefix %s names "</font>
00980                                     <font class="stringliteral">"an abstract type that is not accessible."</font>,
00981                                     <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
00982                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
00983                                     pfx),
00984                                    cstring_makeLiteral 
00985                                    (<font class="stringliteral">"Use +accessslovak to allow access to "</font>
00986                                     <font class="stringliteral">"type &lt;t&gt; in functions named &lt;t&gt;_&lt;name&gt;."</font>), 
00987                                    <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
00988                                 {
00989                                   <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
00990                                 }
00991                             }
00992                           
00993                           <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
00994                           <font class="keywordflow">return</font> FALSE;
00995                         }
00996                     }
00997                 }
00998               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a61">ctype_isManifestBool</a> (ct))
00999                 {
01000                   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a137">context_canAccessBool</a> ())
01001                     {
01002                       ;
01003                     }
01004                   <font class="keywordflow">else</font>
01005                     {
01006                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSSLOVAK)
01007                           || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_ACCESSCZECHOSLOVAK))
01008                         {
01009                           <font class="keywordflow">if</font> (!<a class="code" href="uentry_c.html#a161">uentry_isVar</a> (ue))
01010                             {
01011                               tid = <a class="code" href="usymtab_c.html#a64">usymtab_getTypeId</a> (context_getBoolName ());
01012                               <a class="code" href="uentry_c.html#a102">uentry_addAccessType</a> (ue, tid);
01013                             }
01014                         }
01015                       <font class="keywordflow">else</font>
01016                         {
01017                           <font class="keywordflow">if</font> (report)
01018                             {
01019                               <font class="keywordflow">if</font> (llgenhinterror
01020                                   (slovakflag,
01021                                    message
01022                                    (<font class="stringliteral">"%s %q name violates Slovak naming convention.  "</font>
01023                                     <font class="stringliteral">"Type bool is not accessible."</font>,
01024                                     <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
01025                                     <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue)),
01026                                    cstring_makeLiteral
01027                                    (<font class="stringliteral">"Use +accessslovak to allow access to "</font>
01028                                     <font class="stringliteral">"type &lt;t&gt; in functions named &lt;t&gt;_&lt;name&gt;."</font>),
01029                                    <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
01030                                 {
01031                                   <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
01032                                 }
01033                             }
01034                           
01035                           <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
01036                           <font class="keywordflow">return</font> FALSE;
01037                         }
01038                     }
01039                 }
01040               <font class="keywordflow">else</font>
01041                 {
01042                   ;
01043                 }
01044             }
01045           <font class="keywordflow">else</font>
01046             {
01047               <font class="keywordflow">if</font> (cstring_equalLit (pfx, <font class="stringliteral">"int"</font>)
01048                   || cstring_equalLit (pfx, <font class="stringliteral">"char"</font>)
01049                   || cstring_equalLit (pfx, <font class="stringliteral">"short"</font>)
01050                   || cstring_equalLit (pfx, <font class="stringliteral">"long"</font>)
01051                   || cstring_equalLit (pfx, <font class="stringliteral">"unsigned"</font>)
01052                   || cstring_equalLit (pfx, <font class="stringliteral">"signed"</font>)
01053                   || cstring_equalLit (pfx, <font class="stringliteral">"float"</font>)
01054                   || cstring_equalLit (pfx, <font class="stringliteral">"double"</font>))
01055                 {
01056                   ; <font class="comment">/* built-in types */</font>
01057                 }
01058               <font class="keywordflow">else</font>
01059                 {
01060                   <font class="comment">/* no accessible types, could match module name */</font>
01061                   
01062                   <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a18">cstring_equal</a> (pfx, context_moduleName ()))
01063                     {
01064                       ;
01065                     }
01066                   <font class="keywordflow">else</font>
01067                     {
01068                       <font class="keywordflow">if</font> (report)
01069                         {
01070                           <font class="keywordflow">if</font> (optgenerror
01071                               (slovakflag,
01072                                message 
01073                                (<font class="stringliteral">"%s %q name violates Slovak naming convention.  "</font>
01074                                 <font class="stringliteral">"Slovak prefix %s is not the name of a type."</font>,
01075                                 <a class="code" href="uentry_c.html#a282">uentry_ekindName</a> (ue),
01076                                 <a class="code" href="uentry_c.html#a195">uentry_getName</a> (ue),
01077                                 pfx),
01078                                <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (ue)))
01079                             {
01080                               <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (ue);
01081                             }
01082                         }
01083 
01084                       <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
01085                       <font class="keywordflow">return</font> FALSE;
01086                     }
01087                 }
01088             }
01089         }
01090 
01091       <a class="code" href="cstring_c.html#a27">cstring_free</a> (pfx);
01092     }
01093 
01094   <font class="keywordflow">return</font> TRUE;
01095 }
01096 
01097 <font class="keywordtype">void</font>
<a name="l01098"></a><a class="code" href="nameChecks_c.html#a15">01098</a> <a class="code" href="nameChecks_c.html#a15">checkGlobalName</a> (uentry ue)<font class="keyword"></font>
01099 <font class="keyword"></font>{
01100   <font class="keywordflow">if</font> (!uentry_isStatic (ue) &amp;&amp; <a class="code" href="uentry_c.html#a187">uentry_hasName</a> (ue))
01101     {
01102       checkNationalName (ue);
01103     }
01104   <font class="keywordflow">else</font>
01105     {
01106       ;
01107     }
01108 }
01109 
01110 <font class="keywordtype">void</font>
<a name="l01111"></a><a class="code" href="nameChecks_c.html#a16">01111</a> <a class="code" href="nameChecks_c.html#a16">checkLocalName</a> (<font class="comment">/*@unused@*/</font> uentry ue)<font class="keyword"></font>
01112 <font class="keyword"></font>{
01113   ;
01114 }
01115 
01116 <font class="comment">/*</font>
01117 <font class="comment">** Checks a name used by user source is not reserved by ANSI </font>
01118 <font class="comment">** (or for future library functions).</font>
01119 <font class="comment">**</font>
01120 <font class="comment">** The restrictions are described in X3.159-1989: 4.13</font>
01121 <font class="comment">*/</font>
01122 
01123 <font class="comment">/*@constant int NRESERVEDNAMES; @*/</font>
<a name="l01124"></a><a class="code" href="nameChecks_c.html#a2">01124</a> <font class="preprocessor"># define NRESERVEDNAMES 201</font>
01125 <font class="preprocessor"></font>
01126 <font class="comment">/*@constant int NCPPNAMES@*/</font>
<a name="l01127"></a><a class="code" href="nameChecks_c.html#a3">01127</a> <font class="preprocessor"># define NCPPNAMES 39</font>
01128 <font class="preprocessor"></font>
<a name="l01129"></a><a class="code" href="nameChecks_c.html#a17">01129</a> <font class="keywordtype">bool</font> <a class="code" href="nameChecks_c.html#a17">checkCppName</a> (cstring name, fileloc loc)<font class="keyword"></font>
01130 <font class="keyword"></font>{
01131   <font class="keyword">static</font> ob_mstring cppNames[NCPPNAMES] =
01132     {
01133       <font class="stringliteral">"and"</font>, <font class="stringliteral">"and_eq"</font>, <font class="stringliteral">"asm"</font>, 
01134       <font class="stringliteral">"bitand"</font>, <font class="stringliteral">"bitor"</font>, <font class="stringliteral">"bool"</font>, <font class="comment">/* gasp: "bool", is special for lclint */</font>
01135       <font class="stringliteral">"catch"</font>, <font class="stringliteral">"class"</font>, <font class="stringliteral">"compl"</font>, <font class="stringliteral">"const_class"</font>,
01136       <font class="stringliteral">"delete"</font>, <font class="stringliteral">"dynamic_cast"</font>, <font class="stringliteral">"false"</font>, <font class="stringliteral">"friend"</font>,
01137       <font class="stringliteral">"inline"</font>, <font class="stringliteral">"mutable"</font>, <font class="stringliteral">"namespace"</font>, <font class="stringliteral">"new"</font>,
01138       <font class="stringliteral">"not"</font>, <font class="stringliteral">"not_eq"</font>,
01139       <font class="stringliteral">"operator"</font>, <font class="stringliteral">"or"</font>, <font class="stringliteral">"or_eq"</font>, <font class="stringliteral">"overload"</font>,
01140       <font class="stringliteral">"private"</font>, <font class="stringliteral">"protected"</font>, <font class="stringliteral">"public"</font>,
01141       <font class="stringliteral">"reinterpret_cast"</font>, <font class="stringliteral">"static_cast"</font>,
01142       <font class="stringliteral">"template"</font>, <font class="stringliteral">"this"</font>, <font class="stringliteral">"throw"</font>, <font class="stringliteral">"true"</font>, <font class="stringliteral">"try"</font>,
01143       <font class="stringliteral">"typeid"</font>, <font class="stringliteral">"using"</font>, <font class="stringliteral">"virtual"</font>, <font class="stringliteral">"xor"</font>, <font class="stringliteral">"xor_eq"</font>
01144       } ;
01145   
01146   <font class="keywordflow">if</font> (cstring_isDefined (cstring_bsearch (name, &amp;cppNames[0],
01147                                           NCPPNAMES)))
01148     {
01149       <font class="keywordflow">return</font> (optgenerror
01150               (FLG_CPPNAMES,
01151                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Name %s is a keyword or reserved word in C++"</font>,
01152                         name),
01153                loc));
01154     }
01155 
01156   <font class="keywordflow">return</font> FALSE;
01157 }
01158 
01159 <font class="keywordtype">bool</font>
<a name="l01160"></a><a class="code" href="nameChecks_c.html#a18">01160</a> <a class="code" href="nameChecks_c.html#a18">checkAnsiName</a> (cstring name, fileloc loc)<font class="keyword"></font>
01161 <font class="keyword"></font>{
01162   <font class="keywordtype">bool</font> hasError = FALSE;
01163   <font class="keywordtype">int</font> length = <a class="code" href="cstring_c.html#a30">cstring_length</a> (name);
01164   <font class="keywordtype">char</font> fchar = (length &gt;= 1) ? <a class="code" href="cstring_c.html#a1">cstring_firstChar</a> (name) : <font class="charliteral">'\0'</font>;
01165   <font class="keywordtype">char</font> schar = (length &gt;= 2) ? cstring_secondChar (name) : <font class="charliteral">'\0'</font>;
01166   <font class="keywordtype">char</font> tchar = (length &gt;= 3) ? <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (name, 3) : <font class="charliteral">'\0'</font>;
01167   <font class="keywordtype">char</font> rchar = (length &gt;= 4) ? <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (name, 4) : <font class="charliteral">'\0'</font>;
01168 
01169   <font class="comment">/* </font>
01170 <font class="comment">  ** reservedNames</font>
01171 <font class="comment">  **   taken from Linden, "Expert C Programming", p. 126-8. </font>
01172 <font class="comment">  **   invariant:  must be sorted (case-insensitive, lexicographically)</font>
01173 <font class="comment">  **               must end with NULL</font>
01174 <font class="comment">  */</font>
01175 
01176   <font class="keyword">static</font> ob_mstring reservedNames[NRESERVEDNAMES] =
01177     { 
01178 <font class="preprocessor"># include "reservedNames.nf"</font>
01179     } ;
01180 
01181   <font class="keywordflow">if</font> (<a class="code" href="fileloc_c.html#a20">fileloc_isSystemFile</a> (loc) || fileloc_isBuiltin (loc))
01182     {
01183       <font class="keywordflow">return</font> FALSE;  <font class="comment">/* no errors for system files */</font>
01184     }
01185 
01186 <font class="preprocessor"># if 0</font>
01187 <font class="preprocessor"></font>  {
01188     <font class="keywordtype">int</font> i = 0;
01189     <font class="keywordtype">char</font> *lastname = NULL;
01190     <font class="keywordtype">char</font> *name;
01191     
01192     <font class="keywordflow">while</font> ((name = reservedNames[i]) != NULL)
01193       {
01194         llassertprint (lastname == NULL
01195                        || strcmp (name, lastname) &gt; 0,
01196                        (<font class="stringliteral">"%s / %s"</font>, lastname, name));
01197         lastname = name;
01198         i++;
01199       }
01200     
01201     nreservedNames = i - 1;
01202   }
01203 <font class="preprocessor"># endif</font>
01204 <font class="preprocessor"></font>  
01205   <font class="keywordflow">if</font> (cstring_isDefined (cstring_bsearch (name, &amp;reservedNames[0],
01206                                           NRESERVEDNAMES)))
01207     {
01208       <font class="keywordflow">return</font> (optgenerror
01209               (FLG_ANSIRESERVED,
01210                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Name %s is reserved for the standard library"</font>,
01211                         name),
01212                loc));
01213     }
01214 
01215   <font class="keywordflow">if</font> (fchar == <font class="charliteral">'_'</font>)
01216     {
01217       hasError = optgenerror
01218         (FLG_ANSIRESERVED,
01219          message 
01220          (<font class="stringliteral">"Name %s is in the implementation name space (any identifier "</font>
01221           <font class="stringliteral">"beginning with underscore)"</font>, 
01222           name),
01223          loc);
01224     }
01225 
01226   <font class="comment">/*</font>
01227 <font class="comment">  ** 4.13.1 Errors &lt;errno.h&gt;</font>
01228 <font class="comment">  **</font>
01229 <font class="comment">  ** Macros that begin with E and a digit or E and an uppercase letter ...</font>
01230 <font class="comment">  */</font>
01231 
01232   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (fchar == <font class="charliteral">'E'</font> &amp;&amp; (isdigit ((<font class="keywordtype">int</font>) schar) 
01233                             || isupper ((<font class="keywordtype">int</font>) schar)))
01234     {
01235       hasError = optgenerror
01236         (FLG_ANSIRESERVED,
01237          message 
01238          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions. "</font>
01239           <font class="stringliteral">"Macros beginning with E and a digit or uppercase letter "</font>
01240           <font class="stringliteral">"may be added to &lt;errno.h&gt;. (See ANSI, Section 4.13.1)"</font>,
01241           name),
01242          loc);
01243     }
01244   
01245   <font class="comment">/*</font>
01246 <font class="comment">  ** 4.13.2 Character Handling &lt;ctype.h&gt;</font>
01247 <font class="comment">  **</font>
01248 <font class="comment">  ** Function names that begin with either "is" or "to" and a lowercase letter ...</font>
01249 <font class="comment">  */</font>
01250 
01251   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (((fchar == <font class="charliteral">'i'</font> &amp;&amp; schar == <font class="charliteral">'s'</font>) 
01252             || (fchar == <font class="charliteral">'t'</font> &amp;&amp; schar == <font class="charliteral">'o'</font>))
01253            &amp;&amp; (islower ((<font class="keywordtype">int</font>) tchar)))
01254     {
01255       hasError = optgenerror
01256         (FLG_ANSIRESERVED,
01257          message
01258          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions.  "</font>
01259           <font class="stringliteral">"Functions beginning with \"is\" or \"to\" and a lowercase "</font>
01260           <font class="stringliteral">"letter may be added to &lt;ctype.h&gt;. (See ANSI, Section 4.13.2)"</font>,
01261           name),
01262          loc);
01263     }
01264   
01265   <font class="comment">/*</font>
01266 <font class="comment">  ** 4.13.3 Localization &lt;locale.h&gt;</font>
01267 <font class="comment">  **</font>
01268 <font class="comment">  ** Macros that begin with LC_ and an uppercase letter ...</font>
01269 <font class="comment">  */</font>
01270 
01271   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (length &gt;= 4 
01272            &amp;&amp; ((fchar == <font class="charliteral">'L'</font>)
01273                &amp;&amp; (schar == <font class="charliteral">'C'</font>)
01274                &amp;&amp; (tchar == <font class="charliteral">'_'</font>))
01275            &amp;&amp; (isupper ((<font class="keywordtype">int</font>) rchar)))
01276     {
01277       hasError = optgenerror
01278         (FLG_ANSIRESERVED,
01279          message
01280          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions.  "</font>
01281           <font class="stringliteral">"Macros beginning with \"LC_\" and an uppercase letter may "</font>
01282           <font class="stringliteral">"be added to &lt;locale.h&gt;. (See ANSI, Section 4.13.3)"</font>,
01283           name),
01284          loc);
01285     }
01286   
01287   <font class="comment">/*</font>
01288 <font class="comment">  ** 4.13.4 Mathematics &lt;math.h&gt;</font>
01289 <font class="comment">  **</font>
01290 <font class="comment">  ** The names of all existing functions declared in the &lt;math.h&gt; header, </font>
01291 <font class="comment">  ** suffixed with f or l...</font>
01292 <font class="comment">  */</font>
01293 
01294   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((<a class="code" href="cstring_c.html#a8">cstring_lastChar</a> (name) == <font class="charliteral">'f'</font> || <a class="code" href="cstring_c.html#a8">cstring_lastChar</a> (name) == <font class="charliteral">'l'</font>)
01295            &amp;&amp; 
01296            (((length == 4)
01297              &amp;&amp; ((<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"cos"</font>) ||
01298                   <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"sin"</font>) ||
01299                   <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"tan"</font>) ||
01300                   <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"exp"</font>) ||
01301                   <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"log"</font>) ||
01302                   <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"pow"</font>))))
01303             || ((length == 5)
01304                 &amp;&amp; ((<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"acos"</font>) ||
01305                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"asin"</font>) ||
01306                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"atan"</font>) ||
01307                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"cosh"</font>) ||
01308                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"sinh"</font>) ||
01309                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"sqrt"</font>) ||
01310                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"ceil"</font>) ||
01311                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"fabs"</font>) ||
01312                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"fmod"</font>) ||
01313                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"tanh"</font>) ||
01314                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"modf"</font>))))
01315             || ((length == 6)
01316                 &amp;&amp; ((<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"atan2"</font>) ||
01317                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"floor"</font>) ||
01318                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"frexp"</font>) ||
01319                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"ldexp"</font>) ||
01320                      <a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (name, <font class="stringliteral">"log10"</font>))))))
01321     {
01322       hasError = optgenerror
01323         (FLG_ANSIRESERVED,
01324          message
01325          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions.  "</font>
01326           <font class="stringliteral">"The names of all existing functions in &lt;math.h&gt; suffixed "</font>
01327           <font class="stringliteral">"with 'f' or 'l' may be added to &lt;math.h&gt;. (See ANSI, Section 4.13.4)"</font>,
01328           name),
01329          loc);
01330     }
01331   
01332   <font class="comment">/*</font>
01333 <font class="comment">  ** 4.13.5 Signal Handling &lt;signal.h&gt;</font>
01334 <font class="comment">  **</font>
01335 <font class="comment">  ** Macros that begin with either SIG or SIG_ and an uppercase letter or...</font>
01336 <font class="comment">  */</font>
01337 
01338   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (fchar == <font class="charliteral">'S'</font> &amp;&amp; schar == <font class="charliteral">'I'</font> &amp;&amp; tchar == <font class="charliteral">'G'</font>
01339            &amp;&amp; ((rchar == <font class="charliteral">'_'</font> &amp;&amp; ((length &gt;= 5 
01340                                   &amp;&amp; isupper ((<font class="keywordtype">int</font>) <a class="code" href="cstring_c.html#a2">cstring_getChar</a> (name, 5)))))
01341                || (isupper ((<font class="keywordtype">int</font>) rchar))))
01342     {
01343       hasError = optgenerror
01344         (FLG_ANSIRESERVED,
01345          message
01346          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions.  "</font>
01347           <font class="stringliteral">"Macros that begin with SIG and an uppercase letter or SIG_ "</font>
01348           <font class="stringliteral">"and an uppercase letter may be added to "</font>
01349           <font class="stringliteral">"&lt;signal.h&gt;. (See ANSI, Section 4.13.5)"</font>,
01350           name),
01351          loc);
01352     }
01353   
01354   <font class="comment">/*</font>
01355 <font class="comment">  ** 4.13.6 Input/Output &lt;stdio.h&gt;</font>
01356 <font class="comment">  **</font>
01357 <font class="comment">  ** (nothing to check)</font>
01358 <font class="comment">  */</font>
01359 
01360   <font class="comment">/*</font>
01361 <font class="comment">  ** 4.13.7 General Utilities &lt;stdlib.h&gt;</font>
01362 <font class="comment">  **</font>
01363 <font class="comment">  ** Functions names that begin with str and a lowercase letter may be added to &lt;stdlib.h&gt;.</font>
01364 <font class="comment">  */</font>
01365 
01366   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (fchar == <font class="charliteral">'s'</font> &amp;&amp; schar == <font class="charliteral">'t'</font> &amp;&amp; tchar == <font class="charliteral">'r'</font> 
01367            &amp;&amp; (islower ((<font class="keywordtype">int</font>) rchar)))
01368     {
01369       hasError = optgenerror
01370         (FLG_ANSIRESERVED,
01371          message
01372          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions.  "</font>
01373           <font class="stringliteral">"Functions that begin with \"str\" and a lowercase letter "</font>
01374           <font class="stringliteral">"may be added to &lt;stdlib.h&gt; or &lt;string.h&gt;. (See ANSI, Section 4.13.7)"</font>,
01375           name),
01376          loc);
01377     }
01378   
01379   <font class="comment">/*</font>
01380 <font class="comment">  ** 4.13.8 String Handling &lt;string.h&gt;</font>
01381 <font class="comment">  **</font>
01382 <font class="comment">  ** Function names that begin with str, mem, or wcs and a lowercase letter ...</font>
01383 <font class="comment">  **</font>
01384 <font class="comment">  ** (Note: already checked "str" above.)</font>
01385 <font class="comment">  */</font>
01386 
01387   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (((fchar == <font class="charliteral">'m'</font> &amp;&amp; schar == <font class="charliteral">'e'</font> &amp;&amp; tchar == <font class="charliteral">'m'</font>)
01388             || (fchar == <font class="charliteral">'w'</font> &amp;&amp; schar == <font class="charliteral">'c'</font> &amp;&amp; tchar == <font class="charliteral">'s'</font>))
01389            &amp;&amp; (islower ((<font class="keywordtype">int</font>) rchar)))
01390     {
01391       hasError = optgenerror
01392         (FLG_ANSIRESERVED,
01393          message
01394          (<font class="stringliteral">"Name %s is reserved for future ANSI library extensions.  "</font>
01395           <font class="stringliteral">"Functions that begin with \"mem\" or \"wcs\" and a "</font>
01396           <font class="stringliteral">"lowercase letter letter may be added to &lt;string.h&gt;. (See ANSI, Section 4.13.8)"</font>,
01397           name),
01398          loc);
01399     }
01400   <font class="keywordflow">else</font>
01401     {
01402       ;
01403     }
01404 
01405   <font class="keywordflow">return</font> hasError;
01406 }
01407 
<a name="l01408"></a><a class="code" href="nameChecks_c.html#a19">01408</a> <font class="keywordtype">void</font> <a class="code" href="nameChecks_c.html#a19">checkParamNames</a> (uentry ue)<font class="keyword"></font>
01409 <font class="keyword"></font>{
01410   cstring fpfx = <a class="code" href="context_c.html#a157">context_getString</a> (FLG_DECLPARAMPREFIX);
01411   <font class="keywordtype">bool</font> noformal = <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_DECLPARAMNAME);
01412 
01413   llassert (uentry_isFunction (ue));
01414   
01415   <font class="keywordflow">if</font> (cstring_isDefined (fpfx) || noformal)
01416     {
01417       uentryList params = <a class="code" href="uentry_c.html#a193">uentry_getParams</a> (ue);
01418       
01419       uentryList_elements (params, p)<font class="keyword"></font>
01420 <font class="keyword">        </font>{
01421           <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a187">uentry_hasName</a> (p))
01422             {
01423               <font class="keywordflow">if</font> (noformal &amp;&amp; !cstring_isDefined (fpfx))
01424                 {
01425                   <font class="keywordflow">if</font> (optgenerror
01426                       (FLG_DECLPARAMNAME, 
01427                        <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Declaration parameter has name: %q"</font>,
01428                                 uentry_getName (p)),
01429                        <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (p)))
01430                     {
01431                       <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (p);
01432                     }
01433                 }
01434               <font class="keywordflow">else</font>
01435                 {
01436                   cstring pname = <a class="code" href="uentry_c.html#a195">uentry_getName</a> (p);
01437                   
01438                   <font class="keywordflow">if</font> (!<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (pname, cstring_toCharsSafe (fpfx)))
01439                     {
01440                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NAMECHECKS))
01441                         {
01442                           <font class="keywordflow">if</font> (optgenerror
01443                               (FLG_DECLPARAMPREFIX, 
01444                                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Declaration parameter name %s does not begin "</font>
01445                                         <font class="stringliteral">"with protoparamprefix (%s)"</font>,
01446                                         pname, fpfx),
01447                                <a class="code" href="uentry_c.html#a198">uentry_whereLast</a> (p)))
01448                             {
01449                               <a class="code" href="uentry_c.html#a283">uentry_setHasNameError</a> (p);
01450                             }
01451                         }
01452                     }
01453                   <a class="code" href="cstring_c.html#a27">cstring_free</a> (pname);
01454                 }
01455             }
01456         } end_uentryList_elements ;
01457     }
01458 }
01459 
01460 
01461 
01462 
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:43 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
