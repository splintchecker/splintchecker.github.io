<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>lex.yy.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:42 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>lex.yy.c</h1><a href="lex_yy_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/* A lexical scanner generated by flex */</font>
00002 
00003 <font class="comment">/* Scanner skeleton version:</font>
00004 <font class="comment"> * $Header: /home/ncvs/src/usr.bin/lex/skel.c,v 1.2 1996/12/14 05:48:48 steve Exp $</font>
00005 <font class="comment"> */</font>
00006 
<a name="l00007"></a><a class="code" href="lex_yy_c.html#a0">00007</a> <font class="preprocessor">#define FLEX_SCANNER</font>
<a name="l00008"></a><a class="code" href="lex_yy_c.html#a1">00008</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_FLEX_MAJOR_VERSION 2</font>
<a name="l00009"></a><a class="code" href="lex_yy_c.html#a2">00009</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_FLEX_MINOR_VERSION 5</font>
00010 <font class="preprocessor"></font>
00011 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00012 
00013 
00014 <font class="comment">/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */</font>
00015 <font class="preprocessor">#ifdef c_plusplus</font>
00016 <font class="preprocessor"></font><font class="preprocessor">#ifndef __cplusplus</font>
00017 <font class="preprocessor"></font><font class="preprocessor">#define __cplusplus</font>
00018 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00019 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00020 <font class="preprocessor"></font>
00021 
00022 <font class="preprocessor">#ifdef __cplusplus</font>
00023 <font class="preprocessor"></font>
00024 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00025 <font class="preprocessor">#include &lt;unistd.h&gt;</font>
00026 
00027 <font class="comment">/* Use prototypes in function declarations. */</font>
00028 <font class="preprocessor">#define YY_USE_PROTOS</font>
00029 <font class="preprocessor"></font>
00030 <font class="comment">/* The "const" storage-class-modifier is valid. */</font>
00031 <font class="preprocessor">#define YY_USE_CONST</font>
00032 <font class="preprocessor"></font>
00033 <font class="preprocessor">#else   </font><font class="comment">/* ! __cplusplus */</font>
00034 
00035 <font class="preprocessor">#if __STDC__</font>
00036 <font class="preprocessor"></font>
00037 <font class="preprocessor">#define YY_USE_PROTOS</font>
00038 <font class="preprocessor"></font><font class="preprocessor">#define YY_USE_CONST</font>
00039 <font class="preprocessor"></font>
00040 <font class="preprocessor">#endif  </font><font class="comment">/* __STDC__ */</font>
00041 <font class="preprocessor">#endif  </font><font class="comment">/* ! __cplusplus */</font>
00042 
00043 <font class="preprocessor">#ifdef __TURBOC__</font>
00044 <font class="preprocessor"></font><font class="preprocessor"> #pragma warn -rch</font>
00045 <font class="preprocessor"></font><font class="preprocessor"> #pragma warn -use</font>
00046 <font class="preprocessor"></font><font class="preprocessor">#include &lt;io.h&gt;</font>
00047 <font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00048 <font class="preprocessor">#define YY_USE_CONST</font>
00049 <font class="preprocessor"></font><font class="preprocessor">#define YY_USE_PROTOS</font>
00050 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00051 <font class="preprocessor"></font>
00052 <font class="preprocessor">#ifdef YY_USE_CONST</font>
00053 <font class="preprocessor"></font><font class="preprocessor">#define yyconst const</font>
00054 <font class="preprocessor"></font><font class="preprocessor">#else</font>
<a name="l00055"></a><a class="code" href="lex_yy_c.html#a3">00055</a> <font class="preprocessor"></font><font class="preprocessor">#define yyconst</font>
00056 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00057 <font class="preprocessor"></font>
00058 
00059 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
00060 <font class="preprocessor"></font><font class="preprocessor">#define YY_PROTO(proto) proto</font>
00061 <font class="preprocessor"></font><font class="preprocessor">#else</font>
<a name="l00062"></a><a class="code" href="lex_yy_c.html#a4">00062</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_PROTO(proto) ()</font>
00063 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00064 <font class="preprocessor"></font>
00065 <font class="comment">/* Returned upon end-of-file. */</font>
<a name="l00066"></a><a class="code" href="lex_yy_c.html#a5">00066</a> <font class="preprocessor">#define YY_NULL 0</font>
00067 <font class="preprocessor"></font>
00068 <font class="comment">/* Promotes a possibly negative, possibly signed char to an unsigned</font>
00069 <font class="comment"> * integer for use as an array index.  If the signed char is negative,</font>
00070 <font class="comment"> * we want to instead treat it as an 8-bit unsigned char, hence the</font>
00071 <font class="comment"> * double cast.</font>
00072 <font class="comment"> */</font>
<a name="l00073"></a><a class="code" href="lex_yy_c.html#a6">00073</a> <font class="preprocessor">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</font>
00074 <font class="preprocessor"></font>
00075 <font class="comment">/* Enter a start condition.  This macro really ought to take a parameter,</font>
00076 <font class="comment"> * but we do it the disgusting crufty way forced on us by the ()-less</font>
00077 <font class="comment"> * definition of BEGIN.</font>
00078 <font class="comment"> */</font>
<a name="l00079"></a><a class="code" href="lex_yy_c.html#a7">00079</a> <font class="preprocessor">#define BEGIN yy_start = 1 + 2 *</font>
00080 <font class="preprocessor"></font>
00081 <font class="comment">/* Translate the current start state into a value that can be later handed</font>
00082 <font class="comment"> * to BEGIN to return to the state.  The YYSTATE alias is for lex</font>
00083 <font class="comment"> * compatibility.</font>
00084 <font class="comment"> */</font>
<a name="l00085"></a><a class="code" href="lex_yy_c.html#a8">00085</a> <font class="preprocessor">#define YY_START ((yy_start - 1) / 2)</font>
<a name="l00086"></a><a class="code" href="lex_yy_c.html#a9">00086</a> <font class="preprocessor"></font><font class="preprocessor">#define YYSTATE YY_START</font>
00087 <font class="preprocessor"></font>
00088 <font class="comment">/* Action number for EOF rule of a given start state. */</font>
<a name="l00089"></a><a class="code" href="lex_yy_c.html#a10">00089</a> <font class="preprocessor">#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</font>
00090 <font class="preprocessor"></font>
00091 <font class="comment">/* Special action meaning "start processing a new file". */</font>
<a name="l00092"></a><a class="code" href="lex_yy_c.html#a11">00092</a> <font class="preprocessor">#define YY_NEW_FILE yyrestart( yyin )</font>
00093 <font class="preprocessor"></font>
<a name="l00094"></a><a class="code" href="lex_yy_c.html#a12">00094</a> <font class="preprocessor">#define YY_END_OF_BUFFER_CHAR 0</font>
00095 <font class="preprocessor"></font>
00096 <font class="comment">/* Size of default input buffer. */</font>
<a name="l00097"></a><a class="code" href="lex_yy_c.html#a13">00097</a> <font class="preprocessor">#define YY_BUF_SIZE 16384</font>
00098 <font class="preprocessor"></font>
<a name="l00099"></a><a class="code" href="lex_yy_c.html#a59">00099</a> <font class="keyword">typedef</font> <font class="keyword">struct </font><a class="code" href="struct_yy_buffer_state.html">yy_buffer_state</a> *<a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a>;
00100 
00101 <font class="keyword">extern</font> <font class="keywordtype">int</font> yyleng;
00102 <font class="keyword">extern</font> FILE *yyin, *yyout;
00103 
<a name="l00104"></a><a class="code" href="lex_yy_c.html#a14">00104</a> <font class="preprocessor">#define EOB_ACT_CONTINUE_SCAN 0</font>
<a name="l00105"></a><a class="code" href="lex_yy_c.html#a15">00105</a> <font class="preprocessor"></font><font class="preprocessor">#define EOB_ACT_END_OF_FILE 1</font>
<a name="l00106"></a><a class="code" href="lex_yy_c.html#a16">00106</a> <font class="preprocessor"></font><font class="preprocessor">#define EOB_ACT_LAST_MATCH 2</font>
00107 <font class="preprocessor"></font>
00108 <font class="comment">/* The funky do-while in the following #define is used to turn the definition</font>
00109 <font class="comment"> * int a single C statement (which needs a semi-colon terminator).  This</font>
00110 <font class="comment"> * avoids problems with code like:</font>
00111 <font class="comment"> *</font>
00112 <font class="comment"> *      if ( condition_holds )</font>
00113 <font class="comment"> *              yyless( 5 );</font>
00114 <font class="comment"> *      else</font>
00115 <font class="comment"> *              do_something_else();</font>
00116 <font class="comment"> *</font>
00117 <font class="comment"> * Prior to using the do-while the compiler would get upset at the</font>
00118 <font class="comment"> * "else" because it interpreted the "if" statement as being all</font>
00119 <font class="comment"> * done when it reached the ';' after the yyless() call.</font>
00120 <font class="comment"> */</font>
00121 
00122 <font class="comment">/* Return all but the first 'n' matched characters back to the input stream. */</font>
00123 
<a name="l00124"></a><a class="code" href="lex_yy_c.html#a58">00124</a> <font class="preprocessor">#define yyless(n) \</font>
00125 <font class="preprocessor">        do \</font>
00126 <font class="preprocessor">                { \</font>
00127 <font class="preprocessor">                </font><font class="comment">/* Undo effects of setting up yytext. */</font> \
00128                 *yy_cp = yy_hold_char; \
00129                 YY_RESTORE_YY_MORE_OFFSET \
00130                 yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
00131                 YY_DO_BEFORE_ACTION; <font class="comment">/* set up yytext again */</font> \
00132                 } \
00133         while ( 0 )
00134 
<a name="l00135"></a><a class="code" href="lex_yy_c.html#a18">00135</a> <font class="preprocessor">#define unput(c) yyunput( c, yytext_ptr )</font>
00136 <font class="preprocessor"></font>
00137 <font class="comment">/* The following is because we cannot portably get our hands on size_t</font>
00138 <font class="comment"> * (without autoconf's help, which isn't available because we want</font>
00139 <font class="comment"> * flex-generated scanners to compile on their own).</font>
00140 <font class="comment"> */</font>
<a name="l00141"></a><a class="code" href="lex_yy_c.html#a62">00141</a> <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> yy_size_t;
00142 
00143 
<a name="l00144"></a><a class="code" href="struct_yy_buffer_state.html">00144</a> <font class="keyword">struct </font><a class="code" href="struct_yy_buffer_state.html">yy_buffer_state</a>
00145         {
<a name="l00146"></a><a class="code" href="struct_yy_buffer_state.html#m0">00146</a>         FILE *yy_input_file;
00147 
<a name="l00148"></a><a class="code" href="struct_yy_buffer_state.html#m1">00148</a>         <font class="keywordtype">char</font> *yy_ch_buf;                <font class="comment">/* input buffer */</font>
<a name="l00149"></a><a class="code" href="struct_yy_buffer_state.html#m2">00149</a>         <font class="keywordtype">char</font> *yy_buf_pos;               <font class="comment">/* current position in input buffer */</font>
00150 
00151         <font class="comment">/* Size of input buffer in bytes, not including room for EOB</font>
00152 <font class="comment">         * characters.</font>
00153 <font class="comment">         */</font>
<a name="l00154"></a><a class="code" href="struct_yy_buffer_state.html#m3">00154</a>         yy_size_t yy_buf_size;
00155 
00156         <font class="comment">/* Number of characters read into yy_ch_buf, not including EOB</font>
00157 <font class="comment">         * characters.</font>
00158 <font class="comment">         */</font>
<a name="l00159"></a><a class="code" href="struct_yy_buffer_state.html#m4">00159</a>         <font class="keywordtype">int</font> yy_n_chars;
00160 
00161         <font class="comment">/* Whether we "own" the buffer - i.e., we know we created it,</font>
00162 <font class="comment">         * and can realloc() it to grow it, and should free() it to</font>
00163 <font class="comment">         * delete it.</font>
00164 <font class="comment">         */</font>
<a name="l00165"></a><a class="code" href="struct_yy_buffer_state.html#m5">00165</a>         <font class="keywordtype">int</font> yy_is_our_buffer;
00166 
00167         <font class="comment">/* Whether this is an "interactive" input source; if so, and</font>
00168 <font class="comment">         * if we're using stdio for input, then we want to use getc()</font>
00169 <font class="comment">         * instead of fread(), to make sure we stop fetching input after</font>
00170 <font class="comment">         * each newline.</font>
00171 <font class="comment">         */</font>
<a name="l00172"></a><a class="code" href="struct_yy_buffer_state.html#m6">00172</a>         <font class="keywordtype">int</font> yy_is_interactive;
00173 
00174         <font class="comment">/* Whether we're considered to be at the beginning of a line.</font>
00175 <font class="comment">         * If so, '^' rules will be active on the next match, otherwise</font>
00176 <font class="comment">         * not.</font>
00177 <font class="comment">         */</font>
<a name="l00178"></a><a class="code" href="struct_yy_buffer_state.html#m7">00178</a>         <font class="keywordtype">int</font> yy_at_bol;
00179 
00180         <font class="comment">/* Whether to try to fill the input buffer when we reach the</font>
00181 <font class="comment">         * end of it.</font>
00182 <font class="comment">         */</font>
<a name="l00183"></a><a class="code" href="struct_yy_buffer_state.html#m8">00183</a>         <font class="keywordtype">int</font> yy_fill_buffer;
00184 
<a name="l00185"></a><a class="code" href="struct_yy_buffer_state.html#m9">00185</a>         <font class="keywordtype">int</font> yy_buffer_status;
<a name="l00186"></a><a class="code" href="lex_yy_c.html#a19">00186</a> <font class="preprocessor">#define YY_BUFFER_NEW 0</font>
<a name="l00187"></a><a class="code" href="lex_yy_c.html#a20">00187</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_BUFFER_NORMAL 1</font>
00188 <font class="preprocessor"></font>        <font class="comment">/* When an EOF's been seen but there's still some text to process</font>
00189 <font class="comment">         * then we mark the buffer as YY_EOF_PENDING, to indicate that we</font>
00190 <font class="comment">         * shouldn't try reading from the input source any more.  We might</font>
00191 <font class="comment">         * still have a bunch of tokens to match, though, because of</font>
00192 <font class="comment">         * possible backing-up.</font>
00193 <font class="comment">         *</font>
00194 <font class="comment">         * When we actually see the EOF, we change the status to "new"</font>
00195 <font class="comment">         * (via yyrestart()), so that the user can continue scanning by</font>
00196 <font class="comment">         * just pointing yyin at a new input file.</font>
00197 <font class="comment">         */</font>
<a name="l00198"></a><a class="code" href="lex_yy_c.html#a21">00198</a> <font class="preprocessor">#define YY_BUFFER_EOF_PENDING 2</font>
00199 <font class="preprocessor"></font>        };
00200 
00201 <font class="keyword">static</font> <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_current_buffer = 0;
00202 
00203 <font class="comment">/* We provide macros for accessing buffer states in case in the</font>
00204 <font class="comment"> * future we want to put the buffer states in a more general</font>
00205 <font class="comment"> * "scanner state".</font>
00206 <font class="comment"> */</font>
<a name="l00207"></a><a class="code" href="lex_yy_c.html#a22">00207</a> <font class="preprocessor">#define YY_CURRENT_BUFFER yy_current_buffer</font>
00208 <font class="preprocessor"></font>
00209 
00210 <font class="comment">/* yy_hold_char holds the character lost when yytext is formed. */</font>
00211 <font class="keyword">static</font> <font class="keywordtype">char</font> yy_hold_char;
00212 
00213 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_n_chars;          <font class="comment">/* number of characters read into yy_ch_buf */</font>
00214 
00215 
<a name="l00216"></a><a class="code" href="lex_yy_c.html#a60">00216</a> <font class="keywordtype">int</font> yyleng;
00217 
00218 <font class="comment">/* Points to current character in buffer. */</font>
00219 <font class="keyword">static</font> <font class="keywordtype">char</font> *yy_c_buf_p = (<font class="keywordtype">char</font> *) 0;
00220 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_init = 1;         <font class="comment">/* whether we need to initialize */</font>
00221 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_start = 0;        <font class="comment">/* start state number */</font>
00222 
00223 <font class="comment">/* Flag which is used to allow yywrap()'s to do buffer switches</font>
00224 <font class="comment"> * instead of setting up a fresh yyin.  A bit of a hack ...</font>
00225 <font class="comment"> */</font>
00226 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_did_buffer_switch_on_eof;
00227 
00228 <font class="keywordtype">void</font> yyrestart <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( FILE *input_file ));
00229 
00230 <font class="keywordtype">void</font> yy_switch_to_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> new_buffer ));
00231 <font class="keywordtype">void</font> yy_load_buffer_state <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00232 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_create_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( FILE *file, <font class="keywordtype">int</font> size ));
00233 <font class="keywordtype">void</font> yy_delete_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b ));
00234 <font class="keywordtype">void</font> yy_init_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b, FILE *file ));
00235 <font class="keywordtype">void</font> yy_flush_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b ));
<a name="l00236"></a><a class="code" href="lex_yy_c.html#a23">00236</a> <font class="preprocessor">#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )</font>
00237 <font class="preprocessor"></font>
00238 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">char</font> *base, yy_size_t size ));
00239 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_string <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( yyconst <font class="keywordtype">char</font> *yy_str ));
00240 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_bytes <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( yyconst <font class="keywordtype">char</font> *bytes, <font class="keywordtype">int</font> len ));
00241 
00242 <font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_alloc <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( yy_size_t ));
00243 <font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_realloc <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> *, yy_size_t ));
00244 <font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_free <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> * ));
00245 
<a name="l00246"></a><a class="code" href="lex_yy_c.html#a24">00246</a> <font class="preprocessor">#define yy_new_buffer yy_create_buffer</font>
00247 <font class="preprocessor"></font>
<a name="l00248"></a><a class="code" href="lex_yy_c.html#a25">00248</a> <font class="preprocessor">#define yy_set_interactive(is_interactive) \</font>
00249 <font class="preprocessor">        { \</font>
00250 <font class="preprocessor">        if ( ! yy_current_buffer ) \</font>
00251 <font class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</font>
00252 <font class="preprocessor">        yy_current_buffer-&gt;yy_is_interactive = is_interactive; \</font>
00253 <font class="preprocessor">        }</font>
00254 <font class="preprocessor"></font>
<a name="l00255"></a><a class="code" href="lex_yy_c.html#a26">00255</a> <font class="preprocessor">#define yy_set_bol(at_bol) \</font>
00256 <font class="preprocessor">        { \</font>
00257 <font class="preprocessor">        if ( ! yy_current_buffer ) \</font>
00258 <font class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</font>
00259 <font class="preprocessor">        yy_current_buffer-&gt;yy_at_bol = at_bol; \</font>
00260 <font class="preprocessor">        }</font>
00261 <font class="preprocessor"></font>
<a name="l00262"></a><a class="code" href="lex_yy_c.html#a27">00262</a> <font class="preprocessor">#define YY_AT_BOL() (yy_current_buffer-&gt;yy_at_bol)</font>
00263 <font class="preprocessor"></font>
<a name="l00264"></a><a class="code" href="lex_yy_c.html#a70">00264</a> <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> YY_CHAR;
<a name="l00265"></a><a class="code" href="lex_yy_c.html#a61">00265</a> FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
<a name="l00266"></a><a class="code" href="lex_yy_c.html#a71">00266</a> <font class="keyword">typedef</font> <font class="keywordtype">int</font> yy_state_type;
00267 <font class="keyword">extern</font> <font class="keywordtype">char</font> *yytext;
<a name="l00268"></a><a class="code" href="lex_yy_c.html#a28">00268</a> <font class="preprocessor">#define yytext_ptr yytext</font>
00269 <font class="preprocessor"></font>
00270 <font class="keyword">static</font> yy_state_type yy_get_previous_state <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00271 <font class="keyword">static</font> yy_state_type yy_try_NUL_trans <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( yy_state_type current_state ));
00272 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_get_next_buffer <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00273 <font class="keyword">static</font> <font class="keywordtype">void</font> yy_fatal_error <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( yyconst <font class="keywordtype">char</font> msg[] ));
00274 
00275 <font class="comment">/* Done after the current pattern has been matched and before the</font>
00276 <font class="comment"> * corresponding action - sets up yytext.</font>
00277 <font class="comment"> */</font>
<a name="l00278"></a><a class="code" href="lex_yy_c.html#a29">00278</a> <font class="preprocessor">#define YY_DO_BEFORE_ACTION \</font>
00279 <font class="preprocessor">        yytext_ptr = yy_bp; \</font>
00280 <font class="preprocessor">        yyleng = (int) (yy_cp - yy_bp); \</font>
00281 <font class="preprocessor">        yy_hold_char = *yy_cp; \</font>
00282 <font class="preprocessor">        *yy_cp = '\0'; \</font>
00283 <font class="preprocessor">        yy_c_buf_p = yy_cp;</font>
00284 <font class="preprocessor"></font>
<a name="l00285"></a><a class="code" href="lex_yy_c.html#a30">00285</a> <font class="preprocessor">#define YY_NUM_RULES 177</font>
<a name="l00286"></a><a class="code" href="lex_yy_c.html#a31">00286</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_END_OF_BUFFER 178</font>
00287 <font class="preprocessor"></font><font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_accept[509] =
00288     {   0,
00289         0,    0,  178,  176,  156,  157,  144,  176,    3,   79,
00290       150,  143,  176,  138,  139,  148,  147,  135,  146,  142,
00291       149,   94,   94,  136,  132,  151,  137,  152,  155,  176,
00292       140,  175,  141,  153,   79,   79,   79,   79,   79,   79,
00293        79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00294        79,   79,   79,   79,   79,  133,  154,  134,  145,  131,
00295         0,   42,    0,    2,   79,  117,  173,  174,  126,  118,
00296         0,    0,  115,  123,  113,  124,  114,  125,    0,  107,
00297         1,  116,  110,   87,    0,   96,   95,    0,   94,  122,
00298       128,  130,  129,  121,    0,    0,    0,  119,   79,   79,
00299 
00300        79,   79,   79,   79,   79,   79,    9,   79,   79,   79,
00301        79,   79,   79,   79,   13,   44,   79,   79,   79,   79,
00302        79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00303        79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00304        79,   79,   79,   79,  120,  127,    0,    0,    2,  101,
00305         4,    0,  105,  106,  107,    0,  108,  109,   89,   88,
00306         0,  104,   97,   98,   98,   80,  112,  111,  163,  164,
00307       161,  166,  171,  162,  172,  167,  170,  165,  168,  169,
00308         0,    0,   79,   79,   79,   79,   79,   79,   79,   79,
00309        79,   79,   79,   79,   79,   79,   79,   79,   79,   11,
00310 
00311        79,   79,   27,   79,   79,   79,   79,   79,   79,   79,
00312        79,   79,   79,   43,   79,   79,   79,   79,   79,   79,
00313        74,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00314        79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00315        79,   79,    0,   42,    0,    0,  107,    0,  105,  106,
00316         0,  110,   90,   91,   91,  102,  103,  100,   99,   81,
00317        83,  160,    0,    0,   79,   79,   39,   79,    6,   29,
00318        79,   79,   79,   79,   79,   79,   10,   25,   79,   79,
00319        79,   79,   12,   79,   79,   79,   51,   79,   31,   79,
00320        79,   52,   79,   79,   68,   79,   79,   79,   79,   79,
00321 
00322        79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00323        79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
00324        26,   79,   79,   79,    0,  107,   93,   92,   82,   84,
00325        84,    0,  159,   79,   79,    5,   79,   36,   79,   79,
00326        79,   79,   79,   79,   79,   30,   79,   79,   79,   79,
00327        79,   79,   79,   79,   79,   69,   79,   79,   79,   79,
00328        79,   79,   79,   32,   79,   79,   79,   79,   79,   79,
00329        79,   79,   79,   79,   77,   24,   79,   79,   79,   79,
00330        79,   18,   76,   86,   85,  158,   79,   79,   79,   79,
00331        79,   79,   79,   28,   79,   38,   79,   21,   79,   54,
00332 
00333        78,   79,   60,   79,   79,   79,   79,   79,   79,   58,
00334        79,   14,   75,   34,   15,   79,   41,   22,   17,   79,
00335        79,   79,   79,   79,   72,   19,   20,   79,   37,   47,
00336        64,   79,   79,    8,   79,   59,   79,   79,   79,   62,
00337        53,   79,   79,   45,   79,   79,   57,   79,   46,   61,
00338        79,   23,   79,   79,   79,   79,   65,    7,   79,   73,
00339        79,   79,   70,   16,   79,   40,   79,   55,   79,   33,
00340        35,   79,   71,   56,   79,   79,   79,   67,   79,   79,
00341        79,   63,   79,   79,   79,   79,   79,   79,   79,   48,
00342        79,   79,   66,   79,   79,   79,   79,   79,   79,   79,
00343 
00344        79,   79,   79,   50,   79,   79,   49,    0
00345     } ;
00346 
00347 <font class="keyword">static</font> yyconst <font class="keywordtype">int</font> yy_ec[256] =
00348     {   0,
00349         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
00350         4,    4,    1,    1,    1,    1,    1,    1,    1,    1,
00351         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00352         1,    2,    5,    6,    7,    8,    9,   10,   11,   12,
00353        13,   14,   15,   16,   17,   18,   19,   20,   21,   21,
00354        21,   21,   21,   21,   21,   21,   21,   22,   23,   24,
00355        25,   26,   27,   28,   29,   30,   31,   30,   32,   33,
00356        34,    8,    8,    8,   35,   36,   37,    8,    8,    8,
00357        38,   39,   40,   41,   42,    8,   43,   44,    8,   45,
00358        46,   47,   48,   49,   50,    1,   51,   52,   53,   54,
00359 
00360        55,   56,   57,   58,   59,    8,   60,   61,   62,   63,
00361        64,   65,    8,   66,   67,   68,   69,   70,   71,   72,
00362        73,   74,   75,   76,   77,   78,    1,    1,    1,    1,
00363         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00364         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00365         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00366         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00367         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00368         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00369         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00370 
00371         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00372         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00373         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00374         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00375         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00376         1,    1,    1,    1,    1
00377     } ;
00378 
00379 <font class="keyword">static</font> yyconst <font class="keywordtype">int</font> yy_meta[79] =
00380     {   0,
00381         1,    1,    1,    1,    1,    1,    1,    2,    1,    1,
00382         3,    1,    1,    1,    1,    1,    1,    1,    1,    4,
00383         4,    1,    1,    1,    1,    1,    1,    1,    5,    5,
00384         5,    5,    5,    2,    2,    2,    2,    2,    2,    2,
00385         2,    2,    2,    2,    2,    1,    1,    1,    1,    2,
00386         5,    5,    5,    5,    5,    5,    2,    2,    2,    2,
00387         2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
00388         2,    2,    2,    2,    1,    1,    1,    1
00389     } ;
00390 
00391 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_base[516] =
00392     {   0,
00393         0,    0,  659,  660,  660,  660,  633,   73,    0,    0,
00394        55,   71,  610,  660,  660,  631,   67,  660,   68,   66,
00395        74,   80,   85,  660,  660,   65,  630,   82,  660,   91,
00396       660,  660,  660,  629,  603,   28,  586,   67,   40,   65,
00397        72,  587,   88,   55,  586,   79,  101,  598,  593,  103,
00398        90,  584,   51,  588,  586,  660,  113,  660,  660,  660,
00399       133,  163,  641,    0,    0,  660,  660,  660,  660,  660,
00400       100,  139,  660,  660,  660,  660,  660,  660,  625,  155,
00401       660,  660,  162,  172,  164,  160,  142,    0,  204,  617,
00402       660,  660,  660,  616,  245,  603,  603,  660,  585,  564,
00403 
00404       568,  580,  567,  122,  570,  141,  563,  564,  561,  144,
00405       568,  564,  561,  558,    0,   99,  562,  569,  562,  559,
00406       550,  552,  558,  551,  561,  555,  547,  551,  547,  174,
00407       556,  135,  158,  556,  154,  551,  547,  539,  542,  184,
00408       556,  167,  546,  549,  660,  660,  242,  153,    0,  660,
00409       660,  235,  660,  660,  251,  243,  660,  660,  233,  230,
00410       241,  272,  165,  660,  234,  261,  660,  660,  660,  562,
00411       660,  660,  660,  660,  660,  660,  660,  660,  660,  660,
00412       563,  564,  536,  531,  534,  546,  541,  529,  541,  200,
00413       542,  537,  539,  535,  527,  524,  532,  519,  534,    0,
00414 
00415       520,  524,  527,  512,  515,  518,  521,  511,  513,  514,
00416       519,  506,  499,    0,  516,  502,  516,  509,  246,  498,
00417         0,  500,  499,  501,  508,  509,  493,  491,  491,  493,
00418       502,  501,  497,  499,  489,  493,  484,  203,  496,  498,
00419       487,  486,  271,  308,  543,  278,  296,  304,  660,  660,
00420       306,  314,  254,  660,  277,  660,  660,  660,  660,  295,
00421       279,  660,  517,  505,  480,  469,    0,  481,    0,    0,
00422       480,  471,  479,  468,  473,  474,    0,    0,  467,  467,
00423       477,  463,    0,  467,  472,  467,    0,  287,    0,  472,
00424       457,    0,  459,  469,    0,  469,  463,  457,  453,  464,
00425 
00426       449,  451,  461,  447,  459,  449,  453,  452,  457,  456,
00427       442,  444,  452,  450,  448,  440,  445,  446,  434,  446,
00428         0,  430,  442,  442,  323,  325,  660,  660,  294,  660,
00429       305,  467,  660,  427,  428,    0,  293,    0,  429,  430,
00430       436,  434,  433,  424,  423,    0,  430,  418,  422,  428,
00431       426,  424,  418,  408,  409,    0,  425,  406,  406,  417,
00432       411,  408,  416,    0,  415,  412,  416,  413,  397,  406,
00433       408,  393,  406,  407,    0,    0,  396,  404,  400,  395,
00434       396,    0,    0,  660,  660,  660,  386,  398,  398,  387,
00435       381,  381,  393,    0,  393,  395,  376,    0,  393,    0,
00436 
00437         0,  387,    0,  381,  386,  376,  378,  375,  382,    0,
00438       375,    0,    0,  376,    0,  373,    0,    0,    0,  377,
00439       371,  375,  370,  374,    0,    0,    0,  367,    0,    0,
00440       360,  372,  370,    0,  361,    0,  362,  361,  360,    0,
00441         0,  354,  363,    0,  350,  351,    0,  353,    0,    0,
00442       345,    0,  347,  343,  339,  325,    0,    0,  317,    0,
00443       323,  315,    0,    0,  327,    0,  312,    0,  325,  319,
00444         0,  311,    0,    0,  303,  320,  318,    0,  309,  312,
00445       304,    0,  311,  299,  312,  307,  294,  304,  286,    0,
00446       300,  292,    0,  278,  254,  236,  250,  176,  186,  174,
00447 
00448       151,  158,  128,    0,   48,   28,    0,  660,  386,  390,
00449       394,  399,  403,  405,  410
00450     } ;
00451 
00452 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_def[516] =
00453     {   0,
00454       508,    1,  508,  508,  508,  508,  508,  509,  510,  511,
00455       508,  508,  512,  508,  508,  508,  508,  508,  508,  508,
00456       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00457       508,  508,  508,  508,  511,  511,  511,  511,  511,  511,
00458       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00459       511,  511,  511,  511,  511,  508,  508,  508,  508,  508,
00460       509,  508,  509,  513,  511,  508,  508,  508,  508,  508,
00461       512,  512,  508,  508,  508,  508,  508,  508,  508,  508,
00462       508,  508,  508,  508,  508,  508,  508,  514,  508,  508,
00463       508,  508,  508,  508,  508,  508,  508,  508,  511,  511,
00464 
00465       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00466       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00467       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00468       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00469       511,  511,  511,  511,  508,  508,  508,  515,  513,  508,
00470       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00471       508,  508,  508,  508,  508,  514,  508,  508,  508,  508,
00472       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00473       508,  508,  511,  511,  511,  511,  511,  511,  511,  511,
00474       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00475 
00476       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00477       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00478       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00479       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00480       511,  511,  515,  508,  515,  508,  508,  508,  508,  508,
00481       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00482       508,  508,  508,  508,  511,  511,  511,  511,  511,  511,
00483       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00484       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00485       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00486 
00487       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00488       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00489       511,  511,  511,  511,  508,  508,  508,  508,  508,  508,
00490       508,  508,  508,  511,  511,  511,  511,  511,  511,  511,
00491       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00492       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00493       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00494       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00495       511,  511,  511,  508,  508,  508,  511,  511,  511,  511,
00496       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00497 
00498       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00499       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00500       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00501       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00502       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00503       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00504       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00505       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00506       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00507       511,  511,  511,  511,  511,  511,  511,  511,  511,  511,
00508 
00509       511,  511,  511,  511,  511,  511,  511,    0,  508,  508,
00510       508,  508,  508,  508,  508
00511     } ;
00512 
00513 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_nxt[739] =
00514     {   0,
00515         4,    5,    6,    5,    7,    8,    9,   10,   11,   12,
00516        13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
00517        23,   24,   25,   26,   27,   28,   29,   30,   10,   10,
00518        10,   10,   10,   10,   10,   10,   10,   10,   10,   10,
00519        10,   10,   10,   10,   10,   31,   32,   33,   34,   35,
00520        36,   37,   38,   39,   40,   41,   42,   10,   43,   44,
00521        45,   10,   46,   47,   48,   49,   50,   51,   52,   53,
00522        54,   10,   55,   10,   56,   57,   58,   59,   62,   66,
00523        69,   74,  507,   79,   76,   80,   80,   81,   90,   91,
00524       100,   75,   77,   78,  106,   70,  101,   83,   82,   84,
00525 
00526        84,  141,   83,  107,   89,   89,   93,   94,   95,  118,
00527       150,   85,  506,  119,  142,   86,   85,  103,   96,   63,
00528        86,   87,  111,   88,  104,  108,   87,  109,   97,   67,
00529       105,   68,  112,  121,   85,  113,  110,  145,   62,   85,
00530        86,  508,  122,  115,  137,   86,   72,  123,   87,   71,
00531       116,   88,  124,   87,  117,  138,  125,  131,  244,  202,
00532       132,  133,  139,  126,  147,  147,  203,  134,  148,  127,
00533       135,  128,  188,  136,   80,   80,  189,  165,  161,   63,
00534       161,  155,  155,  162,  162,  222,  152,  153,  146,   83,
00535       154,   84,   84,  156,  157,  163,  191,  158,  223,  245,
00536 
00537       505,  164,  165,   85,  227,  192,  258,  159,  196,  152,
00538       153,  197,  504,  160,  224,  154,  156,  157,  503,  228,
00539       163,   83,  158,   89,   89,  239,   85,  240,  164,  217,
00540       218,  225,  159,  258,  219,   85,  233,  234,  502,   86,
00541       160,  220,  235,  147,  147,   87,  501,  148,  500,  246,
00542       236,  246,  237,  319,  247,  247,  320,  251,   85,  251,
00543       162,  162,  252,  252,   86,  255,  272,  273,  253,  259,
00544       155,  155,   87,  169,  254,  170,  244,  171,  172,  173,
00545       174,  175,  248,  249,  176,  177,  250,  178,  179,  180,
00546       255,  162,  162,  253,  259,  327,  260,  247,  247,  300,
00547 
00548       499,  254,  261,  498,  256,  248,  249,  257,  301,  147,
00549       147,  250,  328,  148,  331,  247,  247,  245,  325,  497,
00550       325,  260,  327,  326,  326,  252,  252,  256,  153,  261,
00551       329,  154,  257,  252,  252,  384,  330,  328,  496,  331,
00552       385,  350,  326,  326,  326,  326,  157,  389,  495,  158,
00553       494,  153,  351,  493,  390,  329,  154,  249,  492,  491,
00554       250,  490,  384,  330,  489,  385,  488,  487,  486,  157,
00555       485,  484,  483,  482,  158,  481,  480,  479,  478,  477,
00556       249,  476,  475,  474,  473,  250,   61,   61,   61,   61,
00557        61,   64,  472,  471,   64,   65,  470,   65,   65,   71,
00558 
00559        71,  469,   71,   71,  149,  468,  149,  149,  166,  166,
00560       243,  243,  243,  243,  243,  467,  466,  465,  464,  463,
00561       462,  461,  460,  459,  458,  457,  456,  455,  454,  453,
00562       452,  451,  450,  449,  448,  447,  446,  445,  444,  443,
00563       442,  441,  440,  439,  438,  437,  436,  435,  434,  433,
00564       432,  431,  430,  429,  428,  427,  426,  425,  424,  423,
00565       422,  421,  420,  419,  418,  417,  416,  415,  414,  413,
00566       412,  411,  410,  409,  408,  407,  406,  405,  404,  403,
00567       402,  401,  400,  399,  398,  397,  396,  395,  394,  393,
00568       392,  391,  388,  387,  386,  383,  382,  381,  380,  379,
00569 
00570       378,  377,  376,  375,  374,  373,  372,  371,  370,  369,
00571       368,  367,  366,  365,  364,  363,  362,  361,  360,  359,
00572       358,  357,  356,  355,  354,  353,  352,  349,  348,  347,
00573       346,  345,  344,  343,  342,  341,  340,  339,  338,  337,
00574       336,  335,  334,  333,  332,  508,  324,  323,  322,  321,
00575       318,  317,  316,  315,  314,  313,  312,  311,  310,  309,
00576       308,  307,  306,  305,  304,  303,  302,  299,  298,  297,
00577       296,  295,  294,  293,  292,  291,  290,  289,  288,  287,
00578       286,  285,  284,  283,  282,  281,  280,  279,  278,  277,
00579       276,  275,  274,  271,  270,  269,  268,  267,  266,  265,
00580 
00581       264,  263,  262,  242,  241,  238,  232,  231,  230,  229,
00582       226,  221,  216,  215,  214,  213,  212,  211,  210,  209,
00583       208,  207,  206,  205,  204,  201,  200,  199,  198,  195,
00584       194,  193,  190,  187,  186,  185,  184,  183,  182,  181,
00585       168,  167,  151,  508,  144,  143,  140,  130,  129,  120,
00586       114,  102,   99,   98,   92,   73,   72,   60,  508,    3,
00587       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00588       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00589       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00590       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00591 
00592       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00593       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00594       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00595       508,  508,  508,  508,  508,  508,  508,  508
00596     } ;
00597 
00598 <font class="keyword">static</font> yyconst <font class="keywordtype">short</font> <font class="keywordtype">int</font> yy_chk[739] =
00599     {   0,
00600         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00601         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00602         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00603         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00604         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00605         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00606         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00607         1,    1,    1,    1,    1,    1,    1,    1,    8,   11,
00608        12,   17,  506,   20,   19,   20,   20,   21,   26,   26,
00609        36,   17,   19,   19,   39,   12,   36,   22,   21,   22,
00610 
00611        22,   53,   23,   39,   23,   23,   28,   28,   30,   44,
00612        71,   22,  505,   44,   53,   22,   23,   38,   30,    8,
00613        23,   22,   41,   22,   38,   40,   23,   40,   30,   11,
00614        38,   11,   41,   46,   22,   41,   40,   57,   61,   23,
00615        22,   72,   46,   43,   51,   23,   71,   46,   22,   72,
00616        43,   22,   47,   23,   43,   51,   47,   50,  148,  116,
00617        50,   50,   51,   47,   62,   62,  116,   50,   62,   47,
00618        50,   47,  104,   50,   80,   80,  104,   87,   85,   61,
00619        85,   83,   83,   85,   85,  132,   80,   80,   57,   84,
00620        80,   84,   84,   83,   83,   86,  106,   83,  132,  148,
00621 
00622       503,   86,   87,   84,  135,  106,  163,   84,  110,   80,
00623        80,  110,  502,   84,  133,   80,   83,   83,  501,  135,
00624        86,   89,   83,   89,   89,  142,   84,  142,   86,  130,
00625       130,  133,   84,  163,  130,   89,  140,  140,  500,   89,
00626        84,  130,  140,  147,  147,   89,  499,  147,  498,  152,
00627       140,  152,  140,  238,  152,  152,  238,  156,   89,  156,
00628       161,  161,  156,  156,   89,  160,  190,  190,  159,  165,
00629       155,  155,   89,   95,  159,   95,  243,   95,   95,   95,
00630        95,   95,  155,  155,   95,   95,  155,   95,   95,   95,
00631       160,  162,  162,  159,  165,  253,  166,  246,  246,  219,
00632 
00633       497,  159,  166,  496,  162,  155,  155,  162,  219,  244,
00634       244,  155,  255,  244,  261,  247,  247,  243,  248,  495,
00635       248,  166,  253,  248,  248,  251,  251,  162,  247,  166,
00636       260,  247,  162,  252,  252,  329,  260,  255,  494,  261,
00637       331,  288,  325,  325,  326,  326,  252,  337,  492,  252,
00638       491,  247,  288,  489,  337,  260,  247,  326,  488,  487,
00639       326,  486,  329,  260,  485,  331,  484,  483,  481,  252,
00640       480,  479,  477,  476,  252,  475,  472,  470,  469,  467,
00641       326,  465,  462,  461,  459,  326,  509,  509,  509,  509,
00642       509,  510,  456,  455,  510,  511,  454,  511,  511,  512,
00643 
00644       512,  453,  512,  512,  513,  451,  513,  513,  514,  514,
00645       515,  515,  515,  515,  515,  448,  446,  445,  443,  442,
00646       439,  438,  437,  435,  433,  432,  431,  428,  424,  423,
00647       422,  421,  420,  416,  414,  411,  409,  408,  407,  406,
00648       405,  404,  402,  399,  397,  396,  395,  393,  392,  391,
00649       390,  389,  388,  387,  381,  380,  379,  378,  377,  374,
00650       373,  372,  371,  370,  369,  368,  367,  366,  365,  363,
00651       362,  361,  360,  359,  358,  357,  355,  354,  353,  352,
00652       351,  350,  349,  348,  347,  345,  344,  343,  342,  341,
00653       340,  339,  335,  334,  332,  324,  323,  322,  320,  319,
00654 
00655       318,  317,  316,  315,  314,  313,  312,  311,  310,  309,
00656       308,  307,  306,  305,  304,  303,  302,  301,  300,  299,
00657       298,  297,  296,  294,  293,  291,  290,  286,  285,  284,
00658       282,  281,  280,  279,  276,  275,  274,  273,  272,  271,
00659       268,  266,  265,  264,  263,  245,  242,  241,  240,  239,
00660       237,  236,  235,  234,  233,  232,  231,  230,  229,  228,
00661       227,  226,  225,  224,  223,  222,  220,  218,  217,  216,
00662       215,  213,  212,  211,  210,  209,  208,  207,  206,  205,
00663       204,  203,  202,  201,  199,  198,  197,  196,  195,  194,
00664       193,  192,  191,  189,  188,  187,  186,  185,  184,  183,
00665 
00666       182,  181,  170,  144,  143,  141,  139,  138,  137,  136,
00667       134,  131,  129,  128,  127,  126,  125,  124,  123,  122,
00668       121,  120,  119,  118,  117,  114,  113,  112,  111,  109,
00669       108,  107,  105,  103,  102,  101,  100,   99,   97,   96,
00670        94,   90,   79,   63,   55,   54,   52,   49,   48,   45,
00671        42,   37,   35,   34,   27,   16,   13,    7,    3,  508,
00672       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00673       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00674       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00675       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00676 
00677       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00678       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00679       508,  508,  508,  508,  508,  508,  508,  508,  508,  508,
00680       508,  508,  508,  508,  508,  508,  508,  508
00681     } ;
00682 
00683 <font class="keyword">static</font> yy_state_type yy_last_accepting_state;
00684 <font class="keyword">static</font> <font class="keywordtype">char</font> *yy_last_accepting_cpos;
00685 
00686 <font class="comment">/* The intent behind this definition is that it'll catch</font>
00687 <font class="comment"> * any uses of REJECT which flex missed.</font>
00688 <font class="comment"> */</font>
<a name="l00689"></a><a class="code" href="lex_yy_c.html#a32">00689</a> <font class="preprocessor">#define REJECT reject_used_but_not_detected</font>
<a name="l00690"></a><a class="code" href="lex_yy_c.html#a33">00690</a> <font class="preprocessor"></font><font class="preprocessor">#define yymore() yymore_used_but_not_detected</font>
<a name="l00691"></a><a class="code" href="lex_yy_c.html#a34">00691</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_MORE_ADJ 0</font>
<a name="l00692"></a><a class="code" href="lex_yy_c.html#a35">00692</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_RESTORE_YY_MORE_OFFSET</font>
<a name="l00693"></a><a class="code" href="lex_yy_c.html#a72">00693</a> <font class="preprocessor"></font><font class="keywordtype">char</font> *yytext;
00694 <font class="preprocessor">#line 1 "cscanner.l"</font>
<a name="l00695"></a><a class="code" href="lex_yy_c.html#a36">00695</a> <font class="preprocessor"></font><font class="preprocessor">#define INITIAL 0</font>
00696 <font class="preprocessor"></font><font class="comment">/*;-*-C-*-; </font>
00697 <font class="comment">** Copyright (c) Massachusetts Institute of Technology 1994-1998.</font>
00698 <font class="comment">**          All Rights Reserved.</font>
00699 <font class="comment">**          Unpublished rights reserved under the copyright laws of</font>
00700 <font class="comment">**          the United States.</font>
00701 <font class="comment">**</font>
00702 <font class="comment">** THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED</font>
00703 <font class="comment">** OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.</font>
00704 <font class="comment">**</font>
00705 <font class="comment">** This code is distributed freely and may be used freely under the </font>
00706 <font class="comment">** following conditions:</font>
00707 <font class="comment">**</font>
00708 <font class="comment">**     1. This notice may not be removed or altered.</font>
00709 <font class="comment">**</font>
00710 <font class="comment">**     2. Works derived from this code are not distributed for</font>
00711 <font class="comment">**        commercial gain without explicit permission from MIT </font>
00712 <font class="comment">**        (for permission contact lclint-request@cs.virginia.edu).</font>
00713 <font class="comment">*/</font>
00714 <font class="comment">/*</font>
00715 <font class="comment"> * Modified by Herbert 08/19/97:</font>
00716 <font class="comment"> * - added #include for IBM's OS/2 compiler.</font>
00717 <font class="comment"> * - fixed weird bug with lookup of tmp files (OS/2 and MSDOS only).</font>
00718 <font class="comment"> */</font>
00719 <font class="comment">/*</font>
00720 <font class="comment"> * Modified by Mike Smith </font>
00721 <font class="comment"> * Corrected missing 'line' in scanf() calls in handleSpecial().</font>
00722 <font class="comment"> * Without this, I get an error when LCLint hits a '#line' directive</font>
00723 <font class="comment"> * in the pre-pre-processed source files. For safety, I have made these</font>
00724 <font class="comment"> * conditional on OS2 and MSDOS because I don't understand why noone else</font>
00725 <font class="comment"> * has seen this problem.</font>
00726 <font class="comment"> *</font>
00727 <font class="comment"> * Modified by Mike Smith, 4th June 1997</font>
00728 <font class="comment"> * Finally resolved the #line problem.  The scanf() calls have been fixed to</font>
00729 <font class="comment"> * allow the following #line forms:-</font>
00730 <font class="comment"> *</font>
00731 <font class="comment"> *        #line 123 "filename"</font>
00732 <font class="comment"> *        #line 123</font>
00733 <font class="comment"> *        # 123 "filename"</font>
00734 <font class="comment"> *        # 123</font>
00735 <font class="comment"> *</font>
00736 <font class="comment"> * The last two are generated by the GNU pre-processor, apparently</font>
00737 <font class="comment"> */</font>
00738 <font class="preprocessor">#line 56 "cscanner.l"</font>
00739 <font class="preprocessor"></font><font class="comment">/*</font>
00740 <font class="comment">** based on original C lexer by Nate Osgood</font>
00741 <font class="comment">**    from hacrat@catfish.lcs.mit.edu Mon Jun 14 13:06:32 1993</font>
00742 <font class="comment">**</font>
00743 <font class="comment">*/</font>
00744 
00745 <font class="preprocessor"># include "lclintMacros.nf"</font>
00746 <font class="preprocessor"># include "basic.h"</font>
00747 
00748 <font class="preprocessor"># include "cgrammar.h"</font>
00749 <font class="preprocessor"># include "cgrammar_tokens.h"</font>
00750 
00751 <font class="preprocessor"># include "fileIdList.h"</font>
00752 <font class="preprocessor"># include "portab.h"</font>
00753 
00754 <font class="preprocessor"># if defined(OS2) &amp;&amp; defined(__IBMC__)</font>
00755 <font class="preprocessor"></font>   <font class="comment">/* needed for isatty()... */</font>
00756 <font class="preprocessor"># include &lt;io.h&gt;</font>
00757 <font class="preprocessor"># endif</font>
00758 <font class="preprocessor"></font>
00759 <font class="keyword">static</font> <font class="keywordtype">bool</font> lastWasString = FALSE;
00760 <font class="keyword">static</font> <font class="keywordtype">char</font> savechar = <font class="charliteral">'\0'</font>;
00761 
00762 <font class="comment">/*@notfunction@*/</font>
<a name="l00763"></a><a class="code" href="lex_yy_c.html#a37">00763</a> <font class="preprocessor"># define yyinput() (incColumn (), getc (yyin))</font>
00764 <font class="preprocessor"></font>
00765 <font class="comment">/*@-noparams@*/</font>
00766 <font class="comment">/*@-incondefs@*/</font>
00767 <font class="keyword">extern</font> <font class="comment">/*@external@*/</font> <font class="keywordtype">int</font> <a class="code" href="lex_yy_c.html#a109">read</a> ();
00768 <font class="comment">/*@=incondefs@*/</font>
00769 <font class="comment">/*@=noparams@*/</font>
00770 
00771 <font class="keyword">static</font> <font class="comment">/*@owned@*/</font> cstring lastidprocessed = cstring_undefined;
00772 
00773 <font class="keyword">static</font> <font class="keywordtype">int</font> lminput (<font class="keywordtype">void</font>);
00774 <font class="keyword">static</font> <font class="keywordtype">int</font> tokLength = 0;
00775 <font class="keyword">static</font> <font class="keywordtype">bool</font> inSpecPart = FALSE;
00776 <font class="keyword">static</font> <font class="keywordtype">bool</font> continueLine = FALSE;
00777 
00778 <font class="keyword">static</font> <font class="keywordtype">int</font> ninput (<font class="keywordtype">void</font>);
00779 <font class="keyword">static</font> <font class="keywordtype">char</font> processChar (<font class="keywordtype">void</font>);
00780 <font class="keyword">static</font> <font class="keywordtype">double</font> processFloat (<font class="keywordtype">void</font>);
00781 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> exprNode processString (<font class="keywordtype">void</font>);
00782 <font class="keyword">static</font> <font class="keywordtype">long</font> processDec (<font class="keywordtype">void</font>);
00783 <font class="keyword">static</font> <font class="keywordtype">long</font> processHex (<font class="keywordtype">void</font>);
00784 <font class="keyword">static</font> <font class="keywordtype">long</font> processOctal (<font class="keywordtype">void</font>);
00785 <font class="keyword">static</font> <font class="keywordtype">int</font> processIdentifier (<font class="comment">/*@only@*/</font> cstring)
00786    <font class="comment">/*@globals undef lastidprocessed@*/</font> ;
00787 <font class="keyword">static</font> <font class="keywordtype">bool</font> processHashIdentifier (<font class="comment">/*@only@*/</font> cstring)
00788    <font class="comment">/*@globals undef lastidprocessed@*/</font> ;
00789 
00790 <font class="keyword">static</font> <font class="keywordtype">int</font> processSpec (<font class="keywordtype">int</font>);
00791 <font class="keyword">static</font> <font class="keywordtype">bool</font> handleSpecial (<font class="keywordtype">char</font> *);
00792 <font class="keyword">static</font> <font class="keywordtype">int</font> handleLlSpecial (<font class="keywordtype">void</font>);
00793 <font class="keyword">static</font> <font class="keywordtype">void</font> handleMacro (<font class="keywordtype">void</font>);
00794 <font class="keyword">static</font> <font class="keywordtype">bool</font> processMacro (<font class="keywordtype">void</font>);
00795 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring makeIdentifier (<font class="keywordtype">char</font> *);
00796 
00797 <font class="comment">/* yes, this is exported! */</font>
<a name="l00798"></a><a class="code" href="lex_yy_c.html#a88">00798</a> <font class="keywordtype">bool</font> g_expectingTypeName = TRUE; <font class="comment">/* beginning of file can be type name! */</font>
00799 
00800 <font class="keyword">static</font> <font class="keywordtype">int</font> returnInt (ctype, <font class="keywordtype">long</font>);
00801 <font class="keyword">static</font> <font class="keywordtype">int</font> returnFloat (ctype, <font class="keywordtype">double</font>);
00802 <font class="keyword">static</font> <font class="keywordtype">int</font> returnChar (<font class="keywordtype">char</font>);
00803 <font class="keyword">static</font> <font class="keywordtype">void</font> setTokLength (<font class="keywordtype">int</font>) <font class="comment">/*@modifies g_currentloc@*/</font> ;
00804 <font class="keyword">static</font> <font class="keywordtype">void</font> setTokLengthT (size_t) <font class="comment">/*@modifies g_currentloc@*/</font> ;
00805 
00806 <font class="keyword">static</font> <font class="keywordtype">void</font> advanceLine (<font class="keywordtype">void</font>)<font class="keyword"></font>
00807 <font class="keyword"></font>{
00808   tokLength = 0;
00809   beginLine ();
00810 }
00811     
00812 <font class="comment">/*@-allmacros@*/</font>
<a name="l00813"></a><a class="code" href="lex_yy_c.html#a38">00813</a> <font class="preprocessor"># define RETURN_INT(c,i) \</font>
00814 <font class="preprocessor">  do { lastWasString = FALSE; \</font>
00815 <font class="preprocessor">       return (returnInt (c, i)); } while (FALSE)</font>
00816 <font class="preprocessor"></font>
<a name="l00817"></a><a class="code" href="lex_yy_c.html#a39">00817</a> <font class="preprocessor"># define RETURN_FLOAT(c,f) \</font>
00818 <font class="preprocessor">  do { lastWasString = FALSE; \</font>
00819 <font class="preprocessor">       return (returnFloat (c, f)); \</font>
00820 <font class="preprocessor">       } while (FALSE)</font>
00821 <font class="preprocessor"></font>
<a name="l00822"></a><a class="code" href="lex_yy_c.html#a40">00822</a> <font class="preprocessor"># define RETURN_CHAR(c) \</font>
00823 <font class="preprocessor">  do { lastWasString = FALSE; \</font>
00824 <font class="preprocessor">       return (returnChar (c)); \</font>
00825 <font class="preprocessor">     } while (FALSE)</font>
00826 <font class="preprocessor"></font>
<a name="l00827"></a><a class="code" href="lex_yy_c.html#a41">00827</a> <font class="preprocessor"># define RETURN_TOK(t) \</font>
00828 <font class="preprocessor">  do { yylval.tok = lltok_create (t, fileloc_decColumn (g_currentloc, tokLength)); \</font>
00829 <font class="preprocessor">       tokLength = 0; \</font>
00830 <font class="preprocessor">       lastWasString = FALSE; \</font>
00831 <font class="preprocessor">       return (t); } while (FALSE)</font>
00832 <font class="preprocessor"></font>
<a name="l00833"></a><a class="code" href="lex_yy_c.html#a42">00833</a> <font class="preprocessor"># define RETURN_TYPE(t, ct) \</font>
00834 <font class="preprocessor">  do { yylval.ctyp = ct; tokLength = 0; return (t); } while (FALSE)</font>
00835 <font class="preprocessor"></font>
00836 <font class="comment">/* don't fileloc_decColumn (g_currentloc, tokLength));  </font>
00837 <font class="comment">   the string could have \n's in it!</font>
00838 <font class="comment">*/</font>
00839 
<a name="l00840"></a><a class="code" href="lex_yy_c.html#a43">00840</a> <font class="preprocessor"># define RETURN_STRING(c) \</font>
00841 <font class="preprocessor"> do { yylval.expr = exprNode_stringLiteral (c, fileloc_decColumn (g_currentloc, tokLength)); \</font>
00842 <font class="preprocessor">      tokLength = 0; \</font>
00843 <font class="preprocessor">      lastWasString = TRUE; \</font>
00844 <font class="preprocessor">      return (CCONSTANT); } while (FALSE)</font>
00845 <font class="preprocessor"></font>
<a name="l00846"></a><a class="code" href="lex_yy_c.html#a44">00846</a> <font class="preprocessor"># define RETURN_EXPR(e) \</font>
00847 <font class="preprocessor"> do { yylval.expr = e; \</font>
00848 <font class="preprocessor">      tokLength = 0; \</font>
00849 <font class="preprocessor">      lastWasString = TRUE; \</font>
00850 <font class="preprocessor">      return (CCONSTANT); } while (FALSE)</font>
00851 <font class="preprocessor"></font>
00852 <font class="comment">/*@=allmacros@*/</font>
00853 
00854 <font class="keyword">static</font> <font class="keywordtype">void</font> setTokLength (<font class="keywordtype">int</font> len)<font class="keyword"> </font>
00855 <font class="keyword"></font>{
00856   addColumn (len);
00857   tokLength = len;
00858 }
00859 
00860 <font class="keyword">static</font> <font class="keywordtype">void</font> setTokLengthT (size_t len)<font class="keyword"></font>
00861 <font class="keyword"></font>{
00862   setTokLength (size_toInt (len));
00863 }
00864 
00865 <font class="preprocessor"># include "flex.head"</font>
00866 <font class="preprocessor">#line 867 "lex.yy.c"</font>
00867 <font class="preprocessor"></font>
00868 <font class="comment">/* Macros after this point can all be overridden by user definitions in</font>
00869 <font class="comment"> * section 1.</font>
00870 <font class="comment"> */</font>
00871 
00872 <font class="preprocessor">#ifndef YY_SKIP_YYWRAP</font>
00873 <font class="preprocessor"></font><font class="preprocessor">#ifdef __cplusplus</font>
00874 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="stringliteral">"C"</font> <font class="keywordtype">int</font> yywrap <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00875 <font class="preprocessor">#else</font>
00876 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="keywordtype">int</font> yywrap <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00877 <font class="preprocessor">#endif</font>
00878 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00879 <font class="preprocessor"></font>
00880 <font class="preprocessor">#ifndef YY_NO_UNPUT</font>
00881 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yyunput <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">int</font> c, <font class="keywordtype">char</font> *buf_ptr ));
00882 <font class="preprocessor">#endif</font>
00883 <font class="preprocessor"></font>
00884 <font class="preprocessor">#ifndef yytext_ptr</font>
00885 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_strncpy <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">char</font> *, yyconst <font class="keywordtype">char</font> *, <font class="keywordtype">int</font> ));
00886 <font class="preprocessor">#endif</font>
00887 <font class="preprocessor"></font>
00888 <font class="preprocessor">#ifdef YY_NEED_STRLEN</font>
00889 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_flex_strlen <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( yyconst <font class="keywordtype">char</font> * ));
00890 <font class="preprocessor">#endif</font>
00891 <font class="preprocessor"></font>
00892 <font class="preprocessor">#ifndef YY_NO_INPUT</font>
00893 <font class="preprocessor"></font><font class="preprocessor">#ifdef __cplusplus</font>
00894 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yyinput <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00895 <font class="preprocessor">#else</font>
00896 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> input <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00897 <font class="preprocessor">#endif</font>
00898 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00899 <font class="preprocessor"></font>
00900 <font class="preprocessor">#if YY_STACK_USED</font>
00901 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_start_stack_ptr = 0;
00902 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_start_stack_depth = 0;
00903 <font class="keyword">static</font> <font class="keywordtype">int</font> *yy_start_stack = 0;
00904 <font class="preprocessor">#ifndef YY_NO_PUSH_STATE</font>
00905 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_push_state <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">int</font> new_state ));
00906 <font class="preprocessor">#endif</font>
00907 <font class="preprocessor"></font><font class="preprocessor">#ifndef YY_NO_POP_STATE</font>
00908 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_pop_state <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00909 <font class="preprocessor">#endif</font>
00910 <font class="preprocessor"></font><font class="preprocessor">#ifndef YY_NO_TOP_STATE</font>
00911 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_top_state <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">void</font> ));
00912 <font class="preprocessor">#endif</font>
00913 <font class="preprocessor"></font>
00914 <font class="preprocessor">#else</font>
<a name="l00915"></a><a class="code" href="lex_yy_c.html#a45">00915</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_NO_PUSH_STATE 1</font>
<a name="l00916"></a><a class="code" href="lex_yy_c.html#a46">00916</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_NO_POP_STATE 1</font>
<a name="l00917"></a><a class="code" href="lex_yy_c.html#a47">00917</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_NO_TOP_STATE 1</font>
00918 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00919 <font class="preprocessor"></font>
00920 <font class="preprocessor">#ifdef YY_MALLOC_DECL</font>
00921 <font class="preprocessor"></font>YY_MALLOC_DECL
00922 <font class="preprocessor">#else</font>
00923 <font class="preprocessor"></font><font class="preprocessor">#if __STDC__</font>
00924 <font class="preprocessor"></font><font class="preprocessor">#ifndef __cplusplus</font>
00925 <font class="preprocessor"></font><font class="preprocessor">#include &lt;stdlib.h&gt;</font>
00926 <font class="preprocessor">#endif</font>
00927 <font class="preprocessor"></font><font class="preprocessor">#else</font>
00928 <font class="preprocessor"></font><font class="comment">/* Just try to get by without declaring the routines.  This will fail</font>
00929 <font class="comment"> * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)</font>
00930 <font class="comment"> * or sizeof(void*) != sizeof(int).</font>
00931 <font class="comment"> */</font>
00932 <font class="preprocessor">#endif</font>
00933 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00934 <font class="preprocessor"></font>
00935 <font class="comment">/* Amount of stuff to slurp up with each read. */</font>
00936 <font class="preprocessor">#ifndef YY_READ_BUF_SIZE</font>
<a name="l00937"></a><a class="code" href="lex_yy_c.html#a48">00937</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_READ_BUF_SIZE 8192</font>
00938 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00939 <font class="preprocessor"></font>
00940 <font class="comment">/* Copy whatever the last rule matched to the standard output. */</font>
00941 
00942 <font class="preprocessor">#ifndef ECHO</font>
00943 <font class="preprocessor"></font><font class="comment">/* This used to be an fputs(), but since the string might contain NUL's,</font>
00944 <font class="comment"> * we now use fwrite().</font>
00945 <font class="comment"> */</font>
<a name="l00946"></a><a class="code" href="lex_yy_c.html#a49">00946</a> <font class="preprocessor">#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )</font>
00947 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00948 <font class="preprocessor"></font>
00949 <font class="comment">/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</font>
00950 <font class="comment"> * is returned in "result".</font>
00951 <font class="comment"> */</font>
00952 <font class="preprocessor">#ifndef YY_INPUT</font>
<a name="l00953"></a><a class="code" href="lex_yy_c.html#a50">00953</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_INPUT(buf,result,max_size) \</font>
00954 <font class="preprocessor">        if ( yy_current_buffer-&gt;yy_is_interactive ) \</font>
00955 <font class="preprocessor">                { \</font>
00956 <font class="preprocessor">                int c = '*', n; \</font>
00957 <font class="preprocessor">                for ( n = 0; n &lt; max_size &amp;&amp; \</font>
00958 <font class="preprocessor">                             (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) \</font>
00959 <font class="preprocessor">                        buf[n] = (char) c; \</font>
00960 <font class="preprocessor">                if ( c == '\n' ) \</font>
00961 <font class="preprocessor">                        buf[n++] = (char) c; \</font>
00962 <font class="preprocessor">                if ( c == EOF &amp;&amp; ferror( yyin ) ) \</font>
00963 <font class="preprocessor">                        YY_FATAL_ERROR( "input in flex scanner failed" ); \</font>
00964 <font class="preprocessor">                result = n; \</font>
00965 <font class="preprocessor">                } \</font>
00966 <font class="preprocessor">        else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \</font>
00967 <font class="preprocessor">                  &amp;&amp; ferror( yyin ) ) \</font>
00968 <font class="preprocessor">                YY_FATAL_ERROR( "input in flex scanner failed" );</font>
00969 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00970 <font class="preprocessor"></font>
00971 <font class="comment">/* No semi-colon after return; correct usage is to write "yyterminate();" -</font>
00972 <font class="comment"> * we don't want an extra ';' after the "return" because that will cause</font>
00973 <font class="comment"> * some compilers to complain about unreachable statements.</font>
00974 <font class="comment"> */</font>
00975 <font class="preprocessor">#ifndef yyterminate</font>
<a name="l00976"></a><a class="code" href="lex_yy_c.html#a51">00976</a> <font class="preprocessor"></font><font class="preprocessor">#define yyterminate() return YY_NULL</font>
00977 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00978 <font class="preprocessor"></font>
00979 <font class="comment">/* Number of entries by which start-condition stack grows. */</font>
00980 <font class="preprocessor">#ifndef YY_START_STACK_INCR</font>
<a name="l00981"></a><a class="code" href="lex_yy_c.html#a52">00981</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_START_STACK_INCR 25</font>
00982 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00983 <font class="preprocessor"></font>
00984 <font class="comment">/* Report a fatal error. */</font>
00985 <font class="preprocessor">#ifndef YY_FATAL_ERROR</font>
<a name="l00986"></a><a class="code" href="lex_yy_c.html#a53">00986</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</font>
00987 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00988 <font class="preprocessor"></font>
00989 <font class="comment">/* Default declaration of generated scanner - a define so the user can</font>
00990 <font class="comment"> * easily add parameters.</font>
00991 <font class="comment"> */</font>
00992 <font class="preprocessor">#ifndef YY_DECL</font>
<a name="l00993"></a><a class="code" href="lex_yy_c.html#a54">00993</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_DECL int yylex YY_PROTO(( void ))</font>
00994 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00995 <font class="preprocessor"></font>
00996 <font class="comment">/* Code executed at the beginning of each rule, after yytext and yyleng</font>
00997 <font class="comment"> * have been set up.</font>
00998 <font class="comment"> */</font>
00999 <font class="preprocessor">#ifndef YY_USER_ACTION</font>
01000 <font class="preprocessor"></font><font class="preprocessor">#define YY_USER_ACTION</font>
01001 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
01002 <font class="preprocessor"></font>
01003 <font class="comment">/* Code executed at the end of each rule. */</font>
01004 <font class="preprocessor">#ifndef YY_BREAK</font>
<a name="l01005"></a><a class="code" href="lex_yy_c.html#a55">01005</a> <font class="preprocessor"></font><font class="preprocessor">#define YY_BREAK break;</font>
01006 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
01007 <font class="preprocessor"></font>
<a name="l01008"></a><a class="code" href="lex_yy_c.html#a56">01008</a> <font class="preprocessor">#define YY_RULE_SETUP \</font>
01009 <font class="preprocessor">        YY_USER_ACTION</font>
01010 <font class="preprocessor"></font>
01011 YY_DECL
01012         {
01013         <font class="keyword">register</font> yy_state_type yy_current_state;
01014         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp, *yy_bp;
01015         <font class="keyword">register</font> <font class="keywordtype">int</font> yy_act;
01016 
01017 <font class="preprocessor">#line 185 "cscanner.l"</font>
01018 <font class="preprocessor"></font>
01019 
01020 <font class="preprocessor">#line 1021 "lex.yy.c"</font>
01021 <font class="preprocessor"></font>
01022         <font class="keywordflow">if</font> ( yy_init )
01023                 {
01024                 yy_init = 0;
01025 
01026 <font class="preprocessor">#ifdef YY_USER_INIT</font>
01027 <font class="preprocessor"></font>                YY_USER_INIT;
01028 <font class="preprocessor">#endif</font>
01029 <font class="preprocessor"></font>
01030                 <font class="keywordflow">if</font> ( ! yy_start )
01031                         yy_start = 1;   <font class="comment">/* first start state */</font>
01032 
01033                 <font class="keywordflow">if</font> ( ! yyin )
01034                         yyin = stdin;
01035 
01036                 <font class="keywordflow">if</font> ( ! yyout )
01037                         yyout = stdout;
01038 
01039                 <font class="keywordflow">if</font> ( ! yy_current_buffer )
01040                         yy_current_buffer =
01041                                 yy_create_buffer( yyin, YY_BUF_SIZE );
01042 
01043                 yy_load_buffer_state();
01044                 }
01045 
01046         <font class="keywordflow">while</font> ( 1 )             <font class="comment">/* loops until end-of-file is reached */</font>
01047                 {
01048                 yy_cp = yy_c_buf_p;
01049 
01050                 <font class="comment">/* Support of yytext. */</font>
01051                 *yy_cp = yy_hold_char;
01052 
01053                 <font class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</font>
01054 <font class="comment">                 * the current run.</font>
01055 <font class="comment">                 */</font>
01056                 yy_bp = yy_cp;
01057 
01058                 yy_current_state = yy_start;
01059 yy_match:
01060                 <font class="keywordflow">do</font>
01061                         {
01062                         <font class="keyword">register</font> YY_CHAR yy_c = yy_ec[<a class="code" href="lex_yy_c.html#a6">YY_SC_TO_UI</a>(*yy_cp)];
01063                         <font class="keywordflow">if</font> ( yy_accept[yy_current_state] )
01064                                 {
01065                                 yy_last_accepting_state = yy_current_state;
01066                                 yy_last_accepting_cpos = yy_cp;
01067                                 }
01068                         <font class="keywordflow">while</font> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
01069                                 {
01070                                 yy_current_state = (<font class="keywordtype">int</font>) yy_def[yy_current_state];
01071                                 <font class="keywordflow">if</font> ( yy_current_state &gt;= 509 )
01072                                         yy_c = yy_meta[(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
01073                                 }
01074                         yy_current_state = yy_nxt[yy_base[yy_current_state] + (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
01075                         ++yy_cp;
01076                         }
01077                 <font class="keywordflow">while</font> ( yy_base[yy_current_state] != 660 );
01078 
01079 yy_find_action:
01080                 yy_act = yy_accept[yy_current_state];
01081                 <font class="keywordflow">if</font> ( yy_act == 0 )
01082                         { <font class="comment">/* have to back up */</font>
01083                         yy_cp = yy_last_accepting_cpos;
01084                         yy_current_state = yy_last_accepting_state;
01085                         yy_act = yy_accept[yy_current_state];
01086                         }
01087 
01088                 YY_DO_BEFORE_ACTION;
01089 
01090 
01091 do_action:      <font class="comment">/* This label is used only to access EOF actions. */</font>
01092 
01093 
01094                 <font class="keywordflow">switch</font> ( yy_act )
01095         { <font class="comment">/* beginning of action switch */</font>
01096                         <font class="keywordflow">case</font> 0: <font class="comment">/* must back up */</font>
01097                         <font class="comment">/* undo the effects of YY_DO_BEFORE_ACTION */</font>
01098                         *yy_cp = yy_hold_char;
01099                         yy_cp = yy_last_accepting_cpos;
01100                         yy_current_state = yy_last_accepting_state;
01101                         <font class="keywordflow">goto</font> yy_find_action;
01102 
01103 <font class="keywordflow">case</font> 1:
01104 YY_RULE_SETUP
01105 <font class="preprocessor">#line 187 "cscanner.l"</font>
01106 <font class="preprocessor"></font>{ <a class="code" href="llerror_c.html#a43">llfatalbug</a> (cstring_makeLiteral (<font class="stringliteral">"Comment in pre-processor output"</font>)); }
01107         YY_BREAK
01108 <font class="keywordflow">case</font> 2:
01109 YY_RULE_SETUP
01110 <font class="preprocessor">#line 189 "cscanner.l"</font>
01111 <font class="preprocessor"></font>{ 
01112                  <a class="code" href="context_c.html#a182">context_saveLocation</a> (); 
01113                  setTokLength (longUnsigned_toInt (mstring_length (yytext))); 
01114 
01115                  <font class="keywordflow">if</font> (processHashIdentifier (makeIdentifier (yytext + 1)))
01116                    {
01117                      <font class="keywordflow">if</font> (lastWasString)
01118                        {
01119                          ;
01120                        }
01121                      <font class="keywordflow">else</font>
01122                        {
01123                          <a class="code" href="lex_yy_c.html#a43">RETURN_STRING</a> (cstring_makeLiteral (<font class="stringliteral">"\"\""</font>));
01124                        }
01125                    }
01126                  <font class="keywordflow">else</font>
01127                    { 
01128                      <font class="keywordflow">if</font> (handleSpecial (yytext)) 
01129                        { 
01130                          setTokLength (1); 
01131                          <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (0); 
01132                        }
01133                    }
01134                 } 
01135         YY_BREAK
01136 <font class="keywordflow">case</font> 3:
01137 YY_RULE_SETUP
01138 <font class="preprocessor">#line 213 "cscanner.l"</font>
01139 <font class="preprocessor"></font>{ <font class="keywordflow">if</font> (handleSpecial (yytext)) 
01140                     { 
01141                        setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (0); 
01142                      }
01143                 }
01144         YY_BREAK
01145 <font class="keywordflow">case</font> 4:
01146 YY_RULE_SETUP
01147 <font class="preprocessor">#line 218 "cscanner.l"</font>
01148 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CTOK_ELIPSIS); }
01149         YY_BREAK
01150 <font class="keywordflow">case</font> 5:
01151 YY_RULE_SETUP
01152 <font class="preprocessor">#line 219 "cscanner.l"</font>
01153 <font class="preprocessor"></font>{ setTokLength (5); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (BREAK); }
01154         YY_BREAK
01155 <font class="keywordflow">case</font> 6:
01156 YY_RULE_SETUP
01157 <font class="preprocessor">#line 220 "cscanner.l"</font>
01158 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CASE); }
01159         YY_BREAK
01160 <font class="keywordflow">case</font> 7:
01161 YY_RULE_SETUP
01162 <font class="preprocessor">#line 221 "cscanner.l"</font>
01163 <font class="preprocessor"></font>{ setTokLength (8); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CONTINUE); }
01164         YY_BREAK
01165 <font class="keywordflow">case</font> 8:
01166 YY_RULE_SETUP
01167 <font class="preprocessor">#line 222 "cscanner.l"</font>
01168 <font class="preprocessor"></font>{ setTokLength (7); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (DEFAULT); }
01169         YY_BREAK
01170 <font class="keywordflow">case</font> 9:
01171 YY_RULE_SETUP
01172 <font class="preprocessor">#line 223 "cscanner.l"</font>
01173 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (DO); }
01174         YY_BREAK
01175 <font class="keywordflow">case</font> 10:
01176 YY_RULE_SETUP
01177 <font class="preprocessor">#line 224 "cscanner.l"</font>
01178 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CELSE); }
01179         YY_BREAK
01180 <font class="keywordflow">case</font> 11:
01181 YY_RULE_SETUP
01182 <font class="preprocessor">#line 225 "cscanner.l"</font>
01183 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CFOR); }
01184         YY_BREAK
01185 <font class="keywordflow">case</font> 12:
01186 YY_RULE_SETUP
01187 <font class="preprocessor">#line 226 "cscanner.l"</font>
01188 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (GOTO); }
01189         YY_BREAK
01190 <font class="keywordflow">case</font> 13:
01191 YY_RULE_SETUP
01192 <font class="preprocessor">#line 227 "cscanner.l"</font>
01193 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CIF); }
01194         YY_BREAK
01195 <font class="keywordflow">case</font> 14:
01196 YY_RULE_SETUP
01197 <font class="preprocessor">#line 228 "cscanner.l"</font>
01198 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (RETURN); }
01199         YY_BREAK
01200 <font class="keywordflow">case</font> 15:
01201 YY_RULE_SETUP
01202 <font class="preprocessor">#line 229 "cscanner.l"</font>
01203 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CSIZEOF); }
01204         YY_BREAK
01205 <font class="keywordflow">case</font> 16:
01206 YY_RULE_SETUP
01207 <font class="preprocessor">#line 230 "cscanner.l"</font>
01208 <font class="preprocessor"></font>{ setTokLength (8); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (COFFSETOF); }
01209         YY_BREAK
01210 <font class="keywordflow">case</font> 17:
01211 YY_RULE_SETUP
01212 <font class="preprocessor">#line 231 "cscanner.l"</font>
01213 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (SWITCH); }
01214         YY_BREAK
01215 <font class="keywordflow">case</font> 18:
01216 YY_RULE_SETUP
01217 <font class="preprocessor">#line 232 "cscanner.l"</font>
01218 <font class="preprocessor"></font>{ setTokLength (5); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (WHILE); }
01219         YY_BREAK
01220 <font class="keywordflow">case</font> 19:
01221 YY_RULE_SETUP
01222 <font class="preprocessor">#line 233 "cscanner.l"</font>
01223 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (VA_ARG); }   
01224         YY_BREAK
01225 <font class="keywordflow">case</font> 20:
01226 YY_RULE_SETUP
01227 <font class="preprocessor">#line 234 "cscanner.l"</font>
01228 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (VA_DCL); }   
01229         YY_BREAK
01230 <font class="keywordflow">case</font> 21:
01231 YY_RULE_SETUP
01232 <font class="preprocessor">#line 235 "cscanner.l"</font>
01233 <font class="preprocessor"></font>{ 
01234                   <font class="comment">/* gcc extension...this might not be appropriate */</font>
01235                   setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QINLINE); }
01236         YY_BREAK
01237 <font class="keywordflow">case</font> 22:
01238 YY_RULE_SETUP
01239 <font class="preprocessor">#line 239 "cscanner.l"</font>
01240 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CSTRUCT); }  
01241         YY_BREAK
01242 <font class="keywordflow">case</font> 23:
01243 YY_RULE_SETUP
01244 <font class="preprocessor">#line 240 "cscanner.l"</font>
01245 <font class="preprocessor"></font>{ setTokLength (7); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CTYPEDEF); }
01246         YY_BREAK
01247 <font class="keywordflow">case</font> 24:
01248 YY_RULE_SETUP
01249 <font class="preprocessor">#line 242 "cscanner.l"</font>
01250 <font class="preprocessor"></font>{ setTokLength (5); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CUNION); }
01251         YY_BREAK
01252 <font class="keywordflow">case</font> 25:
01253 YY_RULE_SETUP
01254 <font class="preprocessor">#line 243 "cscanner.l"</font>
01255 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (CENUM); }
01256         YY_BREAK
01257 <font class="keywordflow">case</font> 26:
01258 YY_RULE_SETUP
01259 <font class="preprocessor">#line 245 "cscanner.l"</font>
01260 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a42">RETURN_TYPE</a> (CVOID, ctype_void); }
01261         YY_BREAK
01262 <font class="keywordflow">case</font> 27:
01263 YY_RULE_SETUP
01264 <font class="preprocessor">#line 246 "cscanner.l"</font>
01265 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="lex_yy_c.html#a42">RETURN_TYPE</a> (CINT, ctype_int); }
01266         YY_BREAK
01267 <font class="keywordflow">case</font> 28:
01268 YY_RULE_SETUP
01269 <font class="preprocessor">#line 247 "cscanner.l"</font>
01270 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a42">RETURN_TYPE</a> (CDOUBLE, ctype_double); }
01271         YY_BREAK
01272 <font class="keywordflow">case</font> 29:
01273 YY_RULE_SETUP
01274 <font class="preprocessor">#line 248 "cscanner.l"</font>
01275 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a42">RETURN_TYPE</a> (CGCHAR, ctype_char); }
01276         YY_BREAK
01277 <font class="keywordflow">case</font> 30:
01278 YY_RULE_SETUP
01279 <font class="preprocessor">#line 249 "cscanner.l"</font>
01280 <font class="preprocessor"></font>{ setTokLength (5); <a class="code" href="lex_yy_c.html#a42">RETURN_TYPE</a> (CGFLOAT, ctype_float); }
01281         YY_BREAK
01282 <font class="keywordflow">case</font> 31:
01283 YY_RULE_SETUP
01284 <font class="preprocessor">#line 251 "cscanner.l"</font>
01285 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QLONG); }
01286         YY_BREAK
01287 <font class="keywordflow">case</font> 32:
01288 YY_RULE_SETUP
01289 <font class="preprocessor">#line 252 "cscanner.l"</font>
01290 <font class="preprocessor"></font>{ setTokLength (5); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QSHORT); }
01291         YY_BREAK
01292 <font class="keywordflow">case</font> 33:
01293 YY_RULE_SETUP
01294 <font class="preprocessor">#line 253 "cscanner.l"</font>
01295 <font class="preprocessor"></font>{ setTokLength (8); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QUNSIGNED); }
01296         YY_BREAK
01297 <font class="keywordflow">case</font> 34:
01298 YY_RULE_SETUP
01299 <font class="preprocessor">#line 254 "cscanner.l"</font>
01300 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QSIGNED); }
01301         YY_BREAK
01302 <font class="keywordflow">case</font> 35:
01303 YY_RULE_SETUP
01304 <font class="preprocessor">#line 256 "cscanner.l"</font>
01305 <font class="preprocessor"></font>{ setTokLength (8); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QVOLATILE); }
01306         YY_BREAK
01307 <font class="keywordflow">case</font> 36:
01308 YY_RULE_SETUP
01309 <font class="preprocessor">#line 257 "cscanner.l"</font>
01310 <font class="preprocessor"></font>{ setTokLength (5); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QCONST); }
01311         YY_BREAK
01312 <font class="comment">/* some systems expect this! [gack!] */</font> 
01313 <font class="keywordflow">case</font> 37:
01314 YY_RULE_SETUP
01315 <font class="preprocessor">#line 260 "cscanner.l"</font>
01316 <font class="preprocessor"></font>{ setTokLength (7); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QCONST); }
01317         YY_BREAK
01318 <font class="keywordflow">case</font> 38:
01319 YY_RULE_SETUP
01320 <font class="preprocessor">#line 262 "cscanner.l"</font>
01321 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QEXTERN); }
01322         YY_BREAK
01323 <font class="keywordflow">case</font> 39:
01324 YY_RULE_SETUP
01325 <font class="preprocessor">#line 263 "cscanner.l"</font>
01326 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QAUTO); }
01327         YY_BREAK
01328 <font class="keywordflow">case</font> 40:
01329 YY_RULE_SETUP
01330 <font class="preprocessor">#line 264 "cscanner.l"</font>
01331 <font class="preprocessor"></font>{ setTokLength (8); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QREGISTER); }
01332         YY_BREAK
01333 <font class="keywordflow">case</font> 41:
01334 YY_RULE_SETUP
01335 <font class="preprocessor">#line 265 "cscanner.l"</font>
01336 <font class="preprocessor"></font>{ setTokLength (6); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QSTATIC); }
01337         YY_BREAK
01338 <font class="keywordflow">case</font> 42:
01339 YY_RULE_SETUP
01340 <font class="preprocessor">#line 267 "cscanner.l"</font>
01341 <font class="preprocessor"></font>{ <a class="code" href="lex_yy_c.html#a44">RETURN_EXPR</a> (processString ()); }
01342         YY_BREAK
01343 <font class="keywordflow">case</font> 43:
01344 YY_RULE_SETUP
01345 <font class="preprocessor">#line 268 "cscanner.l"</font>
01346 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QOUT)); }
01347         YY_BREAK
01348 <font class="keywordflow">case</font> 44:
01349 YY_RULE_SETUP
01350 <font class="preprocessor">#line 269 "cscanner.l"</font>
01351 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QIN)); }
01352         YY_BREAK
01353 <font class="keywordflow">case</font> 45:
01354 YY_RULE_SETUP
01355 <font class="preprocessor">#line 270 "cscanner.l"</font>
01356 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QPARTIAL)); }
01357         YY_BREAK
01358 <font class="keywordflow">case</font> 46:
01359 YY_RULE_SETUP
01360 <font class="preprocessor">#line 271 "cscanner.l"</font>
01361 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QSPECIAL)); }
01362         YY_BREAK
01363 <font class="keywordflow">case</font> 47:
01364 YY_RULE_SETUP
01365 <font class="preprocessor">#line 272 "cscanner.l"</font>
01366 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QANYTYPE)); }
01367         YY_BREAK
01368 <font class="keywordflow">case</font> 48:
01369 YY_RULE_SETUP
01370 <font class="preprocessor">#line 273 "cscanner.l"</font>
01371 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QINTEGRALTYPE)); }
01372         YY_BREAK
01373 <font class="keywordflow">case</font> 49:
01374 YY_RULE_SETUP
01375 <font class="preprocessor">#line 274 "cscanner.l"</font>
01376 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QUNSIGNEDINTEGRALTYPE)); }
01377         YY_BREAK
01378 <font class="keywordflow">case</font> 50:
01379 YY_RULE_SETUP
01380 <font class="preprocessor">#line 275 "cscanner.l"</font>
01381 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QSIGNEDINTEGRALTYPE)); }
01382         YY_BREAK
01383 <font class="keywordflow">case</font> 51:
01384 YY_RULE_SETUP
01385 <font class="preprocessor">#line 276 "cscanner.l"</font>
01386 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QKEEP)); }
01387         YY_BREAK
01388 <font class="keywordflow">case</font> 52:
01389 YY_RULE_SETUP
01390 <font class="preprocessor">#line 277 "cscanner.l"</font>
01391 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QNULL)); } 
01392         YY_BREAK
01393 <font class="keywordflow">case</font> 53:
01394 YY_RULE_SETUP
01395 <font class="preprocessor">#line 278 "cscanner.l"</font>
01396 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QNOTNULL)); } 
01397         YY_BREAK
01398 <font class="keywordflow">case</font> 54:
01399 YY_RULE_SETUP
01400 <font class="preprocessor">#line 279 "cscanner.l"</font>
01401 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QISNULL)); } 
01402         YY_BREAK
01403 <font class="keywordflow">case</font> 55:
01404 YY_RULE_SETUP
01405 <font class="preprocessor">#line 280 "cscanner.l"</font>
01406 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QTRUENULL)); } 
01407         YY_BREAK
01408 <font class="keywordflow">case</font> 56:
01409 YY_RULE_SETUP
01410 <font class="preprocessor">#line 281 "cscanner.l"</font>
01411 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QFALSENULL)); } 
01412         YY_BREAK
01413 <font class="keywordflow">case</font> 57:
01414 YY_RULE_SETUP
01415 <font class="preprocessor">#line 282 "cscanner.l"</font>
01416 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QRELNULL)); }
01417         YY_BREAK
01418 <font class="keywordflow">case</font> 58:
01419 YY_RULE_SETUP
01420 <font class="preprocessor">#line 283 "cscanner.l"</font>
01421 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QRELDEF)); }
01422         YY_BREAK
01423 <font class="keywordflow">case</font> 59:
01424 YY_RULE_SETUP
01425 <font class="preprocessor">#line 284 "cscanner.l"</font>
01426 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QEXPOSED)); }
01427         YY_BREAK
01428 <font class="keywordflow">case</font> 60:
01429 YY_RULE_SETUP
01430 <font class="preprocessor">#line 285 "cscanner.l"</font>
01431 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QNEWREF)); }
01432         YY_BREAK
01433 <font class="keywordflow">case</font> 61:
01434 YY_RULE_SETUP
01435 <font class="preprocessor">#line 286 "cscanner.l"</font>
01436 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QTEMPREF)); }
01437         YY_BREAK
01438 <font class="keywordflow">case</font> 62:
01439 YY_RULE_SETUP
01440 <font class="preprocessor">#line 287 "cscanner.l"</font>
01441 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QKILLREF)); }
01442         YY_BREAK
01443 <font class="keywordflow">case</font> 63:
01444 YY_RULE_SETUP
01445 <font class="preprocessor">#line 288 "cscanner.l"</font>
01446 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QREFCOUNTED)); }
01447         YY_BREAK
01448 <font class="keywordflow">case</font> 64:
01449 YY_RULE_SETUP
01450 <font class="preprocessor">#line 289 "cscanner.l"</font>
01451 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QCHECKED)); }
01452         YY_BREAK
01453 <font class="keywordflow">case</font> 65:
01454 YY_RULE_SETUP
01455 <font class="preprocessor">#line 290 "cscanner.l"</font>
01456 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QCHECKMOD)); }
01457         YY_BREAK
01458 <font class="keywordflow">case</font> 66:
01459 YY_RULE_SETUP
01460 <font class="preprocessor">#line 291 "cscanner.l"</font>
01461 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QCHECKEDSTRICT)); }
01462         YY_BREAK
01463 <font class="keywordflow">case</font> 67:
01464 YY_RULE_SETUP
01465 <font class="preprocessor">#line 292 "cscanner.l"</font>
01466 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QUNCHECKED)); }
01467         YY_BREAK
01468 <font class="keywordflow">case</font> 68:
01469 YY_RULE_SETUP
01470 <font class="preprocessor">#line 293 "cscanner.l"</font>
01471 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QONLY)); }
01472         YY_BREAK
01473 <font class="keywordflow">case</font> 69:
01474 YY_RULE_SETUP
01475 <font class="preprocessor">#line 294 "cscanner.l"</font>
01476 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QOWNED)); }
01477         YY_BREAK
01478 <font class="keywordflow">case</font> 70:
01479 YY_RULE_SETUP
01480 <font class="preprocessor">#line 295 "cscanner.l"</font>
01481 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QOBSERVER)); }
01482         YY_BREAK
01483 <font class="keywordflow">case</font> 71:
01484 YY_RULE_SETUP
01485 <font class="preprocessor">#line 296 "cscanner.l"</font>
01486 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QDEPENDENT)); }
01487         YY_BREAK
01488 <font class="keywordflow">case</font> 72:
01489 YY_RULE_SETUP
01490 <font class="preprocessor">#line 297 "cscanner.l"</font>
01491 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QUNUSED)); }
01492         YY_BREAK
01493 <font class="keywordflow">case</font> 73:
01494 YY_RULE_SETUP
01495 <font class="preprocessor">#line 298 "cscanner.l"</font>
01496 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QEXTERNAL)); }
01497         YY_BREAK
01498 <font class="keywordflow">case</font> 74:
01499 YY_RULE_SETUP
01500 <font class="preprocessor">#line 299 "cscanner.l"</font>
01501 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QSEF)); }
01502         YY_BREAK
01503 <font class="keywordflow">case</font> 75:
01504 YY_RULE_SETUP
01505 <font class="preprocessor">#line 300 "cscanner.l"</font>
01506 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QSHARED)); }
01507         YY_BREAK
01508 <font class="keywordflow">case</font> 76:
01509 YY_RULE_SETUP
01510 <font class="preprocessor">#line 301 "cscanner.l"</font>
01511 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QYIELD)); }
01512         YY_BREAK
01513 <font class="keywordflow">case</font> 77:
01514 YY_RULE_SETUP
01515 <font class="preprocessor">#line 302 "cscanner.l"</font>
01516 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QUNDEF)); }
01517         YY_BREAK
01518 <font class="keywordflow">case</font> 78:
01519 YY_RULE_SETUP
01520 <font class="preprocessor">#line 303 "cscanner.l"</font>
01521 <font class="preprocessor"></font>{ <font class="keywordflow">return</font> (processSpec (QKILLED)); }
01522         YY_BREAK
01523 <font class="keywordflow">case</font> 79:
01524 YY_RULE_SETUP
01525 <font class="preprocessor">#line 304 "cscanner.l"</font>
01526 <font class="preprocessor"></font>{ <font class="keywordtype">int</font> tok; 
01527                               <a class="code" href="context_c.html#a182">context_saveLocation</a> (); 
01528                               setTokLength (longUnsigned_toInt (mstring_length (yytext))); 
01529                               tok = processIdentifier (makeIdentifier (yytext)); 
01530                               <font class="keywordflow">if</font> (tok != BADTOK)
01531                                 {
01532                                   <font class="keywordflow">return</font> (tok);
01533                                 }
01534                             }
01535         YY_BREAK
01536 <font class="keywordflow">case</font> 80:
01537 YY_RULE_SETUP
01538 <font class="preprocessor">#line 313 "cscanner.l"</font>
01539 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01540                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_int, processHex ());  <font class="comment">/* evs 2000-05-17 was ctype_uint */</font>
01541                         }
01542         YY_BREAK
01543 <font class="keywordflow">case</font> 81:
01544 YY_RULE_SETUP
01545 <font class="preprocessor">#line 316 "cscanner.l"</font>
01546 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01547                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_lint, processHex ()); }
01548         YY_BREAK
01549 <font class="keywordflow">case</font> 82:
01550 YY_RULE_SETUP
01551 <font class="preprocessor">#line 318 "cscanner.l"</font>
01552 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01553                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_llint, processHex ()); }
01554         YY_BREAK
01555 <font class="keywordflow">case</font> 83:
01556 YY_RULE_SETUP
01557 <font class="preprocessor">#line 320 "cscanner.l"</font>
01558 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01559                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_uint, processHex ()); }
01560         YY_BREAK
01561 <font class="keywordflow">case</font> 84:
01562 YY_RULE_SETUP
01563 <font class="preprocessor">#line 322 "cscanner.l"</font>
01564 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01565                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ulint, processHex ()); }
01566         YY_BREAK
01567 <font class="keywordflow">case</font> 85:
01568 YY_RULE_SETUP
01569 <font class="preprocessor">#line 324 "cscanner.l"</font>
01570 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01571                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ullint, processHex ()); }
01572         YY_BREAK
01573 <font class="keywordflow">case</font> 86:
01574 YY_RULE_SETUP
01575 <font class="preprocessor">#line 326 "cscanner.l"</font>
01576 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01577                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ullint, processHex ()); }
01578         YY_BREAK
01579 <font class="keywordflow">case</font> 87:
01580 YY_RULE_SETUP
01581 <font class="preprocessor">#line 328 "cscanner.l"</font>
01582 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01583                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_int, processOctal ()); } 
01584         YY_BREAK
01585 <font class="keywordflow">case</font> 88:
01586 YY_RULE_SETUP
01587 <font class="preprocessor">#line 330 "cscanner.l"</font>
01588 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01589                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_uint, processOctal ()); } 
01590         YY_BREAK
01591 <font class="keywordflow">case</font> 89:
01592 YY_RULE_SETUP
01593 <font class="preprocessor">#line 332 "cscanner.l"</font>
01594 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01595                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_lint, processOctal ()); } 
01596         YY_BREAK
01597 <font class="keywordflow">case</font> 90:
01598 YY_RULE_SETUP
01599 <font class="preprocessor">#line 334 "cscanner.l"</font>
01600 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01601                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_llint, processOctal ()); } 
01602         YY_BREAK
01603 <font class="keywordflow">case</font> 91:
01604 YY_RULE_SETUP
01605 <font class="preprocessor">#line 336 "cscanner.l"</font>
01606 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01607                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ulint, processOctal ()); } 
01608         YY_BREAK
01609 <font class="keywordflow">case</font> 92:
01610 YY_RULE_SETUP
01611 <font class="preprocessor">#line 338 "cscanner.l"</font>
01612 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01613                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ullint, processOctal ()); } 
01614         YY_BREAK
01615 <font class="keywordflow">case</font> 93:
01616 YY_RULE_SETUP
01617 <font class="preprocessor">#line 340 "cscanner.l"</font>
01618 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01619                           <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ullint, processOctal ()); } 
01620         YY_BREAK
01621 <font class="keywordflow">case</font> 94:
01622 YY_RULE_SETUP
01623 <font class="preprocessor">#line 342 "cscanner.l"</font>
01624 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01625                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_int, processDec ()); } 
01626         YY_BREAK
01627 <font class="keywordflow">case</font> 95:
01628 YY_RULE_SETUP
01629 <font class="preprocessor">#line 344 "cscanner.l"</font>
01630 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01631                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_uint, processDec ()); } 
01632         YY_BREAK
01633 <font class="keywordflow">case</font> 96:
01634 YY_RULE_SETUP
01635 <font class="preprocessor">#line 346 "cscanner.l"</font>
01636 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01637                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_lint, processDec ()); } 
01638         YY_BREAK
01639 <font class="keywordflow">case</font> 97:
01640 YY_RULE_SETUP
01641 <font class="preprocessor">#line 348 "cscanner.l"</font>
01642 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01643                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_llint, processDec ()); } 
01644         YY_BREAK
01645 <font class="keywordflow">case</font> 98:
01646 YY_RULE_SETUP
01647 <font class="preprocessor">#line 350 "cscanner.l"</font>
01648 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01649                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ulint, processDec ()); } 
01650         YY_BREAK
01651 <font class="keywordflow">case</font> 99:
01652 YY_RULE_SETUP
01653 <font class="preprocessor">#line 352 "cscanner.l"</font>
01654 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01655                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ullint, processDec ()); } 
01656         YY_BREAK
01657 <font class="keywordflow">case</font> 100:
01658 YY_RULE_SETUP
01659 <font class="preprocessor">#line 354 "cscanner.l"</font>
01660 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01661                          <a class="code" href="lex_yy_c.html#a38">RETURN_INT</a> (ctype_ullint, processDec ()); } 
01662         YY_BREAK
01663 <font class="keywordflow">case</font> 101:
01664 YY_RULE_SETUP
01665 <font class="preprocessor">#line 356 "cscanner.l"</font>
01666 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01667                          <a class="code" href="lex_yy_c.html#a40">RETURN_CHAR</a> (processChar ()); }
01668         YY_BREAK
01669 <font class="keywordflow">case</font> 102:
01670 YY_RULE_SETUP
01671 <font class="preprocessor">#line 358 "cscanner.l"</font>
01672 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01673                          <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_float, processFloat ()); }
01674         YY_BREAK
01675 <font class="keywordflow">case</font> 103:
01676 YY_RULE_SETUP
01677 <font class="preprocessor">#line 360 "cscanner.l"</font>
01678 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01679                          <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_ldouble, processFloat ()); }
01680         YY_BREAK
01681 <font class="keywordflow">case</font> 104:
01682 YY_RULE_SETUP
01683 <font class="preprocessor">#line 362 "cscanner.l"</font>
01684 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01685                          <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_double, processFloat ()); }
01686         YY_BREAK
01687 <font class="keywordflow">case</font> 105:
01688 YY_RULE_SETUP
01689 <font class="preprocessor">#line 365 "cscanner.l"</font>
01690 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01691                                 <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_float, processFloat ()); }
01692         YY_BREAK
01693 <font class="keywordflow">case</font> 106:
01694 YY_RULE_SETUP
01695 <font class="preprocessor">#line 367 "cscanner.l"</font>
01696 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01697                                 <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_ldouble, processFloat ()); }
01698         YY_BREAK
01699 <font class="keywordflow">case</font> 107:
01700 YY_RULE_SETUP
01701 <font class="preprocessor">#line 369 "cscanner.l"</font>
01702 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01703                                 <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_double, processFloat ()); }
01704         YY_BREAK
01705 <font class="keywordflow">case</font> 108:
01706 YY_RULE_SETUP
01707 <font class="preprocessor">#line 372 "cscanner.l"</font>
01708 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01709                                   <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_float, processFloat ()); }
01710         YY_BREAK
01711 <font class="keywordflow">case</font> 109:
01712 YY_RULE_SETUP
01713 <font class="preprocessor">#line 374 "cscanner.l"</font>
01714 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01715                                   <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_ldouble, processFloat ()); }
01716         YY_BREAK
01717 <font class="keywordflow">case</font> 110:
01718 YY_RULE_SETUP
01719 <font class="preprocessor">#line 376 "cscanner.l"</font>
01720 <font class="preprocessor"></font>{ setTokLengthT (mstring_length (yytext)); 
01721                                   <a class="code" href="lex_yy_c.html#a39">RETURN_FLOAT</a> (ctype_double, processFloat ()); }
01722         YY_BREAK
01723 <font class="keywordflow">case</font> 111:
01724 YY_RULE_SETUP
01725 <font class="preprocessor">#line 379 "cscanner.l"</font>
01726 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (RIGHT_ASSIGN); }
01727         YY_BREAK
01728 <font class="keywordflow">case</font> 112:
01729 YY_RULE_SETUP
01730 <font class="preprocessor">#line 380 "cscanner.l"</font>
01731 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LEFT_ASSIGN); }
01732         YY_BREAK
01733 <font class="keywordflow">case</font> 113:
01734 YY_RULE_SETUP
01735 <font class="preprocessor">#line 381 "cscanner.l"</font>
01736 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (ADD_ASSIGN); }
01737         YY_BREAK
01738 <font class="keywordflow">case</font> 114:
01739 YY_RULE_SETUP
01740 <font class="preprocessor">#line 382 "cscanner.l"</font>
01741 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (SUB_ASSIGN); }
01742         YY_BREAK
01743 <font class="keywordflow">case</font> 115:
01744 YY_RULE_SETUP
01745 <font class="preprocessor">#line 383 "cscanner.l"</font>
01746 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (MUL_ASSIGN); }
01747         YY_BREAK
01748 <font class="keywordflow">case</font> 116:
01749 YY_RULE_SETUP
01750 <font class="preprocessor">#line 384 "cscanner.l"</font>
01751 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (DIV_ASSIGN); }
01752         YY_BREAK
01753 <font class="keywordflow">case</font> 117:
01754 YY_RULE_SETUP
01755 <font class="preprocessor">#line 385 "cscanner.l"</font>
01756 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (MOD_ASSIGN); }
01757         YY_BREAK
01758 <font class="keywordflow">case</font> 118:
01759 YY_RULE_SETUP
01760 <font class="preprocessor">#line 386 "cscanner.l"</font>
01761 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (AND_ASSIGN); }
01762         YY_BREAK
01763 <font class="keywordflow">case</font> 119:
01764 YY_RULE_SETUP
01765 <font class="preprocessor">#line 387 "cscanner.l"</font>
01766 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (XOR_ASSIGN); }
01767         YY_BREAK
01768 <font class="keywordflow">case</font> 120:
01769 YY_RULE_SETUP
01770 <font class="preprocessor">#line 388 "cscanner.l"</font>
01771 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (OR_ASSIGN); }
01772         YY_BREAK
01773 <font class="keywordflow">case</font> 121:
01774 YY_RULE_SETUP
01775 <font class="preprocessor">#line 389 "cscanner.l"</font>
01776 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (RIGHT_OP); }
01777         YY_BREAK
01778 <font class="keywordflow">case</font> 122:
01779 YY_RULE_SETUP
01780 <font class="preprocessor">#line 390 "cscanner.l"</font>
01781 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LEFT_OP); }
01782         YY_BREAK
01783 <font class="keywordflow">case</font> 123:
01784 YY_RULE_SETUP
01785 <font class="preprocessor">#line 391 "cscanner.l"</font>
01786 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (INC_OP); }
01787         YY_BREAK
01788 <font class="keywordflow">case</font> 124:
01789 YY_RULE_SETUP
01790 <font class="preprocessor">#line 392 "cscanner.l"</font>
01791 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (DEC_OP); }
01792         YY_BREAK
01793 <font class="keywordflow">case</font> 125:
01794 YY_RULE_SETUP
01795 <font class="preprocessor">#line 393 "cscanner.l"</font>
01796 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (ARROW_OP); }
01797         YY_BREAK
01798 <font class="keywordflow">case</font> 126:
01799 YY_RULE_SETUP
01800 <font class="preprocessor">#line 394 "cscanner.l"</font>
01801 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (AND_OP); }
01802         YY_BREAK
01803 <font class="keywordflow">case</font> 127:
01804 YY_RULE_SETUP
01805 <font class="preprocessor">#line 395 "cscanner.l"</font>
01806 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (OR_OP); }
01807         YY_BREAK
01808 <font class="keywordflow">case</font> 128:
01809 YY_RULE_SETUP
01810 <font class="preprocessor">#line 396 "cscanner.l"</font>
01811 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LE_OP); }
01812         YY_BREAK
01813 <font class="keywordflow">case</font> 129:
01814 YY_RULE_SETUP
01815 <font class="preprocessor">#line 397 "cscanner.l"</font>
01816 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (GE_OP); }
01817         YY_BREAK
01818 <font class="keywordflow">case</font> 130:
01819 YY_RULE_SETUP
01820 <font class="preprocessor">#line 398 "cscanner.l"</font>
01821 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (EQ_OP); }
01822         YY_BREAK
01823 <font class="keywordflow">case</font> 131:
01824 YY_RULE_SETUP
01825 <font class="preprocessor">#line 399 "cscanner.l"</font>
01826 <font class="preprocessor"></font>{ setTokLength (2); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (NE_OP); }
01827         YY_BREAK
01828 <font class="keywordflow">case</font> 132:
01829 YY_RULE_SETUP
01830 <font class="preprocessor">#line 400 "cscanner.l"</font>
01831 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TSEMI); }
01832         YY_BREAK
01833 <font class="keywordflow">case</font> 133:
01834 YY_RULE_SETUP
01835 <font class="preprocessor">#line 401 "cscanner.l"</font>
01836 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TLBRACE); }
01837         YY_BREAK
01838 <font class="keywordflow">case</font> 134:
01839 YY_RULE_SETUP
01840 <font class="preprocessor">#line 402 "cscanner.l"</font>
01841 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TRBRACE); }
01842         YY_BREAK
01843 <font class="keywordflow">case</font> 135:
01844 YY_RULE_SETUP
01845 <font class="preprocessor">#line 403 "cscanner.l"</font>
01846 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TCOMMA); }
01847         YY_BREAK
01848 <font class="keywordflow">case</font> 136:
01849 YY_RULE_SETUP
01850 <font class="preprocessor">#line 404 "cscanner.l"</font>
01851 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TCOLON); }
01852         YY_BREAK
01853 <font class="keywordflow">case</font> 137:
01854 YY_RULE_SETUP
01855 <font class="preprocessor">#line 405 "cscanner.l"</font>
01856 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TASSIGN); }
01857         YY_BREAK
01858 <font class="keywordflow">case</font> 138:
01859 YY_RULE_SETUP
01860 <font class="preprocessor">#line 406 "cscanner.l"</font>
01861 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TLPAREN); }
01862         YY_BREAK
01863 <font class="keywordflow">case</font> 139:
01864 YY_RULE_SETUP
01865 <font class="preprocessor">#line 407 "cscanner.l"</font>
01866 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TRPAREN); }
01867         YY_BREAK
01868 <font class="keywordflow">case</font> 140:
01869 YY_RULE_SETUP
01870 <font class="preprocessor">#line 408 "cscanner.l"</font>
01871 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TLSQBR); }
01872         YY_BREAK
01873 <font class="keywordflow">case</font> 141:
01874 YY_RULE_SETUP
01875 <font class="preprocessor">#line 409 "cscanner.l"</font>
01876 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TRSQBR); }
01877         YY_BREAK
01878 <font class="keywordflow">case</font> 142:
01879 YY_RULE_SETUP
01880 <font class="preprocessor">#line 410 "cscanner.l"</font>
01881 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TDOT); }
01882         YY_BREAK
01883 <font class="keywordflow">case</font> 143:
01884 YY_RULE_SETUP
01885 <font class="preprocessor">#line 411 "cscanner.l"</font>
01886 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TAMPERSAND); }
01887         YY_BREAK
01888 <font class="keywordflow">case</font> 144:
01889 YY_RULE_SETUP
01890 <font class="preprocessor">#line 412 "cscanner.l"</font>
01891 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TEXCL); }
01892         YY_BREAK
01893 <font class="keywordflow">case</font> 145:
01894 YY_RULE_SETUP
01895 <font class="preprocessor">#line 415 "cscanner.l"</font>
01896 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TTILDE); }
01897         YY_BREAK
01898 <font class="keywordflow">case</font> 146:
01899 YY_RULE_SETUP
01900 <font class="preprocessor">#line 416 "cscanner.l"</font>
01901 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TMINUS); }
01902         YY_BREAK
01903 <font class="keywordflow">case</font> 147:
01904 YY_RULE_SETUP
01905 <font class="preprocessor">#line 417 "cscanner.l"</font>
01906 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TPLUS); }
01907         YY_BREAK
01908 <font class="keywordflow">case</font> 148:
01909 YY_RULE_SETUP
01910 <font class="preprocessor">#line 418 "cscanner.l"</font>
01911 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TMULT); }
01912         YY_BREAK
01913 <font class="keywordflow">case</font> 149:
01914 YY_RULE_SETUP
01915 <font class="preprocessor">#line 419 "cscanner.l"</font>
01916 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TDIV); }
01917         YY_BREAK
01918 <font class="keywordflow">case</font> 150:
01919 YY_RULE_SETUP
01920 <font class="preprocessor">#line 420 "cscanner.l"</font>
01921 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TPERCENT); }
01922         YY_BREAK
01923 <font class="keywordflow">case</font> 151:
01924 YY_RULE_SETUP
01925 <font class="preprocessor">#line 421 "cscanner.l"</font>
01926 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TLT); }
01927         YY_BREAK
01928 <font class="keywordflow">case</font> 152:
01929 YY_RULE_SETUP
01930 <font class="preprocessor">#line 422 "cscanner.l"</font>
01931 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TGT); }
01932         YY_BREAK
01933 <font class="keywordflow">case</font> 153:
01934 YY_RULE_SETUP
01935 <font class="preprocessor">#line 423 "cscanner.l"</font>
01936 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TCIRC); }
01937         YY_BREAK
01938 <font class="keywordflow">case</font> 154:
01939 YY_RULE_SETUP
01940 <font class="preprocessor">#line 424 "cscanner.l"</font>
01941 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TBAR); }
01942         YY_BREAK
01943 <font class="keywordflow">case</font> 155:
01944 YY_RULE_SETUP
01945 <font class="preprocessor">#line 425 "cscanner.l"</font>
01946 <font class="preprocessor"></font>{ setTokLength (1); <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (TQUEST); }
01947         YY_BREAK
01948 <font class="keywordflow">case</font> 156:
01949 YY_RULE_SETUP
01950 <font class="preprocessor">#line 427 "cscanner.l"</font>
01951 <font class="preprocessor"></font>{ incColumn (); }
01952         YY_BREAK
01953 <font class="keywordflow">case</font> 157:
01954 YY_RULE_SETUP
01955 <font class="preprocessor">#line 428 "cscanner.l"</font>
01956 <font class="preprocessor"></font>{ <a class="code" href="context_c.html#a46">context_incLineno</a> ();
01957                   <font class="keywordflow">if</font> (continueLine)
01958                     {
01959                       continueLine = FALSE;
01960                     }
01961                  <font class="keywordflow">else</font> 
01962                    {
01963                      <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a235">context_inMacro</a> ())
01964                        {
01965                          <font class="comment">/* Don't use RETURN_TOK */</font>
01966                          yylval.tok = <a class="code" href="lltok_c.html#a2">lltok_create</a> (TENDMACRO, g_currentloc);
01967                          lastWasString = FALSE;
01968                          <font class="keywordflow">return</font> (TENDMACRO);
01969                        }  
01970                    }
01971                 }
01972         YY_BREAK
01973 <font class="keywordflow">case</font> 158:
01974 YY_RULE_SETUP
01975 <font class="preprocessor">#line 444 "cscanner.l"</font>
01976 <font class="preprocessor"></font>{ setTokLength (6); 
01977                   
01978                   <font class="keywordflow">if</font> (processMacro ()) {
01979                     <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a236">context_inIterDef</a> ()) 
01980                       { 
01981                         <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LLMACROITER); 
01982                       }
01983                     <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a237">context_inIterEnd</a> ())
01984                       {
01985                         <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LLMACROEND); 
01986                       }
01987                     <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a235">context_inMacro</a> ())
01988                       {
01989                         <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LLMACRO); 
01990                       }
01991                   }
01992                 }
01993         YY_BREAK
01994 <font class="keywordflow">case</font> 159:
01995 YY_RULE_SETUP
01996 <font class="preprocessor">#line 461 "cscanner.l"</font>
01997 <font class="preprocessor"></font>{ <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a219">context_inHeader</a> () || <a class="code" href="context_c.html#a174">context_inFunction</a> ())
01998                     { 
01999                       handleMacro ();
02000                     }
02001                   <font class="keywordflow">else</font>
02002                     {
02003                       <font class="keywordtype">int</font> nspchar = ninput ();
02004                       <font class="keywordtype">int</font> nspaces;
02005 
02006                       <font class="comment">/* </font>
02007 <font class="comment">                      ** This is a hack to get the column number correct.</font>
02008 <font class="comment">                      */</font>
02009 
02010                       llassert (nspchar &gt;= <font class="charliteral">'0'</font> &amp;&amp; nspchar &lt;= <font class="charliteral">'9'</font>);
02011                       
02012                       nspaces = nspchar - <font class="charliteral">'0'</font>;
02013 
02014                       setTokLength (5 + nspaces); 
02015                       
02016                       <font class="keywordflow">if</font> (processMacro ()) 
02017                         {
02018                           <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a236">context_inIterDef</a> ()) 
02019                             {
02020                               <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LLMACROITER); 
02021                             }
02022                           <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a237">context_inIterEnd</a> ())
02023                             {
02024                               <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LLMACROEND); 
02025                             }
02026                           <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a235">context_inMacro</a> ())
02027                             { 
02028                               <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (LLMACRO); 
02029                             }
02030                         }
02031                     }
02032                 }
02033         YY_BREAK
02034 <font class="keywordflow">case</font> 160:
02035 YY_RULE_SETUP
02036 <font class="preprocessor">#line 497 "cscanner.l"</font>
02037 <font class="preprocessor"></font>{ setTokLength (4); <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (ctype_unparseTable ()); }
02038         YY_BREAK
02039 <font class="keywordflow">case</font> 161:
02040 YY_RULE_SETUP
02041 <font class="preprocessor">#line 498 "cscanner.l"</font>
02042 <font class="preprocessor"></font>{ setTokLength (3); 
02043                   <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (message (<font class="stringliteral">"%q: *** marker ***"</font>, fileloc_unparse (g_currentloc)));
02044                 }
02045         YY_BREAK
02046 <font class="keywordflow">case</font> 162:
02047 YY_RULE_SETUP
02048 <font class="preprocessor">#line 501 "cscanner.l"</font>
02049 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="usymtab_c.html#a162">usymtab_printLocal</a> (); }
02050         YY_BREAK
02051 <font class="keywordflow">case</font> 163:
02052 YY_RULE_SETUP
02053 <font class="preprocessor">#line 502 "cscanner.l"</font>
02054 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (usymtab_unparseAliases ()); }
02055         YY_BREAK
02056 <font class="keywordflow">case</font> 164:
02057 YY_RULE_SETUP
02058 <font class="preprocessor">#line 503 "cscanner.l"</font>
02059 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (context_unparse ()); }
02060         YY_BREAK
02061 <font class="keywordflow">case</font> 165:
02062 YY_RULE_SETUP
02063 <font class="preprocessor">#line 504 "cscanner.l"</font>
02064 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (context_unparseClauses ()); }
02065         YY_BREAK
02066 <font class="keywordflow">case</font> 166:
02067 YY_RULE_SETUP
02068 <font class="preprocessor">#line 505 "cscanner.l"</font>
02069 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="usymtab_c.html#a148">usymtab_printGuards</a> (); }
02070         YY_BREAK
02071 <font class="keywordflow">case</font> 167:
02072 YY_RULE_SETUP
02073 <font class="preprocessor">#line 506 "cscanner.l"</font>
02074 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="usymtab_c.html#a158">usymtab_printOut</a> (); }
02075         YY_BREAK
02076 <font class="keywordflow">case</font> 168:
02077 YY_RULE_SETUP
02078 <font class="preprocessor">#line 507 "cscanner.l"</font>
02079 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="usymtab_c.html#a160">usymtab_printAll</a> (); }
02080         YY_BREAK
02081 <font class="keywordflow">case</font> 169:
02082 YY_RULE_SETUP
02083 <font class="preprocessor">#line 508 "cscanner.l"</font>
02084 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="usymtab_c.html#a161">usymtab_printComplete</a> (); }
02085         YY_BREAK
02086 <font class="keywordflow">case</font> 170:
02087 YY_RULE_SETUP
02088 <font class="preprocessor">#line 509 "cscanner.l"</font>
02089 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="usymtab_c.html#a159">usymtab_printTypes</a> (); }
02090         YY_BREAK
02091 <font class="keywordflow">case</font> 171:
02092 YY_RULE_SETUP
02093 <font class="preprocessor">#line 510 "cscanner.l"</font>
02094 <font class="preprocessor"></font>{ setTokLength (3); <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (usymtab_unparseStack ()); }
02095         YY_BREAK
02096 <font class="keywordflow">case</font> 172:
02097 YY_RULE_SETUP
02098 <font class="preprocessor">#line 511 "cscanner.l"</font>
02099 <font class="preprocessor"></font>{ setTokLength (3); 
02100                   <a class="code" href="llerror_c.html#a22">lldiagmsg</a> (message (<font class="stringliteral">"Can modify: %q"</font>, 
02101                                   sRefSet_unparse (context_modList ()))); 
02102                 }
02103         YY_BREAK
02104 <font class="keywordflow">case</font> 173:
02105 YY_RULE_SETUP
02106 <font class="preprocessor">#line 515 "cscanner.l"</font>
02107 <font class="preprocessor"></font>{ <font class="comment">/* BEFORE_COMMENT_MARKER */</font>
02108                   <font class="keywordtype">int</font> tok; 
02109                   incColumn (); incColumn ();
02110                   tok = handleLlSpecial (); 
02111                   <font class="keywordflow">if</font> (tok != BADTOK)
02112                     {
02113                       <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (tok); 
02114                     }
02115                 }
02116         YY_BREAK
02117 <font class="keywordflow">case</font> 174:
02118 YY_RULE_SETUP
02119 <font class="preprocessor">#line 524 "cscanner.l"</font>
02120 <font class="preprocessor"></font>{ <font class="comment">/* AFTER_COMMENT_MARKER */</font> 
02121                   setTokLength (2);
02122                   inSpecPart = FALSE;
02123                   <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (QENDMACRO); }
02124         YY_BREAK
02125 <font class="keywordflow">case</font> 175:
02126 YY_RULE_SETUP
02127 <font class="preprocessor">#line 528 "cscanner.l"</font>
02128 <font class="preprocessor"></font>{ incColumn (); continueLine = TRUE; }
02129         YY_BREAK
02130 <font class="keywordflow">case</font> 176:
02131 YY_RULE_SETUP
02132 <font class="preprocessor">#line 529 "cscanner.l"</font>
02133 <font class="preprocessor"></font>{ incColumn (); 
02134                   voptgenerror
02135                     (FLG_SYNTAX, 
02136                      <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Invalid character (ascii: %d), skipping character"</font>,
02137                               (<font class="keywordtype">int</font>)(*yytext)),
02138                      g_currentloc);
02139                 }
02140         YY_BREAK
02141 <font class="keywordflow">case</font> 177:
02142 YY_RULE_SETUP
02143 <font class="preprocessor">#line 536 "cscanner.l"</font>
02144 <font class="preprocessor"></font>ECHO;
02145         YY_BREAK
02146 <font class="preprocessor">#line 2147 "lex.yy.c"</font>
02147 <font class="preprocessor"></font><font class="keywordflow">case</font> <a class="code" href="lex_yy_c.html#a10">YY_STATE_EOF</a>(INITIAL):
02148         <a class="code" href="lex_yy_c.html#a51">yyterminate</a>();
02149 
02150         <font class="keywordflow">case</font> YY_END_OF_BUFFER:
02151                 {
02152                 <font class="comment">/* Amount of text matched not including the EOB char. */</font>
02153                 <font class="keywordtype">int</font> yy_amount_of_matched_text = (<font class="keywordtype">int</font>) (yy_cp - yytext_ptr) - 1;
02154 
02155                 <font class="comment">/* Undo the effects of YY_DO_BEFORE_ACTION. */</font>
02156                 *yy_cp = yy_hold_char;
02157                 YY_RESTORE_YY_MORE_OFFSET
02158 
02159                 <font class="keywordflow">if</font> ( yy_current_buffer-&gt;yy_buffer_status == YY_BUFFER_NEW )
02160                         {
02161                         <font class="comment">/* We're scanning a new file or input source.  It's</font>
02162 <font class="comment">                         * possible that this happened because the user</font>
02163 <font class="comment">                         * just pointed yyin at a new source and called</font>
02164 <font class="comment">                         * yylex().  If so, then we have to assure</font>
02165 <font class="comment">                         * consistency between yy_current_buffer and our</font>
02166 <font class="comment">                         * globals.  Here is the right place to do so, because</font>
02167 <font class="comment">                         * this is the first action (other than possibly a</font>
02168 <font class="comment">                         * back-up) that will match for the new input source.</font>
02169 <font class="comment">                         */</font>
02170                         yy_n_chars = yy_current_buffer-&gt;yy_n_chars;
02171                         yy_current_buffer-&gt;yy_input_file = yyin;
02172                         yy_current_buffer-&gt;yy_buffer_status = YY_BUFFER_NORMAL;
02173                         }
02174 
02175                 <font class="comment">/* Note that here we test for yy_c_buf_p "&lt;=" to the position</font>
02176 <font class="comment">                 * of the first EOB in the buffer, since yy_c_buf_p will</font>
02177 <font class="comment">                 * already have been incremented past the NUL character</font>
02178 <font class="comment">                 * (since all states make transitions on EOB to the</font>
02179 <font class="comment">                 * end-of-buffer state).  Contrast this with the test</font>
02180 <font class="comment">                 * in input().</font>
02181 <font class="comment">                 */</font>
02182                 <font class="keywordflow">if</font> ( yy_c_buf_p &lt;= &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] )
02183                         { <font class="comment">/* This was really a NUL. */</font>
02184                         yy_state_type yy_next_state;
02185 
02186                         yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
02187 
02188                         yy_current_state = yy_get_previous_state();
02189 
02190                         <font class="comment">/* Okay, we're now positioned to make the NUL</font>
02191 <font class="comment">                         * transition.  We couldn't have</font>
02192 <font class="comment">                         * yy_get_previous_state() go ahead and do it</font>
02193 <font class="comment">                         * for us because it doesn't know how to deal</font>
02194 <font class="comment">                         * with the possibility of jamming (and we don't</font>
02195 <font class="comment">                         * want to build jamming into it because then it</font>
02196 <font class="comment">                         * will run more slowly).</font>
02197 <font class="comment">                         */</font>
02198 
02199                         yy_next_state = yy_try_NUL_trans( yy_current_state );
02200 
02201                         yy_bp = yytext_ptr + YY_MORE_ADJ;
02202 
02203                         <font class="keywordflow">if</font> ( yy_next_state )
02204                                 {
02205                                 <font class="comment">/* Consume the NUL. */</font>
02206                                 yy_cp = ++yy_c_buf_p;
02207                                 yy_current_state = yy_next_state;
02208                                 <font class="keywordflow">goto</font> yy_match;
02209                                 }
02210 
02211                         <font class="keywordflow">else</font>
02212                                 {
02213                                 yy_cp = yy_c_buf_p;
02214                                 <font class="keywordflow">goto</font> yy_find_action;
02215                                 }
02216                         }
02217 
02218                 <font class="keywordflow">else</font> <font class="keywordflow">switch</font> ( yy_get_next_buffer() )
02219                         {
02220                         <font class="keywordflow">case</font> EOB_ACT_END_OF_FILE:
02221                                 {
02222                                 yy_did_buffer_switch_on_eof = 0;
02223 
02224                                 <font class="keywordflow">if</font> ( yywrap() )
02225                                         {
02226                                         <font class="comment">/* Note: because we've taken care in</font>
02227 <font class="comment">                                         * yy_get_next_buffer() to have set up</font>
02228 <font class="comment">                                         * yytext, we can now set up</font>
02229 <font class="comment">                                         * yy_c_buf_p so that if some total</font>
02230 <font class="comment">                                         * hoser (like flex itself) wants to</font>
02231 <font class="comment">                                         * call the scanner after we return the</font>
02232 <font class="comment">                                         * YY_NULL, it'll still work - another</font>
02233 <font class="comment">                                         * YY_NULL will get returned.</font>
02234 <font class="comment">                                         */</font>
02235                                         yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
02236 
02237                                         yy_act = <a class="code" href="lex_yy_c.html#a10">YY_STATE_EOF</a>(YY_START);
02238                                         <font class="keywordflow">goto</font> do_action;
02239                                         }
02240 
02241                                 <font class="keywordflow">else</font>
02242                                         {
02243                                         <font class="keywordflow">if</font> ( ! yy_did_buffer_switch_on_eof )
02244                                                 YY_NEW_FILE;
02245                                         }
02246                                 <font class="keywordflow">break</font>;
02247                                 }
02248 
02249                         <font class="keywordflow">case</font> EOB_ACT_CONTINUE_SCAN:
02250                                 yy_c_buf_p =
02251                                         yytext_ptr + yy_amount_of_matched_text;
02252 
02253                                 yy_current_state = yy_get_previous_state();
02254 
02255                                 yy_cp = yy_c_buf_p;
02256                                 yy_bp = yytext_ptr + YY_MORE_ADJ;
02257                                 <font class="keywordflow">goto</font> yy_match;
02258 
02259                         <font class="keywordflow">case</font> EOB_ACT_LAST_MATCH:
02260                                 yy_c_buf_p =
02261                                 &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars];
02262 
02263                                 yy_current_state = yy_get_previous_state();
02264 
02265                                 yy_cp = yy_c_buf_p;
02266                                 yy_bp = yytext_ptr + YY_MORE_ADJ;
02267                                 <font class="keywordflow">goto</font> yy_find_action;
02268                         }
02269                 <font class="keywordflow">break</font>;
02270                 }
02271 
02272         <font class="keywordflow">default</font>:
02273                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>(
02274                         <font class="stringliteral">"fatal flex scanner internal error--no action found"</font> );
02275         } <font class="comment">/* end of action switch */</font>
02276                 } <font class="comment">/* end of scanning one token */</font>
02277         } <font class="comment">/* end of yylex */</font>
02278 
02279 
02280 <font class="comment">/* yy_get_next_buffer - try to read in a new buffer</font>
02281 <font class="comment"> *</font>
02282 <font class="comment"> * Returns a code representing an action:</font>
02283 <font class="comment"> *      EOB_ACT_LAST_MATCH -</font>
02284 <font class="comment"> *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position</font>
02285 <font class="comment"> *      EOB_ACT_END_OF_FILE - end of file</font>
02286 <font class="comment"> */</font>
02287 
02288 <font class="keyword">static</font> <font class="keywordtype">int</font> yy_get_next_buffer()<font class="keyword"></font>
02289 <font class="keyword">        </font>{
02290         <font class="keyword">register</font> <font class="keywordtype">char</font> *dest = yy_current_buffer-&gt;yy_ch_buf;
02291         <font class="keyword">register</font> <font class="keywordtype">char</font> *source = yytext_ptr;
02292         <font class="keyword">register</font> <font class="keywordtype">int</font> number_to_move, i;
02293         <font class="keywordtype">int</font> ret_val;
02294 
02295         <font class="keywordflow">if</font> ( yy_c_buf_p &gt; &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars + 1] )
02296                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>(
02297                 <font class="stringliteral">"fatal flex scanner internal error--end of buffer missed"</font> );
02298 
02299         <font class="keywordflow">if</font> ( yy_current_buffer-&gt;yy_fill_buffer == 0 )
02300                 { <font class="comment">/* Don't try to fill the buffer, so this is an EOF. */</font>
02301                 <font class="keywordflow">if</font> ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
02302                         {
02303                         <font class="comment">/* We matched a single character, the EOB, so</font>
02304 <font class="comment">                         * treat this as a final EOF.</font>
02305 <font class="comment">                         */</font>
02306                         <font class="keywordflow">return</font> EOB_ACT_END_OF_FILE;
02307                         }
02308 
02309                 <font class="keywordflow">else</font>
02310                         {
02311                         <font class="comment">/* We matched some text prior to the EOB, first</font>
02312 <font class="comment">                         * process it.</font>
02313 <font class="comment">                         */</font>
02314                         <font class="keywordflow">return</font> EOB_ACT_LAST_MATCH;
02315                         }
02316                 }
02317 
02318         <font class="comment">/* Try to read more data. */</font>
02319 
02320         <font class="comment">/* First move last chars to start of buffer. */</font>
02321         number_to_move = (<font class="keywordtype">int</font>) (yy_c_buf_p - yytext_ptr) - 1;
02322 
02323         <font class="keywordflow">for</font> ( i = 0; i &lt; number_to_move; ++i )
02324                 *(dest++) = *(source++);
02325 
02326         <font class="keywordflow">if</font> ( yy_current_buffer-&gt;yy_buffer_status == YY_BUFFER_EOF_PENDING )
02327                 <font class="comment">/* don't do the read, it's not guaranteed to return an EOF,</font>
02328 <font class="comment">                 * just force an EOF</font>
02329 <font class="comment">                 */</font>
02330                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars = 0;
02331 
02332         <font class="keywordflow">else</font>
02333                 {
02334                 <font class="keywordtype">int</font> num_to_read =
02335                         yy_current_buffer-&gt;yy_buf_size - number_to_move - 1;
02336 
02337                 <font class="keywordflow">while</font> ( num_to_read &lt;= 0 )
02338                         { <font class="comment">/* Not enough room in the buffer - grow it. */</font>
02339 <font class="preprocessor">#ifdef YY_USES_REJECT</font>
02340 <font class="preprocessor"></font>                        <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>(
02341 <font class="stringliteral">"input buffer overflow, can't enlarge buffer because scanner uses REJECT"</font> );
02342 <font class="preprocessor">#else</font>
02343 <font class="preprocessor"></font>
02344                         <font class="comment">/* just a shorter name for the current buffer */</font>
02345                         <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b = yy_current_buffer;
02346 
02347                         <font class="keywordtype">int</font> yy_c_buf_p_offset =
02348                                 (<font class="keywordtype">int</font>) (yy_c_buf_p - b-&gt;yy_ch_buf);
02349 
02350                         <font class="keywordflow">if</font> ( b-&gt;yy_is_our_buffer )
02351                                 {
02352                                 <font class="keywordtype">int</font> new_size = b-&gt;yy_buf_size * 2;
02353 
02354                                 <font class="keywordflow">if</font> ( new_size &lt;= 0 )
02355                                         b-&gt;yy_buf_size += b-&gt;yy_buf_size / 8;
02356                                 <font class="keywordflow">else</font>
02357                                         b-&gt;yy_buf_size *= 2;
02358 
02359                                 b-&gt;yy_ch_buf = (<font class="keywordtype">char</font> *)
02360                                         <font class="comment">/* Include room in for 2 EOB chars. */</font>
02361                                         yy_flex_realloc( (<font class="keywordtype">void</font> *) b-&gt;yy_ch_buf,
02362                                                          b-&gt;yy_buf_size + 2 );
02363                                 }
02364                         <font class="keywordflow">else</font>
02365                                 <font class="comment">/* Can't grow it, we don't own it. */</font>
02366                                 b-&gt;yy_ch_buf = 0;
02367 
02368                         <font class="keywordflow">if</font> ( ! b-&gt;yy_ch_buf )
02369                                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>(
02370                                 <font class="stringliteral">"fatal error - scanner input buffer overflow"</font> );
02371 
02372                         yy_c_buf_p = &amp;b-&gt;yy_ch_buf[yy_c_buf_p_offset];
02373 
02374                         num_to_read = yy_current_buffer-&gt;yy_buf_size -
02375                                                 number_to_move - 1;
02376 <font class="preprocessor">#endif</font>
02377 <font class="preprocessor"></font>                        }
02378 
02379                 <font class="keywordflow">if</font> ( num_to_read &gt; YY_READ_BUF_SIZE )
02380                         num_to_read = YY_READ_BUF_SIZE;
02381 
02382                 <font class="comment">/* Read in more data. */</font>
02383                 <a class="code" href="lex_yy_c.html#a50">YY_INPUT</a>( (&amp;yy_current_buffer-&gt;yy_ch_buf[number_to_move]),
02384                         yy_n_chars, num_to_read );
02385 
02386                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars;
02387                 }
02388 
02389         <font class="keywordflow">if</font> ( yy_n_chars == 0 )
02390                 {
02391                 <font class="keywordflow">if</font> ( number_to_move == YY_MORE_ADJ )
02392                         {
02393                         ret_val = EOB_ACT_END_OF_FILE;
02394                         yyrestart( yyin );
02395                         }
02396 
02397                 <font class="keywordflow">else</font>
02398                         {
02399                         ret_val = EOB_ACT_LAST_MATCH;
02400                         yy_current_buffer-&gt;yy_buffer_status =
02401                                 YY_BUFFER_EOF_PENDING;
02402                         }
02403                 }
02404 
02405         <font class="keywordflow">else</font>
02406                 ret_val = EOB_ACT_CONTINUE_SCAN;
02407 
02408         yy_n_chars += number_to_move;
02409         yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
02410         yy_current_buffer-&gt;yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
02411 
02412         yytext_ptr = &amp;yy_current_buffer-&gt;yy_ch_buf[0];
02413 
02414         <font class="keywordflow">return</font> ret_val;
02415         }
02416 
02417 
02418 <font class="comment">/* yy_get_previous_state - get the state just before the EOB char was reached */</font>
02419 
02420 <font class="keyword">static</font> yy_state_type yy_get_previous_state()<font class="keyword"></font>
02421 <font class="keyword">        </font>{
02422         <font class="keyword">register</font> yy_state_type yy_current_state;
02423         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp;
02424 
02425         yy_current_state = yy_start;
02426 
02427         <font class="keywordflow">for</font> ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp &lt; yy_c_buf_p; ++yy_cp )
02428                 {
02429                 <font class="keyword">register</font> YY_CHAR yy_c = (*yy_cp ? yy_ec[<a class="code" href="lex_yy_c.html#a6">YY_SC_TO_UI</a>(*yy_cp)] : 1);
02430                 <font class="keywordflow">if</font> ( yy_accept[yy_current_state] )
02431                         {
02432                         yy_last_accepting_state = yy_current_state;
02433                         yy_last_accepting_cpos = yy_cp;
02434                         }
02435                 <font class="keywordflow">while</font> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
02436                         {
02437                         yy_current_state = (<font class="keywordtype">int</font>) yy_def[yy_current_state];
02438                         <font class="keywordflow">if</font> ( yy_current_state &gt;= 509 )
02439                                 yy_c = yy_meta[(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
02440                         }
02441                 yy_current_state = yy_nxt[yy_base[yy_current_state] + (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
02442                 }
02443 
02444         <font class="keywordflow">return</font> yy_current_state;
02445         }
02446 
02447 
02448 <font class="comment">/* yy_try_NUL_trans - try to make a transition on the NUL character</font>
02449 <font class="comment"> *</font>
02450 <font class="comment"> * synopsis</font>
02451 <font class="comment"> *      next_state = yy_try_NUL_trans( current_state );</font>
02452 <font class="comment"> */</font>
02453 
02454 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02455 <font class="preprocessor"></font><font class="keyword">static</font> yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
02456 <font class="preprocessor">#else</font>
02457 <font class="preprocessor"></font><font class="keyword">static</font> yy_state_type yy_try_NUL_trans( yy_current_state )
02458 yy_state_type yy_current_state;
02459 <font class="preprocessor">#endif</font>
02460 <font class="preprocessor"></font>        {
02461         <font class="keyword">register</font> <font class="keywordtype">int</font> yy_is_jam;
02462         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp = yy_c_buf_p;
02463 
02464         <font class="keyword">register</font> YY_CHAR yy_c = 1;
02465         <font class="keywordflow">if</font> ( yy_accept[yy_current_state] )
02466                 {
02467                 yy_last_accepting_state = yy_current_state;
02468                 yy_last_accepting_cpos = yy_cp;
02469                 }
02470         <font class="keywordflow">while</font> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
02471                 {
02472                 yy_current_state = (<font class="keywordtype">int</font>) yy_def[yy_current_state];
02473                 <font class="keywordflow">if</font> ( yy_current_state &gt;= 509 )
02474                         yy_c = yy_meta[(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
02475                 }
02476         yy_current_state = yy_nxt[yy_base[yy_current_state] + (<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>) yy_c];
02477         yy_is_jam = (yy_current_state == 508);
02478 
02479         <font class="keywordflow">return</font> yy_is_jam ? 0 : yy_current_state;
02480         }
02481 
02482 
02483 <font class="preprocessor">#ifndef YY_NO_UNPUT</font>
02484 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02485 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yyunput( <font class="keywordtype">int</font> c, <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_bp )
02486 <font class="preprocessor">#else</font>
02487 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yyunput( c, yy_bp )
02488 <font class="keywordtype">int</font> c;
<a name="l02489"></a><a class="code" href="lex_yy_c.html#a89">02489</a> <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_bp;
02490 <font class="preprocessor">#endif</font>
02491 <font class="preprocessor"></font>        {
02492         <font class="keyword">register</font> <font class="keywordtype">char</font> *yy_cp = yy_c_buf_p;
02493 
02494         <font class="comment">/* undo effects of setting up yytext */</font>
02495         *yy_cp = yy_hold_char;
02496 
02497         <font class="keywordflow">if</font> ( yy_cp &lt; yy_current_buffer-&gt;yy_ch_buf + 2 )
02498                 { <font class="comment">/* need to shift things up to make room */</font>
02499                 <font class="comment">/* +2 for EOB chars. */</font>
02500                 <font class="keyword">register</font> <font class="keywordtype">int</font> number_to_move = yy_n_chars + 2;
02501                 <font class="keyword">register</font> <font class="keywordtype">char</font> *dest = &amp;yy_current_buffer-&gt;yy_ch_buf[
02502                                         yy_current_buffer-&gt;yy_buf_size + 2];
02503                 <font class="keyword">register</font> <font class="keywordtype">char</font> *source =
02504                                 &amp;yy_current_buffer-&gt;yy_ch_buf[number_to_move];
02505 
02506                 <font class="keywordflow">while</font> ( source &gt; yy_current_buffer-&gt;yy_ch_buf )
02507                         *--dest = *--source;
02508 
02509                 yy_cp += (<font class="keywordtype">int</font>) (dest - source);
02510                 yy_bp += (<font class="keywordtype">int</font>) (dest - source);
02511                 yy_current_buffer-&gt;yy_n_chars =
02512                         yy_n_chars = yy_current_buffer-&gt;yy_buf_size;
02513 
02514                 <font class="keywordflow">if</font> ( yy_cp &lt; yy_current_buffer-&gt;yy_ch_buf + 2 )
02515                         <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"flex scanner push-back overflow"</font> );
02516                 }
02517 
02518         *--yy_cp = (<font class="keywordtype">char</font>) c;
02519 
02520 
02521         yytext_ptr = yy_bp;
02522         yy_hold_char = *yy_cp;
02523         yy_c_buf_p = yy_cp;
02524         }
02525 <font class="preprocessor">#endif  </font><font class="comment">/* ifndef YY_NO_UNPUT */</font>
02526 
02527 
02528 <font class="preprocessor">#ifdef __cplusplus</font>
02529 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> <a class="code" href="lex_yy_c.html#a37">yyinput</a>()
02530 <font class="preprocessor">#else</font>
02531 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> input()
02532 <font class="preprocessor">#endif</font>
02533 <font class="preprocessor"></font>        {
02534         <font class="keywordtype">int</font> c;
02535 
02536         *yy_c_buf_p = yy_hold_char;
02537 
02538         <font class="keywordflow">if</font> ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
02539                 {
02540                 <font class="comment">/* yy_c_buf_p now points to the character we want to return.</font>
02541 <font class="comment">                 * If this occurs *before* the EOB characters, then it's a</font>
02542 <font class="comment">                 * valid NUL; if not, then we've hit the end of the buffer.</font>
02543 <font class="comment">                 */</font>
02544                 <font class="keywordflow">if</font> ( yy_c_buf_p &lt; &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] )
02545                         <font class="comment">/* This was really a NUL. */</font>
02546                         *yy_c_buf_p = <font class="charliteral">'\0'</font>;
02547 
02548                 <font class="keywordflow">else</font>
02549                         { <font class="comment">/* need more input */</font>
02550                         <font class="keywordtype">int</font> offset = yy_c_buf_p - yytext_ptr;
02551                         ++yy_c_buf_p;
02552 
02553                         <font class="keywordflow">switch</font> ( yy_get_next_buffer() )
02554                                 {
02555                                 <font class="keywordflow">case</font> EOB_ACT_LAST_MATCH:
02556                                         <font class="comment">/* This happens because yy_g_n_b()</font>
02557 <font class="comment">                                         * sees that we've accumulated a</font>
02558 <font class="comment">                                         * token and flags that we need to</font>
02559 <font class="comment">                                         * try matching the token before</font>
02560 <font class="comment">                                         * proceeding.  But for input(),</font>
02561 <font class="comment">                                         * there's no matching to consider.</font>
02562 <font class="comment">                                         * So convert the EOB_ACT_LAST_MATCH</font>
02563 <font class="comment">                                         * to EOB_ACT_END_OF_FILE.</font>
02564 <font class="comment">                                         */</font>
02565 
02566                                         <font class="comment">/* Reset buffer status. */</font>
02567                                         yyrestart( yyin );
02568 
02569                                         <font class="comment">/* fall through */</font>
02570 
02571                                 <font class="keywordflow">case</font> EOB_ACT_END_OF_FILE:
02572                                         {
02573                                         <font class="keywordflow">if</font> ( yywrap() )
02574                                                 <font class="keywordflow">return</font> EOF;
02575 
02576                                         <font class="keywordflow">if</font> ( ! yy_did_buffer_switch_on_eof )
02577                                                 YY_NEW_FILE;
02578 <font class="preprocessor">#ifdef __cplusplus</font>
02579 <font class="preprocessor"></font>                                        <font class="keywordflow">return</font> <a class="code" href="lex_yy_c.html#a37">yyinput</a>();
02580 <font class="preprocessor">#else</font>
02581 <font class="preprocessor"></font>                                        <font class="keywordflow">return</font> input();
02582 <font class="preprocessor">#endif</font>
02583 <font class="preprocessor"></font>                                        }
02584 
02585                                 <font class="keywordflow">case</font> EOB_ACT_CONTINUE_SCAN:
02586                                         yy_c_buf_p = yytext_ptr + offset;
02587                                         <font class="keywordflow">break</font>;
02588                                 }
02589                         }
02590                 }
02591 
02592         c = *(<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> *) yy_c_buf_p;      <font class="comment">/* cast for 8-bit char's */</font>
02593         *yy_c_buf_p = <font class="charliteral">'\0'</font>;     <font class="comment">/* preserve yytext */</font>
02594         yy_hold_char = *++yy_c_buf_p;
02595 
02596 
02597         <font class="keywordflow">return</font> c;
02598         }
02599 
02600 
02601 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02602 <font class="preprocessor"></font><font class="keywordtype">void</font> yyrestart( FILE *input_file )
02603 <font class="preprocessor">#else</font>
02604 <font class="preprocessor"></font><font class="keywordtype">void</font> yyrestart( input_file )
02605 FILE *input_file;
02606 <font class="preprocessor">#endif</font>
02607 <font class="preprocessor"></font>        {
02608         <font class="keywordflow">if</font> ( ! yy_current_buffer )
02609                 yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
02610 
02611         <a class="code" href="lex_yy_c.html#a133">yy_init_buffer</a>( yy_current_buffer, input_file );
02612         yy_load_buffer_state();
02613         }
02614 
02615 
02616 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02617 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_switch_to_buffer( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> new_buffer )
02618 <font class="preprocessor">#else</font>
02619 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_switch_to_buffer( new_buffer )
02620 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> new_buffer;
02621 <font class="preprocessor">#endif</font>
02622 <font class="preprocessor"></font>        {
02623         <font class="keywordflow">if</font> ( yy_current_buffer == new_buffer )
02624                 <font class="keywordflow">return</font>;
02625 
02626         <font class="keywordflow">if</font> ( yy_current_buffer )
02627                 {
02628                 <font class="comment">/* Flush out information for old buffer. */</font>
02629                 *yy_c_buf_p = yy_hold_char;
02630                 yy_current_buffer-&gt;yy_buf_pos = yy_c_buf_p;
02631                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars;
02632                 }
02633 
02634         yy_current_buffer = new_buffer;
02635         yy_load_buffer_state();
02636 
02637         <font class="comment">/* We don't actually know whether we did this switch during</font>
02638 <font class="comment">         * EOF (yywrap()) processing, but the only time this flag</font>
02639 <font class="comment">         * is looked at is after yywrap() is called, so it's safe</font>
02640 <font class="comment">         * to go ahead and always set it.</font>
02641 <font class="comment">         */</font>
02642         yy_did_buffer_switch_on_eof = 1;
02643         }
02644 
02645 
02646 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02647 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_load_buffer_state( <font class="keywordtype">void</font> )
02648 <font class="preprocessor">#else</font>
02649 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_load_buffer_state()
02650 <font class="preprocessor">#endif</font>
02651 <font class="preprocessor"></font>        {
02652         yy_n_chars = yy_current_buffer-&gt;yy_n_chars;
02653         yytext_ptr = yy_c_buf_p = yy_current_buffer-&gt;yy_buf_pos;
02654         yyin = yy_current_buffer-&gt;yy_input_file;
02655         yy_hold_char = *yy_c_buf_p;
02656         }
02657 
02658 
02659 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02660 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_create_buffer( FILE *file, <font class="keywordtype">int</font> size )
02661 <font class="preprocessor">#else</font>
02662 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_create_buffer( file, size )
02663 FILE *file;
02664 <font class="keywordtype">int</font> size;
02665 <font class="preprocessor">#endif</font>
02666 <font class="preprocessor"></font>        {
02667         <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b;
02668 
02669         b = (<a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a>) yy_flex_alloc( <font class="keyword">sizeof</font>( <font class="keyword">struct</font> <a class="code" href="struct_yy_buffer_state.html">yy_buffer_state</a> ) );
02670         <font class="keywordflow">if</font> ( ! b )
02671                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"out of dynamic memory in yy_create_buffer()"</font> );
02672 
02673         b-&gt;yy_buf_size = size;
02674 
02675         <font class="comment">/* yy_ch_buf has to be 2 characters longer than the size given because</font>
02676 <font class="comment">         * we need to put in 2 end-of-buffer characters.</font>
02677 <font class="comment">         */</font>
02678         b-&gt;yy_ch_buf = (<font class="keywordtype">char</font> *) yy_flex_alloc( b-&gt;yy_buf_size + 2 );
02679         <font class="keywordflow">if</font> ( ! b-&gt;yy_ch_buf )
02680                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"out of dynamic memory in yy_create_buffer()"</font> );
02681 
02682         b-&gt;yy_is_our_buffer = 1;
02683 
02684         <a class="code" href="lex_yy_c.html#a133">yy_init_buffer</a>( b, file );
02685 
02686         <font class="keywordflow">return</font> b;
02687         }
02688 
02689 
02690 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02691 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_delete_buffer( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b )
02692 <font class="preprocessor">#else</font>
02693 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_delete_buffer( b )
02694 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b;
02695 <font class="preprocessor">#endif</font>
02696 <font class="preprocessor"></font>        {
02697         <font class="keywordflow">if</font> ( ! b )
02698                 <font class="keywordflow">return</font>;
02699 
02700         <font class="keywordflow">if</font> ( b == yy_current_buffer )
02701                 yy_current_buffer = (<a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a>) 0;
02702 
02703         <font class="keywordflow">if</font> ( b-&gt;yy_is_our_buffer )
02704                 yy_flex_free( (<font class="keywordtype">void</font> *) b-&gt;yy_ch_buf );
02705 
02706         yy_flex_free( (<font class="keywordtype">void</font> *) b );
02707         }
02708 
02709 
02710 <font class="preprocessor">#ifndef YY_ALWAYS_INTERACTIVE</font>
02711 <font class="preprocessor"></font><font class="preprocessor">#ifndef YY_NEVER_INTERACTIVE</font>
02712 <font class="preprocessor"></font><font class="keyword">extern</font> <font class="keywordtype">int</font> isatty <a class="code" href="lex_yy_c.html#a4">YY_PROTO</a>(( <font class="keywordtype">int</font> ));
02713 <font class="preprocessor">#endif</font>
02714 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
02715 <font class="preprocessor"></font>
02716 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02717 <font class="preprocessor"></font><font class="keywordtype">void</font> <a class="code" href="lex_yy_c.html#a133">yy_init_buffer</a>( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b, FILE *file )
02718 <font class="preprocessor">#else</font>
02719 <font class="preprocessor"></font><font class="keywordtype">void</font> <a class="code" href="lex_yy_c.html#a133">yy_init_buffer</a>( b, file )
02720 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b;
<a name="l02721"></a><a class="code" href="lex_yy_c.html#a91">02721</a> FILE *file;
02722 <font class="preprocessor">#endif</font>
02723 <font class="preprocessor"></font>
02724 
02725         {
02726         yy_flush_buffer( b );
02727 
02728         b-&gt;yy_input_file = file;
02729         b-&gt;yy_fill_buffer = 1;
02730 
02731 <font class="preprocessor">#if YY_ALWAYS_INTERACTIVE</font>
02732 <font class="preprocessor"></font>        b-&gt;yy_is_interactive = 1;
02733 <font class="preprocessor">#else</font>
02734 <font class="preprocessor"></font><font class="preprocessor">#if YY_NEVER_INTERACTIVE</font>
02735 <font class="preprocessor"></font>        b-&gt;yy_is_interactive = 0;
02736 <font class="preprocessor">#else</font>
02737 <font class="preprocessor"></font>        b-&gt;yy_is_interactive = file ? (isatty( fileno(file) ) &gt; 0) : 0;
02738 <font class="preprocessor">#endif</font>
02739 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
02740 <font class="preprocessor"></font>        }
02741 
02742 
02743 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02744 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_flush_buffer( <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b )
02745 <font class="preprocessor">#else</font>
02746 <font class="preprocessor"></font><font class="keywordtype">void</font> yy_flush_buffer( b )
02747 <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b;
02748 <font class="preprocessor">#endif</font>
02749 <font class="preprocessor"></font>
02750         {
02751         <font class="keywordflow">if</font> ( ! b )
02752                 <font class="keywordflow">return</font>;
02753 
02754         b-&gt;yy_n_chars = 0;
02755 
02756         <font class="comment">/* We always need two end-of-buffer characters.  The first causes</font>
02757 <font class="comment">         * a transition to the end-of-buffer state.  The second causes</font>
02758 <font class="comment">         * a jam in that state.</font>
02759 <font class="comment">         */</font>
02760         b-&gt;yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
02761         b-&gt;yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
02762 
02763         b-&gt;yy_buf_pos = &amp;b-&gt;yy_ch_buf[0];
02764 
02765         b-&gt;yy_at_bol = 1;
02766         b-&gt;yy_buffer_status = YY_BUFFER_NEW;
02767 
02768         <font class="keywordflow">if</font> ( b == yy_current_buffer )
02769                 yy_load_buffer_state();
02770         }
02771 
02772 
02773 <font class="preprocessor">#ifndef YY_NO_SCAN_BUFFER</font>
02774 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02775 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_buffer( <font class="keywordtype">char</font> *base, yy_size_t size )
02776 <font class="preprocessor">#else</font>
02777 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_buffer( base, size )
02778 <font class="keywordtype">char</font> *base;
02779 yy_size_t size;
02780 <font class="preprocessor">#endif</font>
02781 <font class="preprocessor"></font>        {
02782         <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b;
02783 
02784         <font class="keywordflow">if</font> ( size &lt; 2 ||
02785              base[size-2] != YY_END_OF_BUFFER_CHAR ||
02786              base[size-1] != YY_END_OF_BUFFER_CHAR )
02787                 <font class="comment">/* They forgot to leave room for the EOB's. */</font>
02788                 <font class="keywordflow">return</font> 0;
02789 
02790         b = (<a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a>) yy_flex_alloc( <font class="keyword">sizeof</font>( <font class="keyword">struct</font> <a class="code" href="struct_yy_buffer_state.html">yy_buffer_state</a> ) );
02791         <font class="keywordflow">if</font> ( ! b )
02792                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"out of dynamic memory in yy_scan_buffer()"</font> );
02793 
02794         b-&gt;yy_buf_size = size - 2;      <font class="comment">/* "- 2" to take care of EOB's */</font>
02795         b-&gt;yy_buf_pos = b-&gt;yy_ch_buf = base;
02796         b-&gt;yy_is_our_buffer = 0;
02797         b-&gt;yy_input_file = 0;
02798         b-&gt;yy_n_chars = b-&gt;yy_buf_size;
02799         b-&gt;yy_is_interactive = 0;
02800         b-&gt;yy_at_bol = 1;
02801         b-&gt;yy_fill_buffer = 0;
02802         b-&gt;yy_buffer_status = YY_BUFFER_NEW;
02803 
02804         yy_switch_to_buffer( b );
02805 
02806         <font class="keywordflow">return</font> b;
02807         }
02808 <font class="preprocessor">#endif</font>
02809 <font class="preprocessor"></font>
02810 
02811 <font class="preprocessor">#ifndef YY_NO_SCAN_STRING</font>
02812 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02813 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_string( yyconst <font class="keywordtype">char</font> *yy_str )
02814 <font class="preprocessor">#else</font>
02815 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_string( yy_str )
02816 yyconst <font class="keywordtype">char</font> *yy_str;
02817 <font class="preprocessor">#endif</font>
02818 <font class="preprocessor"></font>        {
02819         <font class="keywordtype">int</font> len;
02820         <font class="keywordflow">for</font> ( len = 0; yy_str[len]; ++len )
02821                 ;
02822 
02823         <font class="keywordflow">return</font> yy_scan_bytes( yy_str, len );
02824         }
02825 <font class="preprocessor">#endif</font>
02826 <font class="preprocessor"></font>
02827 
02828 <font class="preprocessor">#ifndef YY_NO_SCAN_BYTES</font>
02829 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02830 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_bytes( yyconst <font class="keywordtype">char</font> *bytes, <font class="keywordtype">int</font> len )
02831 <font class="preprocessor">#else</font>
02832 <font class="preprocessor"></font><a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> yy_scan_bytes( bytes, len )
02833 yyconst <font class="keywordtype">char</font> *bytes;
<a name="l02834"></a><a class="code" href="lex_yy_c.html#a92">02834</a> <font class="keywordtype">int</font> len;
02835 <font class="preprocessor">#endif</font>
02836 <font class="preprocessor"></font>        {
02837         <a class="code" href="struct_yy_buffer_state.html">YY_BUFFER_STATE</a> b;
02838         <font class="keywordtype">char</font> *buf;
02839         yy_size_t n;
02840         <font class="keywordtype">int</font> i;
02841 
02842         <font class="comment">/* Get memory for full buffer, including space for trailing EOB's. */</font>
02843         n = len + 2;
02844         buf = (<font class="keywordtype">char</font> *) yy_flex_alloc( n );
02845         <font class="keywordflow">if</font> ( ! buf )
02846                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"out of dynamic memory in yy_scan_bytes()"</font> );
02847 
02848         <font class="keywordflow">for</font> ( i = 0; i &lt; len; ++i )
02849                 buf[i] = bytes[i];
02850 
02851         buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
02852 
02853         b = yy_scan_buffer( buf, n );
02854         <font class="keywordflow">if</font> ( ! b )
02855                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"bad buffer in yy_scan_bytes()"</font> );
02856 
02857         <font class="comment">/* It's okay to grow etc. this buffer, and we should throw it</font>
02858 <font class="comment">         * away when we're done.</font>
02859 <font class="comment">         */</font>
02860         b-&gt;yy_is_our_buffer = 1;
02861 
02862         <font class="keywordflow">return</font> b;
02863         }
02864 <font class="preprocessor">#endif</font>
02865 <font class="preprocessor"></font>
02866 
02867 <font class="preprocessor">#ifndef YY_NO_PUSH_STATE</font>
02868 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02869 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_push_state( <font class="keywordtype">int</font> new_state )
02870 <font class="preprocessor">#else</font>
02871 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_push_state( new_state )
02872 <font class="keywordtype">int</font> new_state;
02873 <font class="preprocessor">#endif</font>
02874 <font class="preprocessor"></font>        {
02875         <font class="keywordflow">if</font> ( yy_start_stack_ptr &gt;= yy_start_stack_depth )
02876                 {
02877                 yy_size_t new_size;
02878 
02879                 yy_start_stack_depth += YY_START_STACK_INCR;
02880                 new_size = yy_start_stack_depth * <font class="keyword">sizeof</font>( <font class="keywordtype">int</font> );
02881 
02882                 <font class="keywordflow">if</font> ( ! yy_start_stack )
02883                         yy_start_stack = (<font class="keywordtype">int</font> *) yy_flex_alloc( new_size );
02884 
02885                 <font class="keywordflow">else</font>
02886                         yy_start_stack = (<font class="keywordtype">int</font> *) yy_flex_realloc(
02887                                         (<font class="keywordtype">void</font> *) yy_start_stack, new_size );
02888 
02889                 <font class="keywordflow">if</font> ( ! yy_start_stack )
02890                         <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>(
02891                         <font class="stringliteral">"out of memory expanding start-condition stack"</font> );
02892                 }
02893 
02894         yy_start_stack[yy_start_stack_ptr++] = YY_START;
02895 
02896         <a class="code" href="lex_yy_c.html#a7">BEGIN</a>(new_state);
02897         }
02898 <font class="preprocessor">#endif</font>
02899 <font class="preprocessor"></font>
02900 
02901 <font class="preprocessor">#ifndef YY_NO_POP_STATE</font>
02902 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_pop_state()<font class="keyword"></font>
02903 <font class="keyword">        </font>{
02904         <font class="keywordflow">if</font> ( --yy_start_stack_ptr &lt; 0 )
02905                 <a class="code" href="lex_yy_c.html#a53">YY_FATAL_ERROR</a>( <font class="stringliteral">"start-condition stack underflow"</font> );
02906 
02907         <a class="code" href="lex_yy_c.html#a7">BEGIN</a>(yy_start_stack[yy_start_stack_ptr]);
02908         }
02909 <font class="preprocessor">#endif</font>
02910 <font class="preprocessor"></font>
02911 
02912 <font class="preprocessor">#ifndef YY_NO_TOP_STATE</font>
02913 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_top_state()<font class="keyword"></font>
02914 <font class="keyword">        </font>{
02915         <font class="keywordflow">return</font> yy_start_stack[yy_start_stack_ptr - 1];
02916         }
02917 <font class="preprocessor">#endif</font>
02918 <font class="preprocessor"></font>
02919 <font class="preprocessor">#ifndef YY_EXIT_FAILURE</font>
02920 <font class="preprocessor"></font><font class="preprocessor">#define YY_EXIT_FAILURE 2</font>
02921 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
02922 <font class="preprocessor"></font>
02923 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02924 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_fatal_error( yyconst <font class="keywordtype">char</font> msg[] )
02925 <font class="preprocessor">#else</font>
02926 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_fatal_error( msg )
02927 <font class="keywordtype">char</font> msg[];
02928 <font class="preprocessor">#endif</font>
02929 <font class="preprocessor"></font>        {
02930         (<font class="keywordtype">void</font>) fprintf( stderr, <font class="stringliteral">"%s\n"</font>, msg );
02931         exit( YY_EXIT_FAILURE );
02932         }
02933 
02934 
02935 
02936 <font class="comment">/* Redefine yyless() so it works in section 3 code. */</font>
02937 
02938 <font class="preprocessor">#undef yyless</font>
02939 <font class="preprocessor"></font><font class="preprocessor">#define yyless(n) \</font>
02940 <font class="preprocessor">        do \</font>
02941 <font class="preprocessor">                { \</font>
02942 <font class="preprocessor">                </font><font class="comment">/* Undo effects of setting up yytext. */</font> \
02943                 yytext[yyleng] = yy_hold_char; \
02944                 yy_c_buf_p = yytext + n; \
02945                 yy_hold_char = *yy_c_buf_p; \
02946                 *yy_c_buf_p = '\0'; \
02947                 yyleng = n; \
02948                 } \
02949         while ( 0 )
02950 
02951 
02952 <font class="comment">/* Internal utility routines. */</font>
02953 
02954 <font class="preprocessor">#ifndef yytext_ptr</font>
02955 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02956 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_strncpy( <font class="keywordtype">char</font> *s1, yyconst <font class="keywordtype">char</font> *s2, <font class="keywordtype">int</font> n )
02957 <font class="preprocessor">#else</font>
02958 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_strncpy( s1, s2, n )
02959 <font class="keywordtype">char</font> *s1;
02960 yyconst <font class="keywordtype">char</font> *s2;
02961 <font class="keywordtype">int</font> n;
02962 <font class="preprocessor">#endif</font>
02963 <font class="preprocessor"></font>        {
02964         <font class="keyword">register</font> <font class="keywordtype">int</font> i;
02965         <font class="keywordflow">for</font> ( i = 0; i &lt; n; ++i )
02966                 s1[i] = s2[i];
02967         }
02968 <font class="preprocessor">#endif</font>
02969 <font class="preprocessor"></font>
02970 <font class="preprocessor">#ifdef YY_NEED_STRLEN</font>
02971 <font class="preprocessor"></font><font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02972 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_flex_strlen( yyconst <font class="keywordtype">char</font> *s )
02973 <font class="preprocessor">#else</font>
02974 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">int</font> yy_flex_strlen( s )
02975 yyconst <font class="keywordtype">char</font> *s;
02976 <font class="preprocessor">#endif</font>
02977 <font class="preprocessor"></font>        {
02978         <font class="keyword">register</font> <font class="keywordtype">int</font> n;
02979         <font class="keywordflow">for</font> ( n = 0; s[n]; ++n )
02980                 ;
02981 
02982         <font class="keywordflow">return</font> n;
02983         }
02984 <font class="preprocessor">#endif</font>
02985 <font class="preprocessor"></font>
02986 
02987 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02988 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_alloc( yy_size_t size )
02989 <font class="preprocessor">#else</font>
02990 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_alloc( size )
02991 yy_size_t size;
02992 <font class="preprocessor">#endif</font>
02993 <font class="preprocessor"></font>        {
02994         <font class="keywordflow">return</font> (<font class="keywordtype">void</font> *) malloc( size );
02995         }
02996 
02997 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
02998 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_realloc( <font class="keywordtype">void</font> *ptr, yy_size_t size )
02999 <font class="preprocessor">#else</font>
03000 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> *yy_flex_realloc( ptr, size )
03001 <font class="keywordtype">void</font> *ptr;
<a name="l03002"></a><a class="code" href="lex_yy_c.html#a90">03002</a> yy_size_t size;
03003 <font class="preprocessor">#endif</font>
03004 <font class="preprocessor"></font>        {
03005         <font class="comment">/* The cast to (char *) in the following accommodates both</font>
03006 <font class="comment">         * implementations that use char* generic pointers, and those</font>
03007 <font class="comment">         * that use void* generic pointers.  It works with the latter</font>
03008 <font class="comment">         * because both ANSI C and C++ allow castless assignment from</font>
03009 <font class="comment">         * any pointer type to void*, and deal with argument conversions</font>
03010 <font class="comment">         * as though doing an assignment.</font>
03011 <font class="comment">         */</font>
03012         <font class="keywordflow">return</font> (<font class="keywordtype">void</font> *) realloc( (<font class="keywordtype">char</font> *) ptr, size );
03013         }
03014 
03015 <font class="preprocessor">#ifdef YY_USE_PROTOS</font>
03016 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_free( <font class="keywordtype">void</font> *ptr )
03017 <font class="preprocessor">#else</font>
03018 <font class="preprocessor"></font><font class="keyword">static</font> <font class="keywordtype">void</font> yy_flex_free( ptr )
03019 <font class="keywordtype">void</font> *ptr;
03020 <font class="preprocessor">#endif</font>
03021 <font class="preprocessor"></font>        {
03022         free( ptr );
03023         }
03024 
03025 <font class="preprocessor">#if YY_MAIN</font>
03026 <font class="preprocessor"></font><font class="keywordtype">int</font> <a class="code" href="llmain_c.html#a25">main</a>()<font class="keyword"></font>
03027 <font class="keyword">        </font>{
03028         <a class="code" href="llgrammar_tab_c.html#a2">yylex</a>();
03029         <font class="keywordflow">return</font> 0;
03030         }
03031 <font class="preprocessor">#endif</font>
03032 <font class="preprocessor"></font><font class="preprocessor">#line 536 "cscanner.l"</font>
03033 <font class="preprocessor"></font>
03034 
03035 <font class="keyword">struct </font>skeyword
03036 {
03037   <font class="comment">/*@null@*/</font> <font class="comment">/*@observer@*/</font> <font class="keywordtype">char</font> *name;
03038   <font class="keywordtype">int</font> <a class="code" href="struct_token.html">token</a>;
03039 } ;
03040 
03041 <font class="comment">/*</font>
03042 <font class="comment">** These tokens are followed by syntax that is parsed by the </font>
03043 <font class="comment">** grammar proper.</font>
03044 <font class="comment">*/</font>
03045 
<a name="l03046"></a><a class="code" href="lex_yy_c.html#a93">03046</a> <font class="keyword">struct </font>skeyword s_parsetable[] = {
03047   { <font class="stringliteral">"modifies"</font>, QMODIFIES } ,
03048   { <font class="stringliteral">"globals"</font>, QGLOBALS } ,
03049   { <font class="stringliteral">"alt"</font>, QALT } ,
03050   { <font class="stringliteral">"constant"</font>, QCONSTANT } ,
03051   { <font class="stringliteral">"function"</font>, QFUNCTION } ,
03052   { <font class="stringliteral">"iter"</font>, QITER } ,
03053   { <font class="stringliteral">"defines"</font>, QDEFINES } ,
03054   { <font class="stringliteral">"uses"</font>, QUSES } ,
03055   { <font class="stringliteral">"allocates"</font>, QALLOCATES } ,
03056   { <font class="stringliteral">"sets"</font>, QSETS } ,
03057   { <font class="stringliteral">"releases"</font>, QRELEASES } ,
03058   { <font class="stringliteral">"pre"</font>, QPRECLAUSE } ,
03059   { <font class="stringliteral">"post"</font>, QPOSTCLAUSE } ,
03060   { NULL, BADTOK } 
03061 } ;
03062 
03063 <font class="comment">/*</font>
03064 <font class="comment">** These tokens are either stand-alone tokens, or followed by </font>
03065 <font class="comment">** token-specific text.</font>
03066 <font class="comment">*/</font>
03067 
<a name="l03068"></a><a class="code" href="lex_yy_c.html#a94">03068</a> <font class="keyword">struct </font>skeyword s_keytable[] = {
03069   { <font class="stringliteral">"anytype"</font>, QANYTYPE } ,
03070   { <font class="stringliteral">"integraltype"</font>, QINTEGRALTYPE } ,
03071   { <font class="stringliteral">"unsignedintegraltype"</font>, QUNSIGNEDINTEGRALTYPE } ,
03072   { <font class="stringliteral">"signedintegraltype"</font>, QSIGNEDINTEGRALTYPE } ,
03073   { <font class="stringliteral">"out"</font>, QOUT } ,
03074   { <font class="stringliteral">"in"</font>, QIN } ,
03075   { <font class="stringliteral">"only"</font>, QONLY } , 
03076   { <font class="stringliteral">"owned"</font>, QOWNED } ,
03077   { <font class="stringliteral">"dependent"</font>, QDEPENDENT } ,
03078   { <font class="stringliteral">"partial"</font>, QPARTIAL } ,
03079   { <font class="stringliteral">"special"</font>, QSPECIAL } ,
03080   { <font class="stringliteral">"truenull"</font>, QTRUENULL } ,
03081   { <font class="stringliteral">"falsenull"</font>, QFALSENULL } ,
03082   { <font class="stringliteral">"keep"</font>, QKEEP } ,
03083   { <font class="stringliteral">"kept"</font>, QKEPT } ,
03084   { <font class="stringliteral">"notnull"</font>, QNOTNULL } ,
03085   { <font class="stringliteral">"abstract"</font>, QABSTRACT } ,
03086   { <font class="stringliteral">"concrete"</font>, QCONCRETE } ,
03087   { <font class="stringliteral">"mutable"</font>, QMUTABLE } ,
03088   { <font class="stringliteral">"immutable"</font>, QIMMUTABLE } ,
03089   { <font class="stringliteral">"unused"</font>, QUNUSED } ,
03090   { <font class="stringliteral">"external"</font>, QEXTERNAL } ,
03091   { <font class="stringliteral">"sef"</font>, QSEF } ,
03092   { <font class="stringliteral">"unique"</font>, QUNIQUE } ,
03093   { <font class="stringliteral">"returned"</font>, QRETURNED } ,
03094   { <font class="stringliteral">"exposed"</font>, QEXPOSED } ,
03095   { <font class="stringliteral">"refcounted"</font>, QREFCOUNTED } ,
03096   { <font class="stringliteral">"refs"</font>, QREFS } ,
03097   { <font class="stringliteral">"newref"</font>, QNEWREF } ,
03098   { <font class="stringliteral">"tempref"</font>, QTEMPREF } ,
03099   { <font class="stringliteral">"killref"</font>, QKILLREF } ,
03100   { <font class="stringliteral">"null"</font>, QNULL } ,
03101   { <font class="stringliteral">"relnull"</font>, QRELNULL } ,
03102   { <font class="stringliteral">"reldef"</font>, QRELDEF } ,
03103   { <font class="stringliteral">"observer"</font>, QOBSERVER } ,
03104   { <font class="stringliteral">"exits"</font>, QEXITS } ,
03105   { <font class="stringliteral">"mayexit"</font>, QMAYEXIT } ,
03106   { <font class="stringliteral">"trueexit"</font>, QTRUEEXIT } ,
03107   { <font class="stringliteral">"falseexit"</font>, QFALSEEXIT } ,
03108   { <font class="stringliteral">"neverexit"</font>, QNEVEREXIT } ,
03109   { <font class="stringliteral">"temp"</font>, QTEMP } ,
03110   { <font class="stringliteral">"shared"</font>, QSHARED } ,
03111   { <font class="stringliteral">"ref"</font>, QREF } ,
03112   { <font class="stringliteral">"unchecked"</font>, QUNCHECKED } ,
03113   { <font class="stringliteral">"checked"</font>, QCHECKED } ,
03114   { <font class="stringliteral">"checkmod"</font>, QCHECKMOD } ,
03115   { <font class="stringliteral">"checkedstrict"</font>, QCHECKEDSTRICT } ,
03116   { <font class="stringliteral">"innercontinue"</font>, QINNERCONTINUE } ,
03117   { <font class="stringliteral">"innerbreak"</font>, QINNERBREAK } ,
03118   { <font class="stringliteral">"loopbreak"</font>, QLOOPBREAK } ,
03119   { <font class="stringliteral">"switchbreak"</font>, QSWITCHBREAK } ,
03120   { <font class="stringliteral">"safebreak"</font>, QSAFEBREAK } , 
03121   { <font class="stringliteral">"fallthrough"</font>, QFALLTHROUGH } ,
03122   { <font class="stringliteral">"l_fallthrou"</font>, QLINTFALLTHROUGH } , 
03123   { <font class="stringliteral">"l_fallth"</font>, QLINTFALLTHRU } ,
03124   { <font class="stringliteral">"notreached"</font>, QNOTREACHED } ,
03125   { <font class="stringliteral">"l_notreach"</font>, QLINTNOTREACHED } ,
03126   { <font class="stringliteral">"printflike"</font>, QPRINTFLIKE } ,
03127   { <font class="stringliteral">"l_printfli"</font>, QLINTPRINTFLIKE } ,
03128   { <font class="stringliteral">"scanflike"</font>, QSCANFLIKE } ,
03129   { <font class="stringliteral">"messagelike"</font>, QMESSAGELIKE } ,
03130   { <font class="stringliteral">"l_argsus"</font>, QARGSUSED } ,
03131   { NULL, BADTOK } 
03132 } ;
03133 
03134 <font class="comment">/*</font>
03135 <font class="comment">** would be better if these weren't hard coded...</font>
03136 <font class="comment">*/</font>
03137 
03138 <font class="keyword">static</font> <font class="keywordtype">bool</font> isArtificial (cstring s)<font class="keyword"></font>
03139 <font class="keyword"></font>{
03140   <font class="keywordflow">return</font> (cstring_equalLit (s, <font class="stringliteral">"modifies"</font>) 
03141           || cstring_equalLit (s, <font class="stringliteral">"globals"</font>) 
03142           || cstring_equalLit (s, <font class="stringliteral">"alt"</font>));
03143 }
03144 
<a name="l03145"></a><a class="code" href="lex_yy_c.html#a223">03145</a> <font class="keywordtype">void</font> <a class="code" href="cgrammar_tab_c.html#a223">swallowMacro</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
03146 <font class="keyword"></font>{
03147   <font class="keywordtype">int</font> i;
03148   <font class="keywordtype">bool</font> skipnext = FALSE;
03149 
03150   <font class="keywordflow">while</font> ((i = lminput ()) != EOF)
03151     {
03152       <font class="keywordtype">char</font> c = (<font class="keywordtype">char</font>) i;
03153       
03154       
03155       <font class="keywordflow">if</font> (c == <font class="charliteral">'\\'</font>)
03156         {
03157           skipnext = TRUE;
03158         }
03159       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c == <font class="charliteral">'\n'</font>)
03160         {
03161           <font class="keywordflow">if</font> (skipnext)
03162             {
03163               skipnext = FALSE;
03164             }
03165           <font class="keywordflow">else</font>
03166             {
03167               <a class="code" href="general_c.html#a43">checkUngetc</a> (i, yyin);
03168               <font class="keywordflow">return</font>;
03169             }
03170         }
03171     }
03172 
03173   <font class="keywordflow">if</font> (i != EOF)
03174     {
03175       <a class="code" href="general_c.html#a43">checkUngetc</a> (i, yyin);
03176     }
03177 }
03178 
03179 <font class="keyword">static</font> <font class="keywordtype">int</font> commentMarkerToken (cstring s)<font class="keyword"></font>
03180 <font class="keyword"></font>{
03181   <font class="keywordtype">int</font> i = 0;
03182   
03183   <font class="keywordflow">while</font> (s_parsetable[i].name != NULL) 
03184     {
03185       <font class="keywordflow">if</font> (cstring_equalLit (s, s_parsetable[i].name))
03186         {
03187           <font class="keywordflow">return</font> s_parsetable[i].token;
03188         }
03189 
03190       i++;
03191     }
03192 
03193   <font class="keywordflow">return</font> BADTOK;
03194 }
03195 
03196 <font class="keyword">static</font> <font class="keywordtype">int</font> tokenMacroCode (cstring s)<font class="keyword"></font>
03197 <font class="keyword"></font>{
03198   <font class="keywordtype">int</font> i = 0;
03199   
03200   <font class="keywordflow">while</font> (s_keytable[i].name != NULL) 
03201     {
03202       <font class="keywordflow">if</font> (cstring_equalLit (s, s_keytable[i].name)) 
03203         {
03204           <font class="keywordflow">if</font> (s_keytable[i].token == QLINTFALLTHROUGH) 
03205             {
03206               voptgenerror
03207                 (FLG_WARNLINTCOMMENTS,
03208                  cstring_makeLiteral
03209                  (<font class="stringliteral">"Traditional lint comment /*FALLTHROUGH*/ used.  "</font>
03210                   <font class="stringliteral">"This is interpreted by "</font>
03211                   <font class="stringliteral">"LCLint in the same way as most Unix lints, but it is "</font>
03212                   <font class="stringliteral">"preferable to replace it with the /*@fallthrough@*/ "</font>
03213                   <font class="stringliteral">"stylized comment"</font>),
03214                  g_currentloc);
03215               <font class="keywordflow">return</font> QFALLTHROUGH;            
03216             }
03217           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QLINTFALLTHRU)
03218             {
03219               voptgenerror 
03220                 (FLG_WARNLINTCOMMENTS,
03221                  cstring_makeLiteral
03222                  (<font class="stringliteral">"Traditional lint comment /*FALLTHRU*/ used.  "</font>
03223                   <font class="stringliteral">"This is interpreted by "</font>
03224                   <font class="stringliteral">"LCLint in the same way as most Unix lints, but it is "</font>
03225                   <font class="stringliteral">"preferable to replace it with the /*@fallthrough@*/ "</font>
03226                   <font class="stringliteral">"stylized comment"</font>),
03227                  g_currentloc);
03228               <font class="keywordflow">return</font> QFALLTHROUGH;
03229             }
03230           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QLINTNOTREACHED)
03231             {
03232               voptgenerror 
03233                 (FLG_WARNLINTCOMMENTS,
03234                  cstring_makeLiteral
03235                  (<font class="stringliteral">"Traditional lint comment /*NOTREACHED*/ used.  "</font>
03236                   <font class="stringliteral">"This is interpreted by "</font>
03237                   <font class="stringliteral">"LCLint in the same way as most Unix lints, but it is "</font>
03238                   <font class="stringliteral">"preferable to replace it with the /*@notreached@*/ "</font>
03239                   <font class="stringliteral">"stylized comment."</font>),
03240                  g_currentloc);
03241               
03242               <font class="keywordflow">return</font> QNOTREACHED;
03243             }
03244           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QPRINTFLIKE)
03245             {
03246               <a class="code" href="clabstract_c.html#a29">setSpecialFunction</a> (QU_PRINTFLIKE);
03247               <font class="keywordflow">return</font> SKIPTOK;
03248             }
03249           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QLINTPRINTFLIKE)
03250             {         
03251               voptgenerror 
03252                 (FLG_WARNLINTCOMMENTS,
03253                  cstring_makeLiteral
03254                  (<font class="stringliteral">"Traditional lint comment /*PRINTFLIKE*/ used.  "</font>
03255                   <font class="stringliteral">"This is interpreted by "</font>
03256                   <font class="stringliteral">"LCLint in the same way as most Unix lints, but it is "</font>
03257                   <font class="stringliteral">"preferable to replace it with either /*@printflike@*/, "</font>
03258                   <font class="stringliteral">"/*@scanflike@*/ or /*@messagelike@*/."</font>),
03259                  g_currentloc);
03260               
03261               <a class="code" href="clabstract_c.html#a29">setSpecialFunction</a> (QU_PRINTFLIKE);
03262               <font class="keywordflow">return</font> SKIPTOK;
03263             }
03264           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QSCANFLIKE)
03265             {
03266               <a class="code" href="clabstract_c.html#a29">setSpecialFunction</a> (QU_SCANFLIKE);
03267               <font class="keywordflow">return</font> SKIPTOK;
03268             }
03269           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QMESSAGELIKE)
03270             {
03271               <a class="code" href="clabstract_c.html#a29">setSpecialFunction</a> (QU_MESSAGELIKE);
03272               <font class="keywordflow">return</font> SKIPTOK;
03273             }
03274           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (s_keytable[i].token == QARGSUSED)
03275             {
03276               voptgenerror
03277                 (FLG_WARNLINTCOMMENTS,
03278                  cstring_makeLiteral
03279                  (<font class="stringliteral">"Traditional lint comment /*ARGSUSED*/ used.  "</font>
03280                   <font class="stringliteral">"This is interpreted by "</font>
03281                   <font class="stringliteral">"LCLint in the same way as most Unix lints, but it is "</font>
03282                   <font class="stringliteral">"preferable to use /*@unused@*/ annotations on "</font>
03283                   <font class="stringliteral">"the unused parameters."</font>),
03284                  g_currentloc);
03285               
03286               <a class="code" href="clabstract_c.html#a27">setArgsUsed</a> ();
03287               <font class="keywordflow">return</font> SKIPTOK;
03288             }
03289           
03290           <font class="keywordflow">return</font> s_keytable[i].token;
03291         }
03292       
03293       i++;
03294     }
03295   
03296   <font class="keywordflow">return</font> BADTOK;
03297 }
03298 
03299 <font class="keyword">static</font> <font class="keywordtype">int</font> lminput ()<font class="keyword"></font>
03300 <font class="keyword"></font>{
03301   <font class="keywordflow">if</font> (savechar == <font class="charliteral">'\0'</font>)
03302     {
03303       incColumn ();
03304       <font class="keywordflow">return</font> (input ());
03305     }
03306   <font class="keywordflow">else</font>
03307     {
03308       <font class="keywordtype">int</font> save = (<font class="keywordtype">int</font>) savechar;
03309       savechar = <font class="charliteral">'\0'</font>;
03310       <font class="keywordflow">return</font> save;
03311     }
03312 }
03313 
03314 <font class="keyword">static</font> <font class="keywordtype">void</font> lmsavechar (<font class="keywordtype">char</font> c)<font class="keyword"></font>
03315 <font class="keyword"></font>{
03316   <font class="keywordflow">if</font> (savechar == <font class="charliteral">'\0'</font>) savechar = c;
03317   <font class="keywordflow">else</font>
03318     {
03319       llbuglit (<font class="stringliteral">"lmsavechar: override"</font>);
03320     }
03321 }
03322 
03323 <font class="keyword">static</font> <font class="keywordtype">int</font> returnFloat (ctype ct, <font class="keywordtype">double</font> f)<font class="keyword"></font>
03324 <font class="keyword"></font>{
03325   yylval.expr = <a class="code" href="exprNode_c.html#a74">exprNode_floatLiteral</a> (f, ct, cstring_fromChars (yytext), 
03326                                        <a class="code" href="fileloc_c.html#a2">fileloc_decColumn</a> (g_currentloc, tokLength));
03327   tokLength = 0; 
03328   <font class="keywordflow">return</font> (CCONSTANT);
03329 }
03330 
03331 <font class="keyword">static</font> <font class="keywordtype">int</font> returnInt (ctype ct, <font class="keywordtype">long</font> i)<font class="keyword"></font>
03332 <font class="keyword"></font>{
03333   ctype c = ct;
03334 
03335   <font class="keywordflow">if</font> (ctype_equal (ct, ctype_int))
03336     {
03337       <font class="keywordflow">if</font> (i == 0)
03338         {
03339           c = <a class="code" href="context_c.html#a160">context_typeofZero</a> ();
03340         }
03341       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (i == 1)
03342         {
03343           c = <a class="code" href="context_c.html#a161">context_typeofOne</a> ();
03344         }
03345     }
03346   
03347   yylval.expr = <a class="code" href="exprNode_c.html#a72">exprNode_numLiteral</a> (c, cstring_fromChars (yytext), 
03348                                      <a class="code" href="fileloc_c.html#a2">fileloc_decColumn</a> (g_currentloc, tokLength), i);   
03349   tokLength = 0; 
03350   <font class="keywordflow">return</font> (CCONSTANT);
03351 }
03352 
03353 <font class="keyword">static</font> <font class="keywordtype">int</font> returnChar (<font class="keywordtype">char</font> c)<font class="keyword"></font>
03354 <font class="keyword"></font>{
03355   yylval.expr = <a class="code" href="exprNode_c.html#a73">exprNode_charLiteral</a> (c, cstring_fromChars (yytext), 
03356                                       <a class="code" href="fileloc_c.html#a2">fileloc_decColumn</a> (g_currentloc, tokLength));
03357   tokLength = 0; 
03358   <font class="keywordflow">return</font> (CCONSTANT);
03359 }
03360 
03361 <font class="keyword">static</font> <font class="keywordtype">int</font> ninput ()<font class="keyword">  </font>
03362 <font class="keyword"></font>{
03363   <font class="keywordtype">int</font> c = lminput ();
03364 
03365   <font class="keywordflow">if</font> (c != EOF &amp;&amp; ((<font class="keywordtype">char</font>)c == <font class="charliteral">'\n'</font>))
03366     {
03367       <a class="code" href="context_c.html#a46">context_incLineno</a> ();
03368     }
03369 
03370   <font class="keywordflow">return</font> c;
03371 }
03372 
03373 <font class="keyword">static</font> <font class="keywordtype">char</font> macro_nextChar ()<font class="keyword"></font>
03374 <font class="keyword"></font>{
03375   <font class="keyword">static</font> <font class="keywordtype">bool</font> in_quote = FALSE, in_escape = FALSE, in_char = FALSE;
03376   <font class="keywordtype">int</font> ic;
03377   <font class="keywordtype">char</font> c;
03378 
03379   ic = lminput ();
03380   c = <a class="code" href="general_c.html#a36">char_fromInt</a> (ic);
03381   
03382   <font class="keywordflow">if</font> (!in_quote &amp;&amp; !in_char &amp;&amp; (c == <font class="charliteral">'\\'</font> || c == BEFORE_COMMENT_MARKER[0]))
03383     {
03384       <font class="keywordflow">if</font> (c == <font class="charliteral">'\\'</font>)
03385         {
03386           <font class="keywordflow">while</font> ((c = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\0'</font> &amp;&amp; c != <font class="charliteral">'\n'</font>)
03387             {
03388               ; <font class="comment">/* skip to newline */</font>
03389             }
03390           
03391           <a class="code" href="context_c.html#a46">context_incLineno</a> ();
03392           
03393           <font class="keywordflow">if</font> (c != <font class="charliteral">'\0'</font>)
03394             {
03395               <font class="keywordflow">return</font> macro_nextChar ();
03396             }
03397           <font class="keywordflow">else</font> 
03398             {
03399               <font class="keywordflow">return</font> c;
03400             }
03401         }
03402       <font class="keywordflow">else</font> <font class="comment">/* if (c == '@') */</font>
03403         {
03404           <font class="keywordflow">if</font> (handleLlSpecial () != BADTOK)
03405             {
03406               llerrorlit (FLG_SYNTAX, <font class="stringliteral">"Macro cannot use special syntax"</font>);
03407             }
03408 
03409           <font class="keywordflow">return</font> macro_nextChar ();
03410         }
03411     }
03412   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!in_escape &amp;&amp; c == <font class="charliteral">'\"'</font>)
03413     {
03414       in_quote = !in_quote;
03415     }
03416   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!in_escape &amp;&amp; c == <font class="charliteral">'\''</font>)
03417     {
03418       in_char = !in_char;
03419     }
03420   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((in_quote || in_char) &amp;&amp; c == <font class="charliteral">'\\'</font>)
03421     {
03422       in_escape = !in_escape;
03423     }
03424   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((in_quote || in_char) &amp;&amp; in_escape)
03425     {
03426       in_escape = FALSE;
03427     }
03428   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!in_quote &amp;&amp; c == <font class="charliteral">'/'</font>)
03429     {
03430       <font class="keywordtype">char</font> c2;
03431       
03432       <font class="keywordflow">if</font> ((c2 = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) == <font class="charliteral">'*'</font>)
03433         {
03434           <font class="keywordflow">while</font> (c2 != <font class="charliteral">'\0'</font>)
03435             {
03436               <font class="keywordflow">while</font> ((c2 = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\0'</font>
03437                      &amp;&amp; c2 != <font class="charliteral">'\n'</font> &amp;&amp; c2 != <font class="charliteral">'*'</font>)
03438                 {
03439                   ;
03440                 }
03441               
03442               <font class="keywordflow">if</font> (c2 == <font class="charliteral">'*'</font>)
03443                 {
03444                   <font class="keywordflow">while</font> ((c2 = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\0'</font> 
03445                          &amp;&amp; c2 == <font class="charliteral">'*'</font>)
03446                     {
03447                       ;
03448                     }
03449 
03450                   <font class="keywordflow">if</font> (c2 == <font class="charliteral">'/'</font>)
03451                     {
03452                       <font class="keywordflow">goto</font> outofcomment;
03453                     }
03454                 }
03455               <font class="keywordflow">else</font> 
03456                 {
03457                   <a class="code" href="llerror_c.html#a48">llfatalerror</a> (cstring_makeLiteral (<font class="stringliteral">"Macro: bad comment!"</font>));
03458                 }
03459             }
03460         outofcomment:
03461           <font class="keywordflow">return</font> macro_nextChar ();
03462         }
03463       <font class="keywordflow">else</font>
03464         {
03465           <font class="comment">/*** putchar does not work!  why?  puts to stdio...??! ***/</font>
03466           lmsavechar (c2);
03467         }
03468     }
03469   <font class="keywordflow">return</font> c;
03470 }
03471 
03472 <font class="comment">/*</font>
03473 <font class="comment">** keeps stylized comments</font>
03474 <font class="comment">*/</font>
03475 
03476 <font class="keyword">static</font> <font class="keywordtype">char</font> macro_nextCharC ()<font class="keyword"></font>
03477 <font class="keyword"></font>{
03478   <font class="keyword">static</font> <font class="keywordtype">bool</font> in_quote = FALSE, in_escape = FALSE, in_char = FALSE;
03479   <font class="keywordtype">char</font> c;
03480 
03481   c = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ());
03482 
03483   <font class="keywordflow">if</font> (!in_quote &amp;&amp; !in_char &amp;&amp; c == <font class="charliteral">'\\'</font>)
03484     {
03485       <font class="keywordflow">while</font> ((c = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\0'</font> &amp;&amp; c != <font class="charliteral">'\n'</font>)
03486         {
03487           ; <font class="comment">/* skip to newline */</font>
03488         }
03489       
03490       <a class="code" href="context_c.html#a46">context_incLineno</a> ();
03491       
03492       <font class="keywordflow">if</font> (c != <font class="charliteral">'\0'</font>)
03493         {
03494           <font class="keywordflow">return</font> macro_nextCharC ();
03495         }
03496       <font class="keywordflow">else</font>
03497         {
03498           <font class="keywordflow">return</font> c;
03499         }
03500     }
03501   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!in_escape &amp;&amp; c == <font class="charliteral">'\"'</font>)
03502     {
03503       in_quote = !in_quote;
03504     }
03505   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!in_escape &amp;&amp; c == <font class="charliteral">'\''</font>)
03506     {
03507       in_char = !in_char;
03508     }
03509   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((in_quote || in_char) &amp;&amp; c == <font class="charliteral">'\\'</font>)
03510     {
03511       in_escape = !in_escape;
03512     }
03513   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((in_quote || in_char) &amp;&amp; in_escape)
03514     {
03515       in_escape = FALSE;
03516     }
03517   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!in_quote &amp;&amp; c == <font class="charliteral">'/'</font>)
03518     {
03519       <font class="keywordtype">char</font> c2;
03520       
03521       <font class="keywordflow">if</font> ((c2 = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) == <font class="charliteral">'*'</font>)
03522         {
03523           <font class="keywordflow">while</font> (c2 != <font class="charliteral">'\0'</font>)
03524             {
03525               <font class="keywordflow">while</font> ((c2 = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\0'</font> 
03526                      &amp;&amp; c2 != <font class="charliteral">'\n'</font> &amp;&amp; c2 != <font class="charliteral">'*'</font>)
03527                 {
03528                   ;
03529                 }
03530               
03531               <font class="keywordflow">if</font> (c2 == <font class="charliteral">'*'</font>)
03532                 {
03533                   <font class="keywordflow">while</font> ((c2 = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\0'</font>
03534                          &amp;&amp; c2 == <font class="charliteral">'*'</font>)
03535                     {
03536                       ;
03537                     }
03538 
03539                   <font class="keywordflow">if</font> (c2 == <font class="charliteral">'/'</font>) 
03540                     {
03541                       <font class="keywordflow">goto</font> outofcomment;
03542                     }
03543                 }
03544               <font class="keywordflow">else</font> 
03545                 {
03546                   <a class="code" href="llerror_c.html#a48">llfatalerror</a> (cstring_makeLiteral (<font class="stringliteral">"Macro: bad comment!"</font>));
03547                 }
03548             }
03549         outofcomment:
03550           <font class="keywordflow">return</font> macro_nextCharC ();
03551         }
03552       <font class="keywordflow">else</font>
03553         {
03554           lmsavechar (c2);
03555         }
03556     }
03557   <font class="keywordflow">return</font> c;
03558 }
03559 
03560 <font class="comment">/*</font>
03561 <font class="comment">** skips whitespace (handles line continuations)</font>
03562 <font class="comment">** returns first non-whitespace character</font>
03563 <font class="comment">*/</font>
03564 
03565 <font class="keyword">static</font> <font class="keywordtype">char</font> skip_whitespace ()<font class="keyword"></font>
03566 <font class="keyword"></font>{
03567   <font class="keywordtype">char</font> c;
03568 
03569   <font class="keywordflow">while</font> ((c = macro_nextChar ()) == <font class="charliteral">' '</font> || c == <font class="charliteral">'\t'</font>)
03570     {
03571       ;
03572     }
03573 
03574   <font class="keywordflow">return</font> c;
03575 }
03576 
03577 <font class="keyword">static</font> <font class="keywordtype">void</font> handleMacro ()<font class="keyword"></font>
03578 <font class="keyword"></font>{
03579   cstring mac = cstring_undefined;
03580   <font class="keywordtype">int</font> macrocode;
03581   <font class="keywordtype">char</font> c;
03582 
03583   <font class="keywordflow">while</font> (currentColumn () &gt; 2)
03584     {
03585       mac = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (mac, <font class="charliteral">' '</font>);
03586       setTokLength (-1);
03587     }
03588 
03589   c = macro_nextCharC ();
03590 
03591   <font class="keywordflow">if</font> (c &gt;= <font class="charliteral">'0'</font> &amp;&amp; c &lt;= <font class="charliteral">'9'</font>)
03592     {
03593       <font class="keywordtype">int</font> i;
03594 
03595       <font class="keywordflow">for</font> (i = 0; i &lt; ((c - <font class="charliteral">'0'</font>) + 1); i++)
03596         {
03597           mac = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (mac, <font class="charliteral">' '</font>);
03598         }
03599     }
03600   <font class="keywordflow">else</font>
03601     {
03602       BADBRANCH;
03603     }
03604 
03605   <font class="keywordflow">while</font> (((c = macro_nextCharC ()) != <font class="charliteral">'\0'</font>) &amp;&amp; (c != <font class="charliteral">'\n'</font>))
03606     {
03607       mac = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (mac, c);
03608     }
03609 
03610   
03611   macrocode = tokenMacroCode (mac);
03612 
03613   <font class="keywordflow">if</font> (macrocode == BADTOK &amp;&amp; !isArtificial (mac))
03614     {
03615       DPRINTF ((<font class="stringliteral">"Add macro: %s"</font>, mac));
03616       <a class="code" href="context_c.html#a34">context_addMacroCache</a> (mac);
03617     }
03618   <font class="keywordflow">else</font>
03619     {
03620       <a class="code" href="cstring_c.html#a27">cstring_free</a> (mac);
03621     }
03622 
03623   <font class="keywordflow">if</font> (c == <font class="charliteral">'\n'</font>)
03624     {
03625       <a class="code" href="context_c.html#a46">context_incLineno</a> ();
03626     }
03627 }
03628 
03629 <font class="keyword">static</font> <font class="keywordtype">bool</font> processMacro (<font class="keywordtype">void</font>)<font class="keyword"></font>
03630 <font class="keyword"></font>{
03631   uentry e2;
03632   ctype ct;
03633   <font class="keywordtype">int</font> noparams = 0;
03634   cstring fname = cstring_undefined;
03635   <font class="keywordtype">bool</font> res = TRUE;
03636   <font class="keywordtype">bool</font> isspecfcn = FALSE;
03637   <font class="keywordtype">bool</font> isiter = FALSE;
03638   <font class="keywordtype">bool</font> skipparam = FALSE;
03639   <font class="keywordtype">bool</font> isenditer = FALSE;
03640   <font class="keywordtype">bool</font> unknownm = FALSE;
03641   <font class="keywordtype">bool</font> hasParams = FALSE;
03642   <font class="keywordtype">bool</font> emptyMacro = FALSE;
03643   <font class="keywordtype">char</font> c = skip_whitespace ();
03644   fileloc loc = <a class="code" href="fileloc_c.html#a3">fileloc_noColumn</a> (g_currentloc);
03645 
03646   <font class="comment">/* are both of these necessary?  what do they mean? */</font>
03647   uentryList specparams = uentryList_undefined;
03648   uentryList pn = uentryList_undefined;
03649 
03650   <a class="code" href="context_c.html#a254">context_resetMacroMissingParams</a> ();
03651 
03652   <font class="keywordflow">if</font> (c == <font class="charliteral">'\0'</font> || c == <font class="charliteral">'\n'</font>)
03653     {
03654       llcontbug (cstring_makeLiteral (<font class="stringliteral">"Bad macro"</font>));
03655       <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
03656       <font class="keywordflow">return</font> FALSE;
03657     }
03658   
03659   fname = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (fname, c);  
03660 
03661   <font class="keywordflow">while</font> ((c = macro_nextChar ()) != <font class="charliteral">'('</font> &amp;&amp; c != <font class="charliteral">'\0'</font>
03662          &amp;&amp; c != <font class="charliteral">' '</font> &amp;&amp; c != <font class="charliteral">'\t'</font> &amp;&amp; c != <font class="charliteral">'\n'</font>)
03663     {
03664       fname = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (fname, c);
03665     }
03666 
03667   <font class="keywordflow">if</font> (c == <font class="charliteral">' '</font> || c == <font class="charliteral">'\t'</font> || c == <font class="charliteral">'\n'</font>)
03668     {
03669       <font class="keywordtype">char</font> oldc = c;
03670 
03671       <font class="keywordflow">if</font> (c != <font class="charliteral">'\n'</font>)
03672         {
03673           <font class="keywordflow">while</font> (c == <font class="charliteral">' '</font> || c == <font class="charliteral">'\t'</font>)
03674             {
03675               c = macro_nextChar ();
03676             }
03677           <a class="code" href="lex_yy_c.html#a18">unput</a> (c);
03678         }
03679 
03680       <font class="keywordflow">if</font> (c == <font class="charliteral">'\n'</font>)
03681         {
03682           emptyMacro = TRUE;
03683           <a class="code" href="lex_yy_c.html#a18">unput</a> (c);
03684         }
03685 
03686       c = oldc;
03687     }
03688 
03689   hasParams = (c == <font class="charliteral">'('</font>);
03690 
03691   
03692   <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (fname))
03693     {
03694       e2 = <a class="code" href="usymtab_c.html#a114">usymtab_lookupExpose</a> (fname);
03695       ct = <a class="code" href="uentry_c.html#a197">uentry_getType</a> (e2);
03696 
03697       
03698       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a211">uentry_isCodeDefined</a> (e2) 
03699           &amp;&amp; <a class="code" href="fileloc_c.html#a50">fileloc_isUser</a> (uentry_whereDefined (e2)))
03700         {
03701           <font class="keywordflow">if</font> (optgenerror 
03702               (FLG_MACROREDEF,
03703                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Macro %s already defined"</font>, fname),
03704                loc))
03705             {
03706               <a class="code" href="uentry_c.html#a246">uentry_showWhereDefined</a> (e2);
03707               <a class="code" href="uentry_c.html#a209">uentry_clearDefined</a> (e2);
03708             }
03709 
03710           <font class="keywordflow">if</font> (uentry_isFunction (e2))
03711             {
03712               <a class="code" href="uentry_c.html#a216">uentry_setType</a> (e2, ctype_unknown);
03713               ct = ctype_unknown;
03714               unknownm = TRUE;
03715               <a class="code" href="context_c.html#a72">context_enterUnknownMacro</a> (e2); 
03716             }
03717           <font class="keywordflow">else</font>
03718             {
03719               <a class="code" href="context_c.html#a95">context_enterConstantMacro</a> (e2);
03720             }
03721         }
03722       <font class="keywordflow">else</font>
03723         {
03724           <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a108">uentry_isForward</a> (e2) &amp;&amp; uentry_isFunction (e2))
03725             {
03726               unknownm = TRUE;
03727 
03728               voptgenerror 
03729                 (FLG_MACROFCNDECL,
03730                  message
03731                  (<font class="stringliteral">"Parameterized macro has no prototype or specification: %s "</font>, 
03732                   fname),
03733                  loc);
03734               
03735               ct = ctype_unknown;
03736               <a class="code" href="uentry_c.html#a216">uentry_setType</a> (e2, ctype_unknown);
03737               <a class="code" href="uentry_c.html#a204">uentry_setFunctionDefined</a> (e2, loc); 
03738               <a class="code" href="uentry_c.html#a278">uentry_setUsed</a> (e2, fileloc_undefined);
03739               <a class="code" href="context_c.html#a72">context_enterUnknownMacro</a> (e2); 
03740             }
03741           <font class="keywordflow">else</font>
03742             {
03743               <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a184">uentry_isIter</a> (e2))
03744                 {
03745                   isiter = TRUE;
03746                   specparams = <a class="code" href="uentry_c.html#a193">uentry_getParams</a> (e2);
03747                   noparams = <a class="code" href="uentryList_c.html#a29">uentryList_size</a> (specparams);
03748                   <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, loc);
03749                   <a class="code" href="context_c.html#a191">context_enterIterDef</a> (e2); 
03750                 }
03751               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a185">uentry_isEndIter</a> (e2))
03752                 {
03753                   isenditer = TRUE;
03754                   <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, loc);
03755                   <a class="code" href="context_c.html#a192">context_enterIterEnd</a> (e2); <font class="comment">/* don't care about it now */</font>
03756                   <font class="comment">/* but should parse like an iter! */</font>
03757                 }
03758               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (uentry_isConstant (e2))
03759                 {
03760                   <font class="keywordflow">if</font> (hasParams)
03761                     {
03762                       voptgenerror 
03763                         (FLG_INCONDEFS, 
03764                          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Constant %s implemented as parameterized macro"</font>,
03765                                   fname),
03766                          g_currentloc);
03767                       
03768                       <a class="code" href="uentry_c.html#a249">uentry_showWhereSpecified</a> (e2);
03769                       <a class="code" href="uentry_c.html#a216">uentry_setType</a> (e2, ctype_unknown);
03770                       <a class="code" href="uentry_c.html#a100">uentry_makeVarFunction</a> (e2);
03771                       <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, g_currentloc);
03772                       <a class="code" href="uentry_c.html#a204">uentry_setFunctionDefined</a> (e2, g_currentloc);
03773                       <a class="code" href="context_c.html#a72">context_enterUnknownMacro</a> (e2); 
03774                     }
03775                   <font class="keywordflow">else</font>
03776                     {
03777                       <font class="keywordflow">if</font> (!<a class="code" href="uentry_c.html#a160">uentry_isSpecified</a> (e2))
03778                         {
03779                           fileloc oloc = <a class="code" href="uentry_c.html#a202">uentry_whereDeclared</a> (e2);
03780 
03781                           <font class="keywordflow">if</font> (<a class="code" href="fileloc_c.html#a47">fileloc_isLib</a> (oloc))
03782                             {
03783                               ;
03784                             }
03785                           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (fileloc_isUndefined (oloc)
03786                                    || fileloc_isPreproc (oloc))
03787                             {
03788                               <font class="keywordflow">if</font> (!emptyMacro)
03789                                 {
03790                                   voptgenerror
03791                                     (FLG_MACROCONSTDECL,
03792                                      message 
03793                                      (<font class="stringliteral">"Macro constant %q not declared"</font>,
03794                                       <a class="code" href="uentry_c.html#a195">uentry_getName</a> (e2)),
03795                                      loc);                       
03796                                 }
03797                             }
03798                           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!<a class="code" href="fileloc_c.html#a13">fileloc_withinLines</a> (oloc, loc, 2))
03799                             { <font class="comment">/* bogus!  will give errors if there is too much whitespace */</font>
03800                               voptgenerror
03801                                 (FLG_SYNTAX,
03802                                  message 
03803                                  (<font class="stringliteral">"Macro constant name %s does not match name in "</font>
03804                                   <font class="stringliteral">"previous constant declaration.  This constant "</font>
03805                                   <font class="stringliteral">"is declared at %q"</font>, fname, 
03806                                   <a class="code" href="fileloc_c.html#a39">fileloc_unparse</a> (oloc)),
03807                                  loc);
03808                             }
03809                         }
03810 
03811                       <a class="code" href="context_c.html#a95">context_enterConstantMacro</a> (e2);        
03812                       <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
03813                       <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
03814                       <font class="keywordflow">return</font> res;
03815                     }
03816 
03817                 }
03818               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a49">ctype_isFunction</a> (ct))
03819                 {
03820                   isspecfcn = TRUE;
03821                   specparams = <a class="code" href="ctype_c.html#a40">ctype_argsFunction</a> (ct);
03822                   noparams = <a class="code" href="uentryList_c.html#a29">uentryList_size</a> (specparams);
03823                   
03824                   <a class="code" href="uentry_c.html#a204">uentry_setFunctionDefined</a> (e2, loc); 
03825                   <a class="code" href="context_c.html#a71">context_enterMacro</a> (e2);
03826                 }
03827               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a161">uentry_isVar</a> (e2))
03828                 {
03829                   <font class="keywordflow">if</font> (hasParams)
03830                     {
03831                       voptgenerror
03832                         (FLG_INCONDEFS,
03833                          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Variable %s implemented as parameterized macro"</font>, 
03834                                   fname),
03835                          loc);
03836 
03837                       <a class="code" href="uentry_c.html#a249">uentry_showWhereSpecified</a> (e2);
03838                       <a class="code" href="uentry_c.html#a216">uentry_setType</a> (e2, ctype_unknown);
03839                       <a class="code" href="uentry_c.html#a100">uentry_makeVarFunction</a> (e2);
03840                       <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, g_currentloc);
03841                       <a class="code" href="uentry_c.html#a204">uentry_setFunctionDefined</a> (e2, g_currentloc);
03842                       <a class="code" href="context_c.html#a72">context_enterUnknownMacro</a> (e2); 
03843                     }
03844                   <font class="keywordflow">else</font>
03845                     {
03846                       uentry ucons = <a class="code" href="uentry_c.html#a85">uentry_makeConstant</a> (fname,
03847                                                           ctype_unknown,
03848                                                           loc);
03849                       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a171">uentry_isExpandedMacro</a> (e2))
03850                         {
03851                           ; <font class="comment">/* okay */</font>
03852                         }
03853                       <font class="keywordflow">else</font>
03854                         {
03855                           <font class="keywordflow">if</font> (optgenerror 
03856                               (FLG_INCONDEFS,
03857                                <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Variable %s implemented by a macro"</font>,
03858                                         fname),
03859                                loc))
03860                             {
03861                               <a class="code" href="uentry_c.html#a249">uentry_showWhereSpecified</a> (e2);
03862                             }
03863                         }
03864 
03865                       <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, loc);
03866                       <a class="code" href="uentry_c.html#a278">uentry_setUsed</a> (ucons, loc);
03867 
03868                       <a class="code" href="context_c.html#a95">context_enterConstantMacro</a> (ucons);
03869                       <a class="code" href="uentry_c.html#a237">uentry_markOwned</a> (ucons);
03870                       <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
03871                       <font class="keywordflow">return</font> res;
03872                     }
03873                 }
03874               <font class="keywordflow">else</font>
03875                 {
03876                   <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (e2))
03877                     {
03878                       vgenhinterror 
03879                         (FLG_SYNTAX,
03880                          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Type implemented as macro: %x"</font>, 
03881                                   uentry_getName (e2)),
03882                          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"A type is implemented using a macro definition.  A "</font>
03883                                   <font class="stringliteral">"typedef should be used instead."</font>),
03884                          g_currentloc);
03885 
03886                       <a class="code" href="cgrammar_tab_c.html#a223">swallowMacro</a> ();
03887                       <font class="comment">/* Must exit scope (not sure why a new scope was entered?) */</font>
03888                       <a class="code" href="usymtab_c.html#a106">usymtab_quietExitScope</a> (g_currentloc);
03889                       <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, g_currentloc);
03890                       res = FALSE;
03891                     }
03892                   <font class="keywordflow">else</font>
03893                     {
03894                       llcontbug 
03895                         (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unexpanded macro not function or constant: %q"</font>, 
03896                                   uentry_unparse (e2)));
03897                       <a class="code" href="uentry_c.html#a216">uentry_setType</a> (e2, ctype_unknown);
03898                       
03899                       <font class="keywordflow">if</font> (hasParams)
03900                         {
03901                           <a class="code" href="uentry_c.html#a100">uentry_makeVarFunction</a> (e2);
03902                           <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (e2, g_currentloc);
03903                           <a class="code" href="uentry_c.html#a204">uentry_setFunctionDefined</a> (e2, g_currentloc);
03904                           <a class="code" href="context_c.html#a72">context_enterUnknownMacro</a> (e2); 
03905                         }
03906                     }
03907                 }
03908             }
03909         }
03910     }
03911   <font class="keywordflow">else</font>
03912     {
03913       uentry ce;
03914 
03915       voptgenerror 
03916         (FLG_MACROMATCHNAME,
03917          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unexpanded macro %s does not match name of a constant "</font>
03918                   <font class="stringliteral">"or iter declaration.  The name used in the control "</font>
03919                   <font class="stringliteral">"comment on the previous line should match.  "</font>
03920                   <font class="stringliteral">"(Assuming macro defines a constant.)"</font>, 
03921                   fname),
03922          loc);
03923 
03924 
03925       ce = <a class="code" href="uentry_c.html#a85">uentry_makeConstant</a> (fname, ctype_unknown, fileloc_undefined);      
03926       <a class="code" href="uentry_c.html#a278">uentry_setUsed</a> (ce, loc); <font class="comment">/* perhaps bogus? */</font>
03927       e2 = <a class="code" href="usymtab_c.html#a52">usymtab_supEntryReturn</a> (ce);
03928       
03929       <a class="code" href="context_c.html#a95">context_enterConstantMacro</a> (e2);        
03930       <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
03931       <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
03932       <font class="keywordflow">return</font> res;
03933     }
03934   
03935   <font class="comment">/* in macros, ( must follow immediatetly after name */</font>
03936   
03937   <font class="keywordflow">if</font> (hasParams)
03938     {
03939       <font class="keywordtype">int</font> paramno = 0;
03940       
03941       c = skip_whitespace ();
03942 
03943       <font class="keywordflow">while</font> (c != <font class="charliteral">')'</font> &amp;&amp; c != <font class="charliteral">'\0'</font>)
03944         {
03945           uentry  param;
03946           <font class="keywordtype">bool</font>    suppress = <a class="code" href="context_c.html#a41">context_inSuppressRegion</a> ();
03947           cstring paramname = cstring_undefined;
03948 
03949           <font class="comment">/*</font>
03950 <font class="comment">          ** save the parameter location</font>
03951 <font class="comment">          */</font>
03952 
03953           decColumn ();
03954           <a class="code" href="context_c.html#a182">context_saveLocation</a> ();
03955           incColumn ();
03956 
03957           <font class="keywordflow">while</font> (c != <font class="charliteral">' '</font> &amp;&amp; c != <font class="charliteral">'\t'</font> &amp;&amp; c != <font class="charliteral">','</font> &amp;&amp; c != <font class="charliteral">'\0'</font> &amp;&amp; c != <font class="charliteral">')'</font>)
03958             {
03959               paramname = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (paramname, c);
03960               c = macro_nextChar ();
03961             }
03962           
03963           <font class="keywordflow">if</font> (c == <font class="charliteral">' '</font> || c == <font class="charliteral">'\t'</font>) c = skip_whitespace ();
03964 
03965           <font class="keywordflow">if</font> (c == <font class="charliteral">','</font>)
03966             {
03967               c = macro_nextChar ();
03968               <font class="keywordflow">if</font> (c == <font class="charliteral">' '</font> || c == <font class="charliteral">'\t'</font>) c = skip_whitespace ();
03969             }
03970           
03971           <font class="keywordflow">if</font> (c == <font class="charliteral">'\0'</font>)
03972             {
03973               <a class="code" href="llerror_c.html#a48">llfatalerror</a> (cstring_makeLiteral
03974                             (<font class="stringliteral">"Bad macro syntax: uentryList"</font>));
03975             }
03976           
03977           <font class="keywordflow">if</font> ((isspecfcn || isiter) &amp;&amp; (paramno &lt; noparams)
03978               &amp;&amp; !uentry_isElipsisMarker (uentryList_getN 
03979                                           (specparams, paramno)))
03980             {
03981               uentry decl = <a class="code" href="uentryList_c.html#a15">uentryList_getN</a> (specparams, paramno);
03982               sRef sr;
03983               
03984               param = <a class="code" href="uentry_c.html#a224">uentry_nameCopy</a> (paramname, decl);
03985 
03986                               
03987               <a class="code" href="uentry_c.html#a219">uentry_setParam</a> (param);
03988               sr = <a class="code" href="sRef_c.html#a133">sRef_makeParam</a> (paramno, uentry_getType (param));
03989 
03990               <font class="keywordflow">if</font> (sRef_getNullState (sr) == NS_ABSNULL)
03991                 {
03992                   ctype pt = <a class="code" href="ctype_c.html#a27">ctype_realType</a> (uentry_getType (param));
03993 
03994                   <font class="keywordflow">if</font> (<a class="code" href="ctype_c.html#a32">ctype_isUser</a> (pt))
03995                     {
03996                       uentry te = <a class="code" href="usymtab_c.html#a72">usymtab_getTypeEntrySafe</a> (ctype_typeId (pt));
03997                       
03998                       <font class="keywordflow">if</font> (uentry_isValid (te))
03999                         {
04000                           <a class="code" href="sRef_c.html#a266">sRef_setStateFromUentry</a> (sr, te);
04001                         }
04002                     }
04003                   <font class="keywordflow">else</font>
04004                     {
04005                       <a class="code" href="sRef_c.html#a214">sRef_setNullState</a> (sr, NS_UNKNOWN, g_currentloc);
04006                     }
04007                 }
04008 
04009               <a class="code" href="uentry_c.html#a220">uentry_setSref</a> (param, sr);
04010               <a class="code" href="uentry_c.html#a206">uentry_setDeclaredForceOnly</a> (param, context_getSaveLocation ());
04011 
04012               skipparam = isiter &amp;&amp; <a class="code" href="uentry_c.html#a176">uentry_isOut</a> (uentryList_getN (specparams, paramno));
04013             }
04014           <font class="keywordflow">else</font>
04015             {
04016               fileloc sloc = <a class="code" href="context_c.html#a183">context_getSaveLocation</a> ();
04017 
04018               param = uentry_makeVariableSrefParam 
04019                 (paramname, ctype_unknown, <a class="code" href="sRef_c.html#a133">sRef_makeParam</a> (paramno, ctype_unknown));
04020               <a class="code" href="cstring_c.html#a27">cstring_free</a> (paramname);
04021 
04022               <a class="code" href="sRef_c.html#a216">sRef_setPosNull</a>  (uentry_getSref (param), sloc);
04023 
04024               <a class="code" href="uentry_c.html#a205">uentry_setDeclaredForce</a> (param, sloc);
04025 
04026               skipparam = FALSE;
04027               <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (sloc);
04028             }
04029 
04030           <font class="keywordflow">if</font> (!skipparam)
04031             {
04032               llassert (!uentry_isElipsisMarker (param));
04033 
04034               <font class="keywordflow">if</font> (!suppress)
04035                 {
04036                   <a class="code" href="sRef_c.html#a168">sRef_makeUnsafe</a> (uentry_getSref (param));
04037                 }
04038               
04039               pn = <a class="code" href="uentryList_c.html#a4">uentryList_add</a> (pn, uentry_copy (param));
04040               <a class="code" href="usymtab_c.html#a50">usymtab_supEntry</a> (param);
04041             }
04042           <font class="keywordflow">else</font>
04043             {
04044               <font class="comment">/* don't add param */</font>
04045               <a class="code" href="uentry_c.html#a238">uentry_free</a> (param);
04046             }
04047 
04048           <font class="keywordflow">if</font> (c == <font class="charliteral">','</font>) 
04049             {
04050               (<font class="keywordtype">void</font>) macro_nextChar ();
04051               c = skip_whitespace ();
04052             }
04053 
04054           paramno++;
04055         }
04056       
04057       <font class="keywordflow">if</font> (c == <font class="charliteral">')'</font>)
04058         {
04059           <font class="keywordflow">if</font> (isspecfcn || isiter)
04060             {
04061               <font class="keywordflow">if</font> (paramno != noparams &amp;&amp; noparams &gt;= 0)
04062                 {
04063                   advanceLine ();
04064 
04065                   voptgenerror 
04066                     (FLG_INCONDEFS,
04067                      <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Macro %s specified with %d args, defined with %d"</font>, 
04068                               fname, noparams, paramno),
04069                      g_currentloc);
04070 
04071                   <a class="code" href="uentry_c.html#a249">uentry_showWhereSpecified</a> (e2);
04072                   <a class="code" href="uentry_c.html#a217">uentry_resetParams</a> (e2, pn);
04073                 }
04074             }
04075           <font class="keywordflow">else</font>
04076             {
04077               <a class="code" href="uentry_c.html#a217">uentry_resetParams</a> (e2, pn);
04078             }
04079         }
04080     }
04081   <font class="keywordflow">else</font>
04082     {
04083       <font class="comment">/*</font>
04084 <font class="comment">      ** the form should be:</font>
04085 <font class="comment">      **</font>
04086 <font class="comment">      ** # define newname oldname</font>
04087 <font class="comment">      ** where oldname refers to a function matching the specification</font>
04088 <font class="comment">      ** of newname.</font>
04089 <font class="comment">      */</font>
04090 
04091       <font class="keywordflow">if</font> (unknownm)
04092         {
04093           <a class="code" href="sRef_c.html#a81">sRef_setGlobalScope</a> ();
04094           <a class="code" href="usymtab_c.html#a61">usymtab_supGlobalEntry</a> (uentry_makeVariableLoc (fname, ctype_unknown));
04095           <a class="code" href="sRef_c.html#a82">sRef_clearGlobalScope</a> ();
04096         }
04097       <font class="keywordflow">else</font>
04098         {
04099           <a class="code" href="context_c.html#a253">context_setMacroMissingParams</a> ();
04100         }
04101     }
04102   
04103   
04104   <font class="comment">/* context_setuentryList (pn); */</font>
04105   <a class="code" href="usymtab_c.html#a84">usymtab_enterScope</a> ();
04106 
04107   <a class="code" href="fileloc_c.html#a8">fileloc_free</a> (loc);
04108   <a class="code" href="cstring_c.html#a27">cstring_free</a> (fname);
04109 
04110   <font class="keywordflow">return</font> res;
04111 }
04112 
04113 <font class="keyword">static</font> <font class="keywordtype">bool</font> handleSpecial (<font class="keywordtype">char</font> *yyt)<font class="keyword"></font>
04114 <font class="keyword"></font>{
04115   <font class="keywordtype">char</font> *l = <a class="code" href="general_c.html#a29">mstring_create</a> (MAX_NAME_LENGTH);
04116   <font class="keyword">static</font> <font class="keywordtype">bool</font> reportcpp = FALSE;
04117   <font class="keywordtype">int</font> lineno = 0;
04118   <font class="keywordtype">char</font> c;
04119   <font class="keywordtype">char</font> *ol;
04120   cstring olc;
04121   
04122   strcpy (l, yyt + 1);
04123 
04124   <font class="comment">/* Need to safe original l for deallocating. */</font>
04125   ol = l;
04126 
04127   l += strlen (yyt) - 1;
04128   
04129   <font class="keywordflow">while</font> ((c = <a class="code" href="general_c.html#a36">char_fromInt</a> (lminput ())) != <font class="charliteral">'\n'</font> &amp;&amp; c != <font class="charliteral">'\0'</font>)
04130     {
04131       *l++ = c;
04132     }
04133 
04134   *l = <font class="charliteral">'\0'</font>;
04135   olc = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (ol);
04136   
04137   <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (olc, <font class="stringliteral">"pragma"</font>))
04138     {
04139       <font class="keywordtype">char</font> *pname = <a class="code" href="general_c.html#a29">mstring_create</a> (longUnsigned_fromInt (MAX_PRAGMA_LEN));
04140       <font class="keywordtype">char</font> *opname = pname;
04141       <font class="keywordtype">char</font> *ptr = ol + 6; <font class="comment">/* pragma is six characters, plus space */</font>
04142       <font class="keywordtype">int</font> len = 0;
04143       
04144       
04145       <font class="comment">/* skip whitespace */</font>
04146       <font class="keywordflow">while</font> (((c = *ptr) != <font class="charliteral">'\0'</font>) &amp;&amp; isspace (c))
04147         {
04148           ptr++;
04149         }
04150 
04151       
04152       <font class="keywordflow">while</font> (((c = *ptr) != <font class="charliteral">'\0'</font>) &amp;&amp; !isspace (c))
04153         {
04154           len++;
04155 
04156           <font class="keywordflow">if</font> (len &gt; MAX_PRAGMA_LEN)
04157             {
04158               <font class="keywordflow">break</font>;
04159             }
04160 
04161           ptr++;
04162           *pname++ = c;
04163         }
04164 
04165       *pname = <font class="charliteral">'\0'</font>;
04166       
04167       <font class="keywordflow">if</font> (len == PRAGMA_LEN_EXPAND 
04168           &amp;&amp; <a class="code" href="general_c.html#a40">mstring_equal</a> (opname, PRAGMA_EXPAND))
04169         {
04170           cstring exname = cstring_undefined;
04171           uentry ue;
04172           
04173           ptr++; 
04174           <font class="keywordflow">while</font> (((c = *ptr) != <font class="charliteral">'\0'</font>) &amp;&amp; !isspace (c))
04175             {
04176               exname = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (exname, c);
04177               ptr++;
04178             }
04179              
04180           
04181           ue = <a class="code" href="usymtab_c.html#a115">usymtab_lookupExposeGlob</a> (exname);
04182           
04183           <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a171">uentry_isExpandedMacro</a> (ue))
04184             {
04185               <font class="keywordflow">if</font> (fileloc_isPreproc (uentry_whereDefined (ue)))
04186                 {
04187                   fileloc_setColumn (g_currentloc, 1);
04188                   <a class="code" href="uentry_c.html#a210">uentry_setDefined</a> (ue, g_currentloc);
04189                 }
04190             }
04191 
04192           <a class="code" href="cstring_c.html#a27">cstring_free</a> (exname);
04193         }
04194     }
04195   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="cstring_c.html#a22">cstring_equalPrefix</a> (olc, <font class="stringliteral">"ident"</font>))
04196     {
04197       <font class="comment">/* Some pre-processors will leave these in the code.  Ignore rest of line */</font>
04198     }
04199   <font class="comment">/*</font>
04200 <font class="comment">  ** Yuk...Win32 filenames can have spaces in them...we need to read</font>
04201 <font class="comment">  ** to the matching end quote.</font>
04202 <font class="comment">  */</font>
04203   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((sscanf (ol, <font class="stringliteral">"line %d \""</font>, &amp;lineno) == 1)
04204            || (sscanf (ol, <font class="stringliteral">" %d \""</font>, &amp;lineno) == 1))
04205     {
04206       <font class="keywordtype">char</font> *tmp = ol;
04207       <font class="keywordtype">char</font> *fname;
04208       fileId fid;
04209 
04210       <font class="keywordflow">while</font> (*tmp != <font class="charliteral">'\"'</font> &amp;&amp; *tmp != <font class="charliteral">'\0'</font>)
04211         {
04212           tmp++;
04213         }
04214 
04215       llassert (*tmp == <font class="charliteral">'\"'</font>);
04216 
04217       tmp++;
04218       fname = tmp;
04219       
04220       <font class="keywordflow">while</font> (*tmp != <font class="charliteral">'\"'</font> &amp;&amp; *tmp != <font class="charliteral">'\0'</font>)
04221         {
04222           tmp++;
04223         }
04224 
04225       llassert (*tmp == <font class="charliteral">'\"'</font>);
04226 
04227       *tmp = <font class="charliteral">'\0'</font>;
04228 
04229       DPRINTF ((<font class="stringliteral">"fname: %s"</font>, fname));
04230 
04231 <font class="preprocessor"># if defined(OS2) || defined(MSDOS) || defined(WIN32)</font>
04232 <font class="preprocessor"></font>
04233       <font class="comment">/*</font>
04234 <font class="comment">      ** DOS-like path delimiters get delivered in pairs, something like </font>
04235 <font class="comment">      ** \"..\\\\file.h\", so we have to make it normal again. We do NOT</font>
04236 <font class="comment">      ** remove the pre dirs yet as we usually specify tmp paths relative</font>
04237 <font class="comment">      ** to the current directory, so tmp files would not get found in</font>
04238 <font class="comment">      ** the hash table.  If this method fails we try it again later. </font>
04239 <font class="comment">      */</font>
04240 
04241       {
04242         <font class="keywordtype">char</font> *stmp = fname;
04243         
04244         <font class="comment">/*</font>
04245 <font class="comment">        ** Skip past the drive marker.</font>
04246 <font class="comment">        */</font>
04247         
04248         DPRINTF ((<font class="stringliteral">"stmp: %s / %s"</font>, stmp, fname));
04249         
04250         <font class="keywordflow">if</font> (strchr (stmp, <font class="charliteral">':'</font>) != NULL)
04251           {
04252             stmp = strchr (stmp, <font class="charliteral">':'</font>) + 1;
04253           }
04254         
04255         DPRINTF ((<font class="stringliteral">"stmp: %s / %s"</font>, stmp, fname));
04256         
04257         <font class="keywordflow">while</font> ((stmp = strchr (stmp, CONNECTCHAR)) != NULL )
04258           {
04259             <font class="keywordflow">if</font> (*(stmp+1) == CONNECTCHAR)
04260               {
04261                 memmove (stmp, stmp+1, strlen (stmp));
04262               }
04263             
04264             stmp++;
04265             DPRINTF ((<font class="stringliteral">"stmp: %s / %s"</font>, stmp, fname));
04266           }
04267         
04268         DPRINTF ((<font class="stringliteral">"Now: base = %s"</font>, fname));
04269         
04270         fid = <a class="code" href="fileTable_c.html#a28">fileTable_lookupBase</a> (context_fileTable (),
04271                                     <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (fname));
04272         <font class="keywordflow">if</font> (!(fileId_isValid (fid)))
04273           {
04274             fname = <a class="code" href="general_c.html#a42">removePreDirs</a> (fname);
04275             fid = <a class="code" href="fileTable_c.html#a28">fileTable_lookupBase</a> (context_fileTable (),
04276                                         <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (fname));
04277           }
04278       }
04279 <font class="preprocessor"># else  </font><font class="comment">/* !defined(OS2) &amp;&amp; !defined(MSDOS) */</font>
04280       fname = <a class="code" href="general_c.html#a42">removePreDirs</a> (fname);
04281       fid = <a class="code" href="fileTable_c.html#a28">fileTable_lookupBase</a> (context_fileTable (),
04282                                   <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (fname));
04283 <font class="preprocessor"># endif </font><font class="comment">/* !defined(OS2) &amp;&amp; !defined(MSDOS) */</font>
04284       
04285       <font class="keywordflow">if</font> (!(fileId_isValid (fid)))
04286         {
04287           <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a44">isHeaderFile</a> (cstring_fromChars (fname)))
04288             {
04289               fid = <a class="code" href="fileTable_c.html#a16">fileTable_addHeaderFile</a> (context_fileTable (), 
04290                                              <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (fname));
04291             }
04292           <font class="keywordflow">else</font>
04293             {
04294               fid = <a class="code" href="fileTable_c.html#a14">fileTable_addFile</a> (context_fileTable (), 
04295                                        <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (fname));
04296             }
04297         }
04298       
04299       setFileLine (fid, lineno);
04300     }
04301   <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((sscanf (ol, <font class="stringliteral">"line %d"</font>, &amp;lineno) == 1) 
04302            || (sscanf (ol, <font class="stringliteral">" %d"</font>, &amp;lineno) == 1))
04303     {
04304       setLine (lineno); <font class="comment">/* next line is &lt;cr&gt; */</font>
04305     }
04306   <font class="keywordflow">else</font>
04307     {
04308       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a40">mstring_equal</a> (ol, <font class="stringliteral">""</font>)) {
04309         DPRINTF ((<font class="stringliteral">"Empty pp command!"</font>));
04310         <font class="comment">/*</font>
04311 <font class="comment">        ** evs 2000-05-16: This is a horrible kludge, to get around a bug (well, difficulty) in the pre-processor.</font>
04312 <font class="comment">        ** We handle a plain # in the input file, by echoing it, and ignoring it in the post-pp-file.</font>
04313 <font class="comment">        */</font>
04314         mstring_free (ol);
04315         <font class="keywordflow">return</font> FALSE;
04316       } <font class="keywordflow">else</font> {
04317         <font class="keywordflow">if</font> (!reportcpp)
04318           {
04319             
04320           } <font class="keywordflow">else</font> {
04321             llbug (message (<font class="stringliteral">"File contains preprocessor command: #%s"</font>, 
04322                             cstring_fromChars (ol)));
04323             reportcpp = TRUE;
04324           }
04325       }
04326       
04327       <a class="code" href="general_c.html#a0">sfree</a> (ol);
04328       <font class="keywordflow">return</font> TRUE;
04329     }
04330 
04331   <a class="code" href="general_c.html#a0">sfree</a> (ol);
04332   <font class="keywordflow">return</font> FALSE;
04333 }
04334   
04335 <font class="keyword">static</font> <font class="keywordtype">int</font> handleLlSpecial ()<font class="keyword"></font>
04336 <font class="keyword"></font>{ 
04337   <font class="keywordtype">int</font> ic; 
04338   <font class="keywordtype">char</font> c;
04339   <font class="keywordtype">char</font> *s = mstring_createEmpty ();
04340   <font class="keywordtype">char</font> *os; 
04341   <font class="keywordtype">int</font> tok;
04342   <font class="keywordtype">int</font> charsread = 0;
04343 
04344   <font class="keywordflow">while</font> (((ic = ninput ()) != 0) &amp;&amp; isalpha (ic))
04345     {
04346       c = (<font class="keywordtype">char</font>) ic;
04347       s = <a class="code" href="general_c.html#a26">mstring_append</a> (s, c);
04348       charsread++;
04349     }
04350 
04351   os = s;
04352 
04353   <font class="keywordflow">if</font> (charsread == 0 &amp;&amp; ic == (<font class="keywordtype">int</font>) AFTER_COMMENT_MARKER[0])
04354     {
04355       ic = ninput ();
04356 
04357       llassert (ic == AFTER_COMMENT_MARKER[1]);
04358 
04359             
04360       <font class="keywordflow">if</font> (<a class="code" href="clabstract_c.html#a64">isProcessingGlobMods</a> () &amp;&amp; (*s == <font class="charliteral">'\0'</font>))
04361         {
04362           <a class="code" href="general_c.html#a0">sfree</a> (os);
04363           <font class="keywordflow">return</font> QNOMODS; <font class="comment">/* special token no modifications token */</font>
04364         }
04365       <font class="keywordflow">else</font>
04366         {
04367           ;
04368         }
04369     }
04370   
04371   tok = commentMarkerToken (cstring_fromChars (os));
04372 
04373   <font class="keywordflow">if</font> (tok != BADTOK)
04374     {
04375       tokLength = charsread;
04376       <a class="code" href="general_c.html#a0">sfree</a> (os);
04377       inSpecPart = TRUE;
04378       <font class="keywordflow">return</font> tok;
04379     }
04380   
04381   <font class="comment">/* Add rest of the comment */</font>
04382   
04383   <font class="keywordflow">if</font> (ic != 0 &amp;&amp; ic != EOF)
04384     {
04385       c = (<font class="keywordtype">char</font>) ic;
04386 
04387       
04388       s = <a class="code" href="general_c.html#a26">mstring_append</a> (s, c);
04389       charsread++;
04390 
04391       <font class="keywordflow">while</font> (((ic = ninput ()) != 0) &amp;&amp; (ic != EOF)
04392              &amp;&amp; (ic != AFTER_COMMENT_MARKER[0]))
04393         {
04394           c = (<font class="keywordtype">char</font>) ic;
04395           s = <a class="code" href="general_c.html#a26">mstring_append</a> (s, c);
04396           charsread++;
04397         }
04398     }
04399 
04400   <font class="keywordflow">if</font> (ic == AFTER_COMMENT_MARKER[0]) 
04401     {
04402       <font class="keywordtype">int</font> nc = ninput ();
04403       llassert ((<font class="keywordtype">char</font>) nc ==  AFTER_COMMENT_MARKER[1]);
04404       charsread++;
04405     }
04406 
04407   
04408   os = s;
04409 
04410   <font class="keywordflow">while</font> (*s == <font class="charliteral">' '</font> || *s == <font class="charliteral">'\t'</font> || *s == <font class="charliteral">'\n'</font>) 
04411     {
04412       s++;
04413     }
04414 
04415   <font class="keywordflow">if</font> (*s == <font class="charliteral">'-'</font> || *s == <font class="charliteral">'+'</font> || *s == <font class="charliteral">'='</font>) <font class="comment">/* setting flags */</font>
04416     {
04417       c = *s;
04418 
04419       <font class="keywordflow">while</font> (c == <font class="charliteral">'-'</font> || c == <font class="charliteral">'+'</font> || c == <font class="charliteral">'='</font>)
04420         {
04421           ynm set = <a class="code" href="ynm_c.html#a0">ynm_fromCodeChar</a> (c);
04422           cstring thisflag;
04423 
04424           s++;
04425           
04426           thisflag = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (s);
04427           
04428           <font class="keywordflow">while</font> ((c = *s) != <font class="charliteral">'\0'</font> &amp;&amp; (c != <font class="charliteral">'-'</font>) &amp;&amp; (c != <font class="charliteral">'='</font>)
04429                  &amp;&amp; (c != <font class="charliteral">'+'</font>) &amp;&amp; (c != <font class="charliteral">' '</font>) &amp;&amp; (c != <font class="charliteral">'\t'</font>) &amp;&amp; (c != <font class="charliteral">'\n'</font>))
04430             {
04431               s++;
04432             }
04433 
04434           *s = <font class="charliteral">'\0'</font>;
04435 
04436           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS))
04437             {
04438               cstring flagname = thisflag;
04439               flagcode <a class="code" href="struct_fflag.html">fflag</a> = <a class="code" href="flags_c.html#a36">identifyFlag</a> (flagname);
04440                 
04441               <font class="keywordflow">if</font> (flagcode_isSkip (<a class="code" href="struct_fflag.html">fflag</a>))
04442                 {
04443                   ;
04444                 }
04445               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (flagcode_isInvalid (<a class="code" href="struct_fflag.html">fflag</a>))
04446                 {
04447                   <font class="keywordflow">if</font> (<a class="code" href="flags_c.html#a40">isMode</a> (flagname))
04448                     {
04449                       <font class="keywordflow">if</font> (ynm_isMaybe (set))
04450                         {
04451                           llerror
04452                             (FLG_BADFLAG, 
04453                              message 
04454                              (<font class="stringliteral">"Stylized comment attempts to restore flag %s.  "</font>
04455                               <font class="stringliteral">"A mode flag cannot be restored."</font>,
04456                               flagname));
04457                         }
04458                       <font class="keywordflow">else</font>
04459                         {
04460                           <a class="code" href="context_c.html#a63">context_setMode</a> (flagname);
04461                         }
04462                     }
04463                   <font class="keywordflow">else</font>
04464                     {
04465                       llerror
04466                         (FLG_BADFLAG, 
04467                          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unrecognized option in stylized comment: %s"</font>, 
04468                                   flagname));
04469                     }
04470                 }
04471               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="flags_c.html#a16">flagcode_isGlobalFlag</a> (<a class="code" href="struct_fflag.html">fflag</a>))
04472                 {
04473                   llerror
04474                     (FLG_BADFLAG, 
04475                      message 
04476                      (<font class="stringliteral">"Stylized comment attempts to set global flag %s.  "</font>
04477                       <font class="stringliteral">"A global flag cannot be set locally."</font>,
04478                       flagname));
04479                 }
04480               <font class="keywordflow">else</font>
04481                 {
04482                   <a class="code" href="context_c.html#a186">context_fileSetFlag</a> (<a class="code" href="struct_fflag.html">fflag</a>, set);
04483                   
04484                   <font class="keywordflow">if</font> (<a class="code" href="flags_c.html#a41">flagcode_hasArgument</a> (<a class="code" href="struct_fflag.html">fflag</a>))
04485                     {
04486                       <font class="keywordflow">if</font> (ynm_isMaybe (set))
04487                         {
04488                           llerror
04489                             (FLG_BADFLAG, 
04490                              message 
04491                              (<font class="stringliteral">"Stylized comment attempts to restore flag %s.  "</font>
04492                               <font class="stringliteral">"A flag for setting a value cannot be restored."</font>,
04493                               flagname));
04494                         }
04495                       <font class="keywordflow">else</font>
04496                         { <font class="comment">/* cut-and-pastied from llmain...blecch */</font>
04497                           cstring extra = cstring_undefined;
04498                           <font class="keywordtype">char</font> *rest;
04499                           <font class="keywordtype">char</font> *orest;
04500                           <font class="keywordtype">char</font> rchar;
04501                           
04502                           *s = c;
04503                           rest = <a class="code" href="general_c.html#a27">mstring_copy</a> (s);
04504                           orest = rest;
04505                           *s = <font class="charliteral">'\0'</font>;
04506                           
04507                           <font class="keywordflow">while</font> ((rchar = *rest) != <font class="charliteral">'\0'</font>
04508                                  &amp;&amp; (isspace (rchar)))
04509                             {
04510                               rest++;
04511                               s++;
04512                             }
04513                           
04514                           <font class="keywordflow">while</font> ((rchar = *rest) != <font class="charliteral">'\0'</font>
04515                                  &amp;&amp; !isspace (rchar))
04516                             {
04517                               extra = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (extra, rchar);
04518                               rest++; 
04519                               s++;
04520                             }
04521                           
04522                           <a class="code" href="general_c.html#a0">sfree</a> (orest);
04523                           
04524                           <font class="keywordflow">if</font> (cstring_isUndefined (extra))
04525                             {
04526                               llerror 
04527                                 (FLG_BADFLAG,
04528                                  message
04529                                  (<font class="stringliteral">"Flag %s (in stylized comment) must be followed by an argument"</font>,
04530                                   flagcode_unparse (<a class="code" href="struct_fflag.html">fflag</a>)));
04531                             }
04532                           <font class="keywordflow">else</font>
04533                             {
04534                               s--;
04535                               
04536                               <font class="keywordflow">if</font> (<a class="code" href="flags_c.html#a42">flagcode_hasValue</a> (<a class="code" href="struct_fflag.html">fflag</a>))
04537                                 {
04538                                   <a class="code" href="flags_c.html#a37">setValueFlag</a> (<a class="code" href="struct_fflag.html">fflag</a>, extra);
04539                                 }
04540                               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="flags_c.html#a43">flagcode_hasString</a> (<a class="code" href="struct_fflag.html">fflag</a>))
04541                                 {
04542                                   <a class="code" href="flags_c.html#a38">setStringFlag</a> (<a class="code" href="struct_fflag.html">fflag</a>, extra);
04543                                 }
04544                               <font class="keywordflow">else</font>
04545                                 {
04546                                   BADEXIT;
04547                                 }
04548                             }
04549                         }
04550                     }
04551                 }
04552             }
04553           <font class="keywordflow">else</font>
04554             {
04555               ;
04556             }
04557 
04558           *s = c;
04559           <font class="keywordflow">while</font> ((c == <font class="charliteral">' '</font>) || (c == <font class="charliteral">'\t'</font>) || (c == <font class="charliteral">'\n'</font>))
04560             {
04561               c = *(++s);
04562             }
04563         } 
04564 
04565       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a219">context_inHeader</a> () &amp;&amp; !isArtificial (cstring_fromChars (os)))
04566         {
04567                   <a class="code" href="context_c.html#a35">context_addComment</a> (cstring_fromCharsNew (os));
04568         }
04569       <font class="keywordflow">else</font>
04570         {
04571           ;
04572         }
04573     }
04574   <font class="keywordflow">else</font>
04575     {
04576       <font class="keywordtype">char</font> *t = s;
04577       <font class="keywordtype">int</font> macrocode;
04578       <font class="keywordtype">char</font> tchar = <font class="charliteral">'\0'</font>;
04579 
04580       <font class="keywordflow">while</font> (*s != <font class="charliteral">'\0'</font> &amp;&amp; *s != <font class="charliteral">' '</font> &amp;&amp; *s != <font class="charliteral">'\t'</font> &amp;&amp; *s != <font class="charliteral">'\n'</font>) 
04581         {
04582           s++;
04583         }
04584 
04585       <font class="keywordflow">if</font> (*s != <font class="charliteral">'\0'</font>) 
04586         {
04587           tchar = *s;
04588           *s = <font class="charliteral">'\0'</font>;
04589           s++;
04590         }
04591       
04592       t = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (cstring_downcase (cstring_fromChars (t)));
04593       macrocode = tokenMacroCode (cstring_fromChars (t));
04594 
04595       <font class="keywordflow">if</font> (macrocode != BADTOK)
04596         {
04597           tokLength = mstring_length (t);
04598 
04599           
04600           <a class="code" href="general_c.html#a0">sfree</a> (t);
04601           <a class="code" href="general_c.html#a0">sfree</a> (os);
04602 
04603           <font class="keywordflow">if</font> (macrocode == SKIPTOK)
04604             {
04605               <font class="keywordflow">return</font> BADTOK;
04606             }
04607 
04608           <font class="keywordflow">return</font> macrocode;
04609         }
04610       
04611       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a219">context_inHeader</a> ())
04612         {
04613           <font class="keywordflow">if</font> (tchar != <font class="charliteral">'\0'</font>)
04614             {
04615               *(s-1) = tchar;
04616             }
04617           
04618           <font class="keywordflow">if</font> ((<a class="code" href="context_c.html#a235">context_inMacro</a> () || <a class="code" href="context_c.html#a242">context_inGlobalContext</a> ())
04619               &amp;&amp; macrocode != SKIPTOK
04620               &amp;&amp; !isArtificial (cstring_fromChars (os))) 
04621             {
04622               <a class="code" href="context_c.html#a35">context_addComment</a> (cstring_fromCharsNew (os));
04623             }
04624           <font class="keywordflow">else</font>
04625             {
04626               ; 
04627             }
04628           
04629           <font class="keywordflow">if</font> (tchar != <font class="charliteral">'\0'</font>)
04630             {
04631               *(s-1) = <font class="charliteral">'\0'</font>;
04632             }
04633         }
04634 
04635       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a40">mstring_equal</a> (t, <font class="stringliteral">"ignore"</font>))
04636         {
04637           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS))
04638             {
04639               <a class="code" href="context_c.html#a42">context_enterSuppressRegion</a> ();
04640             }
04641         }
04642       <font class="keywordflow">else</font> <font class="keywordflow">if</font> ((*t == <font class="charliteral">'i'</font> || *t == <font class="charliteral">'t'</font>)
04643                &amp;&amp; (*(t + 1) == <font class="charliteral">'\0'</font>))
04644         {
04645           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS)
04646               &amp;&amp; (*t == <font class="charliteral">'i'</font> || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_TMPCOMMENTS)))
04647             {
04648               <a class="code" href="context_c.html#a44">context_enterSuppressLine</a> (-1); <font class="comment">/* infinite suppression */</font>
04649             }
04650         }
04651       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (((*t == <font class="charliteral">'i'</font>) || (*t == <font class="charliteral">'t'</font>))
04652                &amp;&amp; ((*(t + 1) &gt;= <font class="charliteral">'0'</font> &amp;&amp; *(t + 1) &lt;= <font class="charliteral">'9'</font>)))
04653         {
04654           <font class="keywordtype">bool</font> tmpcomment = (*t == <font class="charliteral">'t'</font>);
04655           <font class="keywordtype">int</font> val = -1; 
04656           <font class="keywordtype">char</font> *tt = t; <font class="comment">/* don't mangle t, since it is free'd */</font>
04657           <font class="keywordtype">char</font> lc = *(++tt);
04658 
04659           <font class="keywordflow">if</font> (lc &gt;= <font class="charliteral">'0'</font> &amp;&amp; lc &lt;= <font class="charliteral">'9'</font>)
04660             {
04661               val = (<font class="keywordtype">int</font>)(lc - <font class="charliteral">'0'</font>);
04662               
04663               lc = *(++tt);       
04664               <font class="keywordflow">while</font> (lc &gt;= <font class="charliteral">'0'</font> &amp;&amp; lc &lt;= <font class="charliteral">'9'</font>)
04665                 {
04666                   val *= 10;
04667                   val += lc - <font class="charliteral">'0'</font>;
04668                   lc = *(++tt);
04669                 }
04670             }
04671 
04672           
04673           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS)
04674               &amp;&amp; (!tmpcomment || <a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_TMPCOMMENTS)))
04675             {
04676               <a class="code" href="context_c.html#a44">context_enterSuppressLine</a> (val);
04677             }
04678         }
04679       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a40">mstring_equal</a> (t, <font class="stringliteral">"end"</font>))
04680         {
04681           <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS))
04682             {
04683               <a class="code" href="context_c.html#a47">context_exitSuppressRegion</a> ();
04684             }
04685         }
04686       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a40">mstring_equal</a> (t, <font class="stringliteral">"notfunction"</font>))
04687         {
04688          ; <font class="comment">/* handled by pcpp */</font>
04689         }
04690       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a40">mstring_equal</a> (t, <font class="stringliteral">"access"</font>))
04691         {
04692           cstring tname;
04693           
04694           <font class="keywordflow">while</font> (TRUE)
04695             {
04696               <font class="keywordflow">while</font> ((c = *s) &amp;&amp; (c == <font class="charliteral">' '</font> || c == <font class="charliteral">'\t'</font> || c == <font class="charliteral">'\n'</font>))
04697                 {
04698                   s++;
04699                 }
04700               
04701               <font class="keywordflow">if</font> (c == <font class="charliteral">'\0'</font>)
04702                 {
04703                    <font class="keywordflow">break</font>;
04704                 }
04705 
04706               tname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (s);
04707               
04708               <font class="keywordflow">while</font> ((c = *s) != <font class="charliteral">'\0'</font> &amp;&amp; c != <font class="charliteral">' '</font> 
04709                      &amp;&amp; c != <font class="charliteral">'\t'</font> &amp;&amp; c != <font class="charliteral">'\n'</font> &amp;&amp; c != <font class="charliteral">','</font>) 
04710                 {
04711                   s++;
04712                 }
04713 
04714               *s = <font class="charliteral">'\0'</font>;
04715 
04716               
04717               <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS) 
04718                   &amp;&amp; !<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOACCESS))
04719                 {
04720                   <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a129">usymtab_existsType</a> (tname))
04721                     {
04722                       usymId uid = <a class="code" href="usymtab_c.html#a64">usymtab_getTypeId</a> (tname);
04723                       <a class="code" href="context_c.html#a66">context_addFileAccessType</a> (uid);
04724                     }
04725                   <font class="keywordflow">else</font>
04726                     {
04727                       <font class="keywordflow">if</font> (!(<a class="code" href="context_c.html#a41">context_inSuppressRegion</a> ()
04728                             || <a class="code" href="context_c.html#a40">context_inSuppressZone</a> (g_currentloc)))
04729                         {
04730                           llmsg 
04731                             (message
04732                              (<font class="stringliteral">"%q: Unrecognized type %s used in access comment"</font>,
04733                               <a class="code" href="fileloc_c.html#a39">fileloc_unparse</a> (g_currentloc), tname));
04734                         }
04735                     }
04736                 }
04737               
04738               <font class="keywordflow">if</font> (c != <font class="charliteral">'\0'</font>) 
04739                 {
04740                   s++;
04741                 }
04742               
04743               <font class="keywordflow">if</font> (c != <font class="charliteral">','</font> &amp;&amp; c != <font class="charliteral">' '</font>)
04744                 {
04745                   <font class="keywordflow">break</font>;
04746                 }
04747             }
04748         }
04749       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a40">mstring_equal</a> (t, <font class="stringliteral">"noaccess"</font>))
04750         {
04751           cstring tname;
04752           <font class="keywordtype">char</font> lc;
04753           
04754           <font class="keywordflow">while</font> (TRUE)
04755             {
04756               <font class="keywordflow">while</font> ((lc = *s) &amp;&amp; (lc == <font class="charliteral">' '</font> || lc == <font class="charliteral">'\t'</font> || lc == <font class="charliteral">'\n'</font>)) 
04757                 {
04758                   s++;
04759                 }
04760               
04761               <font class="keywordflow">if</font> (lc == <font class="charliteral">'\0'</font>)
04762                 {
04763                  <font class="keywordflow">break</font>;
04764                 }
04765 
04766               tname = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (s);
04767               
04768               <font class="keywordflow">while</font> ((lc = *s) != <font class="charliteral">'\0'</font> &amp;&amp; lc != <font class="charliteral">' '</font> &amp;&amp; lc != <font class="charliteral">'\t'</font> 
04769                      &amp;&amp; lc != <font class="charliteral">'\n'</font> &amp;&amp; lc != <font class="charliteral">','</font>) 
04770                 {
04771                   s++;
04772                 }
04773 
04774               *s = <font class="charliteral">'\0'</font>;
04775 
04776               <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOCOMMENTS) 
04777                   &amp;&amp; !<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_NOACCESS))
04778                 {
04779                   <font class="keywordflow">if</font> (<a class="code" href="usymtab_c.html#a129">usymtab_existsType</a> (tname))
04780                     {
04781                       typeId tuid = <a class="code" href="usymtab_c.html#a64">usymtab_getTypeId</a> (tname);
04782                       
04783                       <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a116">context_couldHaveAccess</a> (tuid))
04784                         {
04785                           <a class="code" href="context_c.html#a67">context_removeFileAccessType</a> (tuid);
04786                         }
04787                       <font class="keywordflow">else</font>
04788                         {
04789                           <font class="keywordflow">if</font> (!(<a class="code" href="context_c.html#a41">context_inSuppressRegion</a> () 
04790                                 || <a class="code" href="context_c.html#a40">context_inSuppressZone</a> (g_currentloc)))
04791                             {
04792                               uentry ue = <a class="code" href="usymtab_c.html#a71">usymtab_getTypeEntry</a> (tuid);
04793                               
04794                               <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a166">uentry_isAbstractDatatype</a> (ue))
04795                                 {
04796                                   llmsg
04797                                     (message
04798                                      (<font class="stringliteral">"%q: Non-accessible abstract type %s used in noaccess comment"</font>,
04799                                       <a class="code" href="fileloc_c.html#a39">fileloc_unparse</a> (g_currentloc), tname));
04800                                 }
04801                               <font class="keywordflow">else</font>
04802                                 {
04803                                   llmsg
04804                                     (message
04805                                      (<font class="stringliteral">"%q: Non-abstract type %s used in noaccess comment"</font>,
04806                                       <a class="code" href="fileloc_c.html#a39">fileloc_unparse</a> (g_currentloc), tname));
04807                                 }
04808                             }
04809                         }
04810                     }
04811                   <font class="keywordflow">else</font>
04812                     {
04813                       <font class="keywordflow">if</font> (!(<a class="code" href="context_c.html#a41">context_inSuppressRegion</a> () 
04814                             || <a class="code" href="context_c.html#a40">context_inSuppressZone</a> (g_currentloc)))
04815                         {
04816                           llmsg
04817                             (message
04818                              (<font class="stringliteral">"%q: Unrecognized type %s used in noaccess comment"</font>,
04819                               <a class="code" href="fileloc_c.html#a39">fileloc_unparse</a> (g_currentloc), tname));
04820                         }
04821                     }
04822                 }
04823               
04824               <font class="keywordflow">if</font> (lc != <font class="charliteral">'\0'</font>) 
04825                 {
04826                   s++;
04827                 }
04828               
04829               <font class="keywordflow">if</font> (lc != <font class="charliteral">','</font> &amp;&amp; lc != <font class="charliteral">' '</font>)
04830                 {
04831                   <font class="keywordflow">break</font>;
04832                 }
04833             }
04834         }
04835       <font class="keywordflow">else</font>
04836         {
04837           setTokLength (- (2 + charsread));
04838 
04839           voptgenerror (FLG_UNRECOGCOMMENTS, 
04840                         message (<font class="stringliteral">"Stylized comment unrecognized: %s"</font>, 
04841                                  cstring_fromChars (os)), 
04842                         g_currentloc);
04843         }
04844 
04845       <a class="code" href="general_c.html#a0">sfree</a> (t);
04846     }
04847   
04848   <a class="code" href="general_c.html#a0">sfree</a> (os); 
04849   <font class="keywordflow">return</font> BADTOK;
04850 }
04851 
04852 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring makeIdentifier (<font class="keywordtype">char</font> *s)<font class="keyword"></font>
04853 <font class="keyword"></font>{
04854   <font class="keywordtype">char</font> *c = <a class="code" href="general_c.html#a29">mstring_create</a> (size_toInt (strlen (s)) + 1);
04855   cstring id = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (c);
04856 
04857   <font class="keywordflow">while</font> (isalnum (*s) || (*s == <font class="charliteral">'_'</font>) || (*s == <font class="charliteral">'$'</font>)) 
04858     {
04859       *c++ = *s++;
04860     }
04861 
04862   *c = <font class="charliteral">'\0'</font>;
04863   <font class="keywordflow">return</font> (id);
04864 }
04865 
<a name="l04866"></a><a class="code" href="lex_yy_c.html#a141">04866</a> <font class="comment">/*@observer@*/</font> <font class="comment">/*@dependent@*/</font> uentry <a class="code" href="lex_yy_c.html#a141">coerceId</a> (cstring cn)<font class="keyword"></font>
04867 <font class="keyword"></font>{
04868   <font class="keywordflow">if</font> (!(<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (cn)))
04869     {
04870       fileloc loc = <a class="code" href="fileloc_c.html#a25">fileloc_createExternal</a> ();
04871       
04872       <font class="comment">/*</font>
04873 <font class="comment">      ** We need to put this in a global scope, otherwise the sRef will be deallocated.</font>
04874 <font class="comment">      */</font>
04875       
04876       uentry ce = <a class="code" href="uentry_c.html#a285">uentry_makeUnrecognized</a> (cn, loc);
04877       
04878       <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a237">context_inIterEnd</a> ())
04879         {
04880           voptgenerror 
04881             (FLG_SYSTEMUNRECOG, 
04882              <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unrecognized (possibly system) identifier: %q"</font>, 
04883                       uentry_getName (ce)), 
04884              g_currentloc);
04885         }
04886       
04887       <font class="keywordflow">return</font> ce;
04888     }
04889   
04890   <font class="keywordflow">return</font> (usymtab_lookup (cn));
04891 }
04892 
04893 <font class="comment">/*</font>
04894 <font class="comment">** like, coerceId, but doesn't supercede for iters</font>
04895 <font class="comment">*/</font>
04896 
<a name="l04897"></a><a class="code" href="lex_yy_c.html#a142">04897</a> <font class="comment">/*@observer@*/</font> uentry <a class="code" href="lex_yy_c.html#a142">coerceIterId</a> (cstring cn)<font class="keyword"></font>
04898 <font class="keyword"></font>{
04899   <font class="keywordflow">if</font> (!(<a class="code" href="usymtab_c.html#a124">usymtab_exists</a> (cn)))
04900     {
04901       <font class="keywordflow">return</font> uentry_undefined;
04902     }
04903   
04904   <font class="keywordflow">return</font> (usymtab_lookup (cn));
04905 }
04906 
<a name="l04907"></a><a class="code" href="lex_yy_c.html#a143">04907</a> <font class="comment">/*@observer@*/</font> cstring <a class="code" href="lex_yy_c.html#a143">LastIdentifier</a> ()<font class="keyword"></font>
04908 <font class="keyword"></font>{
04909   <font class="keywordflow">return</font> (lastidprocessed);
04910 }
04911 
04912 <font class="keyword">static</font> <font class="keywordtype">int</font> processIdentifier (cstring id)<font class="keyword"></font>
04913 <font class="keyword"></font>{
04914   uentry le;
04915 
04916   DPRINTF ((<font class="stringliteral">"Process identifier: %s"</font>, id));
04917 
04918   <a class="code" href="context_c.html#a251">context_clearJustPopped</a> ();
04919   lastidprocessed = id; 
04920 
04921   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a70">context_inFunctionDecl</a> ())
04922     {
04923       <font class="keywordtype">int</font> tok = commentMarkerToken (id);
04924 
04925       <font class="keywordflow">if</font> (tok != BADTOK)
04926         {
04927           <font class="keywordflow">return</font> tok;
04928         }
04929       <font class="keywordflow">else</font> 
04930         {
04931           tok = tokenMacroCode (id);
04932 
04933           <font class="keywordflow">if</font> (tok != BADTOK)
04934             {
04935               <font class="keywordflow">return</font> tok;
04936             }
04937         }
04938     }
04939 
04940   <font class="comment">/* Consider handling: Defined by C99 as static const char __func__[] */</font>
04941 
04942   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_GNUEXTENSIONS))
04943     {
04944       <font class="keywordtype">int</font> tok = BADTOK;
04945       
04946       <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__stdcall"</font>)
04947           || cstring_equalLit (id, <font class="stringliteral">"__cdecl"</font>)
04948           || cstring_equalLit (id, <font class="stringliteral">"__extension__"</font>))
04949         {
04950           <font class="keywordflow">return</font> BADTOK;
04951         }
04952       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__volatile__"</font>))
04953         {
04954           tok = QVOLATILE;
04955         }
04956       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__signed"</font>))
04957         {
04958           tok = QSIGNED;
04959         }
04960       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__unsigned"</font>))
04961         {
04962           tok = QUNSIGNED;
04963         }
04964       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__const__"</font>))
04965         {
04966           tok = QCONST;
04967         }
04968       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__alignof__"</font>)) 
04969         {
04970           tok = CALIGNOF; <font class="comment">/* alignof is parsed like sizeof */</font>
04971         }
04972       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__FUNCTION__"</font>)
04973                || cstring_equalLit (id, <font class="stringliteral">"__PRETTY_FUNCTION__"</font>)) 
04974         {
04975           <font class="comment">/* These tokens hold the name of the current function as strings */</font>
04976           yylval.expr = <a class="code" href="exprNode_c.html#a76">exprNode_stringLiteral</a> (id, fileloc_copy (g_currentloc));
04977           tokLength = 0;
04978           lastWasString = TRUE;
04979           tok = CCONSTANT;
04980           <font class="keywordflow">return</font> tok;
04981         }
04982       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__attribute__"</font>)
04983                || cstring_equalLit (id, <font class="stringliteral">"__asm__"</font>)
04984                || cstring_equalLit (id, <font class="stringliteral">"_asm"</font>)
04985                || cstring_equalLit (id, <font class="stringliteral">"__asm"</font>)
04986                || cstring_equalLit (id, <font class="stringliteral">"__declspec"</font>))
04987         {
04988           <font class="keywordtype">int</font> depth = 0;
04989           <font class="keywordtype">bool</font> useparens = FALSE;
04990           <font class="keywordtype">bool</font> usebraces = FALSE;
04991           <font class="keywordtype">bool</font> inquote = FALSE;
04992           <font class="keywordtype">bool</font> inescape = FALSE;
04993           <font class="keywordtype">int</font> ic;
04994 
04995           <font class="keywordflow">while</font> ((ic = input ()) != EOF)
04996             {
04997                               
04998               <font class="keywordflow">if</font> (inescape)
04999                 {
05000                   inescape = FALSE;
05001                 }
05002               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ic == <font class="charliteral">'\\'</font>)
05003                 {
05004                   inescape = TRUE;
05005                 }
05006               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ic == <font class="charliteral">'\"'</font>)
05007                 {
05008                   inquote = !inquote;
05009                 }
05010               <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!inquote)
05011                 {
05012                   <font class="keywordflow">if</font> (ic == <font class="charliteral">'('</font>)
05013                     {
05014                       <font class="keywordflow">if</font> (!useparens)
05015                         {
05016                           <font class="keywordflow">if</font> (!usebraces)
05017                             {
05018                               useparens = TRUE;
05019                             }
05020                         }
05021 
05022                       <font class="keywordflow">if</font> (useparens)
05023                         {
05024                           depth++;
05025                         }
05026                     }
05027                   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ic == <font class="charliteral">'{'</font>)
05028                     {
05029                       <font class="keywordflow">if</font> (!usebraces)
05030                         {
05031                           <font class="keywordflow">if</font> (!useparens)
05032                             {
05033                               usebraces = TRUE;
05034                             }
05035                         }
05036 
05037                       <font class="keywordflow">if</font> (usebraces)
05038                         {
05039                           depth++;
05040                         }
05041                     }
05042                   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ic == <font class="charliteral">')'</font> &amp;&amp; useparens)
05043                     {
05044                       depth--;
05045                       <font class="keywordflow">if</font> (depth == 0) <font class="keywordflow">break</font>;
05046                     }
05047                   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ic == <font class="charliteral">'}'</font> &amp;&amp; usebraces)
05048                     {
05049                       depth--;
05050                       <font class="keywordflow">if</font> (depth == 0) <font class="keywordflow">break</font>;
05051                     }
05052                   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ic == <font class="charliteral">'}'</font> 
05053                            &amp;&amp; !usebraces &amp;&amp; !useparens
05054                            &amp;&amp; cstring_equalLit (id, <font class="stringliteral">"__asm"</font>))
05055                     {
05056                       <font class="comment">/*</font>
05057 <font class="comment">                      ** We need this because some MS VC++ include files</font>
05058 <font class="comment">                      ** have __asm mov ... }</font>
05059 <font class="comment">                      ** Its a kludge, but otherwise would need to parse</font>
05060 <font class="comment">                      ** the asm code!</font>
05061 <font class="comment">                      */</font> 
05062                       <font class="keywordflow">return</font> TRBRACE;
05063                     }
05064                 }
05065 
05066               <font class="keywordflow">if</font> (ic == <font class="charliteral">'\n'</font>)
05067                 {
05068                   <a class="code" href="context_c.html#a46">context_incLineno</a> ();
05069 
05070                   <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"__asm"</font>)
05071                       &amp;&amp; !useparens &amp;&amp; !usebraces)
05072                     {
05073                       <font class="keywordflow">break</font>;
05074                     }
05075                 }
05076             }
05077           
05078           llassert ((useparens &amp;&amp; ic == <font class="charliteral">')'</font>)
05079                     || (usebraces &amp;&amp; ic == <font class="charliteral">'}'</font>)
05080                     || (!useparens &amp;&amp; !usebraces));
05081 
05082           <font class="keywordflow">return</font> BADTOK;
05083         }
05084       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (cstring_equalLit (id, <font class="stringliteral">"inline"</font>)
05085                || cstring_equalLit (id, <font class="stringliteral">"__inline"</font>)
05086                || cstring_equalLit (id, <font class="stringliteral">"_inline"</font>)
05087                || cstring_equalLit (id, <font class="stringliteral">"__inline__"</font>))
05088         {
05089           tok = QINLINE;
05090         }
05091       
05092       <font class="keywordflow">if</font> (tok != BADTOK)
05093         {
05094           <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (tok);
05095         }
05096     }
05097 
05098   le = <a class="code" href="usymtab_c.html#a113">usymtab_lookupSafe</a> (id);
05099 
05100   <font class="comment">/*@-dependenttrans@*/</font>
05101   
05102   <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a184">uentry_isIter</a> (le))
05103     {
05104       yylval.entry = le;
05105       <font class="keywordflow">return</font> (ITER_NAME);
05106     }
05107   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a185">uentry_isEndIter</a> (le))
05108     {
05109       yylval.entry = le;
05110       <font class="keywordflow">return</font> (ITER_ENDNAME);
05111     }
05112   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (uentry_isUndefined (le))
05113     {
05114       yylval.cname = id;
05115 
05116       <font class="comment">/* avoid parse errors for certain system built ins */</font>
05117 
05118       <font class="keywordflow">if</font> (g_expectingTypeName &amp;&amp; (<a class="code" href="cstring_c.html#a1">cstring_firstChar</a> (id) == <font class="charliteral">'_'</font>)
05119           &amp;&amp; (cstring_secondChar (id) == <font class="charliteral">'_'</font>))
05120         {
05121           <font class="keywordflow">return</font> (TYPE_NAME_OR_ID);
05122         }
05123 
05124       <font class="keywordflow">return</font> (NEW_IDENTIFIER);
05125     }
05126   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (!<a class="code" href="uentry_c.html#a212">uentry_isDeclared</a> (le) &amp;&amp; !<a class="code" href="uentry_c.html#a211">uentry_isCodeDefined</a> (le))
05127     {
05128       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (le))
05129         {
05130           yylval.cname = id;
05131           <font class="keywordflow">return</font> (NEW_IDENTIFIER);
05132         }
05133       <font class="keywordflow">else</font>
05134         {
05135           yylval.entry = le;              
05136           <font class="keywordflow">return</font> (IDENTIFIER); 
05137         }
05138     }
05139   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a163">uentry_isDatatype</a> (le))
05140     {
05141       <font class="keywordflow">if</font> (!g_expectingTypeName)
05142         {
05143           yylval.cname = id;
05144 
05145           <font class="keywordflow">return</font> (NEW_IDENTIFIER);
05146         }
05147       <font class="keywordflow">else</font>
05148         {
05149           yylval.ctyp = <a class="code" href="uentry_c.html#a221">uentry_getAbstractType</a> (le);
05150           
05151           <a class="code" href="uentry_c.html#a278">uentry_setUsed</a> (le, g_currentloc);
05152           <font class="keywordflow">return</font> (TYPE_NAME);
05153         }
05154     }
05155   <font class="keywordflow">else</font>
05156     {
05157       yylval.entry = le;            
05158       <font class="keywordflow">return</font> (IDENTIFIER); 
05159     }
05160 
05161   <font class="comment">/*@=dependenttrans@*/</font>
05162 }
05163 
05164 <font class="keyword">static</font> <font class="keywordtype">bool</font> processHashIdentifier (<font class="comment">/*@only@*/</font> cstring id)<font class="keyword"></font>
05165 <font class="keyword"></font>{
05166   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a235">context_inMacro</a> () || <a class="code" href="context_c.html#a236">context_inIterDef</a> () ||
05167       <a class="code" href="context_c.html#a237">context_inIterEnd</a> ())
05168     {
05169       uentry le;
05170       
05171       <a class="code" href="context_c.html#a251">context_clearJustPopped</a> ();
05172 
05173       lastidprocessed = id; 
05174       le = <a class="code" href="usymtab_c.html#a113">usymtab_lookupSafe</a> (id);
05175 
05176       <font class="keywordflow">if</font> (<a class="code" href="uentry_c.html#a170">uentry_isParam</a> (le) || <a class="code" href="uentry_c.html#a173">uentry_isRefParam</a> (le))
05177         {
05178           <font class="keywordflow">return</font> TRUE;
05179         }
05180       <font class="keywordflow">else</font>
05181         {
05182           <font class="keywordflow">return</font> FALSE;
05183         }
05184     }
05185   <font class="keywordflow">else</font>
05186     {
05187       <a class="code" href="cstring_c.html#a27">cstring_free</a> (id);
05188       <font class="keywordflow">return</font> FALSE;
05189     }
05190 }
05191 
05192 
05193 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> exprNode processString ()<font class="keyword"></font>
05194 <font class="keyword"></font>{
05195   exprNode res;
05196   fileloc loc;
05197   <font class="keywordtype">char</font> *nl = strchr (yytext, <font class="charliteral">'\n'</font>);
05198   cstring ns = cstring_fromCharsNew (yytext);
05199 
05200   <font class="keywordflow">if</font> (nl == NULL)
05201     {
05202       loc = <a class="code" href="fileloc_c.html#a5">fileloc_copy</a> (g_currentloc);
05203       addColumn (cstring_length (ns));
05204     }
05205   <font class="keywordflow">else</font>
05206     {
05207       <font class="keywordtype">char</font> *lastnl = nl;
05208 
05209       loc = <a class="code" href="fileloc_c.html#a5">fileloc_copy</a> (g_currentloc);
05210 
05211       <a class="code" href="context_c.html#a46">context_incLineno</a> ();
05212       
05213       <font class="keywordflow">while</font> ((nl = strchr ((nl + 1), <font class="charliteral">'\n'</font>)) != NULL)
05214         {
05215           <a class="code" href="context_c.html#a46">context_incLineno</a> ();
05216           lastnl = nl;
05217         }
05218     }
05219 
05220     
05221   res = <a class="code" href="exprNode_c.html#a76">exprNode_stringLiteral</a> (ns, loc);
05222   <font class="keywordflow">return</font> (res);
05223 }
05224 
05225 <font class="keyword">static</font> 
05226 <font class="keywordtype">char</font> processChar ()<font class="keyword"></font>
05227 <font class="keyword"></font>{
05228   <font class="keywordtype">char</font> fchar;
05229   <font class="keywordtype">char</font> next;
05230 
05231   llassert (*yytext != <font class="charliteral">'\0'</font>);
05232   fchar = *(yytext + 1);
05233   <font class="keywordflow">if</font> (fchar != <font class="charliteral">'\\'</font>) <font class="keywordflow">return</font> fchar;
05234   
05235   next = *(yytext + 2);
05236   
05237   <font class="keywordflow">switch</font> (next)
05238     {
05239     <font class="keywordflow">case</font> <font class="charliteral">'n'</font>: <font class="keywordflow">return</font> <font class="charliteral">'\n'</font>;
05240     <font class="keywordflow">case</font> <font class="charliteral">'t'</font>: <font class="keywordflow">return</font> <font class="charliteral">'\t'</font>;
05241     <font class="keywordflow">case</font> <font class="charliteral">'\"'</font>: <font class="keywordflow">return</font> <font class="charliteral">'\"'</font>;
05242     <font class="keywordflow">case</font> <font class="charliteral">'\''</font>: <font class="keywordflow">return</font> <font class="charliteral">'\''</font>;
05243     <font class="keywordflow">case</font> <font class="charliteral">'\\'</font>: <font class="keywordflow">return</font> <font class="charliteral">'\\'</font>;
05244     <font class="keywordflow">default</font>: <font class="keywordflow">return</font> <font class="charliteral">'\0'</font>;
05245     }
05246 }
05247 
05248 <font class="keyword">static</font>
05249 <font class="keywordtype">double</font> processFloat ()<font class="keyword"></font>
05250 <font class="keyword"></font>{
05251   <font class="keywordtype">double</font> ret = atof (yytext);
05252 
05253     <font class="keywordflow">return</font> (ret);
05254 }
05255 
05256 <font class="keyword">static</font>
05257 <font class="keywordtype">long</font> processHex ()<font class="keyword"></font>
05258 <font class="keyword"></font>{
05259   <font class="keywordtype">int</font> index = 2;
05260   <font class="keywordtype">long</font> val = 0;
05261 
05262   llassert (yytext[0] == <font class="charliteral">'0'</font>
05263             &amp;&amp; (yytext[1] == <font class="charliteral">'X'</font> || yytext[1] == <font class="charliteral">'x'</font>));
05264 
05265   <font class="keywordflow">while</font> (yytext[index] != <font class="charliteral">'\0'</font>) {
05266     <font class="keywordtype">int</font> tval;
05267     <font class="keywordtype">char</font> c = yytext[index];
05268 
05269     <font class="keywordflow">if</font> (c &gt;= <font class="charliteral">'0'</font> &amp;&amp; c &lt;= <font class="charliteral">'9'</font>) {
05270       tval = (<font class="keywordtype">int</font>) c - (<font class="keywordtype">int</font>) <font class="charliteral">'0'</font>;
05271     } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c &gt;= <font class="charliteral">'A'</font> &amp;&amp; c &lt;= <font class="charliteral">'F'</font>) {
05272       tval = (<font class="keywordtype">int</font>) c - (<font class="keywordtype">int</font>) <font class="charliteral">'A'</font> + 10;
05273     } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c &gt;= <font class="charliteral">'a'</font> &amp;&amp; c &lt;= <font class="charliteral">'f'</font>) {
05274       tval = (<font class="keywordtype">int</font>) c - (<font class="keywordtype">int</font>) <font class="charliteral">'a'</font> + 10;
05275     } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (c == <font class="charliteral">'U'</font> || c == <font class="charliteral">'L'</font> || c == <font class="charliteral">'u'</font> || c == <font class="charliteral">'l'</font>) {
05276       index++;
05277       <font class="keywordflow">while</font> (yytext[index] != <font class="charliteral">'\0'</font>) {
05278         <font class="keywordflow">if</font> (c == <font class="charliteral">'U'</font> || c == <font class="charliteral">'L'</font> || c == <font class="charliteral">'u'</font> || c == <font class="charliteral">'l'</font>) {
05279           ;
05280         } <font class="keywordflow">else</font> {
05281           voptgenerror
05282             (FLG_SYNTAX, 
05283              <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Invalid character (%c) following specifier in hex constant: %s"</font>,
05284                       c, cstring_fromChars (yytext)),
05285              g_currentloc);
05286         }
05287         index++;
05288       }
05289 
05290       <font class="keywordflow">break</font>;
05291     } <font class="keywordflow">else</font> {
05292       voptgenerror
05293         (FLG_SYNTAX, 
05294          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Invalid character (%c) in hex constant: %s"</font>,
05295                   c, cstring_fromChars (yytext)),
05296          g_currentloc);
05297       <font class="keywordflow">break</font>;
05298     }
05299 
05300     val = (val * 16) + tval;
05301     index++;
05302   }
05303 
05304   DPRINTF ((<font class="stringliteral">"Hex constant: %s = %ld"</font>, yytext, val));
05305   <font class="keywordflow">return</font> val;
05306 }
05307 
05308 <font class="keyword">static</font>
05309 <font class="keywordtype">long</font> processOctal ()<font class="keyword"></font>
05310 <font class="keyword"></font>{
05311   <font class="keywordtype">int</font> index = 1;
05312   <font class="keywordtype">long</font> val = 0;
05313 
05314   llassert (yytext[0] == <font class="charliteral">'0'</font> &amp;&amp; yytext[1] != <font class="charliteral">'X'</font> &amp;&amp; yytext[1] != <font class="charliteral">'x'</font>);
05315     
05316   <font class="keywordflow">while</font> (yytext[index] != <font class="charliteral">'\0'</font>) {
05317     <font class="keywordtype">int</font> tval;
05318     <font class="keywordtype">char</font> c = yytext[index];
05319     
05320     <font class="keywordflow">if</font> (c &gt;= <font class="charliteral">'0'</font> &amp;&amp; c &lt;= <font class="charliteral">'7'</font>) {
05321       tval = (<font class="keywordtype">int</font>) c - (<font class="keywordtype">int</font>) <font class="charliteral">'0'</font>;
05322     } <font class="keywordflow">else</font> {
05323       voptgenerror
05324         (FLG_SYNTAX, 
05325          <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Invalid character (%c) in octal constant: %s"</font>,
05326                   c, cstring_fromChars (yytext)),
05327          g_currentloc);
05328       <font class="keywordflow">break</font>;
05329     }
05330 
05331     val = (val * 8) + tval;
05332     index++;
05333   }
05334 
05335   DPRINTF ((<font class="stringliteral">"Octal constant: %s = %ld"</font>, yytext, val));
05336   <font class="keywordflow">return</font> val;
05337 }
05338 
05339 <font class="keyword">static</font>
05340 <font class="keywordtype">long</font> processDec ()<font class="keyword"></font>
05341 <font class="keyword"></font>{
05342   <font class="keywordflow">return</font> (atol (yytext));
05343 }
05344 
05345 <font class="keyword">static</font> <font class="keywordtype">int</font>
05346 processSpec (<font class="keywordtype">int</font> tok)<font class="keyword"></font>
05347 <font class="keyword"></font>{
05348   size_t length = strlen (yytext);
05349 
05350   
05351   <font class="keywordflow">if</font> (inSpecPart)
05352     {
05353       setTokLengthT (length);
05354       <a class="code" href="lex_yy_c.html#a41">RETURN_TOK</a> (tok);
05355     }
05356   <font class="keywordflow">else</font>
05357     {
05358       
05359       <a class="code" href="context_c.html#a182">context_saveLocation</a> ();
05360       setTokLengthT (length);
05361       <font class="keywordflow">return</font> (processIdentifier (makeIdentifier (yytext)));
05362     }
05363 }
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:42 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
