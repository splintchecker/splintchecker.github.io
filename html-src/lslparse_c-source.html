<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>lslparse.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:43 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>lslparse.c</h1><a href="lslparse_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** lslparse.c</font>
00026 <font class="comment">**</font>
00027 <font class="comment">** Module for calling LSL checker.</font>
00028 <font class="comment">**</font>
00029 <font class="comment">**  AUTHOR:</font>
00030 <font class="comment">**      Yang Meng Tan,</font>
00031 <font class="comment">**         Massachusetts Institute of Technology</font>
00032 <font class="comment">*/</font>
00033 
00034 <font class="preprocessor"># include "lclintMacros.nf"</font>
00035 <font class="preprocessor"># include "llbasic.h"</font>
00036 <font class="preprocessor"># include "lclscan.h"</font>
00037 <font class="preprocessor"># include "signature.h"</font>
00038 <font class="preprocessor"># include "signature2.h"</font>
00039 <font class="preprocessor"># include "scan.h"</font>
00040 <font class="preprocessor"># include "scanline.h"</font>
00041 <font class="preprocessor"># include "syntable.h"</font>
00042 <font class="preprocessor"># include "tokentable.h"</font>
00043 <font class="preprocessor"># include "lslinit.h"</font>
00044 <font class="preprocessor"># include "lslparse.h"</font>
00045 <font class="preprocessor"># include "llmain.h"</font>
00046 
00047 <font class="comment">/*@+ignorequals@*/</font>
00048 
<a name="l00049"></a><a class="code" href="lslparse_c.html#a0">00049</a> <font class="comment">/*@dependent@*/</font> <font class="comment">/*@null@*/</font> lslOp g_importedlslOp = NULL;
<a name="l00050"></a><a class="code" href="lslparse_c.html#a1">00050</a> <font class="keywordtype">bool</font> g_lslParsingTraits = FALSE;
00051 
00052 <font class="keyword">static</font> <font class="keywordtype">void</font> invokeLSL (<font class="keywordtype">char</font> *p_infile, <font class="keywordtype">char</font> *p_outfile, <font class="keywordtype">bool</font> p_deletep);
00053 
00054 <font class="keywordtype">int</font>
<a name="l00055"></a><a class="code" href="lslparse_c.html#a3">00055</a> <a class="code" href="lslparse_c.html#a3">parseSignatures</a> (cstring infile)<font class="keyword"></font>
00056 <font class="keyword"></font>{
00057   <font class="keywordtype">char</font> *cinfile = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (infile);
00058   tsource *sourceFile;
00059   ltoken *id = (ltoken *) dmalloc (<font class="keyword">sizeof</font> (*id));
00060   <font class="keywordtype">int</font> status = 0;
00061 
00062   <font class="comment">/* parse traits */</font>
00063   *id = <a class="code" href="tokentable_c.html#a1">LSLInsertToken</a> (LST_SIMPLEID, lsymbol_fromChars (cinfile), 0, FALSE);
00064   ltoken_setFileName (*id, cinfile);
00065   ltoken_setLine (*id, 0);
00066   ltoken_setCol (*id, 0);
00067 
00068   sourceFile = <a class="code" href="source_c.html#a2">tsource_create</a> (cinfile, <font class="stringliteral">""</font>, FALSE);
00069 
00070   <font class="keywordflow">if</font> (!<a class="code" href="source_c.html#a6">tsource_getPath</a> (cstring_toCharsSafe (context_getLarchPath ()), sourceFile))
00071     {
00072       lclplainerror 
00073         (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"LSL signature parsing: can't find file %s containing trait"</font>,
00074                   cstring_fromChars (tsource_fileName (sourceFile))));
00075       status = 1;
00076 
00077       <a class="code" href="general_c.html#a0">sfree</a> (id);
00078       <a class="code" href="source_c.html#a1">tsource_free</a> (sourceFile);
00079       <font class="keywordflow">return</font> status;
00080     }
00081 
00082   <font class="keywordflow">if</font> (!<a class="code" href="source_c.html#a5">tsource_open</a> (sourceFile))
00083     {
00084       lclplainerror 
00085         (cstring_makeLiteral (<font class="stringliteral">"LSL parsing: can't open file containing trait"</font>));
00086       status = 2;
00087       <a class="code" href="general_c.html#a0">sfree</a> (id);
00088       <a class="code" href="source_c.html#a1">tsource_free</a> (sourceFile);
00089 
00090       <font class="keywordflow">return</font> status;
00091     }
00092 
00093   lsldebug = 0;
00094   g_lslParsingTraits = TRUE;
00095   <a class="code" href="scan_c.html#a7">LSLScanReset</a> (sourceFile);
00096   <a class="code" href="scanline_c.html#a6">LSLReportEolTokens</a> (FALSE);
00097 
00098   status = lslparse ();
00099 
00100   <font class="comment">/* symtable_dump (symtab, stdout, TRUE); */</font>
00101   g_lslParsingTraits = FALSE;
00102 
00103   (<font class="keywordtype">void</font>) <a class="code" href="source_c.html#a0">tsource_close</a> (sourceFile);
00104   <a class="code" href="source_c.html#a1">tsource_free</a> (sourceFile);
00105 
00106   <a class="code" href="general_c.html#a0">sfree</a> (id);
00107 
00108   
00109   <font class="keywordflow">return</font> status;
00110 }
00111 
00112 <font class="comment">/*@only@*/</font> lslOp
<a name="l00113"></a><a class="code" href="lslparse_c.html#a4">00113</a> <a class="code" href="lslparse_c.html#a4">parseOpLine</a> (<font class="keywordtype">char</font> *fname, <font class="keywordtype">char</font> *line)<font class="keyword"></font>
00114 <font class="keyword"></font>{
00115   tsource *sourceFile;
00116   <font class="keywordtype">bool</font> status;
00117 
00118   sourceFile = <a class="code" href="source_c.html#a3">tsource_fromString</a> (fname, line);
00119   
00120   <font class="keywordflow">if</font> (check (tsource_open (sourceFile)))
00121     {
00122       <a class="code" href="scan_c.html#a7">LSLScanReset</a> (sourceFile);
00123       <a class="code" href="scanline_c.html#a6">LSLReportEolTokens</a> (FALSE); <font class="comment">/* 0 by default, lslParsingTraits = 0; */</font>
00124       
00125       <font class="comment">/*</font>
00126 <font class="comment">      ** lsl parsing and importing .lcs files are expected to be mutually</font>
00127 <font class="comment">      ** exclusive. </font>
00128 <font class="comment">      **</font>
00129 <font class="comment">      ** lslparse sets importedlslOp</font>
00130 <font class="comment">      */</font>
00131       
00132       status = (lslparse () != 0);
00133       
00134       <font class="keywordflow">if</font> (status)
00135         {
00136           <a class="code" href="llerror_c.html#a57">lclplainfatalerror</a> (message (<font class="stringliteral">"Error in parsing line: %s"</font>, 
00137                                        cstring_fromChars (line)));
00138         }
00139       
00140       (<font class="keywordtype">void</font>) <a class="code" href="source_c.html#a0">tsource_close</a> (sourceFile);
00141     }
00142 
00143   <a class="code" href="source_c.html#a1">tsource_free</a> (sourceFile);
00144   
00145   llassert (g_importedlslOp != NULL);
00146   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a238">lslOp_copy</a> (g_importedlslOp));
00147 }
00148 
00149 lsymbol
<a name="l00150"></a><a class="code" href="lslparse_c.html#a5">00150</a> <a class="code" href="lslparse_c.html#a5">processTraitSortId</a> (lsymbol sortid)<font class="keyword"></font>
00151 <font class="keyword"></font>{
00152   lsymbol out = <a class="code" href="symtable_c.html#a46">lsymbol_sortFromType</a> (g_symtab, sortid);
00153   <font class="keywordflow">if</font> (out == sortid)
00154     { <font class="comment">/* may be a new sort */</font>
00155       (<font class="keywordtype">void</font>) <a class="code" href="sort_c.html#a116">sort_fromLsymbol</a> (sortid);
00156     }
00157   <font class="keywordflow">return</font> out;
00158 }
00159 
00160 <font class="comment">/* formerly from check.c module */</font>
00161 
00162 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00163 printTypeName2 (typeNameNode n)<font class="keyword"></font>
00164 <font class="keyword"></font>{
00165   cstring s = cstring_undefined;
00166   sortNode sn;
00167   lsymbol lclSort;
00168   ltoken err;
00169 
00170   <font class="keywordflow">if</font> (n != (typeNameNode) 0)
00171     {
00172       <font class="keywordflow">if</font> (n-&gt;isTypeName)
00173         {
00174           <font class="comment">/* does not process opForm renaming, pass on to LSL</font>
00175 <font class="comment">             and hope that it works for now. */</font>
00176           typeNamePack p = n-&gt;typename;
00177 
00178           llassert (p != NULL);
00179 
00180           <font class="comment">/* get the LCL type, assume LCL type has already been mentioned. */</font>
00181           lclSort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (p-&gt;type);
00182           lclSort = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (lclSort);
00183           <font class="comment">/* lclsource = LCLSLScanSource (); */</font>
00184           <font class="keywordflow">if</font> (!<a class="code" href="sort_c.html#a105">sort_isValidSort</a> (lclSort))
00185             {
00186               err = <a class="code" href="abstract_c.html#a76">lclTypeSpecNode_errorToken</a> (p-&gt;type);
00187               <font class="comment">/* errorShowPoint (tsource_thisLine (lclsource), ltoken_getCol (err)); */</font>
00188               <a class="code" href="llerror_c.html#a54">lclerror</a> (err, message (<font class="stringliteral">"Unrecognized type in uses: %q"</font>, 
00189                                       typeNameNode_unparse (n)));
00190             }
00191           <font class="keywordflow">else</font>
00192             {
00193               <font class="comment">/* </font>
00194 <font class="comment">              ** Below is necessary because this is one place where an LCL mutable</font>
00195 <font class="comment">              ** type name is mapped directly into its value sort, not obj sort.</font>
00196 <font class="comment">              ** Allows us to support only one qualifying "obj", rather</font>
00197 <font class="comment">              ** than "val" as well. </font>
00198 <font class="comment">              */</font>
00199               
00200               lclSort = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (lclSort, p-&gt;abst);
00201               lclSort = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (lclSort);
00202               
00203               <font class="comment">/*</font>
00204 <font class="comment">              ** Check that lclSort is not a HOFSort ...</font>
00205 <font class="comment">              ** Propagation of HOFSort should stop here.  </font>
00206 <font class="comment">              */</font>
00207 
00208               <font class="keywordflow">if</font> (<a class="code" href="sort_c.html#a117">sort_isHOFSortKind</a> (lclSort))
00209                 {
00210                   err = <a class="code" href="abstract_c.html#a76">lclTypeSpecNode_errorToken</a> (p-&gt;type);
00211                   
00212                   lclfatalerror
00213                     (err, 
00214                      cstring_makeLiteral 
00215                      (<font class="stringliteral">"LCL uses cannot handle higher-order types"</font>));
00216                 }
00217               <font class="keywordflow">if</font> (p-&gt;isObj)
00218                 lclSort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (lclSort);
00219               
00220               <font class="comment">/*        if (!p-&gt;isObj) {</font>
00221 <font class="comment">                        lclSort = sort_makeVal (lclSort);</font>
00222 <font class="comment">                        } */</font>
00223               
00224               sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (lclSort);
00225               s = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (cstring_fromChars (lsymbol_toChars (sn.name)));
00226               <font class="comment">/* s = string_paste (s, AbstDeclaratorNode_unparse (p-&gt;abst)); */</font>
00227             }
00228         }
00229       <font class="keywordflow">else</font>
00230         {
00231           <font class="comment">/* s = OpFormNode_unparse (n-&gt;opform); */</font>
00232           <font class="keywordflow">if</font> (n-&gt;opform != 0)
00233             {
00234               lclfatalerror 
00235                 (n-&gt;opform-&gt;tok,
00236                  cstring_makeLiteral (<font class="stringliteral">"Attempt to rename operator with uses: "</font>
00237                                      <font class="stringliteral">"use LSL includes renaming facility"</font>));
00238             }
00239           <font class="keywordflow">else</font>
00240             {           
00241               BADEXIT;
00242             }
00243         }
00244     }
00245   <font class="keywordflow">return</font> s;
00246 }
00247 
00248 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00249 replaceNode_unparseAlt (replaceNode x)<font class="keyword"></font>
00250 <font class="keyword"></font>{
00251   cstring s = cstring_undefined;
00252 
00253   <font class="keywordflow">if</font> (x != (replaceNode) 0)
00254     {
00255       s = printTypeName2 (x-&gt;<font class="keyword">typename</font>);
00256       s = <a class="code" href="cstring_c.html#a40">cstring_concatChars</a> (s, <font class="stringliteral">" for "</font>);
00257 
00258       <font class="keywordflow">if</font> (x-&gt;isCType)
00259         {
00260           s = <a class="code" href="cstring_c.html#a39">cstring_concatFree1</a> (s, ltoken_unparse (x-&gt;content.ctype));
00261         }
00262       <font class="keywordflow">else</font>
00263         {
00264           s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, nameNode_unparse (x-&gt;content.renamesortname.name));
00265           s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, 
00266                                   sigNode_unparse (x-&gt;content.renamesortname.signature));
00267         }
00268     }
00269 
00270   <font class="keywordflow">return</font> s;
00271 }
00272 
00273 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00274 replaceNodeList_unparseAlt (replaceNodeList x)<font class="keyword"></font>
00275 <font class="keyword"></font>{
00276   cstring s = cstring_undefined;
00277   <font class="keywordtype">bool</font> first = TRUE;
00278 
00279   replaceNodeList_elements (x, i)<font class="keyword"></font>
00280 <font class="keyword">    </font>{
00281       <font class="keywordflow">if</font> (first)
00282         {
00283           s = replaceNode_unparseAlt (i);
00284           first = FALSE;
00285         }
00286       <font class="keywordflow">else</font>
00287         {
00288           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q, %q"</font>, s, replaceNode_unparseAlt (i));
00289         }
00290     } end_replaceNodeList_elements;
00291 
00292   <font class="keywordflow">return</font> s;
00293 }
00294 
00295 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00296 printNameList2 (typeNameNodeList x)<font class="keyword"></font>
00297 <font class="keyword"></font>{
00298   <font class="comment">/* printing a list of typeNameNode's, not nameNode's */</font>
00299   <font class="keywordtype">bool</font> first = TRUE;
00300   cstring s = cstring_undefined;
00301 
00302   typeNameNodeList_elements (x, i)<font class="keyword"></font>
00303 <font class="keyword">  </font>{
00304     <font class="keywordflow">if</font> (first)
00305       {
00306         s = printTypeName2 (i);
00307         first = FALSE;
00308       }
00309     <font class="keywordflow">else</font>
00310       {
00311         s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q, %q"</font>, s, printTypeName2 (i));
00312       }
00313     } end_typeNameNodeList_elements; 
00314 
00315   <font class="keywordflow">return</font> s;
00316 }
00317 
00318 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00319 printRenamingNode2 (renamingNode x)<font class="keyword"></font>
00320 <font class="keyword"></font>{
00321   cstring s = cstring_undefined;
00322 
00323   <font class="keywordflow">if</font> (x != (renamingNode) 0)
00324     {
00325       <font class="keywordflow">if</font> (x-&gt;is_replace)
00326         {
00327           replaceNodeList r = x-&gt;content.replace;
00328           s = replaceNodeList_unparseAlt (r);
00329         }
00330       <font class="keywordflow">else</font>
00331         {
00332           nameAndReplaceNode n = x-&gt;content.name;
00333           <font class="keywordtype">bool</font> printComma = TRUE;
00334           <font class="keywordflow">if</font> (typeNameNodeList_size (n-&gt;namelist) == 0)
00335             {
00336               printComma = FALSE;
00337             }
00338           s = printNameList2 (n-&gt;namelist);
00339           <font class="keywordflow">if</font> (printComma)
00340             <font class="keywordflow">if</font> (replaceNodeList_isDefined (n-&gt;replacelist) &amp;&amp;
00341                 replaceNodeList_size (n-&gt;replacelist) != 0)
00342               {
00343                 s = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (s, <font class="charliteral">','</font>);
00344                 s = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (s, <font class="charliteral">' '</font>);
00345               }
00346           s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, replaceNodeList_unparseAlt (n-&gt;replacelist));
00347         }
00348     }
00349   <font class="keywordflow">return</font> s;
00350 }
00351 
00352 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00353 printTraitRefList2 (traitRefNodeList x)<font class="keyword"></font>
00354 <font class="keyword"></font>{
00355   cstring s = cstring_undefined;
00356 
00357   traitRefNodeList_elements (x, i)<font class="keyword"></font>
00358 <font class="keyword">  </font>{
00359     s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%qincludes (%q)"</font>, s, printRawLeaves2 (i-&gt;traitid));
00360 
00361     <font class="keywordflow">if</font> (i-&gt;rename != 0)
00362       {
00363         s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q(%q)"</font>, s, printRenamingNode2 (i-&gt;rename));
00364       }
00365     s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q\n"</font>, s);
00366   } end_traitRefNodeList_elements;
00367 
00368   <font class="keywordflow">return</font> s;
00369 }
00370 
00371 <font class="keywordtype">void</font>
<a name="l00372"></a><a class="code" href="lslparse_c.html#a12">00372</a> <a class="code" href="lslparse_c.html#a12">callLSL</a> (<font class="comment">/*@unused@*/</font> <font class="keywordtype">char</font> *specfile, <font class="comment">/*@only@*/</font> <font class="keywordtype">char</font> *text)<font class="keyword"></font>
00373 <font class="keyword"></font>{
00374   <font class="comment">/* specfile is the name of the LCL file that contains "uses"</font>
00375 <font class="comment">     Create an intermediate file named</font>
00376 <font class="comment">     specfile_&lt;TEMP_LSL_SUFFIX&gt;.&lt;TEMP_LSL_IN_SUFFIX&gt;.</font>
00377 <font class="comment">     put text in the file, run lsl on it and direct</font>
00378 <font class="comment">     output to specfile_&lt;TEMP_LSL_SUFFIX&gt;.&lt;TEMP_LSL_OUT_SUFFIX&gt;.</font>
00379 <font class="comment">     specfile can be a full pathname.</font>
00380 <font class="comment">     Note: LSL does not support traitnames that are pathnames, only</font>
00381 <font class="comment">     symbols. </font>
00382 <font class="comment">     */</font>
00383 
00384   <font class="keywordtype">char</font> *infile, *outfile;
00385   <font class="keywordtype">char</font> *tmp1, *tmp2;
00386   FILE *inptr;
00387 
00388   infile = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (fileName (fileTable_addltemp (context_fileTable ())));
00389   
00390   inptr = fopen (infile, <font class="stringliteral">"w"</font>);
00391   
00392   <font class="keywordflow">if</font> (inptr == NULL)
00393     {
00394       <font class="comment">/* fopen fails */</font>
00395       <a class="code" href="llerror_c.html#a48">llfatalerror</a> (message (<font class="stringliteral">"Unable to write intermediate file: %s"</font>, 
00396                              cstring_fromChars (infile)));
00397     }
00398   
00399   tmp1 = <a class="code" href="general_c.html#a11">removePath</a> (infile);
00400   tmp2 = <a class="code" href="general_c.html#a14">removeAnyExtension</a> (tmp1);
00401 
00402   fprintf (inptr, <font class="stringliteral">"%s : trait\n"</font>, tmp2);
00403   <a class="code" href="general_c.html#a0">sfree</a> (tmp1);
00404   <a class="code" href="general_c.html#a0">sfree</a> (tmp2);
00405 
00406   fprintf (inptr, <font class="stringliteral">"%s"</font>, text);
00407   check (fclose (inptr) == 0);
00408 
00409   <font class="comment">/* the default is to delete the input file */</font>
00410 
00411   outfile = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (fileName (fileTable_addltemp (context_fileTable ())));
00412   invokeLSL (infile, outfile, context_getFlag (FLG_KEEP));
00413   <a class="code" href="general_c.html#a0">sfree</a> (text);
00414 }
00415 
00416 <font class="keyword">static</font> <font class="keywordtype">void</font> invokeLSL (<font class="keywordtype">char</font> *infile, <font class="keywordtype">char</font> *outfile, <font class="keywordtype">bool</font> deletep)<font class="keyword"></font>
00417 <font class="keyword"></font>{
00418   <font class="comment">/* run lsl on infile and leave result in outfile */</font>
00419   FILE *outptr;
00420   filestatus status;
00421   <font class="keywordtype">int</font> callstatus;
00422   cstring call;
00423   <font class="keywordtype">char</font> *returnPath = NULL;
00424   
00425   <font class="comment">/*</font>
00426 <font class="comment">  ** Ensures that outfile can be written into, should find a better</font>
00427 <font class="comment">  ** way to do this. </font>
00428 <font class="comment">  */</font>
00429   
00430   outptr = fopen (outfile, <font class="stringliteral">"w"</font>);
00431 
00432   <font class="keywordflow">if</font> (outptr == NULL)
00433     {                   
00434       <font class="comment">/* fopen fails */</font>
00435       <a class="code" href="llerror_c.html#a48">llfatalerror</a> (message (<font class="stringliteral">"Unable to write intermediate file: %s"</font>, 
00436                              cstring_fromChars (outfile)));
00437     }
00438   
00439   check (fclose (outptr) == 0);
00440 
00441   <font class="comment">/* set call to the right command */</font>
00442   status = <a class="code" href="osd_c.html#a8">osd_getExePath</a> (<font class="stringliteral">"PATH"</font>, <font class="stringliteral">"lsl"</font>, &amp;returnPath);
00443     
00444 
00445   <font class="keywordflow">if</font> (status == OSD_FILEFOUND)
00446     {
00447       call = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s -syms %s &gt; %s"</font>, cstring_fromChars (returnPath), 
00448                       <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (infile), <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (outfile));
00449       
00450       <font class="comment">/* before calling, make sure old file is removed */</font>
00451       (<font class="keywordtype">void</font>) <a class="code" href="osd_c.html#a15">osd_unlink</a> (outfile);
00452 
00453       callstatus = <a class="code" href="osd_c.html#a13">osd_system</a> (cstring_toCharsSafe (call));
00454       
00455       <a class="code" href="cstring_c.html#a27">cstring_free</a> (call);
00456 
00457       <font class="keywordflow">if</font> (callstatus != CALL_SUCCESS)
00458         {
00459           <font class="comment">/*</font>
00460 <font class="comment">          ** lsl errors: call lsl again without -syms, sending output to stdout</font>
00461 <font class="comment">          */</font>
00462           cstring syscal = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %s"</font>, cstring_fromChars (returnPath), 
00463                                     <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (infile));
00464 
00465           (<font class="keywordtype">void</font>) <a class="code" href="osd_c.html#a13">osd_system</a> (cstring_toCharsSafe (syscal));
00466           <a class="code" href="cstring_c.html#a27">cstring_free</a> (syscal);
00467 
00468           <a class="code" href="llerror_c.html#a48">llfatalerror</a> (cstring_makeLiteral (<font class="stringliteral">"LSL trait used contains errors."</font>)); 
00469         }
00470       <font class="keywordflow">else</font>
00471         {                       <font class="comment">/* ok, go ahead */</font>
00472          <font class="comment">/* Now parse the LSL output and store info in symbol table */</font>
00473           callstatus = <a class="code" href="lslparse_c.html#a3">parseSignatures</a> (cstring_fromChars (outfile));
00474 
00475           <font class="keywordflow">if</font> (callstatus == 0)
00476             {   
00477               <font class="comment">/* all went well */</font>
00478               <font class="keywordflow">if</font> (!<a class="code" href="context_c.html#a189">context_getFlag</a> (FLG_KEEP))
00479                 {
00480                   <font class="comment">/* delete temporary files */</font>
00481                   <font class="keywordflow">if</font> (deletep)
00482                     {
00483                       (<font class="keywordtype">void</font>) <a class="code" href="osd_c.html#a15">osd_unlink</a> (infile);
00484                     }
00485                   
00486                   (<font class="keywordtype">void</font>) <a class="code" href="osd_c.html#a15">osd_unlink</a> (outfile);
00487                 }
00488             }
00489         }
00490     }
00491   <font class="keywordflow">else</font> <font class="keywordflow">if</font> (status == OSD_FILENOTFOUND)
00492     {
00493       llfatalerror 
00494         (cstring_makeLiteral (<font class="stringliteral">"Cannot find LSL checker: check your command search path."</font>));
00495     }
00496   <font class="keywordflow">else</font>                          <font class="comment">/* must be (status == OSD_PATHTOOLONG) */</font>
00497     {
00498       <a class="code" href="llerror_c.html#a44">lclfatalbug</a> (<font class="stringliteral">"invokeLSL: lsl plus directory from search path is too long"</font>);
00499     }
00500 }
00501 
00502 <font class="comment">/* callLSL ("MySet", "includes Set (CC for C, EE for E)");  */</font>
00503 
00504 <font class="keywordtype">void</font>
<a name="l00505"></a><a class="code" href="lslparse_c.html#a13">00505</a> <a class="code" href="lslparse_c.html#a13">readlsignatures</a> (interfaceNode n)<font class="keyword"></font>
00506 <font class="keyword"></font>{
00507   <font class="comment">/* assume n-&gt;kind = usesKIND */</font>
00508   <font class="keywordtype">char</font> *content;
00509   
00510   content = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (printTraitRefList2 (n-&gt;content.uses));
00511   <a class="code" href="lslparse_c.html#a12">callLSL</a> (cstring_toCharsSafe (g_currentSpec), content);
00512 }
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:43 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
