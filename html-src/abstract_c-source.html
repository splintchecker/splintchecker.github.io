<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>abstract.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:57:38 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>abstract.c</h1><a href="abstract_c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment">** LCLint - annotation-assisted static program checker</font>
00003 <font class="comment">** Copyright (C) 1994-2000 University of Virginia,</font>
00004 <font class="comment">**         Massachusetts Institute of Technology</font>
00005 <font class="comment">**</font>
00006 <font class="comment">** This program is free software; you can redistribute it and/or modify it</font>
00007 <font class="comment">** under the terms of the GNU General Public License as published by the</font>
00008 <font class="comment">** Free Software Foundation; either version 2 of the License, or (at your</font>
00009 <font class="comment">** option) any later version.</font>
00010 <font class="comment">** </font>
00011 <font class="comment">** This program is distributed in the hope that it will be useful, but</font>
00012 <font class="comment">** WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00013 <font class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00014 <font class="comment">** General Public License for more details.</font>
00015 <font class="comment">** </font>
00016 <font class="comment">** The GNU General Public License is available from http://www.gnu.org/ or</font>
00017 <font class="comment">** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</font>
00018 <font class="comment">** MA 02111-1307, USA.</font>
00019 <font class="comment">**</font>
00020 <font class="comment">** For information on lclint: lclint-request@cs.virginia.edu</font>
00021 <font class="comment">** To report a bug: lclint-bug@cs.virginia.edu</font>
00022 <font class="comment">** For more information: http://lclint.cs.virginia.edu</font>
00023 <font class="comment">*/</font>
00024 <font class="comment">/*</font>
00025 <font class="comment">** abstract.c</font>
00026 <font class="comment">**</font>
00027 <font class="comment">** Module for building abstract syntax trees for LCL.</font>
00028 <font class="comment">**</font>
00029 <font class="comment">** This module is too close to the surface syntax of LCL.</font>
00030 <font class="comment">** Suffices for now.</font>
00031 <font class="comment">**</font>
00032 <font class="comment">** AUTHOR:</font>
00033 <font class="comment">**      Yang Meng Tan,</font>
00034 <font class="comment">**         Massachusetts Institute of Technology</font>
00035 <font class="comment">*/</font>
00036 
00037 <font class="preprocessor"># include "lclintMacros.nf"</font>
00038 <font class="preprocessor"># include "llbasic.h"</font>
00039 <font class="preprocessor"># include "lslparse.h"</font>
00040 <font class="preprocessor"># include "llgrammar.h"</font> <font class="comment">/* need simpleOp, MULOP and logicalOp in makeInfixTermNode */</font>
00041 <font class="preprocessor"># include "lclscan.h"</font>
00042 <font class="preprocessor"># include "lh.h"</font>
00043 <font class="preprocessor"># include "imports.h"</font>
00044 
00045 <font class="keyword">static</font> lsymbol lsymbol_Bool;
00046 <font class="keyword">static</font> lsymbol lsymbol_bool;
00047 <font class="keyword">static</font> lsymbol lsymbol_TRUE;
00048 <font class="keyword">static</font> lsymbol lsymbol_FALSE;
00049 
00050 <font class="keyword">static</font> <font class="keywordtype">void</font> lclPredicateNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> lclPredicateNode p_x) ;
00051 <font class="keyword">static</font> <font class="keywordtype">void</font> exposedNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> exposedNode p_x) ;
00052 <font class="keyword">static</font> <font class="keywordtype">void</font> CTypesNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> CTypesNode p_x);
00053 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> CTypesNode CTypesNode_copy (<font class="comment">/*@null@*/</font> CTypesNode p_x) <font class="comment">/*@*/</font> ;
00054 <font class="keyword">static</font> <font class="keywordtype">void</font> 
00055   constDeclarationNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> constDeclarationNode p_x);
00056 <font class="keyword">static</font> <font class="keywordtype">void</font> claimNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> claimNode p_x);
00057 <font class="keyword">static</font> <font class="keywordtype">void</font> iterNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> iterNode p_x);
00058 <font class="keyword">static</font> <font class="keywordtype">void</font> abstBodyNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> abstBodyNode p_n);
00059 <font class="keyword">static</font> <font class="keywordtype">void</font> abstractNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> abstractNode p_x);
00060 <font class="keyword">static</font> <font class="keywordtype">void</font> taggedUnionNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> taggedUnionNode p_x);
00061 <font class="keyword">static</font> <font class="keywordtype">void</font> typeNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> typeNode p_t);
00062 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> strOrUnionNode 
00063   strOrUnionNode_copy (<font class="comment">/*@null@*/</font> strOrUnionNode p_n) <font class="comment">/*@*/</font> ;
00064 <font class="keyword">static</font> <font class="keywordtype">void</font> strOrUnionNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> strOrUnionNode p_n)
00065   <font class="comment">/*@modifies *p_n @*/</font> ;
00066 
00067 <font class="keyword">static</font> <font class="keywordtype">void</font> enumSpecNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> enumSpecNode p_x);
00068 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> enumSpecNode
00069   enumSpecNode_copy (<font class="comment">/*@null@*/</font> enumSpecNode p_x) <font class="comment">/*@*/</font> ;
00070 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> lclTypeSpecNode
00071   lclTypeSpecNode_copySafe (lclTypeSpecNode p_n) <font class="comment">/*@*/</font> ;
00072 <font class="keyword">static</font> <font class="keywordtype">void</font> lclTypeSpecNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> lclTypeSpecNode p_n);
00073 <font class="keyword">static</font> <font class="keywordtype">void</font> typeNamePack_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> typeNamePack p_x);
00074 <font class="keyword">static</font> <font class="keywordtype">void</font> opFormNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> opFormNode p_op);
00075 <font class="keyword">static</font> quantifiedTermNode quantifiedTermNode_copy (quantifiedTermNode p_q) <font class="comment">/*@*/</font> ;
00076 <font class="keyword">static</font> <font class="keywordtype">void</font> nameAndReplaceNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> nameAndReplaceNode p_x);
00077 <font class="keyword">static</font> <font class="keywordtype">void</font> renamingNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> renamingNode p_x);
00078 <font class="keyword">static</font> <font class="keywordtype">void</font> exportNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> exportNode p_x);
00079 <font class="keyword">static</font> <font class="keywordtype">void</font> privateNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> privateNode p_x);
00080 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> termNode termNode_copy (<font class="comment">/*@null@*/</font> termNode p_t) <font class="comment">/*@*/</font> ;
00081 <font class="keyword">static</font> <font class="keywordtype">void</font> 
00082   stmtNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> stmtNode p_x) <font class="comment">/*@modifies *p_x@*/</font> ;
00083 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> typeExpr typeExpr_copy (<font class="comment">/*@null@*/</font> typeExpr p_x) <font class="comment">/*@*/</font> ;
00084 
00085 <font class="keyword">static</font> lsymbol ConditionalSymbol;
00086 <font class="keyword">static</font> lsymbol equalSymbol;
00087 <font class="keyword">static</font> lsymbol eqSymbol;
00088 <font class="keyword">static</font> lclTypeSpecNode exposedType;
00089 
00090 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring abstDeclaratorNode_unparse (abstDeclaratorNode p_x);
00091 <font class="keyword">static</font> pairNodeList extractParams (<font class="comment">/*@null@*/</font> typeExpr p_te);
00092 <font class="keyword">static</font> sort extractReturnSort (lclTypeSpecNode p_t, declaratorNode p_d);
00093 <font class="keyword">static</font> <font class="keywordtype">void</font> checkAssociativity (termNode p_x, ltoken p_op);
00094 <font class="keyword">static</font> <font class="keywordtype">void</font> LCLBootstrap (<font class="keywordtype">void</font>);
00095 <font class="keyword">static</font> cstring printMiddle (<font class="keywordtype">int</font> p_j);
00096 <font class="keyword">static</font> <font class="keywordtype">void</font> paramNode_checkQualifiers (lclTypeSpecNode p_t, typeExpr p_d);
00097 
00098 <font class="keywordtype">void</font>
<a name="l00099"></a><a class="code" href="abstract_c.html#a42">00099</a> <a class="code" href="abstract_c.html#a42">resetImports</a> (cstring current)<font class="keyword"></font>
00100 <font class="keyword"></font>{
00101   <a class="code" href="lsymbolSet_c.html#a5">lsymbolSet_free</a> (g_currentImports); 
00102 
00103   g_currentImports = <a class="code" href="lsymbolSet_c.html#a0">lsymbolSet_new</a> (); <font class="comment">/* equal_symbol; */</font>
00104   (<font class="keywordtype">void</font>) <a class="code" href="lsymbolSet_c.html#a2">lsymbolSet_insert</a> (g_currentImports, 
00105                               lsymbol_fromChars (cstring_toCharsSafe (current)));
00106 }
00107 
00108 <font class="keywordtype">void</font>
<a name="l00109"></a><a class="code" href="abstract_c.html#a43">00109</a> <a class="code" href="abstract_c.html#a43">abstract_init</a> ()<font class="keyword"></font>
00110 <font class="keyword"></font>{
00111   typeInfo ti = (typeInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
00112   nameNode nn;
00113   ltoken dom, range;
00114   sigNode sign;
00115   opFormNode opform;
00116   ltokenList domain = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
00117   ltokenList domain2;
00118 
00119   equalSymbol = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"="</font>);
00120   eqSymbol = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"\\eq"</font>);
00121 
00122   <font class="comment">/*</font>
00123 <font class="comment">  ** not: cstring_toCharsSafe (context_getBoolName ())</font>
00124 <font class="comment">  ** we use the hard wired "bool" name.</font>
00125 <font class="comment">  */</font>
00126 
00127   lsymbol_bool = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"bool"</font>);
00128   lsymbol_Bool = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"Bool"</font>);
00129 
00130   lsymbol_TRUE = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"TRUE"</font>);
00131   lsymbol_FALSE = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"FALSE"</font>);
00132 
00133   ConditionalSymbol = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"if__then__else__"</font>);
00134 
00135   <font class="comment">/* generate operators for</font>
00136 <font class="comment">  **    __ \not, __ \implies __ , __ \and __, __ \or __ </font>
00137 <font class="comment">  */</font>
00138 
00139   range = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, lsymbol_bool);
00140   dom = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, lsymbol_bool);
00141 
00142   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain, ltoken_copy (dom));
00143 
00144   domain2 = <a class="code" href="ltokenList_c.html#a10">ltokenList_copy</a> (domain);  <font class="comment">/* moved this here (before release) */</font>
00145 
00146   sign = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain, ltoken_copy (range));
00147 
00148   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_ANYOPM, 
00149                            opFormUnion_createAnyOp (ltoken_not),
00150                            ltoken_undefined);
00151   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
00152     <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, sign);
00153 
00154   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (domain2, dom);
00155 
00156   sign = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, domain2, range);
00157 
00158   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, 
00159                            opFormUnion_createAnyOp (ltoken_and), 
00160                            ltoken_undefined);
00161 
00162   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
00163   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, sigNode_copy (sign));
00164 
00165   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, 
00166                            opFormUnion_createAnyOp (ltoken_or),
00167                            ltoken_undefined);
00168 
00169   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
00170   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, sigNode_copy (sign));
00171 
00172   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, 
00173                            opFormUnion_createAnyOp (ltoken_implies),
00174                            ltoken_undefined);
00175   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
00176   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn, sign);
00177   
00178   <font class="comment">/* from lclscanline.c's init procedure */</font>
00179   <font class="comment">/* comment out so we can add in lclinit.lci: synonym double float */</font>
00180   <font class="comment">/* ReserveToken (FLOAT,                   "float"); */</font>
00181   <font class="comment">/* But we need to make the scanner parse "float" not as a simpleId, but</font>
00182 <font class="comment">     as a TYPEDEF_NAME.  This is done later in abstract_init  */</font>
00183   
00184   ti-&gt;id = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (LLT_TYPEDEF_NAME, SID_TYPE, lsymbol_fromChars (<font class="stringliteral">"float"</font>));
00185 
00186   ti-&gt;modifiable = FALSE;
00187   ti-&gt;abstract = FALSE;
00188   ti-&gt;export = FALSE;           <font class="comment">/* this is implicit, not exported */</font>
00189   ti-&gt;basedOn = sort_float;
00190   <a class="code" href="symtable_c.html#a45">symtable_enterType</a> (g_symtab, ti);
00191 }
00192 
00193 <font class="keywordtype">void</font> 
<a name="l00194"></a><a class="code" href="abstract_c.html#a44">00194</a> <a class="code" href="abstract_c.html#a44">declareForwardType</a> (declaratorNode declare)<font class="keyword"></font>
00195 <font class="keyword"></font>{
00196   typeInfo ti = (typeInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
00197   sort tsort, handle;
00198   lsymbol typedefname;
00199 
00200   typedefname = ltoken_getText (declare-&gt;id);
00201   ti-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (declare-&gt;id);
00202 
00203   ltoken_setCode (ti-&gt;id, LLT_TYPEDEF_NAME);
00204   ltoken_setIdType (ti-&gt;id, SID_TYPE);
00205 
00206   ti-&gt;modifiable = FALSE;
00207   ti-&gt;abstract = FALSE;
00208   tsort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (exposedType);
00209   handle = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (tsort, declare-&gt;type);
00210   ti-&gt;basedOn = <a class="code" href="sort_c.html#a72">sort_makeSyn</a> (declare-&gt;id, handle, typedefname);
00211   ti-&gt;export = FALSE;
00212 
00213   <a class="code" href="symtable_c.html#a45">symtable_enterType</a> (g_symtab, ti);
00214 }
00215 
<a name="l00216"></a><a class="code" href="abstract_c.html#a45">00216</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a45">LCLBuiltins</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
00217 <font class="keyword"></font>{
00218   typeInfo ti = (typeInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
00219   varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
00220   
00221   <font class="comment">/* immutable type bool;</font>
00222 <font class="comment">     uses CTrait;</font>
00223 <font class="comment">     constant bool FALSE = false;</font>
00224 <font class="comment">     constant bool TRUE  = true; */</font>
00225   
00226   <font class="comment">/* the following defines the builtin LSL sorts and operators */</font>
00227   LCLBootstrap ();
00228   
00229   <font class="comment">/* now LCL builtin proper */</font>
00230   <font class="comment">/* do "immutable type bool;" */</font>
00231   
00232   ti-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_bool);
00233 
00234   ltoken_setCode (ti-&gt;id, LLT_TYPEDEF_NAME);
00235   ltoken_setIdType (ti-&gt;id, SID_TYPE);
00236 
00237   ti-&gt;modifiable = FALSE;
00238   ti-&gt;abstract = TRUE;
00239   ti-&gt;basedOn = sort_bool;
00240   ti-&gt;export = FALSE; <font class="comment">/* this wasn't set (detected by lclint) */</font>
00241   <a class="code" href="symtable_c.html#a45">symtable_enterType</a> (g_symtab, ti);
00242   
00243   <font class="comment">/* do "constant bool FALSE = false;" */</font>
00244   vi-&gt;id = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_VAR, lsymbol_fromChars (<font class="stringliteral">"FALSE"</font>));
00245 
00246   vi-&gt;kind = VRK_CONST;
00247   vi-&gt;sort = sort_bool;
00248   vi-&gt;export = TRUE;
00249 
00250   (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
00251   
00252   <font class="comment">/* do "constant bool TRUE  = true;"  */</font>
00253   <font class="comment">/* vi-&gt;id = ltoken_copy (vi-&gt;id); */</font>
00254   ltoken_setText (vi-&gt;id, lsymbol_fromChars (<font class="stringliteral">"TRUE"</font>));
00255   (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
00256 
00257   <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
00258   
00259   <a class="code" href="imports_c.html#a1">importCTrait</a> ();
00260 }
00261 
00262 <font class="keyword">static</font> <font class="keywordtype">void</font>
00263 LCLBootstrap (<font class="keywordtype">void</font>)<font class="keyword"></font>
00264 <font class="keyword"></font>{
00265   nameNode nn1, nn2;
00266   ltoken range;
00267   sigNode sign;
00268   sort s;
00269 
00270  <font class="comment">/*</font>
00271 <font class="comment"> ** Minimal we need to bootstrap is to provide the sort</font>
00272 <font class="comment"> ** "bool" and 2 bool constants "true" and "false". </font>
00273 <font class="comment"> ** sort_init should already have been called, and hence</font>
00274 <font class="comment"> ** the bool and Bool sorts defined.</font>
00275 <font class="comment"> */</font>
00276  
00277   s = <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (ltoken_undefined, lsymbol_bool);
00278   range = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, lsymbol_bool);
00279   sign = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, ltokenList_new (), range);
00280 
00281   nn1 = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*nn1));
00282   nn1-&gt;isOpId = TRUE;
00283 
00284   nn1-&gt;content.opid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, lsymbol_fromChars (<font class="stringliteral">"true"</font>));
00285 
00286   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn1, sign);
00287   
00288   nn2 = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*nn2));
00289   nn2-&gt;isOpId = TRUE;
00290   nn2-&gt;content.opid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, lsymbol_fromChars (<font class="stringliteral">"false"</font>));
00291 
00292   <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nn2, sigNode_copy (sign));
00293 }
00294 
00295 interfaceNodeList
<a name="l00296"></a><a class="code" href="abstract_c.html#a46">00296</a> <a class="code" href="abstract_c.html#a46">consInterfaceNode</a> (<font class="comment">/*@only@*/</font> interfaceNode n, <font class="comment">/*@returned@*/</font> interfaceNodeList ns)<font class="keyword"></font>
00297 <font class="keyword"></font>{
00298   <font class="comment">/* n is never empty, but ns may be empty */</font>
00299   <a class="code" href="interfaceNodeList_c.html#a3">interfaceNodeList_addl</a> (ns, n);
00300   <font class="keywordflow">return</font> (ns);
00301 }
00302 
00303 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00304"></a><a class="code" href="abstract_c.html#a47">00304</a> <a class="code" href="abstract_c.html#a47">makeInterfaceNodeImports</a> (<font class="comment">/*@only@*/</font> importNodeList x)<font class="keyword"></font>
00305 <font class="keyword"></font>{
00306   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00307   lsymbol importSymbol;
00308 
00309   i-&gt;kind = INF_IMPORTS;
00310   i-&gt;content.imports = x;       <font class="comment">/* an importNodeList */</font>
00311   
00312   importNodeList_elements (x, imp)<font class="keyword"></font>
00313 <font class="keyword">    </font>{
00314       importSymbol = <a class="code" href="ltoken_c.html#a40">ltoken_getRawText</a> (imp-&gt;val);
00315       
00316       <font class="keywordflow">if</font> (<a class="code" href="lsymbolSet_c.html#a3">lsymbolSet_member</a> (g_currentImports, importSymbol))
00317         {
00318           <a class="code" href="llerror_c.html#a54">lclerror</a> (imp-&gt;val, 
00319                     message (<font class="stringliteral">"Circular imports: %s"</font>, 
00320                              cstring_fromChars (lsymbol_toChars (importSymbol))));
00321         }      
00322       <font class="keywordflow">else</font>
00323         {
00324           <a class="code" href="imports_c.html#a2">processImport</a> (importSymbol, imp-&gt;val, imp-&gt;kind);
00325         }
00326     } end_importNodeList_elements;
00327 
00328   <a class="code" href="lh_c.html#a19">lhOutLine</a> (cstring_undefined);
00329   <font class="keywordflow">return</font> (i);
00330 }
00331 
00332 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00333"></a><a class="code" href="abstract_c.html#a48">00333</a> <a class="code" href="abstract_c.html#a48">makeInterfaceNodeUses</a> (<font class="comment">/*@only@*/</font> traitRefNodeList x)<font class="keyword"></font>
00334 <font class="keyword"></font>{
00335   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00336 
00337   i-&gt;kind = INF_USES;
00338   i-&gt;content.uses = x;
00339   <font class="comment">/* read in LSL traits */</font>
00340 
00341   <font class="keywordflow">return</font> (i);
00342 }
00343 
00344 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00345"></a><a class="code" href="abstract_c.html#a49">00345</a> <a class="code" href="abstract_c.html#a49">interfaceNode_makeConst</a> (<font class="comment">/*@only@*/</font> constDeclarationNode x)<font class="keyword"></font>
00346 <font class="keyword"></font>{
00347   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00348   exportNode e = (exportNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00349 
00350   e-&gt;kind = XPK_CONST;
00351   e-&gt;content.constdeclaration = x;
00352   i-&gt;kind = INF_EXPORT;
00353   i-&gt;content.export = e;
00354 
00355   <font class="keywordflow">return</font> (i);
00356 }
00357 
00358 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00359"></a><a class="code" href="abstract_c.html#a50">00359</a> <a class="code" href="abstract_c.html#a50">interfaceNode_makeVar</a> (<font class="comment">/*@only@*/</font> varDeclarationNode x)<font class="keyword"></font>
00360 <font class="keyword"></font>{
00361   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00362   exportNode e = (exportNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00363 
00364   e-&gt;kind = XPK_VAR;
00365   e-&gt;content.vardeclaration = x;
00366   i-&gt;kind = INF_EXPORT;
00367   i-&gt;content.export = e;
00368   
00369   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a199">context_msgLh</a> ())
00370     {
00371       <a class="code" href="lh_c.html#a19">lhOutLine</a> (lhVarDecl (x-&gt;type, x-&gt;decls, x-&gt;qualifier));
00372     }
00373 
00374     <font class="keywordflow">return</font> (i);
00375 }
00376 
00377 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00378"></a><a class="code" href="abstract_c.html#a51">00378</a> <a class="code" href="abstract_c.html#a51">interfaceNode_makeType</a> (<font class="comment">/*@only@*/</font> typeNode x)<font class="keyword"></font>
00379 <font class="keyword"></font>{
00380   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00381   exportNode e = (exportNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00382   e-&gt;kind = XPK_TYPE;
00383   e-&gt;content.type = x;
00384   i-&gt;kind = INF_EXPORT;
00385   i-&gt;content.export = e;
00386 
00387   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a199">context_msgLh</a> ())
00388     {
00389       
00390       <a class="code" href="lh_c.html#a19">lhOutLine</a> (lhType (x));
00391     }
00392 
00393   <font class="keywordflow">return</font> (i);
00394 }
00395 
00396 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00397"></a><a class="code" href="abstract_c.html#a52">00397</a> <a class="code" href="abstract_c.html#a52">interfaceNode_makeFcn</a> (<font class="comment">/*@only@*/</font> fcnNode x)<font class="keyword"></font>
00398 <font class="keyword"></font>{
00399   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00400   exportNode e = (exportNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00401 
00402   e-&gt;kind = XPK_FCN;
00403   e-&gt;content.fcn = x;
00404   i-&gt;kind = INF_EXPORT;
00405   i-&gt;content.export = e;
00406 
00407   <font class="keywordflow">if</font> (<a class="code" href="context_c.html#a199">context_msgLh</a> ())
00408     {
00409       llassert (x-&gt;typespec != NULL);
00410       llassert (x-&gt;declarator != NULL);
00411 
00412       <a class="code" href="lh_c.html#a19">lhOutLine</a> (lhFunction (x-&gt;typespec, x-&gt;declarator));
00413     }
00414 
00415   <font class="keywordflow">return</font> (i);
00416 }
00417 
00418 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00419"></a><a class="code" href="abstract_c.html#a53">00419</a> <a class="code" href="abstract_c.html#a53">interfaceNode_makeClaim</a> (<font class="comment">/*@only@*/</font> claimNode x)<font class="keyword"></font>
00420 <font class="keyword"></font>{
00421   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00422   exportNode e = (exportNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00423 
00424   e-&gt;kind = XPK_CLAIM;
00425   e-&gt;content.claim = x;
00426   i-&gt;kind = INF_EXPORT;
00427   i-&gt;content.export = e;
00428   <font class="keywordflow">return</font> (i);
00429 }
00430 
00431 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00432"></a><a class="code" href="abstract_c.html#a54">00432</a> <a class="code" href="abstract_c.html#a54">interfaceNode_makeIter</a> (<font class="comment">/*@only@*/</font> iterNode x)<font class="keyword"></font>
00433 <font class="keyword"></font>{
00434   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00435   exportNode e = (exportNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00436 
00437   e-&gt;kind = XPK_ITER;
00438   e-&gt;content.iter = x;
00439   i-&gt;kind = INF_EXPORT;
00440   i-&gt;content.export = e;
00441   <font class="keywordflow">return</font> (i);
00442 }
00443 
00444 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00445"></a><a class="code" href="abstract_c.html#a55">00445</a> <a class="code" href="abstract_c.html#a55">interfaceNode_makePrivConst</a> (<font class="comment">/*@only@*/</font> constDeclarationNode x)<font class="keyword"></font>
00446 <font class="keyword"></font>{
00447   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00448   privateNode e = (privateNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00449 
00450   e-&gt;kind = PRIV_CONST;
00451   e-&gt;content.constdeclaration = x;
00452   i-&gt;kind = INF_PRIVATE;
00453   i-&gt;content.<font class="keyword">private</font> = e;
00454   <font class="keywordflow">return</font> (i);
00455 }
00456 
00457 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00458"></a><a class="code" href="abstract_c.html#a56">00458</a> <a class="code" href="abstract_c.html#a56">interfaceNode_makePrivVar</a> (<font class="comment">/*@only@*/</font> varDeclarationNode x)<font class="keyword"></font>
00459 <font class="keyword"></font>{
00460   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00461   privateNode e = (privateNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00462   
00463   e-&gt;kind = PRIV_VAR;
00464   e-&gt;content.vardeclaration = x;
00465   i-&gt;kind = INF_PRIVATE;
00466   i-&gt;content.<font class="keyword">private</font> = e;
00467   <font class="keywordflow">return</font> (i);
00468 }
00469 
00470 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00471"></a><a class="code" href="abstract_c.html#a57">00471</a> <a class="code" href="abstract_c.html#a57">interfaceNode_makePrivType</a> (<font class="comment">/*@only@*/</font> typeNode x)<font class="keyword"></font>
00472 <font class="keyword"></font>{
00473   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00474   privateNode e = (privateNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00475 
00476   e-&gt;kind = PRIV_TYPE;
00477   e-&gt;content.type = x;
00478   i-&gt;kind = INF_PRIVATE;
00479   i-&gt;content.<font class="keyword">private</font> = e;
00480   <font class="keywordflow">return</font> (i);
00481 }
00482 
00483 <font class="comment">/*@only@*/</font> interfaceNode
<a name="l00484"></a><a class="code" href="abstract_c.html#a58">00484</a> <a class="code" href="abstract_c.html#a58">interfaceNode_makePrivFcn</a> (<font class="comment">/*@only@*/</font> fcnNode x)<font class="keyword"></font>
00485 <font class="keyword"></font>{
00486   interfaceNode i = (interfaceNode) dmalloc (<font class="keyword">sizeof</font> (*i));
00487   privateNode e = (privateNode) dmalloc (<font class="keyword">sizeof</font> (*e));
00488 
00489   <font class="comment">/*</font>
00490 <font class="comment">  ** bug detected by lclint enum checking</font>
00491 <font class="comment">  ** e-&gt;kind = XPK_FCN;</font>
00492 <font class="comment">  */</font>
00493 
00494   e-&gt;kind = PRIV_FUNCTION;
00495   e-&gt;content.fcn = x;
00496   i-&gt;kind = INF_PRIVATE;
00497   i-&gt;content.<font class="keyword">private</font> = e;
00498   <font class="keywordflow">return</font> (i);
00499 }
00500 
00501 <font class="comment">/*@only@*/</font> cstring
<a name="l00502"></a><a class="code" href="abstract_c.html#a59">00502</a> <a class="code" href="abstract_c.html#a59">exportNode_unparse</a> (exportNode n)<font class="keyword"></font>
00503 <font class="keyword"></font>{
00504   <font class="keywordflow">if</font> (n != (exportNode) 0)
00505     {
00506       <font class="keywordflow">switch</font> (n-&gt;kind)
00507         {
00508         <font class="keywordflow">case</font> XPK_CONST:
00509           <font class="keywordflow">return</font> (message 
00510                   (<font class="stringliteral">"%q\n"</font>, 
00511                    <a class="code" href="abstract_c.html#a67">constDeclarationNode_unparse</a> (n-&gt;content.constdeclaration)));
00512         <font class="keywordflow">case</font> XPK_VAR:
00513           <font class="keywordflow">return</font> (message 
00514                   (<font class="stringliteral">"%q\n"</font>, 
00515                    <a class="code" href="abstract_c.html#a65">varDeclarationNode_unparse</a> (n-&gt;content.vardeclaration)));
00516         <font class="keywordflow">case</font> XPK_TYPE:
00517           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q\n"</font>, typeNode_unparse (n-&gt;content.type)));
00518         <font class="keywordflow">case</font> XPK_FCN:
00519           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a64">fcnNode_unparse</a> (n-&gt;content.fcn));
00520         <font class="keywordflow">case</font> XPK_CLAIM:
00521           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a200">claimNode_unparse</a> (n-&gt;content.claim));
00522         <font class="keywordflow">case</font> XPK_ITER:
00523           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a63">iterNode_unparse</a> (n-&gt;content.iter));
00524         <font class="keywordflow">default</font>:
00525           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"exportNode_unparse: unknown kind: %d"</font>, (<font class="keywordtype">int</font>) n-&gt;kind));
00526         }
00527     }
00528   <font class="keywordflow">return</font> cstring_undefined;
00529 }
00530 
00531 <font class="comment">/*@only@*/</font> cstring
<a name="l00532"></a><a class="code" href="abstract_c.html#a60">00532</a> <a class="code" href="abstract_c.html#a60">privateNode_unparse</a> (privateNode n)<font class="keyword"></font>
00533 <font class="keyword"></font>{
00534   <font class="keywordflow">if</font> (n != (privateNode) 0)
00535     {
00536       <font class="keywordflow">switch</font> (n-&gt;kind)
00537         {
00538         <font class="keywordflow">case</font> PRIV_CONST:
00539           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a67">constDeclarationNode_unparse</a> (n-&gt;content.constdeclaration));
00540         <font class="keywordflow">case</font> PRIV_VAR:
00541           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a65">varDeclarationNode_unparse</a> (n-&gt;content.vardeclaration));
00542         <font class="keywordflow">case</font> PRIV_TYPE:
00543           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a66">typeNode_unparse</a> (n-&gt;content.type));
00544         <font class="keywordflow">case</font> PRIV_FUNCTION:
00545           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a64">fcnNode_unparse</a> (n-&gt;content.fcn));
00546         <font class="keywordflow">default</font>:
00547           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"privateNode_unparse: unknown kind: %d"</font>, 
00548                                (<font class="keywordtype">int</font>) n-&gt;kind));
00549         }
00550     }
00551   <font class="keywordflow">return</font> cstring_undefined;
00552 }
00553 
00554 <font class="keywordtype">void</font> lclPredicateNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> lclPredicateNode x)<font class="keyword"></font>
00555 <font class="keyword"></font>{
00556   <font class="keywordflow">if</font> (x != NULL)
00557     {
00558       <a class="code" href="abstract_c.html#a243">termNode_free</a> (x-&gt;predicate);
00559       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;tok);
00560       <a class="code" href="general_c.html#a0">sfree</a> (x);
00561     }
00562 }
00563 
00564 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
00565 lclPredicateNode_unparse (<font class="comment">/*@null@*/</font> lclPredicateNode p) <font class="comment">/*@*/</font> 
00566 {
00567   <font class="keywordflow">if</font> (p != (lclPredicateNode) 0)
00568     {
00569       cstring st = cstring_undefined;
00570       
00571       <font class="keywordflow">switch</font> (p-&gt;kind)
00572         {
00573         <font class="keywordflow">case</font> LPD_REQUIRES:
00574           st = cstring_makeLiteral (<font class="stringliteral">"  requires "</font>);
00575           <font class="keywordflow">break</font>;
00576         <font class="keywordflow">case</font> LPD_CHECKS:
00577           st = cstring_makeLiteral (<font class="stringliteral">"  checks "</font>); 
00578           <font class="keywordflow">break</font>;
00579         <font class="keywordflow">case</font> LPD_ENSURES:
00580           st = cstring_makeLiteral (<font class="stringliteral">"  ensures "</font>);
00581           <font class="keywordflow">break</font>;
00582         <font class="keywordflow">case</font> LPD_INTRACLAIM:
00583           st = cstring_makeLiteral (<font class="stringliteral">"  claims "</font>);
00584           <font class="keywordflow">break</font>;
00585         <font class="keywordflow">case</font> LPD_CONSTRAINT:
00586           st = cstring_makeLiteral (<font class="stringliteral">"constraint "</font>);
00587           <font class="keywordflow">break</font>;
00588         <font class="keywordflow">case</font> LPD_INITIALLY:
00589           st = cstring_makeLiteral (<font class="stringliteral">"initially "</font>);
00590           <font class="keywordflow">break</font>;
00591         <font class="keywordflow">case</font> LPD_PLAIN:
00592           <font class="keywordflow">break</font>;
00593         <font class="keywordflow">default</font>:
00594           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"lclPredicateNode_unparse: unknown kind: %d"</font>, 
00595                                (<font class="keywordtype">int</font>) p-&gt;kind));
00596         }
00597       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q;\n"</font>, st, termNode_unparse (p-&gt;predicate)));
00598     }
00599   <font class="keywordflow">return</font> cstring_undefined;
00600 }
00601 
00602 <font class="keywordtype">bool</font>
<a name="l00603"></a><a class="code" href="abstract_c.html#a62">00603</a> <a class="code" href="abstract_c.html#a62">ltoken_similar</a> (ltoken t1, ltoken t2)<font class="keyword"></font>
00604 <font class="keyword"></font>{
00605   lsymbol sym1 = ltoken_getText (t1);
00606   lsymbol sym2 = ltoken_getText (t2);
00607   
00608   <font class="keywordflow">if</font> (sym1 == sym2)
00609     {
00610       <font class="keywordflow">return</font> TRUE;
00611     }
00612 
00613   <font class="keywordflow">if</font> ((sym1 == eqSymbol &amp;&amp; sym2 == equalSymbol) ||
00614       (sym2 == eqSymbol &amp;&amp; sym1 == equalSymbol))
00615     {
00616       <font class="keywordflow">return</font> TRUE;
00617     }
00618 
00619   <font class="keywordflow">if</font> ((sym1 == lsymbol_bool &amp;&amp; sym2 == lsymbol_Bool) ||
00620       (sym2 == lsymbol_bool &amp;&amp; sym1 == lsymbol_Bool))
00621     {
00622       <font class="keywordflow">return</font> TRUE;
00623     }
00624 
00625   <font class="keywordflow">return</font> FALSE;
00626 }
00627 
00628 <font class="comment">/*@only@*/</font> cstring
<a name="l00629"></a><a class="code" href="abstract_c.html#a63">00629</a> <a class="code" href="abstract_c.html#a63">iterNode_unparse</a> (<font class="comment">/*@null@*/</font> iterNode i)<font class="keyword"></font>
00630 <font class="keyword"></font>{
00631   <font class="keywordflow">if</font> (i != (iterNode) 0)
00632     {
00633       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"iter %s %q"</font>, ltoken_unparse (i-&gt;name), 
00634                        <a class="code" href="paramNodeList_c.html#a5">paramNodeList_unparse</a> (i-&gt;params)));
00635     }
00636   <font class="keywordflow">return</font> cstring_undefined;
00637 }
00638 
00639 
00640 <font class="comment">/*@only@*/</font> cstring
<a name="l00641"></a><a class="code" href="abstract_c.html#a64">00641</a> <a class="code" href="abstract_c.html#a64">fcnNode_unparse</a> (<font class="comment">/*@null@*/</font> fcnNode f)<font class="keyword"></font>
00642 <font class="keyword"></font>{
00643   <font class="keywordflow">if</font> (f != (fcnNode) 0)
00644     {
00645       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %q%q{\n%q%q%q%q%q%q}\n"</font>,
00646                        lclTypeSpecNode_unparse (f-&gt;typespec),
00647                        <a class="code" href="abstract_c.html#a130">declaratorNode_unparse</a> (f-&gt;declarator),
00648                        <a class="code" href="varDeclarationNodeList_c.html#a3">varDeclarationNodeList_unparse</a> (f-&gt;globals),
00649                        <a class="code" href="varDeclarationNodeList_c.html#a3">varDeclarationNodeList_unparse</a> (f-&gt;inits),
00650                        <a class="code" href="letDeclNodeList_c.html#a3">letDeclNodeList_unparse</a> (f-&gt;lets),
00651                        lclPredicateNode_unparse (f-&gt;require),
00652                        <a class="code" href="abstract_c.html#a205">modifyNode_unparse</a> (f-&gt;modify),
00653                        lclPredicateNode_unparse (f-&gt;ensures),
00654                        lclPredicateNode_unparse (f-&gt;claim)));
00655     }
00656   <font class="keywordflow">return</font> cstring_undefined;
00657 }
00658 
00659 <font class="comment">/*@only@*/</font> cstring
<a name="l00660"></a><a class="code" href="abstract_c.html#a65">00660</a> <a class="code" href="abstract_c.html#a65">varDeclarationNode_unparse</a> (<font class="comment">/*@null@*/</font> varDeclarationNode x)<font class="keyword"></font>
00661 <font class="keyword"></font>{
00662   <font class="keywordflow">if</font> (x != (varDeclarationNode) 0)
00663     {
00664       cstring st;
00665 
00666       <font class="keywordflow">if</font> (x-&gt;isSpecial)
00667         {
00668           <font class="keywordflow">return</font> (<a class="code" href="sRef_c.html#a123">sRef_unparse</a> (x-&gt;sref));
00669         }
00670       <font class="keywordflow">else</font>
00671         {
00672           <font class="keywordflow">switch</font> (x-&gt;qualifier)
00673             {
00674             <font class="keywordflow">case</font> QLF_NONE:
00675               st = cstring_undefined;
00676               <font class="keywordflow">break</font>;
00677             <font class="keywordflow">case</font> QLF_CONST:
00678               st = cstring_makeLiteral (<font class="stringliteral">"const "</font>);
00679               <font class="keywordflow">break</font>;
00680             <font class="keywordflow">case</font> QLF_VOLATILE:
00681               st = cstring_makeLiteral (<font class="stringliteral">"volatile "</font>);
00682               <font class="keywordflow">break</font>;
00683               BADDEFAULT;
00684             }
00685           
00686           st = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q %q"</font>, st, lclTypeSpecNode_unparse (x-&gt;type),
00687                         <a class="code" href="initDeclNodeList_c.html#a3">initDeclNodeList_unparse</a> (x-&gt;decls));
00688           <font class="keywordflow">return</font> (st);
00689         }
00690     }
00691 
00692   <font class="keywordflow">return</font> cstring_undefined;
00693 }
00694 
00695 <font class="comment">/*@only@*/</font> cstring
<a name="l00696"></a><a class="code" href="abstract_c.html#a66">00696</a> <a class="code" href="abstract_c.html#a66">typeNode_unparse</a> (<font class="comment">/*@null@*/</font> typeNode t)<font class="keyword"></font>
00697 <font class="keyword"></font>{
00698   <font class="keywordflow">if</font> (t != (typeNode) 0)
00699     {
00700       <font class="keywordflow">switch</font> (t-&gt;kind)
00701         {
00702         <font class="keywordflow">case</font> TK_ABSTRACT:
00703           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a146">abstractNode_unparse</a> (t-&gt;content.abstract));
00704         <font class="keywordflow">case</font> TK_EXPOSED:
00705           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a149">exposedNode_unparse</a> (t-&gt;content.exposed));
00706         <font class="keywordflow">case</font> TK_UNION:
00707           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a154">taggedUnionNode_unparse</a> (t-&gt;content.taggedunion));
00708         <font class="keywordflow">default</font>:
00709           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"typeNode_unparse: unknown kind: %d"</font>, (<font class="keywordtype">int</font>)t-&gt;kind));
00710         }
00711     }
00712   <font class="keywordflow">return</font> cstring_undefined;
00713 }
00714 
00715 <font class="comment">/*@only@*/</font> cstring
<a name="l00716"></a><a class="code" href="abstract_c.html#a67">00716</a> <a class="code" href="abstract_c.html#a67">constDeclarationNode_unparse</a> (<font class="comment">/*@null@*/</font> constDeclarationNode x)<font class="keyword"></font>
00717 <font class="keyword"></font>{
00718   <font class="keywordflow">if</font> (x != (constDeclarationNode) 0)
00719     {
00720       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"constant %q %q"</font>, lclTypeSpecNode_unparse (x-&gt;type),
00721                        <a class="code" href="initDeclNodeList_c.html#a3">initDeclNodeList_unparse</a> (x-&gt;decls)));
00722     }
00723 
00724   <font class="keywordflow">return</font> cstring_undefined;
00725 }
00726 
00727 <font class="comment">/*@only@*/</font> storeRefNode
<a name="l00728"></a><a class="code" href="abstract_c.html#a68">00728</a> <a class="code" href="abstract_c.html#a68">makeStoreRefNodeTerm</a> (<font class="comment">/*@only@*/</font> termNode t)<font class="keyword"></font>
00729 <font class="keyword"></font>{
00730   storeRefNode x = (storeRefNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00731 
00732   x-&gt;kind = SRN_TERM;
00733   x-&gt;content.term = t;
00734   <font class="keywordflow">return</font> (x);
00735 }
00736 
00737 <font class="comment">/*@only@*/</font> storeRefNode
<a name="l00738"></a><a class="code" href="abstract_c.html#a69">00738</a> <a class="code" href="abstract_c.html#a69">makeStoreRefNodeType</a> (<font class="comment">/*@only@*/</font> lclTypeSpecNode t, <font class="keywordtype">bool</font> isObj)<font class="keyword"></font>
00739 <font class="keyword"></font>{
00740   storeRefNode x = (storeRefNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00741 
00742   x-&gt;kind = isObj ? SRN_OBJ : SRN_TYPE;
00743   x-&gt;content.type = t;
00744   <font class="keywordflow">return</font> (x);
00745 }
00746 
00747 storeRefNode
<a name="l00748"></a><a class="code" href="abstract_c.html#a70">00748</a> <a class="code" href="abstract_c.html#a70">makeStoreRefNodeInternal</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
00749 <font class="keyword"></font>{
00750   storeRefNode x = (storeRefNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00751 
00752   x-&gt;kind = SRN_SPECIAL;
00753   x-&gt;content.ref = <a class="code" href="sRef_c.html#a156">sRef_makeInternalState</a> ();
00754   <font class="keywordflow">return</font> (x);
00755 }
00756 
00757 storeRefNode
<a name="l00758"></a><a class="code" href="abstract_c.html#a71">00758</a> <a class="code" href="abstract_c.html#a71">makeStoreRefNodeSystem</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
00759 <font class="keyword"></font>{
00760   storeRefNode x = (storeRefNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00761 
00762   x-&gt;kind = SRN_SPECIAL;
00763   x-&gt;content.ref = <a class="code" href="sRef_c.html#a158">sRef_makeSystemState</a> ();
00764   <font class="keywordflow">return</font> (x);
00765 }
00766 
00767 <font class="comment">/*@only@*/</font> modifyNode
<a name="l00768"></a><a class="code" href="abstract_c.html#a72">00768</a> <a class="code" href="abstract_c.html#a72">makeModifyNodeSpecial</a> (<font class="comment">/*@only@*/</font> ltoken t, <font class="keywordtype">bool</font> modifiesNothing)<font class="keyword"></font>
00769 <font class="keyword"></font>{
00770   modifyNode x = (modifyNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00771 
00772   x-&gt;tok = t;
00773   x-&gt;modifiesNothing = modifiesNothing;
00774   x-&gt;hasStoreRefList = FALSE;
00775   <font class="keywordflow">return</font> (x);
00776 }
00777 
00778 <font class="comment">/*@only@*/</font> modifyNode
<a name="l00779"></a><a class="code" href="abstract_c.html#a73">00779</a> <a class="code" href="abstract_c.html#a73">makeModifyNodeRef</a> (<font class="comment">/*@only@*/</font> ltoken t, <font class="comment">/*@only@*/</font> storeRefNodeList y)<font class="keyword"></font>
00780 <font class="keyword"></font>{
00781   modifyNode x = (modifyNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00782   sort sort;
00783   
00784   x-&gt;tok = t;
00785   x-&gt;hasStoreRefList = TRUE;
00786   x-&gt;modifiesNothing = FALSE;
00787   x-&gt;list = y;
00788   <font class="comment">/* check that all storeRef's are modifiable */</font>
00789   
00790   storeRefNodeList_elements (y, sr)<font class="keyword"></font>
00791 <font class="keyword">    </font>{
00792       <font class="keywordflow">if</font> (storeRefNode_isTerm (sr))
00793         {
00794           sort = sr-&gt;content.term-&gt;sort;
00795 
00796           <font class="keywordflow">if</font> (!<a class="code" href="sort_c.html#a103">sort_mutable</a> (sort) &amp;&amp; <a class="code" href="sort_c.html#a105">sort_isValidSort</a> (sort))
00797             {
00798               ltoken errtok = <a class="code" href="abstract_c.html#a74">termNode_errorToken</a> (sr-&gt;content.term);
00799               <a class="code" href="llerror_c.html#a54">lclerror</a> (errtok, 
00800                         message (<font class="stringliteral">"Term denoting immutable object used in modifies list: %q"</font>,
00801                                  termNode_unparse (sr-&gt;content.term)));
00802             }
00803         }
00804       <font class="keywordflow">else</font> 
00805         {
00806           <font class="keywordflow">if</font> (!storeRefNode_isSpecial (sr))
00807             {
00808               sort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (sr-&gt;content.type);
00809               
00810               <font class="keywordflow">if</font> (storeRefNode_isObj (sr))
00811                 {
00812                   sort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (sort);
00813                 }
00814               
00815               <font class="keywordflow">if</font> (!<a class="code" href="sort_c.html#a103">sort_mutable</a> (sort))
00816                 {
00817                   ltoken errtok = <a class="code" href="abstract_c.html#a76">lclTypeSpecNode_errorToken</a> (sr-&gt;content.type);
00818                   <a class="code" href="llerror_c.html#a54">lclerror</a> (errtok, 
00819                             message (<font class="stringliteral">"Immutable type used in modifies list: %q"</font>,
00820                                      sort_unparse (sort)));
00821                 }
00822             }
00823         }
00824     } end_storeRefNodeList_elements;
00825   <font class="keywordflow">return</font> (x);
00826 }
00827 
00828 <font class="comment">/*@observer@*/</font> ltoken
<a name="l00829"></a><a class="code" href="abstract_c.html#a74">00829</a> <a class="code" href="abstract_c.html#a74">termNode_errorToken</a> (<font class="comment">/*@null@*/</font> termNode n)<font class="keyword"></font>
00830 <font class="keyword"></font>{
00831   <font class="keywordflow">if</font> (n != (termNode) 0)
00832     {
00833       <font class="keywordflow">switch</font> (n-&gt;kind)
00834         {
00835         <font class="keywordflow">case</font> TRM_LITERAL:
00836         <font class="keywordflow">case</font> TRM_UNCHANGEDALL:
00837         <font class="keywordflow">case</font> TRM_UNCHANGEDOTHERS:
00838         <font class="keywordflow">case</font> TRM_SIZEOF:
00839         <font class="keywordflow">case</font> TRM_CONST:
00840         <font class="keywordflow">case</font> TRM_VAR:
00841         <font class="keywordflow">case</font> TRM_ZEROARY:       <font class="comment">/* also the default kind, when no in symbol table */</font>
00842           <font class="keywordflow">return</font> n-&gt;literal;
00843         <font class="keywordflow">case</font> TRM_QUANTIFIER:
00844           <font class="keywordflow">return</font> n-&gt;quantified-&gt;open;
00845         <font class="keywordflow">case</font> TRM_APPLICATION:
00846           <font class="keywordflow">if</font> (n-&gt;name != NULL)
00847             {
00848               <font class="keywordflow">if</font> (n-&gt;name-&gt;isOpId)
00849                 {
00850                   <font class="keywordflow">return</font> n-&gt;name-&gt;content.opid;
00851                 }
00852               <font class="keywordflow">else</font>
00853                 {
00854                   llassert (n-&gt;name-&gt;content.opform != NULL);
00855                   <font class="keywordflow">return</font> n-&gt;name-&gt;content.opform-&gt;tok;
00856                 }
00857             }
00858           <font class="keywordflow">else</font>
00859             {
00860               <font class="keywordflow">return</font> ltoken_undefined;
00861             }
00862         }
00863     }
00864   <font class="keywordflow">return</font> ltoken_undefined;
00865 }
00866 
00867 <font class="comment">/*@observer@*/</font> ltoken
<a name="l00868"></a><a class="code" href="abstract_c.html#a75">00868</a> <a class="code" href="abstract_c.html#a75">nameNode_errorToken</a> (<font class="comment">/*@null@*/</font> nameNode nn)<font class="keyword"></font>
00869 <font class="keyword"></font>{
00870   <font class="keywordflow">if</font> (nn != (nameNode) 0)
00871     {
00872       <font class="keywordflow">if</font> (nn-&gt;isOpId)
00873         {
00874           <font class="keywordflow">return</font> nn-&gt;content.opid;
00875         }
00876       <font class="keywordflow">else</font>
00877         {
00878           <font class="keywordflow">if</font> (nn-&gt;content.opform != NULL)
00879             {
00880               <font class="keywordflow">return</font> nn-&gt;content.opform-&gt;tok;
00881             }
00882         }
00883     }
00884 
00885   <font class="keywordflow">return</font> ltoken_undefined;
00886 }
00887 
00888 <font class="comment">/*@observer@*/</font> ltoken
<a name="l00889"></a><a class="code" href="abstract_c.html#a76">00889</a> <a class="code" href="abstract_c.html#a76">lclTypeSpecNode_errorToken</a> (<font class="comment">/*@null@*/</font> lclTypeSpecNode t)<font class="keyword"></font>
00890 <font class="keyword"></font>{
00891   <font class="keywordflow">if</font> (t != (lclTypeSpecNode) 0)
00892     {
00893       <font class="keywordflow">switch</font> (t-&gt;kind)
00894         {
00895         <font class="keywordflow">case</font> LTS_TYPE:
00896           {
00897             llassert (t-&gt;content.type != NULL);
00898 
00899             <font class="keywordflow">if</font> (ltokenList_empty (t-&gt;content.type-&gt;ctypes))
00900               <font class="keywordflow">break</font>;
00901             <font class="keywordflow">else</font>
00902               <font class="keywordflow">return</font> (<a class="code" href="ltokenList_c.html#a8">ltokenList_head</a> (t-&gt;content.type-&gt;ctypes));
00903           }
00904         <font class="keywordflow">case</font> LTS_STRUCTUNION:
00905           llassert (t-&gt;content.structorunion != NULL);
00906           <font class="keywordflow">return</font> t-&gt;content.structorunion-&gt;tok;
00907         <font class="keywordflow">case</font> LTS_ENUM:
00908           llassert (t-&gt;content.enumspec != NULL);
00909           <font class="keywordflow">return</font> t-&gt;content.enumspec-&gt;tok;
00910         <font class="keywordflow">case</font> LTS_CONJ:
00911           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a76">lclTypeSpecNode_errorToken</a> (t-&gt;content.conj-&gt;a));
00912         }
00913     }
00914 
00915   <font class="keywordflow">return</font> ltoken_undefined;
00916 }
00917 
00918 <font class="keyword">static</font> <font class="keywordtype">bool</font>
00919 sort_member_modulo_cstring (sort s, <font class="comment">/*@null@*/</font> termNode t)<font class="keyword"></font>
00920 <font class="keyword"></font>{
00921   
00922   <font class="keywordflow">if</font> (t != (termNode) 0)
00923     {
00924       <font class="keywordflow">if</font> (t-&gt;kind == TRM_LITERAL)
00925         { <font class="comment">/* allow multiple types */</font>
00926           sortNode sn;
00927 
00928           sortSet_elements (t-&gt;possibleSorts, el)<font class="keyword"></font>
00929 <font class="keyword">            </font>{
00930               <font class="keywordflow">if</font> (<a class="code" href="sort_c.html#a112">sort_compatible_modulo_cstring</a> (s, el))
00931                 {
00932                   <font class="keywordflow">return</font> TRUE;
00933                 }
00934             } end_sortSet_elements;
00935 
00936           sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (s);
00937 
00938           <font class="keywordflow">if</font> (sn.kind == SRT_PTR)
00939             {
00940               <font class="keywordtype">char</font> *lit = <a class="code" href="lsymbol_c.html#a17">lsymbol_toChars</a> (ltoken_getText (t-&gt;literal));
00941               
00942               <font class="keywordflow">if</font> (lit != NULL)
00943                 {
00944                   <font class="keywordtype">long</font> val = 0;
00945                   
00946                   <font class="keywordflow">if</font> (sscanf (lit, <font class="stringliteral">"%ld"</font>, &amp;val) == 1)
00947                     {
00948                       <font class="keywordflow">if</font> (val == 0) <font class="keywordflow">return</font> TRUE;
00949                     }
00950                 }
00951             }
00952           
00953           <font class="keywordflow">return</font> FALSE;
00954         }
00955       <font class="keywordflow">else</font>
00956         {
00957           <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a112">sort_compatible_modulo_cstring</a> (s, t-&gt;sort);
00958         }
00959     }
00960   <font class="keywordflow">return</font> FALSE;
00961 }
00962 
00963 <font class="comment">/*@only@*/</font> letDeclNode
<a name="l00964"></a><a class="code" href="abstract_c.html#a78">00964</a>   <a class="code" href="abstract_c.html#a78">makeLetDeclNode</a> (ltoken varid, <font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> lclTypeSpecNode t, 
00965                    <font class="comment">/*@only@*/</font> termNode term)<font class="keyword"></font>
00966 <font class="keyword"></font>{
00967   letDeclNode x = (letDeclNode) dmalloc (<font class="keyword">sizeof</font> (*x));
00968   varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
00969   ltoken errtok;
00970   sort s, termsort;
00971 
00972   <font class="keywordflow">if</font> (t != (lclTypeSpecNode) 0)
00973     {
00974       <font class="comment">/* check varid has the same sort as term */</font>
00975       s = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (t);
00976       termsort = term-&gt;sort;
00977       <font class="comment">/* should keep the arguments in order */</font>
00978       <font class="keywordflow">if</font> (!sort_member_modulo_cstring (s, term) &amp;&amp;
00979           !term-&gt;error_reported)
00980         {
00981           errtok = <a class="code" href="abstract_c.html#a74">termNode_errorToken</a> (term);
00982           
00983           <font class="comment">/*      errorShowPoint (tsource_thisLine (lclsource), ltoken_getCol (errtok)); */</font>
00984           <font class="comment">/*      sprintf (ERRMSG, "expect `%s' type but given term has `%s' type",</font>
00985 <font class="comment">                  sort_unparse (s), sort_unparse (termsort)); */</font>
00986           
00987           <a class="code" href="llerror_c.html#a54">lclerror</a> (errtok, 
00988                     message (<font class="stringliteral">"Let declaration expects type %q"</font>, sort_unparse (s)));
00989           <font class="comment">/* evs --- don't know how to generated this message or what it means? */</font>
00990         }
00991     }
00992   <font class="keywordflow">else</font>
00993     {
00994       s = term-&gt;sort;
00995     }
00996   <font class="comment">/* assign variable its type and sort, store in symbol table */</font>
00997   vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (varid);
00998   vi-&gt;kind = VRK_LET;
00999   vi-&gt;sort = s;
01000   vi-&gt;export = TRUE;
01001 
01002   (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
01003   <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
01004 
01005   x-&gt;varid = varid;
01006   x-&gt;sortspec = t;
01007   x-&gt;term = term;
01008   x-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
01009 
01010   <font class="keywordflow">return</font> (x);
01011 }
01012 
01013 <font class="comment">/*@only@*/</font> programNode
<a name="l01014"></a><a class="code" href="abstract_c.html#a79">01014</a> <a class="code" href="abstract_c.html#a79">makeProgramNodeAction</a> (<font class="comment">/*@only@*/</font> programNodeList x, actionKind k)<font class="keyword"></font>
01015 <font class="keyword"></font>{
01016   programNode n = (programNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01017   n-&gt;wrapped = 0;
01018   n-&gt;kind = k;
01019   n-&gt;content.args = x;
01020   <font class="keywordflow">return</font> (n);
01021 }
01022 
01023 <font class="comment">/*@only@*/</font> programNode
<a name="l01024"></a><a class="code" href="abstract_c.html#a80">01024</a> <a class="code" href="abstract_c.html#a80">makeProgramNode</a> (<font class="comment">/*@only@*/</font> stmtNode x)<font class="keyword"></font>
01025 <font class="keyword"></font>{
01026   programNode n = (programNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01027 
01028   n-&gt;wrapped = 0;
01029   n-&gt;kind = ACT_SELF;
01030   n-&gt;content.self = x;
01031   <font class="keywordflow">return</font> (n);
01032 }
01033 
01034 <font class="comment">/*@only@*/</font> typeNode
<a name="l01035"></a><a class="code" href="abstract_c.html#a81">01035</a> <a class="code" href="abstract_c.html#a81">makeAbstractTypeNode</a> (<font class="comment">/*@only@*/</font> abstractNode x)<font class="keyword"></font>
01036 <font class="keyword"></font>{
01037   typeNode n = (typeNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01038   
01039   n-&gt;kind = TK_ABSTRACT;
01040   n-&gt;content.abstract = x;
01041   
01042     <font class="keywordflow">return</font> (n);
01043 }
01044 
01045 <font class="comment">/*@only@*/</font> typeNode
<a name="l01046"></a><a class="code" href="abstract_c.html#a82">01046</a> <a class="code" href="abstract_c.html#a82">makeExposedTypeNode</a> (<font class="comment">/*@only@*/</font> exposedNode x)<font class="keyword"></font>
01047 <font class="keyword"></font>{
01048   typeNode n = (typeNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01049 
01050   n-&gt;kind = TK_EXPOSED;
01051   n-&gt;content.exposed = x;
01052   <font class="keywordflow">return</font> (n);
01053 }
01054 
01055 <font class="comment">/*</font>
01056 <font class="comment">** evs added 8 Sept 1993</font>
01057 <font class="comment">*/</font>
01058 
01059 <font class="comment">/*@only@*/</font> importNode
<a name="l01060"></a><a class="code" href="abstract_c.html#a83">01060</a> <a class="code" href="abstract_c.html#a83">importNode_makePlain</a> (<font class="comment">/*@only@*/</font> ltoken t)<font class="keyword"></font>
01061 <font class="keyword"></font>{
01062   importNode imp = (importNode) dmalloc (<font class="keyword">sizeof</font> (*imp));
01063 
01064   imp-&gt;kind = IMPPLAIN;
01065   imp-&gt;val = t;
01066   <font class="keywordflow">return</font> (imp);
01067 }
01068 
01069 <font class="comment">/*@only@*/</font> importNode
<a name="l01070"></a><a class="code" href="abstract_c.html#a84">01070</a> <a class="code" href="abstract_c.html#a84">importNode_makeBracketed</a> (<font class="comment">/*@only@*/</font> ltoken t)<font class="keyword"></font>
01071 <font class="keyword"></font>{
01072   importNode imp = (importNode) dmalloc (<font class="keyword">sizeof</font> (*imp));
01073 
01074   imp-&gt;kind = IMPBRACKET;
01075   imp-&gt;val = t;
01076   <font class="keywordflow">return</font> (imp);
01077 }
01078 
01079 <font class="keyword">static</font> cstring extractQuote (<font class="comment">/*@only@*/</font> cstring s)<font class="keyword"></font>
01080 <font class="keyword"></font>{
01081   <font class="keywordtype">int</font> len = <a class="code" href="cstring_c.html#a30">cstring_length</a> (s);
01082   <font class="keywordtype">char</font> *sc = <a class="code" href="cstring_c.html#a29">cstring_toCharsSafe</a> (s);
01083   cstring t;
01084 
01085   llassert (len &gt; 1);
01086   *(sc + len - 1) = <font class="charliteral">'\0'</font>;
01087   t = <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (mstring_copy (sc + 1));
01088   <a class="code" href="cstring_c.html#a27">cstring_free</a> (s);
01089   <font class="keywordflow">return</font> (t);
01090 }
01091 
01092 <font class="comment">/*@only@*/</font> importNode
<a name="l01093"></a><a class="code" href="abstract_c.html#a86">01093</a> <a class="code" href="abstract_c.html#a86">importNode_makeQuoted</a> (<font class="comment">/*@only@*/</font> ltoken t)<font class="keyword"></font>
01094 <font class="keyword"></font>{
01095   importNode imp = (importNode) dmalloc (<font class="keyword">sizeof</font> (*imp));
01096   cstring q = extractQuote (cstring_copy (ltoken_getRawString (t)));
01097 
01098   imp-&gt;kind = IMPQUOTE;
01099 
01100   ltoken_setRawText (t, lsymbol_fromChars (cstring_toCharsSafe (q)));
01101 
01102   imp-&gt;val = t;  
01103 
01104   <a class="code" href="cstring_c.html#a27">cstring_free</a> (q);
01105   <font class="keywordflow">return</font> (imp);
01106 }
01107 
01108 <font class="comment">/*</font>
01109 <font class="comment">** check that is it '&lt;' and '&gt;'</font>
01110 <font class="comment">** should probably be in a different file?</font>
01111 <font class="comment">*/</font>
01112 
01113 <font class="keyword">static</font> <font class="keywordtype">void</font> cylerror (<font class="comment">/*@only@*/</font> <font class="keywordtype">char</font> *s)<font class="keyword"></font>
01114 <font class="keyword"></font>{
01115   <a class="code" href="llgrammar_tab_c.html#a169">ylerror</a>(s);
01116   <a class="code" href="general_c.html#a0">sfree</a> (s);
01117 }
01118 
01119 <font class="keywordtype">void</font>
<a name="l01120"></a><a class="code" href="abstract_c.html#a88">01120</a> <a class="code" href="abstract_c.html#a88">checkBrackets</a> (ltoken lb, ltoken rb)<font class="keyword"></font>
01121 <font class="keyword"></font>{
01122   <font class="comment">/* no attempt at error recovery...not really necessary */</font>
01123   cstring tname;
01124 
01125   tname = ltoken_getRawString (lb);
01126 
01127   <font class="keywordflow">if</font> (!cstring_equalLit (tname, <font class="stringliteral">"&lt;"</font>))
01128     {
01129       cylerror (cstring_toCharsSafeO (message (<font class="stringliteral">"Invalid import token: %s"</font>, tname)));
01130     }
01131 
01132   tname = ltoken_getRawString (rb);
01133 
01134   <font class="keywordflow">if</font> (!cstring_equalLit (tname, <font class="stringliteral">"&gt;"</font>))
01135     {
01136       cylerror (cstring_toCharsSafeO (message (<font class="stringliteral">"Invalid import token: %s"</font>, tname)));
01137     }
01138 }
01139 
01140 <font class="comment">/*@only@*/</font> traitRefNode
<a name="l01141"></a><a class="code" href="abstract_c.html#a89">01141</a> <a class="code" href="abstract_c.html#a89">makeTraitRefNode</a> (<font class="comment">/*@only@*/</font> ltokenList fl, <font class="comment">/*@only@*/</font> renamingNode r)<font class="keyword"></font>
01142 <font class="keyword"></font>{
01143   traitRefNode n = (traitRefNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01144 
01145   n-&gt;traitid = fl;
01146   n-&gt;rename = r;
01147   <font class="keywordflow">return</font> (n);
01148 }
01149 
01150 <font class="comment">/*</font>
01151 <font class="comment">** printLeaves: no commas</font>
01152 <font class="comment">*/</font>
01153 
01154 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
01155 printLeaves (ltokenList f)<font class="keyword"></font>
01156 <font class="keyword"></font>{
01157   <font class="keywordtype">bool</font> firstone = TRUE;
01158   cstring s = cstring_undefined;
01159 
01160   ltokenList_elements (f, i)<font class="keyword"></font>
01161 <font class="keyword">  </font>{
01162     <font class="keywordflow">if</font> (firstone)
01163       {
01164         s = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_unparse (i));
01165         firstone = FALSE;
01166       }
01167     <font class="keywordflow">else</font>
01168       {
01169         s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %s"</font>, s, ltoken_unparse (i));
01170       }
01171   } end_ltokenList_elements;
01172 
01173   <font class="keywordflow">return</font> s;
01174 }
01175 
01176 
01177 <font class="comment">/*@only@*/</font> cstring
<a name="l01178"></a><a class="code" href="abstract_c.html#a91">01178</a> <a class="code" href="abstract_c.html#a91">printLeaves2</a> (ltokenList f)<font class="keyword"></font>
01179 <font class="keyword"></font>{
01180   <font class="keywordflow">return</font> (<a class="code" href="ltokenList_c.html#a13">ltokenList_unparse</a> (f));
01181 }
01182 
01183 <font class="comment">/*@only@*/</font> cstring
<a name="l01184"></a><a class="code" href="abstract_c.html#a92">01184</a> <a class="code" href="abstract_c.html#a92">printRawLeaves2</a> (ltokenList f)<font class="keyword"></font>
01185 <font class="keyword"></font>{
01186   <font class="keywordtype">bool</font> first = TRUE;
01187   cstring s = cstring_undefined;
01188 
01189   ltokenList_elements (f, i)<font class="keyword"></font>
01190 <font class="keyword">  </font>{
01191     <font class="keywordflow">if</font> (first)
01192       {
01193         s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s"</font>, ltoken_getRawString (i));
01194         first = FALSE;
01195       }
01196     <font class="keywordflow">else</font>
01197       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q, %s"</font>, s, ltoken_getRawString (i));
01198   } end_ltokenList_elements;
01199 
01200   <font class="keywordflow">return</font> s;
01201 }
01202 
01203 <font class="comment">/*@only@*/</font> renamingNode
<a name="l01204"></a><a class="code" href="abstract_c.html#a93">01204</a> <a class="code" href="abstract_c.html#a93">makeRenamingNode</a> (<font class="comment">/*@only@*/</font> typeNameNodeList n, <font class="comment">/*@only@*/</font> replaceNodeList r)<font class="keyword"></font>
01205 <font class="keyword"></font>{
01206    renamingNode ren = (renamingNode) dmalloc (<font class="keyword">sizeof</font> (*ren));
01207 
01208   <font class="keywordflow">if</font> (typeNameNodeList_empty (n))
01209     {
01210       ren-&gt;is_replace = TRUE;
01211       ren-&gt;content.replace = r;
01212       <a class="code" href="typeNameNodeList_c.html#a4">typeNameNodeList_free</a> (n);
01213     }
01214   <font class="keywordflow">else</font>
01215     {
01216       nameAndReplaceNode nr = (nameAndReplaceNode) dmalloc (<font class="keyword">sizeof</font> (*nr));
01217       nr-&gt;replacelist = r;
01218       nr-&gt;namelist = n;
01219       ren-&gt;is_replace = FALSE;
01220       ren-&gt;content.name = nr;
01221     }
01222 
01223   <font class="keywordflow">return</font> (ren);
01224 }
01225 
01226 <font class="comment">/*@only@*/</font> cstring
<a name="l01227"></a><a class="code" href="abstract_c.html#a94">01227</a> <a class="code" href="abstract_c.html#a94">renamingNode_unparse</a> (<font class="comment">/*@null@*/</font> renamingNode x)<font class="keyword"></font>
01228 <font class="keyword"></font>{
01229   <font class="keywordflow">if</font> (x != (renamingNode) 0)
01230     {
01231       <font class="keywordflow">if</font> (x-&gt;is_replace)
01232         {
01233           <font class="keywordflow">return</font> (<a class="code" href="replaceNodeList_c.html#a3">replaceNodeList_unparse</a> (x-&gt;content.replace));
01234         }
01235       <font class="keywordflow">else</font>
01236         {
01237           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q"</font>, typeNameNodeList_unparse (x-&gt;content.name-&gt;namelist),
01238                    <a class="code" href="replaceNodeList_c.html#a3">replaceNodeList_unparse</a> (x-&gt;content.name-&gt;replacelist)));
01239         }
01240     }
01241   <font class="keywordflow">return</font> cstring_undefined;
01242 }
01243 
01244 <font class="comment">/*@only@*/</font> replaceNode
<a name="l01245"></a><a class="code" href="abstract_c.html#a95">01245</a> <a class="code" href="abstract_c.html#a95">makeReplaceNameNode</a> (ltoken t, typeNameNode tn, nameNode nn)<font class="keyword"></font>
01246 <font class="keyword"></font>{
01247   replaceNode r = (replaceNode) dmalloc (<font class="keyword">sizeof</font> (*r));
01248 
01249   r-&gt;tok = t;
01250   r-&gt;isCType = FALSE;
01251   r-&gt;typename = tn;
01252   r-&gt;content.renamesortname.name = nn;
01253   r-&gt;content.renamesortname.signature = (sigNode)NULL;
01254   
01255   <font class="keywordflow">return</font> (r);
01256 }
01257 
01258 <font class="comment">/*@only@*/</font> replaceNode
<a name="l01259"></a><a class="code" href="abstract_c.html#a96">01259</a> <a class="code" href="abstract_c.html#a96">makeReplaceNode</a> (ltoken t, typeNameNode tn,
01260                  <font class="keywordtype">bool</font> is_ctype, ltoken ct,
01261                  nameNode nn, sigNode sn)<font class="keyword"></font>
01262 <font class="keyword"></font>{
01263   replaceNode r = (replaceNode) dmalloc (<font class="keyword">sizeof</font> (*r));
01264   
01265   r-&gt;tok = t;
01266   r-&gt;isCType = is_ctype;
01267   r-&gt;typename = tn;
01268 
01269   <font class="keywordflow">if</font> (is_ctype)
01270     {
01271       r-&gt;content.ctype = ct;
01272       <a class="code" href="abstract_c.html#a234">sigNode_free</a> (sn);
01273       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (nn);
01274     }
01275   <font class="keywordflow">else</font>
01276     {
01277       r-&gt;content.renamesortname.name = nn;
01278       r-&gt;content.renamesortname.signature = sn;
01279       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (ct);
01280     }
01281 
01282   <font class="keywordflow">return</font> (r);
01283 }
01284 
01285 <font class="comment">/*@only@*/</font> cstring
<a name="l01286"></a><a class="code" href="abstract_c.html#a97">01286</a> <a class="code" href="abstract_c.html#a97">replaceNode_unparse</a> (<font class="comment">/*@null@*/</font> replaceNode x)<font class="keyword"></font>
01287 <font class="keyword"></font>{
01288   <font class="keywordflow">if</font> (x != (replaceNode) 0)
01289     {
01290       cstring st;
01291 
01292       st = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q for "</font>, typeNameNode_unparse (x-&gt;<font class="keyword">typename</font>));
01293 
01294       <font class="keywordflow">if</font> (x-&gt;isCType)
01295         {
01296           st = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, st, ltoken_getRawString (x-&gt;content.ctype));
01297         }
01298       <font class="keywordflow">else</font>
01299         {
01300           st = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q%q"</font>, st, nameNode_unparse (x-&gt;content.renamesortname.name),
01301                <a class="code" href="abstract_c.html#a102">sigNode_unparse</a> (x-&gt;content.renamesortname.signature));
01302         }
01303       <font class="keywordflow">return</font> st;
01304     }
01305   <font class="keywordflow">return</font> cstring_undefined;
01306 }
01307 
01308 <font class="comment">/*@only@*/</font> nameNode
<a name="l01309"></a><a class="code" href="abstract_c.html#a98">01309</a> <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> opFormNode opform)<font class="keyword"></font>
01310 <font class="keyword"></font>{
01311   nameNode nn = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*nn));
01312   
01313   nn-&gt;isOpId = FALSE;
01314   nn-&gt;content.opform = opform;
01315 
01316   <font class="keywordflow">return</font> (nn);
01317 }
01318 
01319 <font class="comment">/*@only@*/</font> nameNode
<a name="l01320"></a><a class="code" href="abstract_c.html#a99">01320</a> <a class="code" href="abstract_c.html#a99">makeNameNodeId</a> (<font class="comment">/*@only@*/</font> ltoken opid)<font class="keyword"></font>
01321 <font class="keyword"></font>{
01322   nameNode nn = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*nn));
01323   
01324   <font class="comment">/* </font>
01325 <font class="comment">  ** current LSL -syms output bug produces "if_then_else_" rather</font>
01326 <font class="comment">  ** than 6 separate tokens </font>
01327 <font class="comment">  */</font>
01328   
01329   <font class="keywordflow">if</font> (ltoken_getText (opid) == ConditionalSymbol)
01330     {
01331       opFormNode opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_IF, 
01332                                           opFormUnion_createMiddle (0),
01333                                           ltoken_undefined);
01334       nn-&gt;isOpId = FALSE;
01335       nn-&gt;content.opform = opform;
01336       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (opid);
01337     }
01338   <font class="keywordflow">else</font>
01339     {
01340       nn-&gt;isOpId = TRUE;
01341       nn-&gt;content.opid = opid;
01342     }
01343 
01344   <font class="keywordflow">return</font> (nn);
01345 }
01346 
01347 <font class="comment">/*@only@*/</font> cstring
<a name="l01348"></a><a class="code" href="abstract_c.html#a100">01348</a> <a class="code" href="abstract_c.html#a100">nameNode_unparse</a> (<font class="comment">/*@null@*/</font> nameNode n)<font class="keyword"></font>
01349 <font class="keyword"></font>{
01350   <font class="keywordflow">if</font> (n != (nameNode) 0)
01351     {
01352       <font class="keywordflow">if</font> (n-&gt;isOpId)
01353         {
01354           <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (n-&gt;content.opid))); 
01355         }
01356       <font class="keywordflow">else</font>
01357         {
01358           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a107">opFormNode_unparse</a> (n-&gt;content.opform));
01359         }
01360     }
01361   <font class="keywordflow">return</font> cstring_undefined;
01362 }
01363 
01364 <font class="comment">/*@only@*/</font> sigNode
<a name="l01365"></a><a class="code" href="abstract_c.html#a101">01365</a> <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken t, <font class="comment">/*@only@*/</font> ltokenList domain, ltoken range)<font class="keyword"></font>
01366 <font class="keyword"></font>{
01367   sigNode s = (sigNode) dmalloc (<font class="keyword">sizeof</font> (*s));
01368   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> key;
01369 
01370   <font class="comment">/*</font>
01371 <font class="comment">  ** Assign a hash key here to speed up lookup of operators.</font>
01372 <font class="comment">  */</font>
01373   
01374   s-&gt;tok = t;
01375   s-&gt;domain = domain;
01376   s-&gt;range = range;
01377   key = MASH (0, ltoken_getText (range));
01378   
01379   ltokenList_elements (domain, id)<font class="keyword"></font>
01380 <font class="keyword">    </font>{
01381       lsymbol sym = ltoken_getText (id);
01382       key = MASH (key, sym);
01383     } end_ltokenList_elements;
01384   
01385   s-&gt;key = key;
01386     <font class="keywordflow">return</font> (s);
01387 }
01388 
<a name="l01389"></a><a class="code" href="abstract_c.html#a102">01389</a> cstring <a class="code" href="abstract_c.html#a102">sigNode_unparse</a> (<font class="comment">/*@null@*/</font> sigNode n)<font class="keyword"></font>
01390 <font class="keyword"></font>{
01391   <font class="keywordflow">if</font> (n != (sigNode) 0)
01392     {
01393       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">":%q -&gt; %s"</font>, printLeaves2 (n-&gt;domain),
01394                        <a class="code" href="ltoken_c.html#a38">ltoken_unparse</a> (n-&gt;range)));
01395     }
01396 
01397   <font class="keywordflow">return</font> cstring_undefined;
01398 }
01399 
<a name="l01400"></a><a class="code" href="abstract_c.html#a103">01400</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a103">sigNode_markOwned</a> (sigNode n)<font class="keyword"></font>
01401 <font class="keyword"></font>{
01402     <a class="code" href="general_c.html#a1">sfreeEventually</a> (n);
01403 }
01404 
01405 <font class="comment">/*@only@*/</font> cstring
<a name="l01406"></a><a class="code" href="abstract_c.html#a104">01406</a> <a class="code" href="abstract_c.html#a104">sigNode_unparseText</a> (<font class="comment">/*@null@*/</font> sigNode n)<font class="keyword"></font>
01407 <font class="keyword"></font>{
01408   <font class="keywordflow">if</font> (n != (sigNode) 0)
01409     {
01410       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q -&gt; %s"</font>, printLeaves2 (n-&gt;domain), 
01411                        <a class="code" href="ltoken_c.html#a38">ltoken_unparse</a> (n-&gt;range)));
01412     }
01413   <font class="keywordflow">return</font> cstring_undefined;
01414 }
01415 
01416 <font class="keyword">static</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>
01417   opFormNode2key (opFormNode op, opFormKind k)<font class="keyword"></font>
01418 <font class="keyword"></font>{
01419   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> key;
01420 
01421   <font class="keywordflow">switch</font> (k)
01422     {
01423     <font class="keywordflow">case</font> OPF_IF:
01424       <font class="comment">/* OPF_IF is the first enum, so it's 0 */</font>
01425 
01426       <font class="comment">/*@-type@*/</font> 
01427       key = MASH (k, k + 1);
01428       <font class="comment">/*@=type@*/</font>
01429       
01430       <font class="keywordflow">break</font>;
01431     <font class="keywordflow">case</font> OPF_ANYOP:
01432     <font class="keywordflow">case</font> OPF_MANYOP:
01433     <font class="keywordflow">case</font> OPF_ANYOPM:
01434     <font class="keywordflow">case</font> OPF_MANYOPM:
01435       {                         <font class="comment">/* treat eq and = the same */</font>
01436         lsymbol sym = ltoken_getText (op-&gt;content.anyop);
01437 
01438         <font class="keywordflow">if</font> (sym == equalSymbol)
01439           {                   
01440             key = MASH (k, eqSymbol);
01441           }
01442         <font class="keywordflow">else</font>
01443           {
01444             key = MASH (k, ltoken_getText (op-&gt;content.anyop));
01445           }
01446         <font class="keywordflow">break</font>;
01447       }
01448     <font class="keywordflow">case</font> OPF_MIDDLE:
01449     <font class="keywordflow">case</font> OPF_MMIDDLE:
01450     <font class="keywordflow">case</font> OPF_MIDDLEM:
01451     <font class="keywordflow">case</font> OPF_MMIDDLEM:
01452     <font class="keywordflow">case</font> OPF_BMIDDLE:
01453     <font class="keywordflow">case</font> OPF_BMMIDDLE:
01454     <font class="keywordflow">case</font> OPF_BMIDDLEM:
01455     <font class="keywordflow">case</font> OPF_BMMIDDLEM:
01456       key = MASH (k, op-&gt;content.middle);
01457       key = MASH (key, ltoken_getRawText (op-&gt;tok));
01458       <font class="keywordflow">break</font>;
01459     <font class="keywordflow">case</font> OPF_SELECT:
01460     <font class="keywordflow">case</font> OPF_MAP:
01461     <font class="keywordflow">case</font> OPF_MSELECT:
01462     <font class="keywordflow">case</font> OPF_MMAP:
01463       key = MASH (k, ltoken_getRawText (op-&gt;content.id));
01464       <font class="keywordflow">break</font>;
01465     <font class="keywordflow">default</font>:
01466       key = 0;
01467     }
01468 
01469   <font class="keywordflow">return</font> key;
01470 }
01471 
01472 <font class="comment">/*@only@*/</font> opFormNode
<a name="l01473"></a><a class="code" href="abstract_c.html#a106">01473</a> <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken t, opFormKind k, opFormUnion u,
01474                 ltoken close)<font class="keyword"></font>
01475 <font class="keyword"></font>{
01476   opFormNode n = (opFormNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01477   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> key = 0;
01478 
01479   <font class="comment">/*</font>
01480 <font class="comment">  ** Assign a hash key here to speed up lookup of operators.</font>
01481 <font class="comment">  */</font>
01482 
01483   n-&gt;tok = t;
01484   n-&gt;close = close;
01485   n-&gt;kind = k;
01486 
01487   
01488   <font class="keywordflow">switch</font> (k)
01489     {
01490     <font class="keywordflow">case</font> OPF_IF:
01491       n-&gt;content.middle = 0;
01492       <font class="comment">/* OPF_IF is the first enum, so it's 0 */</font>
01493       key = MASH <font class="comment">/*@+enumint@*/</font> (k, k + 1) <font class="comment">/*@=enumint@*/</font>;
01494       <font class="keywordflow">break</font>;
01495     <font class="keywordflow">case</font> OPF_ANYOP:
01496     <font class="keywordflow">case</font> OPF_MANYOP:
01497     <font class="keywordflow">case</font> OPF_ANYOPM:
01498     <font class="keywordflow">case</font> OPF_MANYOPM:
01499       {                         <font class="comment">/* treat eq and = the same */</font>
01500         lsymbol sym = ltoken_getText (u.anyop);
01501 
01502         <font class="keywordflow">if</font> (sym == equalSymbol)
01503           {             
01504             key = MASH (k, eqSymbol);
01505           }
01506         <font class="keywordflow">else</font>
01507           {
01508             key = MASH (k, ltoken_getText (u.anyop));
01509           }
01510 
01511         n-&gt;content = u;
01512         <font class="keywordflow">break</font>;
01513       }
01514     <font class="keywordflow">case</font> OPF_MIDDLE:
01515     <font class="keywordflow">case</font> OPF_MMIDDLE:
01516     <font class="keywordflow">case</font> OPF_MIDDLEM:
01517     <font class="keywordflow">case</font> OPF_MMIDDLEM:
01518     <font class="keywordflow">case</font> OPF_BMIDDLE:
01519     <font class="keywordflow">case</font> OPF_BMMIDDLE:
01520     <font class="keywordflow">case</font> OPF_BMIDDLEM:
01521     <font class="keywordflow">case</font> OPF_BMMIDDLEM:
01522       n-&gt;content = u;
01523       key = MASH (k, u.middle);
01524       key = MASH (key, ltoken_getRawText (t));
01525       <font class="keywordflow">break</font>;
01526     <font class="keywordflow">case</font> OPF_SELECT:
01527     <font class="keywordflow">case</font> OPF_MAP:
01528     <font class="keywordflow">case</font> OPF_MSELECT:
01529     <font class="keywordflow">case</font> OPF_MMAP:
01530       key = MASH (k, ltoken_getRawText (u.id));
01531       n-&gt;content = u;
01532       <font class="keywordflow">break</font>;
01533     <font class="keywordflow">default</font>:
01534       {
01535         llbug (message (<font class="stringliteral">"makeOpFormNode: unknown opFormKind: %d"</font>, (<font class="keywordtype">int</font>) k));
01536       }
01537     }
01538   n-&gt;key = key;
01539     <font class="keywordflow">return</font> (n);
01540 }
01541 
01542 <font class="keyword">static</font> cstring printMiddle (<font class="keywordtype">int</font> j)<font class="keyword"></font>
01543 <font class="keyword"></font>{
01544   <font class="keywordtype">int</font> i;
01545   <font class="keywordtype">char</font> *s = mstring_createEmpty ();
01546 
01547   <font class="keywordflow">for</font> (i = j; i &gt;= 1; i--)
01548     {
01549       s = <a class="code" href="general_c.html#a25">mstring_concatFree1</a> (s, <font class="stringliteral">"__"</font>);
01550 
01551       <font class="keywordflow">if</font> (i != 1)
01552         {
01553           s = <a class="code" href="general_c.html#a25">mstring_concatFree1</a> (s, <font class="stringliteral">", "</font>);
01554         }
01555     }
01556 
01557   <font class="keywordflow">return</font> cstring_fromCharsO (s);
01558 }
01559 
01560 <font class="comment">/*@only@*/</font> cstring
<a name="l01561"></a><a class="code" href="abstract_c.html#a107">01561</a> <a class="code" href="abstract_c.html#a107">opFormNode_unparse</a> (<font class="comment">/*@null@*/</font> opFormNode n)<font class="keyword"></font>
01562 <font class="keyword"></font>{
01563   <font class="keywordflow">if</font> (n != (opFormNode) 0)
01564     {
01565       <font class="keywordflow">switch</font> (n-&gt;kind)
01566         {
01567         <font class="keywordflow">case</font> OPF_IF:
01568           <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"if __ then __ else __ "</font>));
01569         <font class="keywordflow">case</font> OPF_ANYOP:
01570           <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (n-&gt;content.anyop)));
01571         <font class="keywordflow">case</font> OPF_MANYOP:
01572           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ %s"</font>, ltoken_getRawString (n-&gt;content.anyop)));
01573         <font class="keywordflow">case</font> OPF_ANYOPM:
01574           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s __ "</font>, ltoken_getRawString (n-&gt;content.anyop)));
01575         <font class="keywordflow">case</font> OPF_MANYOPM:
01576           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ %s __ "</font>, ltoken_getRawString (n-&gt;content.anyop)));
01577         <font class="keywordflow">case</font> OPF_MIDDLE:
01578           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q %s"</font>, 
01579                            ltoken_getRawString (n-&gt;tok),
01580                            printMiddle (n-&gt;content.middle),
01581                            ltoken_getRawString (n-&gt;close)));
01582         <font class="keywordflow">case</font> OPF_MMIDDLE:
01583           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ %s %q %s"</font>, 
01584                            ltoken_getRawString (n-&gt;tok),
01585                            printMiddle (n-&gt;content.middle),
01586                            ltoken_getRawString (n-&gt;close)));
01587         <font class="keywordflow">case</font> OPF_MIDDLEM:
01588           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %q %s __"</font>, 
01589                            ltoken_getRawString (n-&gt;tok),
01590                            printMiddle (n-&gt;content.middle), 
01591                            ltoken_getRawString (n-&gt;close)));
01592         <font class="keywordflow">case</font> OPF_MMIDDLEM:
01593           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ %s%q %s __"</font>, 
01594                            ltoken_getRawString (n-&gt;tok),
01595                            printMiddle (n-&gt;content.middle),
01596                            ltoken_getRawString (n-&gt;close)));
01597         <font class="keywordflow">case</font> OPF_BMIDDLE:
01598           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[%q]"</font>, printMiddle (n-&gt;content.middle)));
01599         <font class="keywordflow">case</font> OPF_BMMIDDLE:
01600           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ [%q]"</font>, printMiddle (n-&gt;content.middle)));
01601         <font class="keywordflow">case</font> OPF_BMIDDLEM:
01602           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[%q] __"</font>, printMiddle (n-&gt;content.middle)));
01603         <font class="keywordflow">case</font> OPF_BMMIDDLEM:
01604           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ [%q] __"</font>, printMiddle (n-&gt;content.middle)));
01605         <font class="keywordflow">case</font> OPF_SELECT:
01606           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">" \\select %s"</font>, ltoken_getRawString (n-&gt;content.id)));
01607         <font class="keywordflow">case</font> OPF_MAP:
01608           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">" \\field_arrow%s"</font>, ltoken_getRawString (n-&gt;content.id)));
01609         <font class="keywordflow">case</font> OPF_MSELECT:
01610           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ \\select %s"</font>, ltoken_getRawString (n-&gt;content.id)));
01611         <font class="keywordflow">case</font> OPF_MMAP:
01612           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ \\field_arrow %s"</font>, ltoken_getRawString (n-&gt;content.id)));
01613         <font class="keywordflow">default</font>:
01614           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"opFormNodeUnparse: unknown kind: %d"</font>,
01615                                (<font class="keywordtype">int</font>) n-&gt;kind));
01616         }
01617     }
01618   <font class="keywordflow">return</font> cstring_undefined;
01619 }
01620 
01621 <font class="comment">/*@only@*/</font> typeNameNode
<a name="l01622"></a><a class="code" href="abstract_c.html#a108">01622</a> <a class="code" href="abstract_c.html#a108">makeTypeNameNode</a> (<font class="keywordtype">bool</font> isObj, lclTypeSpecNode t, abstDeclaratorNode n)<font class="keyword"></font>
01623 <font class="keyword"></font>{
01624   typeNameNode tn = (typeNameNode) dmalloc (<font class="keyword">sizeof</font> (*tn));
01625   typeNamePack p = (typeNamePack) dmalloc (<font class="keyword">sizeof</font> (*p));
01626 
01627   tn-&gt;isTypeName = TRUE;
01628   p-&gt;isObj = isObj;
01629   p-&gt;type = t;
01630   p-&gt;abst = n;
01631   tn-&gt;opform = (opFormNode) 0;
01632   tn-&gt;typename = p;
01633   <font class="keywordflow">return</font> (tn);
01634 }
01635 
01636 <font class="comment">/*@only@*/</font> typeNameNode
<a name="l01637"></a><a class="code" href="abstract_c.html#a109">01637</a> <a class="code" href="abstract_c.html#a109">makeTypeNameNodeOp</a> (opFormNode n)<font class="keyword"></font>
01638 <font class="keyword"></font>{
01639   typeNameNode t = (typeNameNode) dmalloc (<font class="keyword">sizeof</font> (*t));
01640   t-&gt;typename = (typeNamePack) 0;
01641   t-&gt;opform = n;
01642   t-&gt;isTypeName = FALSE;
01643   <font class="keywordflow">return</font> (t);
01644 }
01645 
01646 <font class="comment">/*@only@*/</font> cstring
<a name="l01647"></a><a class="code" href="abstract_c.html#a110">01647</a> <a class="code" href="abstract_c.html#a110">typeNameNode_unparse</a> (<font class="comment">/*@null@*/</font> typeNameNode n)<font class="keyword"></font>
01648 <font class="keyword"></font>{
01649   <font class="keywordflow">if</font> (n != (typeNameNode) 0)
01650     {
01651       <font class="keywordflow">if</font> (n-&gt;isTypeName)
01652         {
01653           cstring st = cstring_undefined;
01654           typeNamePack p = n-&gt;typename;
01655 
01656           llassert (p != NULL);
01657 
01658           <font class="keywordflow">if</font> (p-&gt;isObj)
01659             st = cstring_makeLiteral (<font class="stringliteral">"obj "</font>);
01660 
01661           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q%q"</font>, st, lclTypeSpecNode_unparse (p-&gt;type),
01662                            abstDeclaratorNode_unparse (p-&gt;abst)));
01663 
01664         }
01665       <font class="keywordflow">else</font>
01666         <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a107">opFormNode_unparse</a> (n-&gt;opform));
01667     }
01668   <font class="keywordflow">return</font> cstring_undefined;
01669 }
01670 
01671 <font class="comment">/*@only@*/</font> lclTypeSpecNode
<a name="l01672"></a><a class="code" href="abstract_c.html#a111">01672</a> <a class="code" href="abstract_c.html#a111">makeLclTypeSpecNodeConj</a> (<font class="comment">/*@null@*/</font> lclTypeSpecNode a, <font class="comment">/*@null@*/</font> lclTypeSpecNode b)<font class="keyword"></font>
01673 <font class="keyword"></font>{
01674   lclTypeSpecNode n = (lclTypeSpecNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01675 
01676   n-&gt;kind = LTS_CONJ;
01677   n-&gt;pointers = 0;
01678   n-&gt;quals = <a class="code" href="qualList_c.html#a0">qualList_new</a> ();
01679   n-&gt;content.conj = (lclconj) dmalloc (<font class="keyword">sizeof</font> (*n-&gt;content.conj));
01680   n-&gt;content.conj-&gt;a = a;
01681   n-&gt;content.conj-&gt;b = b;
01682 
01683   <font class="keywordflow">return</font> (n);
01684 }
01685 
01686 <font class="comment">/*@only@*/</font> lclTypeSpecNode
<a name="l01687"></a><a class="code" href="abstract_c.html#a112">01687</a> <a class="code" href="abstract_c.html#a112">makeLclTypeSpecNodeType</a> (<font class="comment">/*@null@*/</font> CTypesNode x)<font class="keyword"></font>
01688 <font class="keyword"></font>{
01689   lclTypeSpecNode n = (lclTypeSpecNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01690 
01691   n-&gt;kind = LTS_TYPE;
01692   n-&gt;pointers = 0;
01693   n-&gt;content.type = x;
01694   n-&gt;quals = <a class="code" href="qualList_c.html#a0">qualList_new</a> ();
01695   <font class="keywordflow">return</font> (n);
01696 }
01697 
01698 <font class="comment">/*@only@*/</font> lclTypeSpecNode
<a name="l01699"></a><a class="code" href="abstract_c.html#a113">01699</a> <a class="code" href="abstract_c.html#a113">makeLclTypeSpecNodeSU</a> (<font class="comment">/*@null@*/</font> strOrUnionNode x)<font class="keyword"></font>
01700 <font class="keyword"></font>{
01701   lclTypeSpecNode n = (lclTypeSpecNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01702 
01703   n-&gt;kind = LTS_STRUCTUNION;
01704   n-&gt;pointers = 0;
01705   n-&gt;content.structorunion = x;
01706   n-&gt;quals = <a class="code" href="qualList_c.html#a0">qualList_new</a> ();
01707   <font class="keywordflow">return</font> (n);
01708 }
01709 
01710 <font class="comment">/*@only@*/</font> lclTypeSpecNode
<a name="l01711"></a><a class="code" href="abstract_c.html#a114">01711</a> <a class="code" href="abstract_c.html#a114">makeLclTypeSpecNodeEnum</a> (<font class="comment">/*@null@*/</font> enumSpecNode x)<font class="keyword"></font>
01712 <font class="keyword"></font>{
01713   lclTypeSpecNode n = (lclTypeSpecNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01714 
01715   n-&gt;quals = <a class="code" href="qualList_c.html#a0">qualList_new</a> ();
01716   n-&gt;kind = LTS_ENUM;
01717   n-&gt;pointers = 0;
01718   n-&gt;content.enumspec = x;
01719   <font class="keywordflow">return</font> (n);
01720 }
01721 
01722 lclTypeSpecNode
<a name="l01723"></a><a class="code" href="abstract_c.html#a115">01723</a> <a class="code" href="abstract_c.html#a115">lclTypeSpecNode_addQual</a> (lclTypeSpecNode n, qual q)<font class="keyword"></font>
01724 <font class="keyword"></font>{
01725   llassert (lclTypeSpecNode_isDefined (n));
01726   n-&gt;quals = <a class="code" href="qualList_c.html#a4">qualList_add</a> (n-&gt;quals, q);
01727   <font class="keywordflow">return</font> n;
01728 }
01729 
01730 <font class="comment">/*@only@*/</font> cstring
<a name="l01731"></a><a class="code" href="abstract_c.html#a116">01731</a> <a class="code" href="abstract_c.html#a116">lclTypeSpecNode_unparse</a> (<font class="comment">/*@null@*/</font> lclTypeSpecNode n)<font class="keyword"></font>
01732 <font class="keyword"></font>{
01733   <font class="keywordflow">if</font> (n != (lclTypeSpecNode) 0)
01734     {
01735       <font class="keywordflow">switch</font> (n-&gt;kind)
01736         {
01737         <font class="keywordflow">case</font> LTS_TYPE:
01738           llassert (n-&gt;content.type != NULL);
01739           <font class="keywordflow">return</font> (printLeaves (n-&gt;content.type-&gt;ctypes));
01740         <font class="keywordflow">case</font> LTS_STRUCTUNION:
01741           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a122">strOrUnionNode_unparse</a> (n-&gt;content.structorunion));
01742         <font class="keywordflow">case</font> LTS_ENUM:
01743           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a119">enumSpecNode_unparse</a> (n-&gt;content.enumspec));
01744         <font class="keywordflow">case</font> LTS_CONJ:
01745           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a116">lclTypeSpecNode_unparse</a> (n-&gt;content.conj-&gt;a));
01746         <font class="keywordflow">default</font>:
01747           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"lclTypeSpecNode_unparse: unknown lclTypeSpec kind: %d"</font>,
01748                                (<font class="keywordtype">int</font>) n-&gt;kind));
01749         }
01750     }
01751   <font class="keywordflow">return</font> cstring_undefined;
01752 }
01753 
01754 <font class="comment">/*@only@*/</font> enumSpecNode
<a name="l01755"></a><a class="code" href="abstract_c.html#a117">01755</a> <a class="code" href="abstract_c.html#a117">makeEnumSpecNode</a> (ltoken t, ltoken optTagId,
01756                   <font class="comment">/*@owned@*/</font> ltokenList enums)<font class="keyword"></font>
01757 <font class="keyword"></font>{
01758   enumSpecNode n = (enumSpecNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01759   tagInfo ti;
01760   smemberInfo *top = smemberInfo_undefined;
01761 
01762   n-&gt;tok = t;
01763   n-&gt;opttagid = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (optTagId);
01764     n-&gt;enums = enums;
01765 
01766   <font class="comment">/* generate sort for this LCL type */</font>
01767   n-&gt;sort = <a class="code" href="sort_c.html#a89">sort_makeEnum</a> (optTagId);
01768   
01769   <font class="keywordflow">if</font> (!ltoken_isUndefined (optTagId))
01770     {
01771       <font class="comment">/* First, check to see if tag is already defined */</font>
01772       ti = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, ltoken_getText (optTagId));
01773 
01774       <font class="keywordflow">if</font> (tagInfo_exists (ti))
01775         {
01776           <font class="keywordflow">if</font> (ti-&gt;kind == TAG_ENUM)
01777             {
01778               <font class="comment">/* 23 Sep 1995 --- had been noting here...is this right? */</font>
01779 
01780               ti-&gt;content.enums = enums;
01781               ti-&gt;sort = n-&gt;sort;
01782               ti-&gt;imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01783             }
01784           <font class="keywordflow">else</font>
01785             {
01786               <a class="code" href="llerror_c.html#a54">lclerror</a> (optTagId, 
01787                         message (<font class="stringliteral">"Tag %s previously defined as %q, redefined as enum"</font>,
01788                                  ltoken_getRawString (optTagId),        
01789                                  <a class="code" href="symtable_c.html#a64">tagKind_unparse</a> (ti-&gt;kind)));
01790               
01791               <font class="comment">/* evs --- shouldn't they be in different name spaces? */</font>
01792             }
01793 
01794           <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (optTagId);
01795         }
01796       <font class="keywordflow">else</font>
01797         {
01798           ti = (tagInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
01799 
01800           ti-&gt;kind = TAG_ENUM;
01801           ti-&gt;id = optTagId;
01802           ti-&gt;content.enums = enums;
01803           ti-&gt;sort = n-&gt;sort;
01804           ti-&gt;imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01805           <font class="comment">/* First, store tag info in symbol table */</font>
01806           (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a38">symtable_enterTag</a> (g_symtab, ti);
01807         }
01808     }
01809 
01810   <font class="comment">/* check that enumeration constants are unique */</font>
01811   
01812   <a class="code" href="ltokenList_c.html#a5">ltokenList_reset</a> (enums);
01813 
01814   <font class="keywordflow">while</font> (!<a class="code" href="ltokenList_c.html#a6">ltokenList_isFinished</a> (enums))
01815     {
01816       ltoken c = <a class="code" href="ltokenList_c.html#a12">ltokenList_current</a> (enums);
01817       smemberInfo *ei = (smemberInfo *) dmalloc (<font class="keyword">sizeof</font> (*ei));
01818 
01819       ei-&gt;name = ltoken_getText (c);
01820       ei-&gt;next = top;
01821       ei-&gt;sort = n-&gt;sort;
01822       top = ei;
01823       
01824       <font class="keywordflow">if</font> (!varInfo_exists (symtable_varInfo (g_symtab, ltoken_getText (c))))
01825         {                               <font class="comment">/* put info into symbol table */</font>
01826           varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
01827           
01828           vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (c);
01829           vi-&gt;kind = VRK_ENUM;
01830           vi-&gt;sort = n-&gt;sort;
01831           vi-&gt;export = TRUE;
01832 
01833           (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
01834           <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
01835         }
01836       <font class="keywordflow">else</font>
01837         {
01838           <a class="code" href="llerror_c.html#a54">lclerror</a> (c, message (<font class="stringliteral">"Enumerated value redeclared: %s"</font>, 
01839                                 ltoken_getRawString (c)));
01840           <a class="code" href="ltokenList_c.html#a11">ltokenList_removeCurrent</a> (enums);
01841         }
01842       <a class="code" href="ltokenList_c.html#a7">ltokenList_advance</a> (enums);
01843       <font class="comment">/*@-branchstate@*/</font>
01844     }
01845   <font class="comment">/*@=branchstate@*/</font>
01846   
01847   (<font class="keywordtype">void</font>) <a class="code" href="sort_c.html#a90">sort_updateEnum</a> (n-&gt;sort, top);
01848   <font class="keywordflow">return</font> (n);
01849 }
01850 
01851 <font class="comment">/*@only@*/</font> enumSpecNode
<a name="l01852"></a><a class="code" href="abstract_c.html#a118">01852</a> <a class="code" href="abstract_c.html#a118">makeEnumSpecNode2</a> (ltoken t, ltoken tagid)<font class="keyword"></font>
01853 <font class="keyword"></font>{
01854   <font class="comment">/* a reference, not a definition */</font>
01855   enumSpecNode n = (enumSpecNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01856   tagInfo ti = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, ltoken_getText (tagid));
01857   
01858   n-&gt;tok = t;
01859   n-&gt;opttagid = tagid;
01860   n-&gt;enums = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
01861   
01862   <font class="keywordflow">if</font> (tagInfo_exists (ti))
01863     {
01864       <font class="keywordflow">if</font> (ti-&gt;kind == TAG_ENUM)
01865         {
01866           n-&gt;sort = ti-&gt;sort;
01867         }
01868       <font class="keywordflow">else</font>
01869         {
01870           n-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
01871           <a class="code" href="llerror_c.html#a54">lclerror</a> (tagid, message (<font class="stringliteral">"Tag %s defined as %q, used as enum"</font>,
01872                                     ltoken_getRawString (tagid),
01873                                     <a class="code" href="symtable_c.html#a64">tagKind_unparse</a> (ti-&gt;kind)));
01874         }
01875     }
01876   <font class="keywordflow">else</font>
01877     {
01878       n-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
01879       <a class="code" href="llerror_c.html#a54">lclerror</a> (t, message (<font class="stringliteral">"Undefined type: enum %s"</font>, 
01880                             ltoken_getRawString (tagid)));
01881     }
01882 
01883   <font class="keywordflow">return</font> (n);
01884 }
01885 
01886 <font class="comment">/*@only@*/</font> cstring
<a name="l01887"></a><a class="code" href="abstract_c.html#a119">01887</a> <a class="code" href="abstract_c.html#a119">enumSpecNode_unparse</a> (<font class="comment">/*@null@*/</font> enumSpecNode n)<font class="keyword"></font>
01888 <font class="keyword"></font>{
01889   <font class="keywordflow">if</font> (n != (enumSpecNode) 0)
01890     {
01891       cstring s = cstring_makeLiteral (<font class="stringliteral">"enum "</font>);
01892 
01893       <font class="keywordflow">if</font> (!ltoken_isUndefined (n-&gt;opttagid))
01894         {
01895           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s "</font>, s, ltoken_getRawString (n-&gt;opttagid));
01896         }
01897 
01898       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q{%q}"</font>, s, printLeaves2 (n-&gt;enums));
01899       <font class="keywordflow">return</font> s;
01900     }
01901   <font class="keywordflow">return</font> cstring_undefined;
01902 }
01903 
01904 <font class="comment">/*@only@*/</font> strOrUnionNode
<a name="l01905"></a><a class="code" href="abstract_c.html#a120">01905</a> <a class="code" href="abstract_c.html#a120">makestrOrUnionNode</a> (ltoken str, suKind k, ltoken opttagid,
01906                        <font class="comment">/*@only@*/</font> stDeclNodeList x)<font class="keyword"></font>
01907 <font class="keyword"></font>{
01908   strOrUnionNode n = (strOrUnionNode) dmalloc (<font class="keyword">sizeof</font> (*n));
01909   lsymbolSet set = <a class="code" href="lsymbolSet_c.html#a0">lsymbolSet_new</a> ();
01910   declaratorNodeList declarators;
01911   sort fieldsort, tsort1, tsort2;
01912   smemberInfo *mi, *top = smemberInfo_undefined;
01913   <font class="keywordtype">bool</font> doTag = FALSE;
01914   <font class="keywordtype">bool</font> isStruct = (k == SU_STRUCT);
01915   tagInfo t;
01916 
01917   
01918   n-&gt;kind = k;
01919   n-&gt;tok = str;
01920   n-&gt;opttagid = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (opttagid);
01921   n-&gt;structdecls = x;
01922   n-&gt;sort = isStruct ? <a class="code" href="sort_c.html#a83">sort_makeStr</a> (opttagid) : <a class="code" href="sort_c.html#a86">sort_makeUnion</a> (opttagid);
01923 
01924   <font class="keywordflow">if</font> (!ltoken_isUndefined (opttagid))
01925     {
01926       <font class="comment">/* First, check to see if tag is already defined */</font>
01927       t = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, ltoken_getText (opttagid));
01928 
01929       <font class="keywordflow">if</font> (tagInfo_exists (t))
01930         {
01931           <font class="keywordflow">if</font> ((t-&gt;kind == TAG_FWDUNION &amp;&amp; k == SU_UNION) ||
01932               (t-&gt;kind == TAG_FWDSTRUCT &amp;&amp; k == SU_STRUCT))
01933             {
01934               <font class="comment">/* to allow self-recursive types and forward tag declarations */</font>
01935               t-&gt;content.decls = <a class="code" href="stDeclNodeList_c.html#a3">stDeclNodeList_copy</a> (x); <font class="comment">/* update tag info */</font>
01936               t-&gt;sort = n-&gt;sort;
01937             }
01938           <font class="keywordflow">else</font>
01939             {
01940               <a class="code" href="llerror_c.html#a54">lclerror</a> (opttagid, 
01941                         message (<font class="stringliteral">"Tag %s previously defined as %q, used as %q"</font>,
01942                                  ltoken_getRawString (opttagid),
01943                                  <a class="code" href="symtable_c.html#a64">tagKind_unparse</a> (t-&gt;kind),
01944                                  cstring_makeLiteral (isStruct ? <font class="stringliteral">"struct"</font> : <font class="stringliteral">"union"</font>)));
01945             }
01946         }
01947       <font class="keywordflow">else</font>
01948         {
01949           doTag = TRUE;
01950         }
01951     }
01952   <font class="keywordflow">else</font>
01953     {
01954       doTag = TRUE;
01955     }
01956   
01957   <font class="keywordflow">if</font> (doTag &amp;&amp; !ltoken_isUndefined (opttagid))
01958     {
01959       t = (tagInfo) dmalloc (<font class="keyword">sizeof</font> (*t));
01960 
01961       <font class="comment">/* can either override prev defn or use prev defn */</font>
01962       <font class="comment">/* override it so as to detect more errors */</font>
01963 
01964       t-&gt;kind = (k == SU_STRUCT) ? TAG_STRUCT : TAG_UNION;
01965       t-&gt;id = opttagid;
01966       t-&gt;content.decls = <a class="code" href="stDeclNodeList_c.html#a3">stDeclNodeList_copy</a> (x);
01967       t-&gt;sort = n-&gt;sort;
01968       t-&gt;imported = FALSE;
01969 
01970             <font class="comment">/* Next, update tag info in symbol table */</font>
01971       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a39">symtable_enterTagForce</a> (g_symtab, t);
01972     }
01973   
01974   <font class="comment">/* check no duplicate field names */</font>
01975   
01976   stDeclNodeList_elements (x, i)<font class="keyword"></font>
01977 <font class="keyword">    </font>{
01978       fieldsort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (i-&gt;lcltypespec);
01979       
01980       <font class="comment">/* need the locations, not values */</font>
01981       <font class="comment">/*  fieldsort = sort_makeObj (fieldsort); */</font>
01982       <font class="comment">/* 2/19/93, was</font>
01983 <font class="comment">         fieldsort = sort_makeGlobal (fieldsort); */</font>
01984       
01985       declarators = i-&gt;declarators;
01986       
01987       declaratorNodeList_elements (declarators, decl)<font class="keyword"></font>
01988 <font class="keyword">        </font>{
01989           lsymbol fieldname;
01990           mi = (smemberInfo *) dmalloc (<font class="keyword">sizeof</font> (*mi));
01991           <font class="comment">/* need to make dynamic copies */</font>
01992           fieldname = ltoken_getText (decl-&gt;id);
01993           
01994           <font class="comment">/* 2/19/93, added */</font>
01995           tsort1 = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (fieldsort, decl-&gt;type);
01996           tsort2 = <a class="code" href="sort_c.html#a74">sort_makeGlobal</a> (tsort1);
01997           
01998           mi-&gt;name = fieldname;
01999           mi-&gt;sort = tsort2;    <font class="comment">/* fieldsort; */</font>
02000           mi-&gt;next = top;
02001           top = mi;
02002           
02003           <font class="keywordflow">if</font> (<a class="code" href="lsymbolSet_c.html#a3">lsymbolSet_member</a> (set, fieldname))
02004             {
02005               <a class="code" href="llerror_c.html#a54">lclerror</a> (decl-&gt;id,
02006                         message (<font class="stringliteral">"Field name reused: %s"</font>, 
02007                                  ltoken_getRawString (decl-&gt;id)));
02008             }
02009           <font class="keywordflow">else</font>
02010             {
02011               (<font class="keywordtype">void</font>) <a class="code" href="lsymbolSet_c.html#a2">lsymbolSet_insert</a> (set, fieldname);
02012             }
02013           <font class="comment">/*@-branchstate@*/</font> 
02014         } end_declaratorNodeList_elements; 
02015       <font class="comment">/*@=branchstate@*/</font>
02016     } end_stDeclNodeList_elements;
02017   
02018   <font class="keywordflow">if</font> (k == SU_STRUCT)
02019     {
02020       (<font class="keywordtype">void</font>) <a class="code" href="sort_c.html#a84">sort_updateStr</a> (n-&gt;sort, top);
02021     }
02022   <font class="keywordflow">else</font>
02023     {
02024       (<font class="keywordtype">void</font>) <a class="code" href="sort_c.html#a87">sort_updateUnion</a> (n-&gt;sort, top);
02025     }
02026 
02027   <font class="comment">/* We shall keep the info with both tags and types if any</font>
02028 <font class="comment">     of them are present. */</font>
02029   
02030   <a class="code" href="lsymbolSet_c.html#a5">lsymbolSet_free</a> (set);
02031 
02032     <font class="keywordflow">return</font> (n);
02033 }
02034 
02035 <font class="comment">/*@only@*/</font> strOrUnionNode
<a name="l02036"></a><a class="code" href="abstract_c.html#a121">02036</a> <a class="code" href="abstract_c.html#a121">makeForwardstrOrUnionNode</a> (ltoken str, suKind k,
02037                         ltoken tagid)<font class="keyword"></font>
02038 <font class="keyword"></font>{
02039   strOrUnionNode n = (strOrUnionNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02040   sort sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
02041   tagInfo t;
02042 
02043   <font class="comment">/* a reference, not a definition */</font>
02044   
02045   n-&gt;kind = k;
02046   n-&gt;tok = str;
02047   n-&gt;opttagid = tagid;
02048   n-&gt;structdecls = <a class="code" href="stDeclNodeList_c.html#a0">stDeclNodeList_new</a> ();
02049   
02050   <font class="comment">/* get sort for this LCL type */</font>
02051   t = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, ltoken_getText (tagid));
02052 
02053   <font class="keywordflow">if</font> (tagInfo_exists (t))
02054     {
02055       sort = t-&gt;sort;
02056       
02057       <font class="keywordflow">if</font> (!(((t-&gt;kind == TAG_STRUCT || t-&gt;kind == TAG_FWDSTRUCT) &amp;&amp; k == SU_STRUCT) 
02058             || ((t-&gt;kind == TAG_UNION || t-&gt;kind == TAG_FWDUNION) &amp;&amp; k == SU_UNION)))
02059         {
02060           <a class="code" href="llerror_c.html#a54">lclerror</a> (tagid, 
02061                     message (<font class="stringliteral">"Tag %s previously defined as %q, used as %q"</font>,
02062                              ltoken_getRawString (tagid),
02063                              <a class="code" href="symtable_c.html#a64">tagKind_unparse</a> (t-&gt;kind),
02064                              cstring_makeLiteral ((k == SU_STRUCT) ? <font class="stringliteral">"struct"</font> : <font class="stringliteral">"union"</font>)));
02065         }
02066     }
02067   <font class="keywordflow">else</font>
02068     {
02069       <font class="comment">/*</font>
02070 <font class="comment">      ** changed from error: 31 Mar 1994</font>
02071 <font class="comment">      **</font>
02072 <font class="comment">      ** lclerror (str, message ("Undefined type: %s %s", s, ltoken_getRawString (tagid));</font>
02073 <font class="comment">      **</font>
02074 <font class="comment">      */</font>
02075 
02076       <font class="comment">/* forward struct's and union's are ok... */</font>
02077 
02078       <font class="keywordflow">if</font> (k == SU_STRUCT)
02079         {
02080           (<font class="keywordtype">void</font>) <a class="code" href="abstract_c.html#a218">checkAndEnterTag</a> (TAG_FWDSTRUCT, ltoken_copy (tagid));
02081           <a class="code" href="lh_c.html#a12">lhForwardStruct</a> (tagid);
02082           sort = <a class="code" href="sort_c.html#a83">sort_makeStr</a> (tagid);
02083         }
02084       <font class="keywordflow">else</font>
02085         {
02086           (<font class="keywordtype">void</font>) <a class="code" href="abstract_c.html#a218">checkAndEnterTag</a> (TAG_FWDUNION, ltoken_copy (tagid));
02087           <a class="code" href="lh_c.html#a13">lhForwardUnion</a> (tagid);
02088           sort = <a class="code" href="sort_c.html#a86">sort_makeUnion</a> (tagid);
02089         }
02090     }
02091   
02092   n-&gt;sort = sort;
02093   <font class="keywordflow">return</font> (n);
02094 }
02095 
02096 <font class="comment">/*@only@*/</font> cstring
<a name="l02097"></a><a class="code" href="abstract_c.html#a122">02097</a> <a class="code" href="abstract_c.html#a122">strOrUnionNode_unparse</a> (<font class="comment">/*@null@*/</font> strOrUnionNode n)<font class="keyword"></font>
02098 <font class="keyword"></font>{
02099   <font class="keywordflow">if</font> (n != (strOrUnionNode) 0)
02100     {
02101       cstring s;
02102       <font class="keywordflow">switch</font> (n-&gt;kind)
02103         {
02104         <font class="keywordflow">case</font> SU_STRUCT:
02105           s = cstring_makeLiteral (<font class="stringliteral">"struct "</font>);
02106           <font class="keywordflow">break</font>;
02107         <font class="keywordflow">case</font> SU_UNION:
02108           s = cstring_makeLiteral (<font class="stringliteral">"union "</font>);
02109           <font class="keywordflow">break</font>;
02110         BADDEFAULT
02111         }
02112 
02113       <font class="keywordflow">if</font> (!ltoken_isUndefined (n-&gt;opttagid))
02114         {
02115           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s "</font>, s, ltoken_getRawString (n-&gt;opttagid));
02116         }
02117       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q{%q}"</font>, s, stDeclNodeList_unparse (n-&gt;structdecls));
02118       <font class="keywordflow">return</font> s;
02119     }
02120   <font class="keywordflow">return</font> cstring_undefined;
02121 }
02122 
02123 <font class="comment">/*@only@*/</font> stDeclNode
<a name="l02124"></a><a class="code" href="abstract_c.html#a123">02124</a> <a class="code" href="abstract_c.html#a123">makestDeclNode</a> (lclTypeSpecNode s,
02125                 declaratorNodeList x)<font class="keyword"></font>
02126 <font class="keyword"></font>{
02127   stDeclNode n = (stDeclNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02128 
02129   n-&gt;lcltypespec = s;
02130   n-&gt;declarators = x;
02131   <font class="keywordflow">return</font> n;
02132 }
02133 
02134 <font class="comment">/*@only@*/</font> typeExpr
<a name="l02135"></a><a class="code" href="abstract_c.html#a124">02135</a> <a class="code" href="abstract_c.html#a124">makeFunctionNode</a> (typeExpr x, paramNodeList p)<font class="keyword"></font>
02136 <font class="keyword"></font>{
02137   typeExpr y = (typeExpr) dmalloc (<font class="keyword">sizeof</font> (*y));
02138 
02139   y-&gt;wrapped = 0;
02140   y-&gt;kind = TEXPR_FCN;
02141   y-&gt;content.function.returntype = x;
02142   y-&gt;content.function.args = p;
02143   y-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
02144 
02145   <font class="keywordflow">return</font> (y);
02146 }
02147 
02148 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> ltoken
02149   extractDeclarator (<font class="comment">/*@null@*/</font> typeExpr t)<font class="keyword"></font>
02150 <font class="keyword"></font>{
02151   <font class="keywordflow">if</font> (t != (typeExpr) 0)
02152     {
02153       <font class="keywordflow">switch</font> (t-&gt;kind)
02154         {
02155         <font class="keywordflow">case</font> TEXPR_BASE:
02156                   <font class="keywordflow">return</font> t-&gt;content.base;
02157         <font class="keywordflow">case</font> TEXPR_PTR:
02158           <font class="keywordflow">return</font> (extractDeclarator (t-&gt;content.pointer));
02159         <font class="keywordflow">case</font> TEXPR_ARRAY:
02160           <font class="keywordflow">return</font> (extractDeclarator (t-&gt;content.array.elementtype));
02161         <font class="keywordflow">case</font> TEXPR_FCN:
02162           <font class="keywordflow">return</font> (extractDeclarator (t-&gt;content.function.returntype));
02163         }
02164     }
02165 
02166   <font class="keywordflow">return</font> ltoken_undefined;
02167 }
02168 
02169 <font class="comment">/*@only@*/</font> typeExpr
<a name="l02170"></a><a class="code" href="abstract_c.html#a126">02170</a> <a class="code" href="abstract_c.html#a126">makeTypeExpr</a> (ltoken t)<font class="keyword"></font>
02171 <font class="keyword"></font>{
02172   typeExpr x = (typeExpr) dmalloc (<font class="keyword">sizeof</font> (*x));
02173   
02174   
02175   x-&gt;wrapped = 0;
02176   x-&gt;kind = TEXPR_BASE;
02177   x-&gt;content.base = t;
02178   x-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
02179 
02180   <font class="keywordflow">return</font> (x);
02181 }
02182 
02183 
02184 <font class="comment">/*@only@*/</font> declaratorNode
<a name="l02185"></a><a class="code" href="abstract_c.html#a127">02185</a> <a class="code" href="abstract_c.html#a127">makeDeclaratorNode</a> (typeExpr t)<font class="keyword"></font>
02186 <font class="keyword"></font>{
02187   declaratorNode x = (declaratorNode) dmalloc (<font class="keyword">sizeof</font> (*x));
02188   
02189   x-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (extractDeclarator (t));
02190   x-&gt;type = t;
02191   x-&gt;isRedecl = FALSE;
02192 
02193     <font class="keywordflow">return</font> (x);
02194 }
02195 
02196 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> declaratorNode
02197 makeUnknownDeclaratorNode (<font class="comment">/*@only@*/</font> ltoken t)<font class="keyword"></font>
02198 <font class="keyword"></font>{
02199   declaratorNode x = (declaratorNode) dmalloc (<font class="keyword">sizeof</font> (*x));
02200 
02201   x-&gt;id = t;
02202   x-&gt;type = (typeExpr) 0;
02203   x-&gt;isRedecl = FALSE;
02204 
02205   <font class="keywordflow">return</font> (x);
02206 }
02207 
02208 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring
02209 printTypeExpr2 (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02210 <font class="keyword"></font>{
02211   paramNodeList params;
02212 
02213   <font class="keywordflow">if</font> (x != (typeExpr) 0)
02214     {
02215       cstring s;                <font class="comment">/* print out types in reverse order */</font>
02216 
02217       <font class="keywordflow">switch</font> (x-&gt;kind)
02218         {
02219         <font class="keywordflow">case</font> TEXPR_BASE:
02220           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s "</font>, ltoken_getRawString (x-&gt;content.base)));
02221         <font class="keywordflow">case</font> TEXPR_PTR:
02222           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%qptr to "</font>, printTypeExpr2 (x-&gt;content.pointer)));
02223         <font class="keywordflow">case</font> TEXPR_ARRAY:
02224           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"array[%q] of %q"</font>,
02225                            termNode_unparse (x-&gt;content.array.size),
02226                            printTypeExpr2 (x-&gt;content.array.elementtype)));
02227         <font class="keywordflow">case</font> TEXPR_FCN:
02228           s = printTypeExpr2 (x-&gt;content.function.returntype);
02229           params = x-&gt;content.function.args;
02230           <font class="keywordflow">if</font> (!paramNodeList_empty (params))
02231             {
02232               s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%qfcn with args: (%q)"</font>, s,
02233                            paramNodeList_unparse (x-&gt;content.function.args));
02234             }
02235           <font class="keywordflow">else</font>
02236             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%qfcn with no args"</font>, s);
02237           <font class="keywordflow">return</font> s;
02238         <font class="keywordflow">default</font>:
02239           <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"printTypeExpr2: unknown typeExprKind: %d"</font>, (<font class="keywordtype">int</font>) x-&gt;kind));
02240         }
02241     }
02242   <font class="keywordflow">return</font> cstring_undefined;
02243 }
02244 
02245 <font class="comment">/*@only@*/</font> cstring
<a name="l02246"></a><a class="code" href="abstract_c.html#a130">02246</a> <a class="code" href="abstract_c.html#a130">declaratorNode_unparse</a> (declaratorNode x)<font class="keyword"></font>
02247 <font class="keyword"></font>{
02248   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a135">typeExpr_unparse</a> (x-&gt;type));
02249 }
02250 
02251 <font class="comment">/*@only@*/</font> declaratorNode
<a name="l02252"></a><a class="code" href="abstract_c.html#a131">02252</a>   <a class="code" href="abstract_c.html#a131">declaratorNode_copy</a> (declaratorNode x)<font class="keyword"></font>
02253 <font class="keyword"></font>{
02254   declaratorNode ret = (declaratorNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
02255 
02256     ret-&gt;type = typeExpr_copy (x-&gt;type);
02257   ret-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (x-&gt;id);
02258   ret-&gt;isRedecl = x-&gt;isRedecl; 
02259 
02260     <font class="keywordflow">return</font> (ret);
02261 }
02262 
02263 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> typeExpr typeExpr_copy (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02264 <font class="keyword"></font>{
02265   <font class="keywordflow">if</font> (x == NULL)
02266     {
02267       <font class="keywordflow">return</font> NULL;
02268     }
02269   <font class="keywordflow">else</font>
02270     {
02271       typeExpr ret = (typeExpr) dmalloc (<font class="keyword">sizeof</font> (*ret));
02272       
02273       ret-&gt;wrapped = x-&gt;wrapped;
02274       ret-&gt;kind = x-&gt;kind;
02275 
02276       <font class="keywordflow">switch</font> (ret-&gt;kind)
02277         {
02278         <font class="keywordflow">case</font> TEXPR_BASE:     
02279           ret-&gt;content.base = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (x-&gt;content.base);
02280           <font class="keywordflow">break</font>;
02281         <font class="keywordflow">case</font> TEXPR_PTR:  
02282           ret-&gt;content.pointer = typeExpr_copy (x-&gt;content.pointer);
02283           <font class="keywordflow">break</font>;
02284         <font class="keywordflow">case</font> TEXPR_ARRAY:    
02285           ret-&gt;content.array.elementtype = typeExpr_copy (x-&gt;content.array.elementtype);
02286           ret-&gt;content.array.size = termNode_copy (x-&gt;content.array.size);
02287           <font class="keywordflow">break</font>;
02288         <font class="keywordflow">case</font> TEXPR_FCN:
02289           ret-&gt;content.function.returntype = typeExpr_copy (x-&gt;content.function.returntype);
02290           ret-&gt;content.function.args = <a class="code" href="paramNodeList_c.html#a4">paramNodeList_copy</a> (x-&gt;content.function.args);
02291           <font class="keywordflow">break</font>;
02292         }
02293 
02294       ret-&gt;sort = x-&gt;sort;
02295       <font class="keywordflow">return</font> ret;
02296     }
02297 }
02298 
02299 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> cstring 
02300   typeExpr_unparseCode (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02301 <font class="keyword"></font>{
02302   <font class="comment">/* print out types in order of appearance in source */</font>
02303   cstring s = cstring_undefined;
02304 
02305   <font class="keywordflow">if</font> (x != (typeExpr) 0)
02306     {
02307       <font class="keywordflow">switch</font> (x-&gt;kind)
02308         {
02309         <font class="keywordflow">case</font> TEXPR_BASE:
02310           <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (x-&gt;content.base)));
02311         <font class="keywordflow">case</font> TEXPR_PTR:
02312           <font class="keywordflow">return</font> (typeExpr_unparseCode (x-&gt;content.pointer));
02313         <font class="keywordflow">case</font> TEXPR_ARRAY:
02314           <font class="keywordflow">return</font> (typeExpr_unparseCode (x-&gt;content.array.elementtype));
02315         <font class="keywordflow">case</font> TEXPR_FCN:
02316           <font class="keywordflow">return</font> (typeExpr_unparseCode (x-&gt;content.function.returntype));
02317         }
02318     }
02319   <font class="keywordflow">return</font> s;
02320 }
02321 
<a name="l02322"></a><a class="code" href="abstract_c.html#a133">02322</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a133">typeExpr_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02323 <font class="keyword"></font>{
02324   <font class="keywordflow">if</font> (x != (typeExpr) 0)
02325     {
02326       <font class="keywordflow">switch</font> (x-&gt;kind)
02327         {
02328         <font class="keywordflow">case</font> TEXPR_BASE:
02329           <font class="keywordflow">break</font>;
02330         <font class="keywordflow">case</font> TEXPR_PTR:
02331           <a class="code" href="abstract_c.html#a133">typeExpr_free</a> (x-&gt;content.pointer);
02332           <font class="keywordflow">break</font>;
02333         <font class="keywordflow">case</font> TEXPR_ARRAY:
02334           <a class="code" href="abstract_c.html#a133">typeExpr_free</a> (x-&gt;content.array.elementtype);
02335           <a class="code" href="abstract_c.html#a243">termNode_free</a> (x-&gt;content.array.size);
02336           <font class="keywordflow">break</font>;
02337         <font class="keywordflow">case</font> TEXPR_FCN:
02338           <a class="code" href="abstract_c.html#a133">typeExpr_free</a> (x-&gt;content.function.returntype);
02339           <a class="code" href="paramNodeList_c.html#a7">paramNodeList_free</a> (x-&gt;content.function.args);
02340           <font class="keywordflow">break</font>;
02341           <font class="comment">/*@-branchstate@*/</font> 
02342         } 
02343       <font class="comment">/*@=branchstate@*/</font>
02344 
02345       <a class="code" href="general_c.html#a0">sfree</a> (x);
02346     }
02347 }
02348 
02349 
02350 <font class="comment">/*@only@*/</font> cstring
<a name="l02351"></a><a class="code" href="abstract_c.html#a134">02351</a> <a class="code" href="abstract_c.html#a134">declaratorNode_unparseCode</a> (declaratorNode x)<font class="keyword"></font>
02352 <font class="keyword"></font>{
02353   <font class="keywordflow">return</font> (typeExpr_unparseCode (x-&gt;type));
02354 }
02355 
02356 <font class="comment">/*@only@*/</font> cstring
<a name="l02357"></a><a class="code" href="abstract_c.html#a135">02357</a> <a class="code" href="abstract_c.html#a135">typeExpr_unparse</a> (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02358 <font class="keyword"></font>{
02359   cstring s = cstring_undefined; <font class="comment">/* print out types in order of appearance in source */</font>
02360   paramNodeList params;
02361   <font class="keywordtype">int</font> i;
02362 
02363   <font class="keywordflow">if</font> (x != (typeExpr) 0)
02364     {
02365       cstring front = cstring_undefined;
02366       cstring back  = cstring_undefined;
02367 
02368       llassert (x-&gt;wrapped &lt; 100);
02369 
02370       <font class="keywordflow">for</font> (i = x-&gt;wrapped; i &gt;= 1; i--)
02371         {
02372           front = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (front, <font class="charliteral">'('</font>);
02373           back = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (back, <font class="charliteral">')'</font>);
02374         }
02375       
02376       <font class="keywordflow">switch</font> (x-&gt;kind)
02377         {
02378         <font class="keywordflow">case</font> TEXPR_BASE:
02379           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, ltoken_getRawString (x-&gt;content.base));
02380           <font class="keywordflow">break</font>;
02381         <font class="keywordflow">case</font> TEXPR_PTR:
02382           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q*%q"</font>, s, typeExpr_unparse (x-&gt;content.pointer));
02383           <font class="keywordflow">break</font>;
02384         <font class="keywordflow">case</font> TEXPR_ARRAY:
02385           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q[%q]"</font>, s, 
02386                        typeExpr_unparse (x-&gt;content.array.elementtype),
02387                        <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (x-&gt;content.array.size));
02388           <font class="keywordflow">break</font>;
02389         <font class="keywordflow">case</font> TEXPR_FCN:
02390           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q ("</font>, s, 
02391                        typeExpr_unparse (x-&gt;content.function.returntype));
02392           params = x-&gt;content.function.args;
02393 
02394           <font class="keywordflow">if</font> (!paramNodeList_empty (params))
02395             {
02396               s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q"</font>, s, 
02397                            paramNodeList_unparse (x-&gt;content.function.args));
02398             }
02399 
02400           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q)"</font>, s);
02401           <font class="keywordflow">break</font>;
02402         }
02403       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q%q"</font>, front, s, back);
02404     }
02405   <font class="keywordflow">else</font>
02406     {
02407       s = cstring_makeLiteral (<font class="stringliteral">"?"</font>);
02408     }
02409 
02410   <font class="keywordflow">return</font> s;
02411 }
02412 
02413 <font class="comment">/*@only@*/</font> cstring
<a name="l02414"></a><a class="code" href="abstract_c.html#a136">02414</a> <a class="code" href="abstract_c.html#a136">typeExpr_unparseNoBase</a> (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02415 <font class="keyword"></font>{
02416   cstring s = cstring_undefined; <font class="comment">/* print out types in order of appearance in source */</font>
02417   paramNodeList params;
02418   <font class="keywordtype">int</font> i;
02419 
02420   <font class="keywordflow">if</font> (x != (typeExpr) 0)
02421     {
02422       cstring front = cstring_undefined;
02423       cstring back  = cstring_undefined;
02424 
02425       llassert (x-&gt;wrapped &lt; 100);
02426 
02427       <font class="keywordflow">for</font> (i = x-&gt;wrapped; i &gt;= 1; i--)
02428         {
02429           front = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (front, <font class="charliteral">'('</font>);
02430           back = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (back, <font class="charliteral">')'</font>);
02431         }
02432       
02433       <font class="keywordflow">switch</font> (x-&gt;kind)
02434         {
02435         <font class="keywordflow">case</font> TEXPR_BASE:
02436           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q /* %s */"</font>, s, ltoken_getRawString (x-&gt;content.base));
02437           <font class="keywordflow">break</font>;
02438         <font class="keywordflow">case</font> TEXPR_PTR:
02439           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q*%q"</font>, s, typeExpr_unparseNoBase (x-&gt;content.pointer));
02440           <font class="keywordflow">break</font>;
02441         <font class="keywordflow">case</font> TEXPR_ARRAY:
02442           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q[%q]"</font>, s, 
02443                        typeExpr_unparseNoBase (x-&gt;content.array.elementtype),
02444                        <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (x-&gt;content.array.size));
02445           <font class="keywordflow">break</font>;
02446         <font class="keywordflow">case</font> TEXPR_FCN:
02447           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q ("</font>, s, 
02448                        typeExpr_unparseNoBase (x-&gt;content.function.returntype));
02449           params = x-&gt;content.function.args;
02450 
02451           <font class="keywordflow">if</font> (!paramNodeList_empty (params))
02452             {
02453               s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q"</font>, s, 
02454                            paramNodeList_unparse (x-&gt;content.function.args));
02455             }
02456 
02457           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q)"</font>, s);
02458           <font class="keywordflow">break</font>;
02459         }
02460       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q%q"</font>, front, s, back);
02461     }
02462   <font class="keywordflow">else</font>
02463     {
02464       s = cstring_makeLiteral (<font class="stringliteral">"?"</font>);
02465     }
02466 
02467   <font class="keywordflow">return</font> s;
02468 }
02469 
02470 cstring
<a name="l02471"></a><a class="code" href="abstract_c.html#a137">02471</a> <a class="code" href="abstract_c.html#a137">typeExpr_name</a> (<font class="comment">/*@null@*/</font> typeExpr x)<font class="keyword"></font>
02472 <font class="keyword"></font>{
02473   <font class="keywordflow">if</font> (x != (typeExpr) 0)
02474     {
02475       <font class="keywordflow">switch</font> (x-&gt;kind)
02476         {
02477         <font class="keywordflow">case</font> TEXPR_BASE:
02478           <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (x-&gt;content.base)));
02479         <font class="keywordflow">case</font> TEXPR_PTR:
02480           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a137">typeExpr_name</a> (x-&gt;content.pointer));
02481         <font class="keywordflow">case</font> TEXPR_ARRAY:
02482           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a137">typeExpr_name</a> (x-&gt;content.array.elementtype));
02483         <font class="keywordflow">case</font> TEXPR_FCN:
02484           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a137">typeExpr_name</a> (x-&gt;content.function.returntype));
02485         }
02486     }
02487 
02488   <font class="comment">/* evs --- 14 Mar 1995</font>
02489 <font class="comment">  ** not a bug: its okay to have empty parameter names</font>
02490 <font class="comment">  **   llbug ("typeExpr_name: null");</font>
02491 <font class="comment">  */</font>
02492 
02493   <font class="keywordflow">return</font> cstring_undefined;
02494 }
02495 
02496 <font class="comment">/*@only@*/</font> typeExpr
<a name="l02497"></a><a class="code" href="abstract_c.html#a138">02497</a>   <a class="code" href="abstract_c.html#a138">makePointerNode</a> (ltoken star, <font class="comment">/*@only@*/</font> <font class="comment">/*@returned@*/</font> typeExpr x)<font class="keyword"></font>
02498 <font class="keyword"></font>{
02499   <font class="keywordflow">if</font> (x != (typeExpr)0 &amp;&amp; (x-&gt;kind == TEXPR_FCN &amp;&amp; (x-&gt;wrapped == 0)))
02500     {
02501       x-&gt;content.function.returntype = <a class="code" href="abstract_c.html#a138">makePointerNode</a> (star, x-&gt;content.function.returntype);
02502       <font class="keywordflow">return</font> x;
02503     }
02504   <font class="keywordflow">else</font>
02505     {
02506       typeExpr y = (typeExpr) dmalloc (<font class="keyword">sizeof</font> (*y));
02507 
02508       y-&gt;wrapped = 0;
02509       y-&gt;kind = TEXPR_PTR;
02510       y-&gt;content.pointer = x;
02511       y-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
02512       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (star);
02513 
02514       <font class="keywordflow">return</font> y;
02515     }
02516 }
02517 
<a name="l02518"></a><a class="code" href="abstract_c.html#a139">02518</a> typeExpr <a class="code" href="abstract_c.html#a139">makeArrayNode</a> (<font class="comment">/*@returned@*/</font> typeExpr x,
02519                         <font class="comment">/*@only@*/</font> arrayQualNode a)<font class="keyword"></font>
02520 <font class="keyword"></font>{
02521   <font class="keywordflow">if</font> (x != (typeExpr)0 &amp;&amp; (x-&gt;kind == TEXPR_FCN &amp;&amp; (x-&gt;wrapped == 0)))
02522     {
02523       <font class="comment">/*</font>
02524 <font class="comment">      ** Spurious errors reported here, because of referencing</font>
02525 <font class="comment">      ** in makeArrayNode.</font>
02526 <font class="comment">      */</font>
02527 
02528       <font class="comment">/*@i3@*/</font> x-&gt;content.function.returntype = <a class="code" href="abstract_c.html#a139">makeArrayNode</a> (x, a);
02529       <font class="comment">/*@i1@*/</font> <font class="keywordflow">return</font> x;
02530     }
02531   <font class="keywordflow">else</font>
02532     {
02533       typeExpr y = (typeExpr) dmalloc (<font class="keyword">sizeof</font> (*y));
02534       y-&gt;wrapped = 0;
02535       y-&gt;kind = TEXPR_ARRAY;
02536 
02537       <font class="keywordflow">if</font> (a == (arrayQualNode) 0)
02538         {
02539           y-&gt;content.array.size = (termNode) 0;
02540         }
02541       <font class="keywordflow">else</font>
02542         {
02543           y-&gt;content.array.size = a-&gt;term;
02544           <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (a-&gt;tok);
02545           <a class="code" href="general_c.html#a0">sfree</a> (a);
02546         }
02547 
02548       y-&gt;content.array.elementtype = x;
02549       y-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
02550 
02551       <font class="keywordflow">return</font> (y);
02552     }
02553 }
02554 
02555 <font class="comment">/*@only@*/</font> constDeclarationNode
<a name="l02556"></a><a class="code" href="abstract_c.html#a140">02556</a> <a class="code" href="abstract_c.html#a140">makeConstDeclarationNode</a> (lclTypeSpecNode t, initDeclNodeList decls)<font class="keyword"></font>
02557 <font class="keyword"></font>{
02558   constDeclarationNode n = (constDeclarationNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02559   sort s, s2, initValueSort;
02560   ltoken varid, errtok;
02561   termNode initValue;
02562 
02563   s = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (t);  
02564 
02565   initDeclNodeList_elements (decls, init)<font class="keyword"></font>
02566 <font class="keyword">    </font>{
02567       declaratorNode vdnode = init-&gt;declarator;
02568       varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
02569 
02570       varid = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (vdnode-&gt;id);
02571       s2 = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (s, vdnode-&gt;type);
02572       initValue = init-&gt;value;
02573       
02574       <font class="keywordflow">if</font> (termNode_isDefined (initValue) &amp;&amp; !initValue-&gt;error_reported)
02575         {
02576           initValueSort = initValue-&gt;sort;
02577 
02578           <font class="comment">/* should keep the arguments in order */</font>
02579           <font class="keywordflow">if</font> (!sort_member_modulo_cstring (s2, initValue)
02580               &amp;&amp; !initValue-&gt;error_reported)
02581             {
02582               errtok = <a class="code" href="abstract_c.html#a74">termNode_errorToken</a> (initValue);
02583               
02584               lclerror 
02585                 (errtok, 
02586                  <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Constant %s declared type %q, initialized to %q: %q"</font>,
02587                           ltoken_unparse (varid), 
02588                           <a class="code" href="sort_c.html#a98">sort_unparse</a> (s2), 
02589                           <a class="code" href="sort_c.html#a98">sort_unparse</a> (initValueSort),
02590                           <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (initValue)));
02591             }
02592         }
02593       
02594       vi-&gt;id = varid;
02595       vi-&gt;kind = VRK_CONST;
02596       vi-&gt;sort = s2;
02597       vi-&gt;export = TRUE;
02598 
02599       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
02600       <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
02601 
02602     } end_initDeclNodeList_elements;
02603 
02604   n-&gt;type = t;
02605   n-&gt;decls = decls;
02606   
02607   <font class="keywordflow">return</font> n;
02608 }
02609 
<a name="l02610"></a><a class="code" href="abstract_c.html#a141">02610</a> varDeclarationNode <a class="code" href="abstract_c.html#a141">makeInternalStateNode</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
02611 <font class="keyword"></font>{
02612   varDeclarationNode n = (varDeclarationNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02613 
02614   n-&gt;isSpecial = TRUE;
02615   n-&gt;sref = <a class="code" href="sRef_c.html#a156">sRef_makeInternalState</a> ();
02616 
02617   <font class="comment">/*@-compdef@*/</font> <font class="keywordflow">return</font> n; <font class="comment">/*@=compdef@*/</font>
02618 }
02619 
<a name="l02620"></a><a class="code" href="abstract_c.html#a142">02620</a> varDeclarationNode <a class="code" href="abstract_c.html#a142">makeFileSystemNode</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
02621 <font class="keyword"></font>{
02622   varDeclarationNode n = (varDeclarationNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02623 
02624   n-&gt;isSpecial = TRUE;
02625   n-&gt;sref = <a class="code" href="sRef_c.html#a158">sRef_makeSystemState</a> ();
02626 
02627   <font class="comment">/*@-compdef@*/</font> <font class="keywordflow">return</font> n; <font class="comment">/*@=compdef@*/</font>
02628 }
02629 
02630 <font class="comment">/*@only@*/</font> varDeclarationNode
<a name="l02631"></a><a class="code" href="abstract_c.html#a143">02631</a> <a class="code" href="abstract_c.html#a143">makeVarDeclarationNode</a> (lclTypeSpecNode t, initDeclNodeList x,
02632                         <font class="keywordtype">bool</font> isGlobal, <font class="keywordtype">bool</font> isPrivate)<font class="keyword"></font>
02633 <font class="keyword"></font>{
02634   varDeclarationNode n = (varDeclarationNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02635   sort s, s2, initValueSort;
02636   ltoken varid, errtok;
02637   termNode initValue;
02638   declaratorNode vdnode;
02639 
02640   n-&gt;isSpecial = FALSE;
02641   n-&gt;qualifier = QLF_NONE;
02642   n-&gt;isGlobal = isGlobal;
02643   n-&gt;isPrivate = isPrivate;
02644   n-&gt;decls = x;
02645 
02646   s = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (t);
02647 
02648   <font class="comment">/* t is an lclTypeSpec, its sort may not be assigned yet */</font>
02649 
02650   initDeclNodeList_elements (x, init)<font class="keyword"></font>
02651 <font class="keyword">    </font>{
02652       vdnode = init-&gt;declarator;
02653       varid = vdnode-&gt;id;
02654       s2 = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (s, vdnode-&gt;type);
02655       initValue = init-&gt;value;
02656 
02657       <font class="keywordflow">if</font> (termNode_isDefined (initValue) &amp;&amp; !initValue-&gt;error_reported)
02658         {
02659           initValueSort = initValue-&gt;sort;
02660           <font class="comment">/* should keep the arguments in order */</font>
02661           <font class="keywordflow">if</font> (!sort_member_modulo_cstring (s2, initValue)
02662               &amp;&amp; !initValue-&gt;error_reported)
02663             {
02664               errtok = <a class="code" href="abstract_c.html#a74">termNode_errorToken</a> (initValue);
02665               
02666               <a class="code" href="llerror_c.html#a54">lclerror</a> (errtok, 
02667                         message (<font class="stringliteral">"Variable %s declared type %q, initialized to %q"</font>,
02668                                  ltoken_unparse (varid), 
02669                                  <a class="code" href="sort_c.html#a98">sort_unparse</a> (s2), 
02670                                  <a class="code" href="sort_c.html#a98">sort_unparse</a> (initValueSort)));
02671             }
02672         }
02673       
02674       <font class="comment">/*</font>
02675 <font class="comment">      ** If global, check that it has been declared already, don't push</font>
02676 <font class="comment">      ** onto symbol table yet (wrong scope, done in enteringFcnScope </font>
02677 <font class="comment">      */</font>
02678 
02679       <font class="keywordflow">if</font> (isGlobal)
02680         {
02681           varInfo vi = <a class="code" href="symtable_c.html#a50">symtable_varInfo</a> (g_symtab, ltoken_getText (varid));
02682           
02683           <font class="keywordflow">if</font> (!varInfo_exists (vi))
02684             {
02685               <a class="code" href="llerror_c.html#a54">lclerror</a> (varid,
02686                         message (<font class="stringliteral">"Undeclared global variable: %s"</font>,
02687                                  ltoken_getRawString (varid)));     
02688             }
02689           <font class="keywordflow">else</font>
02690             {
02691               <font class="keywordflow">if</font> (vi-&gt;kind == VRK_CONST)
02692                 {
02693                   <a class="code" href="llerror_c.html#a54">lclerror</a> (varid,
02694                             message (<font class="stringliteral">"Constant used in global list: %s"</font>,
02695                                      ltoken_getRawString (varid)));
02696                 }
02697             }
02698         }
02699       <font class="keywordflow">else</font>
02700         {
02701           varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
02702           
02703           vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (varid);
02704           <font class="keywordflow">if</font> (isPrivate)
02705             {
02706               vi-&gt;kind = VRK_PRIVATE;
02707               <font class="comment">/* check that initValue is not empty */</font>
02708               <font class="keywordflow">if</font> (initValue == (termNode) 0)
02709                 {
02710                   <a class="code" href="llerror_c.html#a54">lclerror</a> (varid,
02711                             message (<font class="stringliteral">"Private variable must have initialization: %s"</font>,
02712                                      ltoken_getRawString (varid)));
02713                 }
02714             }
02715           <font class="keywordflow">else</font>
02716             {
02717               vi-&gt;kind = VRK_VAR;
02718             }
02719           
02720           vi-&gt;sort = <a class="code" href="sort_c.html#a74">sort_makeGlobal</a> (s2);
02721           vi-&gt;export = TRUE;
02722           
02723           vdnode-&gt;isRedecl = <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
02724           <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
02725         }
02726     } end_initDeclNodeList_elements;
02727   
02728   n-&gt;type = t;
02729 
02730   <font class="keywordflow">return</font> n;
02731 }
02732 
02733 <font class="comment">/*@only@*/</font> initDeclNode
<a name="l02734"></a><a class="code" href="abstract_c.html#a144">02734</a> <a class="code" href="abstract_c.html#a144">makeInitDeclNode</a> (declaratorNode d, termNode x)<font class="keyword"></font>
02735 <font class="keyword"></font>{
02736   initDeclNode n = (initDeclNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02737 
02738   n-&gt;declarator = d;
02739   n-&gt;value = x;
02740   <font class="keywordflow">return</font> n;
02741 }
02742 
02743 <font class="comment">/*@only@*/</font> abstractNode
<a name="l02744"></a><a class="code" href="abstract_c.html#a145">02744</a> <a class="code" href="abstract_c.html#a145">makeAbstractNode</a> (ltoken t, ltoken name,
02745                   <font class="keywordtype">bool</font> isMutable, <font class="keywordtype">bool</font> isRefCounted, abstBodyNode a)<font class="keyword"></font>
02746 <font class="keyword"></font>{
02747   abstractNode n = (abstractNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02748   sort handle;
02749   typeInfo ti = (typeInfo) dmalloc (<font class="keyword">sizeof</font> (*ti));
02750   
02751   n-&gt;tok = t;
02752   n-&gt;isMutable = isMutable;
02753   n-&gt;name = name;
02754   n-&gt;body = a;
02755   n-&gt;isRefCounted = isRefCounted;
02756 
02757   <font class="keywordflow">if</font> (isMutable)
02758     handle = <a class="code" href="sort_c.html#a82">sort_makeMutable</a> (name, ltoken_getText (name));
02759   <font class="keywordflow">else</font>
02760     handle = <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (name, ltoken_getText (name));
02761   n-&gt;sort = handle;
02762   
02763   ti-&gt;id = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (ltoken_getCode (ltoken_typename), SID_TYPE, 
02764                                 ltoken_getText (name));
02765   ti-&gt;modifiable = isMutable;
02766   ti-&gt;abstract = TRUE;
02767   ti-&gt;basedOn = handle;
02768   ti-&gt;export = TRUE;
02769 
02770   <a class="code" href="symtable_c.html#a45">symtable_enterType</a> (g_symtab, ti);
02771 
02772   
02773     <font class="keywordflow">return</font> n;
02774 }
02775 
02776 <font class="comment">/*@only@*/</font> cstring
<a name="l02777"></a><a class="code" href="abstract_c.html#a146">02777</a> <a class="code" href="abstract_c.html#a146">abstractNode_unparse</a> (abstractNode n)<font class="keyword"></font>
02778 <font class="keyword"></font>{
02779   <font class="keywordflow">if</font> (n != (abstractNode) 0)
02780     {
02781       cstring s;
02782 
02783       <font class="keywordflow">if</font> (n-&gt;isMutable)
02784         s = cstring_makeLiteral (<font class="stringliteral">"mutable"</font>);
02785       <font class="keywordflow">else</font>
02786         s = cstring_makeLiteral (<font class="stringliteral">"immutable"</font>);
02787 
02788       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q type %s%q;"</font>, s, ltoken_getRawString (n-&gt;name),
02789                        <a class="code" href="abstract_c.html#a152">abstBodyNode_unparse</a> (n-&gt;body)));
02790     }
02791   <font class="keywordflow">return</font> cstring_undefined;
02792 }
02793 
02794 <font class="keywordtype">void</font>
<a name="l02795"></a><a class="code" href="abstract_c.html#a147">02795</a> <a class="code" href="abstract_c.html#a147">setExposedType</a> (lclTypeSpecNode s)<font class="keyword"></font>
02796 <font class="keyword"></font>{
02797   exposedType = s;
02798 }
02799 
02800 <font class="comment">/*@only@*/</font> exposedNode
<a name="l02801"></a><a class="code" href="abstract_c.html#a148">02801</a> <a class="code" href="abstract_c.html#a148">makeExposedNode</a> (ltoken t, lclTypeSpecNode s,
02802                  declaratorInvNodeList d)<font class="keyword"></font>
02803 <font class="keyword"></font>{
02804   exposedNode n = (exposedNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02805   
02806   n-&gt;tok = t;
02807   n-&gt;type = s;
02808   n-&gt;decls = d;
02809 
02810     <font class="keywordflow">return</font> n;
02811 }
02812 
02813 <font class="comment">/*@only@*/</font> cstring
<a name="l02814"></a><a class="code" href="abstract_c.html#a149">02814</a> <a class="code" href="abstract_c.html#a149">exposedNode_unparse</a> (exposedNode n)<font class="keyword"></font>
02815 <font class="keyword"></font>{
02816   <font class="keywordflow">if</font> (n != (exposedNode) 0)
02817     {
02818       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"typedef %q %q;"</font>,
02819                        lclTypeSpecNode_unparse (n-&gt;type),
02820                        <a class="code" href="declaratorInvNodeList_c.html#a3">declaratorInvNodeList_unparse</a> (n-&gt;decls)));
02821     }
02822   <font class="keywordflow">return</font> cstring_undefined;
02823 }
02824 
02825 <font class="comment">/*@only@*/</font> declaratorInvNode
<a name="l02826"></a><a class="code" href="abstract_c.html#a150">02826</a> <a class="code" href="abstract_c.html#a150">makeDeclaratorInvNode</a> (declaratorNode d, abstBodyNode b)<font class="keyword"></font>
02827 <font class="keyword"></font>{
02828   declaratorInvNode n = (declaratorInvNode) dmalloc (<font class="keyword">sizeof</font> (*n));
02829   n-&gt;declarator = d;
02830   n-&gt;body = b;
02831 
02832   <font class="keywordflow">return</font> (n);
02833 }
02834 
02835 <font class="comment">/*@only@*/</font> cstring
<a name="l02836"></a><a class="code" href="abstract_c.html#a151">02836</a> <a class="code" href="abstract_c.html#a151">declaratorInvNode_unparse</a> (declaratorInvNode d)<font class="keyword"></font>
02837 <font class="keyword"></font>{
02838   <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q"</font>, declaratorNode_unparse (d-&gt;declarator),
02839                    <a class="code" href="abstract_c.html#a153">abstBodyNode_unparseExposed</a> (d-&gt;body)));
02840 }
02841 
02842 <font class="comment">/*@only@*/</font> cstring
<a name="l02843"></a><a class="code" href="abstract_c.html#a152">02843</a> <a class="code" href="abstract_c.html#a152">abstBodyNode_unparse</a> (abstBodyNode n)<font class="keyword"></font>
02844 <font class="keyword"></font>{
02845   <font class="keywordflow">if</font> (n != (abstBodyNode) 0)
02846     {
02847       <font class="keywordflow">return</font> (lclPredicateNode_unparse (n-&gt;typeinv));
02848     }
02849   <font class="keywordflow">return</font> cstring_undefined;
02850 }
02851 
02852 <font class="comment">/*@only@*/</font> cstring
<a name="l02853"></a><a class="code" href="abstract_c.html#a153">02853</a> <a class="code" href="abstract_c.html#a153">abstBodyNode_unparseExposed</a> (abstBodyNode n)<font class="keyword"></font>
02854 <font class="keyword"></font>{
02855   <font class="keywordflow">if</font> (n != (abstBodyNode) 0)
02856     {
02857       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q"</font>, lclPredicateNode_unparse (n-&gt;typeinv)));
02858     }
02859   <font class="keywordflow">return</font> cstring_undefined;
02860 }
02861 
02862 <font class="comment">/*@only@*/</font> cstring
<a name="l02863"></a><a class="code" href="abstract_c.html#a154">02863</a> <a class="code" href="abstract_c.html#a154">taggedUnionNode_unparse</a> (taggedUnionNode n)<font class="keyword"></font>
02864 <font class="keyword"></font>{
02865   <font class="keywordflow">if</font> (n != (taggedUnionNode) 0)
02866     {
02867       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"tagged union {%q}%q;\n"</font>,
02868                        stDeclNodeList_unparse (n-&gt;structdecls),
02869                        <a class="code" href="abstract_c.html#a130">declaratorNode_unparse</a> (n-&gt;declarator)));
02870     }
02871   <font class="keywordflow">return</font> cstring_undefined;
02872 }
02873 
02874 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> paramNodeList
02875   typeExpr_toParamNodeList (<font class="comment">/*@null@*/</font> typeExpr te)<font class="keyword"></font>
02876 <font class="keyword"></font>{
02877   <font class="keywordflow">if</font> (te != (typeExpr) 0)
02878     {
02879       <font class="keywordflow">switch</font> (te-&gt;kind)
02880         {
02881         <font class="keywordflow">case</font> TEXPR_FCN:
02882           <font class="keywordflow">return</font> te-&gt;content.function.args;
02883         <font class="keywordflow">case</font> TEXPR_PTR:
02884           <font class="keywordflow">return</font> typeExpr_toParamNodeList (te-&gt;content.pointer);
02885         <font class="keywordflow">case</font> TEXPR_ARRAY:
02886          <font class="comment">/* return typeExpr_toParamNodeList (te-&gt;content.array.elementtype); */</font>
02887         <font class="keywordflow">case</font> TEXPR_BASE:
02888           <font class="keywordflow">return</font> paramNodeList_undefined;
02889         }
02890     }
02891   <font class="keywordflow">return</font> paramNodeList_undefined;
02892 }
02893 
02894 <font class="comment">/*@only@*/</font> fcnNode
<a name="l02895"></a><a class="code" href="abstract_c.html#a156">02895</a>   <a class="code" href="abstract_c.html#a156">fcnNode_fromDeclarator</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> lclTypeSpecNode t, 
02896                           <font class="comment">/*@only@*/</font> declaratorNode d)<font class="keyword"></font>
02897 <font class="keyword"></font>{
02898   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a158">makeFcnNode</a> (QU_UNKNOWN, t, d,
02899                        varDeclarationNodeList_new (),
02900                        <a class="code" href="varDeclarationNodeList_c.html#a0">varDeclarationNodeList_new</a> (),
02901                        <a class="code" href="letDeclNodeList_c.html#a0">letDeclNodeList_new</a> (),
02902                        (lclPredicateNode) 0,
02903                        (lclPredicateNode) 0,
02904                        (modifyNode) 0,
02905                        (lclPredicateNode) 0,
02906                        (lclPredicateNode) 0));
02907 }
02908 
02909 <font class="comment">/*@only@*/</font> iterNode
<a name="l02910"></a><a class="code" href="abstract_c.html#a157">02910</a> <a class="code" href="abstract_c.html#a157">makeIterNode</a> (ltoken id, paramNodeList p)<font class="keyword"></font>
02911 <font class="keyword"></font>{
02912   iterNode x = (iterNode) dmalloc (<font class="keyword">sizeof</font> (*x));
02913   <font class="keywordtype">bool</font> hasYield = FALSE;
02914   
02915   x-&gt;name = id;
02916   x-&gt;params = p;
02917   
02918   <font class="comment">/* check there is at least one yield param */</font>
02919   
02920   paramNodeList_elements (p, pe)<font class="keyword"></font>
02921 <font class="keyword">    </font>{
02922       <font class="keywordflow">if</font> (paramNode_isYield (pe)) 
02923         {
02924           hasYield = TRUE; 
02925           <font class="keywordflow">break</font>; 
02926         }
02927     } end_paramNodeList_elements 
02928       
02929   <font class="keywordflow">if</font> (!hasYield)
02930     {
02931       <a class="code" href="llerror_c.html#a54">lclerror</a> (id, message (<font class="stringliteral">"Iterator has no yield parameters: %s"</font>, 
02932                              ltoken_getRawString (id)));
02933     }
02934 
02935   <font class="keywordflow">return</font> (x);
02936 }
02937 
02938 <font class="comment">/*@only@*/</font> fcnNode
<a name="l02939"></a><a class="code" href="abstract_c.html#a158">02939</a> <a class="code" href="abstract_c.html#a158">makeFcnNode</a> (qual specQual,
02940              <font class="comment">/*@null@*/</font> lclTypeSpecNode t,
02941                         declaratorNode d,
02942              <font class="comment">/*@null@*/</font> globalList g, 
02943              <font class="comment">/*@null@*/</font> varDeclarationNodeList privateinits,
02944              <font class="comment">/*@null@*/</font> letDeclNodeList lets,
02945              <font class="comment">/*@null@*/</font> lclPredicateNode checks,
02946              <font class="comment">/*@null@*/</font> lclPredicateNode requires, 
02947              <font class="comment">/*@null@*/</font> modifyNode m,
02948              <font class="comment">/*@null@*/</font> lclPredicateNode ensures, 
02949              <font class="comment">/*@null@*/</font> lclPredicateNode claims)<font class="keyword"></font>
02950 <font class="keyword"></font>{
02951   fcnNode x = (fcnNode) dmalloc (<font class="keyword">sizeof</font> (*x));
02952   
02953   <font class="keywordflow">if</font> (d-&gt;type != (typeExpr)0 &amp;&amp; (d-&gt;type)-&gt;kind != TEXPR_FCN)
02954     {
02955       <a class="code" href="llerror_c.html#a54">lclerror</a> (d-&gt;id, cstring_makeLiteral 
02956                 (<font class="stringliteral">"Attempt to specify function without parameter list"</font>));
02957       d-&gt;type = <a class="code" href="abstract_c.html#a124">makeFunctionNode</a> (d-&gt;type, paramNodeList_new ());
02958     }
02959   
02960   
02961   x-&gt;special = specQual;
02962   x-&gt;typespec = t;
02963   x-&gt;declarator = d;
02964   x-&gt;globals = g;
02965   x-&gt;inits = privateinits;
02966   x-&gt;lets = lets;
02967   x-&gt;checks = checks;
02968   x-&gt;require = requires;
02969   x-&gt;modify = m;
02970   x-&gt;ensures = ensures;
02971   x-&gt;claim = claims;
02972   
02973   <font class="comment">/* extract info to fill in x-&gt;name =;  x-&gt;signature =; */</font>
02974   x-&gt;name = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (d-&gt;id);
02975   
02976   <font class="keywordflow">return</font> (x);
02977 }
02978 
02979 <font class="comment">/*@only@*/</font> claimNode
<a name="l02980"></a><a class="code" href="abstract_c.html#a159">02980</a> <a class="code" href="abstract_c.html#a159">makeClaimNode</a> (ltoken id, paramNodeList p,
02981                globalList g, letDeclNodeList lets, lclPredicateNode requires,
02982                programNode b, lclPredicateNode ensures)<font class="keyword"></font>
02983 <font class="keyword"></font>{
02984   claimNode x = (claimNode) dmalloc (<font class="keyword">sizeof</font> (*x));
02985 
02986   
02987   x-&gt;name = id;
02988   x-&gt;params = p;
02989   x-&gt;globals = g;
02990   x-&gt;lets = lets;
02991   x-&gt;require = requires;
02992   x-&gt;body = b;
02993   x-&gt;ensures = ensures;
02994   <font class="keywordflow">return</font> (x);
02995 }
02996 
02997 <font class="comment">/*@only@*/</font> lclPredicateNode
<a name="l02998"></a><a class="code" href="abstract_c.html#a160">02998</a> <a class="code" href="abstract_c.html#a160">makeIntraClaimNode</a> (ltoken t, lclPredicateNode n)<font class="keyword"></font>
02999 <font class="keyword"></font>{
03000   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;tok);
03001   n-&gt;tok = t;
03002   n-&gt;kind = LPD_INTRACLAIM;
03003   <font class="keywordflow">return</font> (n);
03004 }
03005 
03006 <font class="comment">/*@only@*/</font> lclPredicateNode
<a name="l03007"></a><a class="code" href="abstract_c.html#a161">03007</a> <a class="code" href="abstract_c.html#a161">makeRequiresNode</a> (ltoken t, lclPredicateNode n)<font class="keyword"></font>
03008 <font class="keyword"></font>{
03009   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;tok);
03010   n-&gt;tok = t;
03011   n-&gt;kind = LPD_REQUIRES;
03012   <font class="keywordflow">return</font> (n);
03013 }
03014 
03015 <font class="comment">/*@only@*/</font> lclPredicateNode
<a name="l03016"></a><a class="code" href="abstract_c.html#a162">03016</a> <a class="code" href="abstract_c.html#a162">makeChecksNode</a> (ltoken t, lclPredicateNode n)<font class="keyword"></font>
03017 <font class="keyword"></font>{
03018   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;tok);
03019   n-&gt;tok = t;
03020   n-&gt;kind = LPD_CHECKS;
03021   <font class="keywordflow">return</font> (n);
03022 }
03023 
03024 <font class="comment">/*@only@*/</font> lclPredicateNode
<a name="l03025"></a><a class="code" href="abstract_c.html#a163">03025</a> <a class="code" href="abstract_c.html#a163">makeEnsuresNode</a> (ltoken t, lclPredicateNode n)<font class="keyword"></font>
03026 <font class="keyword"></font>{
03027   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;tok);
03028   n-&gt;tok = t;
03029   n-&gt;kind = LPD_ENSURES;
03030   <font class="keywordflow">return</font> (n);
03031 }
03032 
03033 <font class="comment">/*@only@*/</font> lclPredicateNode
<a name="l03034"></a><a class="code" href="abstract_c.html#a164">03034</a> <a class="code" href="abstract_c.html#a164">makeLclPredicateNode</a> (ltoken t, termNode n,
03035                       lclPredicateKind k)<font class="keyword"></font>
03036 <font class="keyword"></font>{
03037   lclPredicateNode x = (lclPredicateNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03038 
03039   x-&gt;tok = t;
03040   x-&gt;predicate = n;
03041   x-&gt;kind = k;
03042   <font class="keywordflow">return</font> (x);
03043 }
03044 
03045 <font class="comment">/*@only@*/</font> quantifierNode
<a name="l03046"></a><a class="code" href="abstract_c.html#a165">03046</a> <a class="code" href="abstract_c.html#a165">makeQuantifierNode</a> (varNodeList v, ltoken quant)<font class="keyword"></font>
03047 <font class="keyword"></font>{
03048   quantifierNode x = (quantifierNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03049 
03050   x-&gt;quant = quant;
03051   x-&gt;vars = v;
03052   x-&gt;isForall = cstring_equalLit (ltoken_unparse (quant), <font class="stringliteral">"\forall"</font>);
03053 
03054   <font class="keywordflow">return</font> (x);
03055 }
03056 
03057 <font class="comment">/*@only@*/</font> arrayQualNode
<a name="l03058"></a><a class="code" href="abstract_c.html#a166">03058</a> <a class="code" href="abstract_c.html#a166">makeArrayQualNode</a> (ltoken t, termNode term)<font class="keyword"></font>
03059 <font class="keyword"></font>{
03060   arrayQualNode x = (arrayQualNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03061 
03062   x-&gt;tok = t;
03063   x-&gt;term = term;
03064   <font class="keywordflow">return</font> (x);
03065 }
03066 
03067 <font class="comment">/*@only@*/</font> varNode
<a name="l03068"></a><a class="code" href="abstract_c.html#a167">03068</a> <a class="code" href="abstract_c.html#a167">makeVarNode</a> (<font class="comment">/*@only@*/</font> ltoken varid, <font class="keywordtype">bool</font> isObj, lclTypeSpecNode t)<font class="keyword"></font>
03069 <font class="keyword"></font>{
03070   varNode x = (varNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03071   varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
03072   sort sort;
03073   
03074   vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (varid);
03075   sort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (t);
03076   
03077   <font class="comment">/* 9/3/93, The following is needed because we want value sorts to be</font>
03078 <font class="comment">     the default, object sort is generated only if there is "obj" qualifier.</font>
03079 <font class="comment">     There are 2 cases: (1) for immutable types (including C primitive types),</font>
03080 <font class="comment">     we need to generate the object sort if qualifier is present; (2) for</font>
03081 <font class="comment">     array, struct and union types, they are already in their object sorts. </font>
03082 <font class="comment">     */</font>
03083   
03084   sort = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (sort);   <font class="comment">/* both cases are now value sorts */</font>
03085   
03086   <font class="keywordflow">if</font> (isObj)
03087     {
03088       sort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (sort);
03089     }
03090   
03091     
03092   vi-&gt;sort = sort;
03093   vi-&gt;kind = VRK_QUANT;
03094   vi-&gt;export = TRUE;
03095 
03096   (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
03097   <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
03098 
03099   x-&gt;varid = varid;
03100   x-&gt;isObj = isObj;
03101   x-&gt;type = t;
03102   x-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03103 
03104   <font class="keywordflow">return</font> (x);
03105 }
03106 
03107 <font class="comment">/*@only@*/</font> abstBodyNode
<a name="l03108"></a><a class="code" href="abstract_c.html#a168">03108</a> <a class="code" href="abstract_c.html#a168">makeAbstBodyNode</a> (ltoken t, fcnNodeList f)<font class="keyword"></font>
03109 <font class="keyword"></font>{
03110   abstBodyNode x = (abstBodyNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03111 
03112   x-&gt;tok = t;
03113   x-&gt;typeinv = (lclPredicateNode)0;
03114   x-&gt;fcns = f;
03115   <font class="keywordflow">return</font> (x);
03116 }
03117 
03118 <font class="comment">/*@only@*/</font> abstBodyNode
<a name="l03119"></a><a class="code" href="abstract_c.html#a169">03119</a> <a class="code" href="abstract_c.html#a169">makeExposedBodyNode</a> (ltoken t, lclPredicateNode inv)<font class="keyword"></font>
03120 <font class="keyword"></font>{
03121   abstBodyNode x = (abstBodyNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03122 
03123   x-&gt;tok = t;
03124   x-&gt;typeinv = inv;
03125   x-&gt;fcns = fcnNodeList_undefined;
03126   <font class="keywordflow">return</font> (x);
03127 }
03128 
03129 <font class="comment">/*@only@*/</font> abstBodyNode
<a name="l03130"></a><a class="code" href="abstract_c.html#a170">03130</a> <a class="code" href="abstract_c.html#a170">makeAbstBodyNode2</a> (ltoken t, ltokenList ops)<font class="keyword"></font>
03131 <font class="keyword"></font>{
03132   abstBodyNode x = (abstBodyNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03133 
03134   x-&gt;tok = t;
03135   x-&gt;typeinv = (lclPredicateNode) 0;
03136 
03137   x-&gt;fcns = <a class="code" href="fcnNodeList_c.html#a0">fcnNodeList_new</a> ();
03138 
03139   ltokenList_elements (ops, op)<font class="keyword"></font>
03140 <font class="keyword">    </font>{
03141       x-&gt;fcns = fcnNodeList_add
03142         (x-&gt;fcns,
03143          <a class="code" href="abstract_c.html#a156">fcnNode_fromDeclarator</a> (lclTypeSpecNode_undefined,
03144                                  makeUnknownDeclaratorNode (ltoken_copy (op))));
03145     } end_ltokenList_elements;
03146   
03147   <a class="code" href="ltokenList_c.html#a14">ltokenList_free</a> (ops);
03148 
03149   <font class="keywordflow">return</font> (x);
03150 }
03151 
03152 <font class="comment">/*@only@*/</font> stmtNode
<a name="l03153"></a><a class="code" href="abstract_c.html#a171">03153</a>   <a class="code" href="abstract_c.html#a171">makeStmtNode</a> (ltoken varId, ltoken fcnId, <font class="comment">/*@only@*/</font> termNodeList v)<font class="keyword"></font>
03154 <font class="keyword"></font>{
03155   stmtNode n = (stmtNode) dmalloc (<font class="keyword">sizeof</font> (*n));
03156 
03157   n-&gt;lhs = varId;
03158   n-&gt;operator = fcnId;
03159   n-&gt;args = v;
03160   <font class="keywordflow">return</font> (n);
03161 }
03162 
03163 <font class="comment">/* printDeclarators -&gt; declaratorNodeList_unparse */</font>
03164 
03165 <font class="keyword">static</font> cstring abstDeclaratorNode_unparse (abstDeclaratorNode x)<font class="keyword"></font>
03166 <font class="keyword"></font>{
03167   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a135">typeExpr_unparse</a> ((typeExpr) x));
03168 }
03169 
03170 <font class="comment">/*@only@*/</font> paramNode
<a name="l03171"></a><a class="code" href="abstract_c.html#a172">03171</a> <a class="code" href="abstract_c.html#a172">makeParamNode</a> (lclTypeSpecNode t, typeExpr d)<font class="keyword"></font>
03172 <font class="keyword"></font>{
03173   paramNode x = (paramNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03174   
03175   paramNode_checkQualifiers (t, d);
03176 
03177   x-&gt;type = t;
03178   x-&gt;paramdecl = d;
03179   x-&gt;kind = PNORMAL; <font class="comment">/*&lt; forgot this! &gt;*/</font>
03180 
03181   <font class="keywordflow">return</font> (x);
03182 }
03183   
03184 <font class="comment">/*@only@*/</font> paramNode
<a name="l03185"></a><a class="code" href="abstract_c.html#a173">03185</a> <a class="code" href="abstract_c.html#a173">paramNode_elipsis</a> (<font class="keywordtype">void</font>)<font class="keyword"></font>
03186 <font class="keyword"></font>{
03187   paramNode x = (paramNode) dmalloc (<font class="keyword">sizeof</font> (*x));
03188 
03189   x-&gt;type = (lclTypeSpecNode) 0;
03190   x-&gt;paramdecl = (typeExpr) 0;
03191   x-&gt;kind = PELIPSIS;
03192 
03193   <font class="keywordflow">return</font> (x);  
03194 }
03195 
03196 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> ltoken typeExpr_getTok (typeExpr d)<font class="keyword"></font>
03197 <font class="keyword"></font>{
03198   <font class="keywordflow">while</font> (d != (typeExpr)0)
03199     {
03200       <font class="keywordflow">if</font> (d-&gt;kind == TEXPR_BASE)
03201         {
03202           <font class="keywordflow">return</font> (d-&gt;content.base);
03203         }
03204       <font class="keywordflow">else</font>
03205         {
03206           <font class="keywordflow">if</font> (d-&gt;kind == TEXPR_PTR)
03207             {
03208               d = d-&gt;content.pointer;
03209             }
03210           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (d-&gt;kind == TEXPR_ARRAY)
03211             {
03212               d = d-&gt;content.array.elementtype;
03213             }
03214           <font class="keywordflow">else</font> <font class="keywordflow">if</font> (d-&gt;kind == TEXPR_FCN) 
03215             {
03216               d = d-&gt;content.function.returntype;
03217             }
03218           <font class="keywordflow">else</font>
03219             {
03220               BADBRANCH;
03221             }
03222         }
03223     }
03224 
03225   <a class="code" href="llerror_c.html#a48">llfatalerror</a> (cstring_makeLiteral (<font class="stringliteral">"typeExpr_getTok: unreachable code"</font>));
03226   BADEXIT;
03227 }
03228 
03229 <font class="keywordtype">void</font>
03230 paramNode_checkQualifiers (lclTypeSpecNode t, typeExpr d)<font class="keyword"></font>
03231 <font class="keyword"></font>{
03232   <font class="keywordtype">bool</font> isPointer = FALSE;
03233   <font class="keywordtype">bool</font> isUser = FALSE;
03234   <font class="keywordtype">bool</font> hasAlloc = FALSE;
03235   <font class="keywordtype">bool</font> hasAlias = FALSE;
03236 
03237   llassert (lclTypeSpecNode_isDefined (t));
03238 
03239   <font class="keywordflow">if</font> (t-&gt;pointers == 0 
03240       &amp;&amp; (d != (typeExpr)0 &amp;&amp; d-&gt;kind != TEXPR_PTR) &amp;&amp; d-&gt;kind != TEXPR_ARRAY)
03241     {
03242       <font class="keywordflow">if</font> (t-&gt;kind == LTS_TYPE)
03243         {
03244           sortNode sn;
03245 
03246           llassert (t-&gt;content.type != NULL);
03247 
03248           sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sort_getUnderlying ((t-&gt;content.type)-&gt;sort));
03249 
03250           <font class="keywordflow">if</font> (sn.kind == SRT_PTR || sn.kind == SRT_ARRAY 
03251               || sn.kind == SRT_HOF || sn.kind == SRT_NONE)
03252             {
03253               isPointer = TRUE;
03254             }
03255         }
03256     }
03257   <font class="keywordflow">else</font>
03258     {
03259       isPointer = TRUE;
03260     }
03261 
03262   <font class="keywordflow">if</font> (d != (typeExpr)0 &amp;&amp; d-&gt;kind != TEXPR_BASE)
03263     {
03264       <font class="keywordflow">if</font> (t-&gt;kind == LTS_TYPE)
03265         {
03266           sortNode sn;
03267 
03268           llassert (t-&gt;content.type != NULL);
03269           sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sort_getUnderlying ((t-&gt;content.type)-&gt;sort));
03270 
03271           <font class="keywordflow">if</font> (sn.kind == SRT_PTR || sn.kind == SRT_ARRAY
03272               || sn.kind == SRT_HOF || sn.kind == SRT_NONE)
03273             {
03274               isUser = TRUE;
03275             }
03276         }
03277     }
03278   <font class="keywordflow">else</font>
03279     {
03280       isPointer = TRUE;
03281     }
03282   
03283   <font class="keywordflow">if</font> (d != (typeExpr)NULL)
03284     {
03285       qualList_elements (t-&gt;quals, q)<font class="keyword"></font>
03286 <font class="keyword">        </font>{
03287           <font class="keywordflow">if</font> (qual_isAllocQual (q))
03288             {
03289               <font class="keywordflow">if</font> (hasAlloc)
03290                 {
03291                   ltoken tok  = typeExpr_getTok (d); 
03292                   <a class="code" href="llerror_c.html#a54">lclerror</a> (tok, message (<font class="stringliteral">"Parameter declared with multiple allocation "</font>
03293                                           <font class="stringliteral">"qualifiers: %q"</font>, typeExpr_unparse (d)));
03294                 }
03295               hasAlloc = TRUE;
03296               
03297               <font class="keywordflow">if</font> (!isPointer)
03298                 {
03299                   ltoken tok  = typeExpr_getTok (d); 
03300                   <a class="code" href="llerror_c.html#a54">lclerror</a> (tok, message (<font class="stringliteral">"Non-pointer declared as %s parameter: %q"</font>, 
03301                                           qual_unparse (q),
03302                                           <a class="code" href="abstract_c.html#a135">typeExpr_unparse</a> (d)));
03303                 }
03304             }
03305           <font class="keywordflow">if</font> (qual_isAliasQual (q))
03306             {
03307               <font class="keywordflow">if</font> (hasAlias)
03308                 {
03309                   ltoken tok  = typeExpr_getTok (d); 
03310                   <a class="code" href="llerror_c.html#a54">lclerror</a> (tok, message (<font class="stringliteral">"Parameter declared with multiple alias qualifiers: %q"</font>, 
03311                                           typeExpr_unparse (d)));
03312                 }
03313               hasAlias = TRUE;
03314               
03315               <font class="keywordflow">if</font> (!(isPointer || isUser))
03316                 {
03317                   ltoken tok  = typeExpr_getTok (d); 
03318                   <a class="code" href="llerror_c.html#a54">lclerror</a> (tok, message (<font class="stringliteral">"Unsharable type declared as %s parameter: %q"</font>, 
03319                                           qual_unparse (q),
03320                                           <a class="code" href="abstract_c.html#a135">typeExpr_unparse</a> (d)));
03321                 }
03322             }
03323         } end_qualList_elements;
03324     }
03325 }
03326 
03327 <font class="comment">/*@only@*/</font> cstring
<a name="l03328"></a><a class="code" href="abstract_c.html#a175">03328</a> <a class="code" href="abstract_c.html#a175">paramNode_unparse</a> (paramNode x)<font class="keyword"></font>
03329 <font class="keyword"></font>{
03330   <font class="keywordflow">if</font> (x != (paramNode) 0)
03331     {
03332       <font class="keywordflow">if</font> (x-&gt;kind == PELIPSIS)
03333         {
03334           <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"..."</font>));
03335         }
03336 
03337       <font class="keywordflow">if</font> (x-&gt;paramdecl != (typeExpr) 0)
03338         { <font class="comment">/* handle (void) */</font>
03339           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %q"</font>, lclTypeSpecNode_unparse (x-&gt;type),
03340                            <a class="code" href="abstract_c.html#a135">typeExpr_unparse</a> (x-&gt;paramdecl)));
03341         }
03342       <font class="keywordflow">else</font>
03343         {
03344           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a116">lclTypeSpecNode_unparse</a> (x-&gt;type));
03345         }
03346     }
03347   <font class="keywordflow">return</font> cstring_undefined;
03348 }
03349 
03350 <font class="keyword">static</font> cstring 
03351 lclTypeSpecNode_unparseAltComments (<font class="comment">/*@null@*/</font> lclTypeSpecNode typespec) <font class="comment">/*@*/</font>
03352 {
03353   <font class="keywordflow">if</font> (typespec != (lclTypeSpecNode) 0)
03354     {
03355       cstring s = <a class="code" href="qualList_c.html#a8">qualList_toCComments</a> (typespec-&gt;quals);
03356 
03357       <font class="keywordflow">switch</font> (typespec-&gt;kind)
03358         {
03359         <font class="keywordflow">case</font> LTS_TYPE:
03360           {
03361             llassert (typespec-&gt;content.type != NULL);
03362 
03363             <font class="keywordflow">return</font> (cstring_concatFree 
03364                     (s, printLeaves (typespec-&gt;content.type-&gt;ctypes)));
03365           }
03366         <font class="keywordflow">case</font> LTS_ENUM:
03367           {
03368             <font class="keywordtype">bool</font> first = TRUE;
03369             enumSpecNode n = typespec-&gt;content.enumspec;
03370             
03371             s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, cstring_makeLiteral (<font class="stringliteral">"enum"</font>));
03372             llassert (n != NULL);
03373 
03374             <font class="keywordflow">if</font> (!ltoken_isUndefined (n-&gt;opttagid))
03375               {
03376                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %s"</font>, s, ltoken_unparse (n-&gt;opttagid));
03377               }
03378             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q {"</font>, s); 
03379 
03380             ltokenList_elements (n-&gt;enums, e)<font class="keyword"></font>
03381 <font class="keyword">            </font>{
03382               <font class="keywordflow">if</font> (first)
03383                 {
03384                   first = FALSE;
03385                   s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, ltoken_getRawString (e));
03386                 }
03387               <font class="keywordflow">else</font>
03388                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q, %s"</font>, s, ltoken_getRawString (e));
03389             } end_ltokenList_elements;
03390             
03391             <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q}"</font>, s));
03392           }
03393         <font class="keywordflow">case</font> LTS_STRUCTUNION:
03394           {
03395             strOrUnionNode n = typespec-&gt;content.structorunion;
03396             stDeclNodeList decls;
03397 
03398             llassert (n != NULL);
03399 
03400             <font class="keywordflow">switch</font> (n-&gt;kind)
03401               {
03402               <font class="keywordflow">case</font> SU_STRUCT:
03403                 s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, cstring_makeLiteral (<font class="stringliteral">"struct "</font>));
03404                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
03405               <font class="keywordflow">case</font> SU_UNION:
03406                 s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, cstring_makeLiteral (<font class="stringliteral">"union "</font>));
03407                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
03408               }
03409 
03410             <font class="keywordflow">if</font> (!ltoken_isUndefined (n-&gt;opttagid))
03411               {
03412                 <font class="keywordflow">if</font> (stDeclNodeList_size (n-&gt;structdecls) == 0)
03413                   {
03414                     <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, ltoken_unparse (n-&gt;opttagid)));
03415                   }
03416 
03417                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s {\n\2\1"</font>, s, ltoken_unparse (n-&gt;opttagid));
03418               }
03419             <font class="keywordflow">else</font>
03420               {
03421                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q{\n\2\1"</font>, s);
03422               }
03423 
03424             decls = n-&gt;structdecls;
03425 
03426             stDeclNodeList_elements (decls, f)<font class="keyword"></font>
03427 <font class="keyword">            </font>{
03428               s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q\1%q;\n\1"</font>, s, 
03429                            lclTypeSpecNode_unparseAltComments (f-&gt;lcltypespec),
03430                           <a class="code" href="declaratorNodeList_c.html#a3">declaratorNodeList_unparse</a> (f-&gt;declarators));
03431             } end_stDeclNodeList_elements;
03432 
03433             <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q\3}"</font>, s));
03434           }
03435         <font class="keywordflow">case</font> LTS_CONJ:
03436           {
03437             <a class="code" href="cstring_c.html#a27">cstring_free</a> (s);
03438 
03439             <font class="keywordflow">return</font> 
03440               (message
03441                (<font class="stringliteral">"%q, %q"</font>,
03442                 lclTypeSpecNode_unparseAltComments (typespec-&gt;content.conj-&gt;a),
03443                 lclTypeSpecNode_unparseAltComments (typespec-&gt;content.conj-&gt;b)));
03444           }
03445         BADDEFAULT;
03446         }
03447     }
03448   <font class="keywordflow">else</font>
03449     {
03450       llcontbuglit (<font class="stringliteral">"lclTypeSpecNode_unparseComments: null typespec"</font>);
03451       
03452       <font class="keywordflow">return</font> cstring_undefined;
03453     }
03454   
03455   BADEXIT;
03456 }
03457 
<a name="l03458"></a><a class="code" href="abstract_c.html#a177">03458</a> cstring <a class="code" href="abstract_c.html#a177">lclTypeSpecNode_unparseComments</a> (<font class="comment">/*@null@*/</font> lclTypeSpecNode typespec)<font class="keyword"></font>
03459 <font class="keyword"></font>{
03460   <font class="keywordflow">if</font> (typespec != (lclTypeSpecNode) 0)
03461     {
03462       cstring s = <a class="code" href="qualList_c.html#a8">qualList_toCComments</a> (typespec-&gt;quals);
03463 
03464       <font class="keywordflow">switch</font> (typespec-&gt;kind)
03465         {
03466         <font class="keywordflow">case</font> LTS_TYPE:
03467           {
03468             llassert (typespec-&gt;content.type != NULL);
03469 
03470             <font class="keywordflow">return</font> (cstring_concatFree 
03471                     (s, printLeaves (typespec-&gt;content.type-&gt;ctypes)));
03472           }
03473         <font class="keywordflow">case</font> LTS_ENUM:
03474           {
03475             <font class="keywordtype">bool</font> first = TRUE;
03476             enumSpecNode n = typespec-&gt;content.enumspec;
03477             
03478             s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, cstring_makeLiteral (<font class="stringliteral">"enum"</font>));
03479             llassert (n != NULL);
03480 
03481             <font class="keywordflow">if</font> (!ltoken_isUndefined (n-&gt;opttagid))
03482               {
03483                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %s"</font>, s, ltoken_unparse (n-&gt;opttagid));
03484               }
03485             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q {"</font>, s); 
03486 
03487             ltokenList_elements (n-&gt;enums, e)<font class="keyword"></font>
03488 <font class="keyword">            </font>{
03489               <font class="keywordflow">if</font> (first)
03490                 {
03491                   first = FALSE;
03492                   s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, ltoken_getRawString (e));
03493                 }
03494               <font class="keywordflow">else</font>
03495                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q, %s"</font>, s, ltoken_getRawString (e));
03496             } end_ltokenList_elements;
03497             
03498             <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q}"</font>, s));
03499           }
03500         <font class="keywordflow">case</font> LTS_STRUCTUNION:
03501           {
03502             strOrUnionNode n = typespec-&gt;content.structorunion;
03503             stDeclNodeList decls;
03504 
03505             llassert (n != NULL);
03506 
03507             <font class="keywordflow">switch</font> (n-&gt;kind)
03508               {
03509               <font class="keywordflow">case</font> SU_STRUCT:
03510                 s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, cstring_makeLiteral (<font class="stringliteral">"struct "</font>));
03511                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
03512               <font class="keywordflow">case</font> SU_UNION:
03513                 s = <a class="code" href="cstring_c.html#a38">cstring_concatFree</a> (s, cstring_makeLiteral (<font class="stringliteral">"union "</font>));
03514                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
03515               }
03516 
03517             <font class="keywordflow">if</font> (!ltoken_isUndefined (n-&gt;opttagid))
03518               {
03519                 <font class="keywordflow">if</font> (stDeclNodeList_size (n-&gt;structdecls) == 0)
03520                   {
03521                     <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, ltoken_unparse (n-&gt;opttagid)));
03522                   }
03523 
03524                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s {\n\2\1"</font>, s, ltoken_unparse (n-&gt;opttagid));
03525               }
03526             <font class="keywordflow">else</font>
03527               {
03528                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q{\n\2\1"</font>, s);
03529               }
03530 
03531             decls = n-&gt;structdecls;
03532 
03533             stDeclNodeList_elements (decls, f)<font class="keyword"></font>
03534 <font class="keyword">            </font>{
03535               s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q\1%q;\n\1"</font>, s, 
03536                            lclTypeSpecNode_unparseComments (f-&gt;lcltypespec),
03537                           <a class="code" href="declaratorNodeList_c.html#a3">declaratorNodeList_unparse</a> (f-&gt;declarators));
03538             } end_stDeclNodeList_elements;
03539 
03540             <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q\3}"</font>, s));
03541           }
03542         <font class="keywordflow">case</font> LTS_CONJ:
03543           {
03544             <a class="code" href="cstring_c.html#a27">cstring_free</a> (s);
03545 
03546             <font class="keywordflow">return</font> 
03547               (message
03548                (<font class="stringliteral">"%q /*@alt %q@*/"</font>,
03549                 <a class="code" href="abstract_c.html#a177">lclTypeSpecNode_unparseComments</a> (typespec-&gt;content.conj-&gt;a),
03550                 lclTypeSpecNode_unparseAltComments (typespec-&gt;content.conj-&gt;b)));
03551              }
03552         BADDEFAULT;
03553         }
03554     }
03555   <font class="keywordflow">else</font>
03556     {
03557       llcontbuglit (<font class="stringliteral">"lclTypeSpecNode_unparseComments: null typespec"</font>);
03558       
03559       <font class="keywordflow">return</font> cstring_undefined;
03560     }
03561   
03562   BADEXIT;
03563 }
03564 
03565 <font class="comment">/*@only@*/</font> cstring
<a name="l03566"></a><a class="code" href="abstract_c.html#a178">03566</a> <a class="code" href="abstract_c.html#a178">paramNode_unparseComments</a> (paramNode x)<font class="keyword"></font>
03567 <font class="keyword"></font>{
03568   <font class="keywordflow">if</font> (x != (paramNode) 0)
03569     {
03570       <font class="keywordflow">if</font> (x-&gt;kind == PELIPSIS)
03571         {
03572           <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"..."</font>));
03573         }
03574 
03575       <font class="keywordflow">if</font> (x-&gt;paramdecl != (typeExpr) 0)
03576         {                       <font class="comment">/* handle (void) */</font>
03577           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %q"</font>, 
03578                            lclTypeSpecNode_unparseComments (x-&gt;type),
03579                            <a class="code" href="abstract_c.html#a136">typeExpr_unparseNoBase</a> (x-&gt;paramdecl)));
03580         }
03581       <font class="keywordflow">else</font>
03582         {
03583           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a177">lclTypeSpecNode_unparseComments</a> (x-&gt;type));
03584         }
03585     }
03586   <font class="keywordflow">return</font> cstring_undefined;
03587 }
03588 
03589 <font class="comment">/*@only@*/</font> termNode
<a name="l03590"></a><a class="code" href="abstract_c.html#a179">03590</a> <a class="code" href="abstract_c.html#a179">makeIfTermNode</a> (ltoken ift, termNode ifn, ltoken thent, 
03591                 termNode thenn, ltoken elset, 
03592                 termNode elsen)<font class="keyword"></font>
03593 <font class="keyword"></font>{
03594   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03595   opFormNode opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ift, OPF_IF, opFormUnion_createMiddle (0),
03596                                       ltoken_undefined);
03597   nameNode nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
03598   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
03599 
03600   t-&gt;error_reported = FALSE;
03601   t-&gt;wrapped = 0;
03602   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, ifn);
03603   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, thenn);
03604   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, elsen);
03605   t-&gt;name = nn;
03606   t-&gt;args = args;
03607   t-&gt;kind = TRM_APPLICATION;
03608   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03609   t-&gt;given = t-&gt;sort;
03610   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
03611   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03612   
03613   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (thent);
03614   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (elset);
03615 
03616   <font class="keywordflow">return</font> (t);
03617 }
03618 
03619 <font class="keyword">static</font> <font class="comment">/*@observer@*/</font> ltoken
03620   nameNode2anyOp (nameNode n)<font class="keyword"></font>
03621 <font class="keyword"></font>{
03622   <font class="keywordflow">if</font> (n != (nameNode) 0)
03623     {
03624       opFormNode opnode = n-&gt;content.opform;
03625       opFormKind kind;
03626 
03627       llassert (opnode != NULL);
03628 
03629       kind = opnode-&gt;kind;
03630 
03631       <font class="keywordflow">if</font> (kind == OPF_MANYOPM || kind == OPF_ANYOP ||
03632           kind == OPF_MANYOP || kind == OPF_ANYOPM)
03633         {
03634           opFormUnion u;
03635 
03636           u = opnode-&gt;content;
03637           <font class="keywordflow">return</font> u.anyop;
03638         }
03639     }
03640   <font class="keywordflow">return</font> ltoken_undefined;
03641 }
03642 
03643 <font class="comment">/*@only@*/</font> termNode
<a name="l03644"></a><a class="code" href="abstract_c.html#a181">03644</a> <a class="code" href="abstract_c.html#a181">makeInfixTermNode</a> (termNode x, ltoken op, termNode y)<font class="keyword"></font>
03645 <font class="keyword"></font>{
03646   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03647   opFormNode opform;
03648   nameNode nn;
03649   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
03650   
03651   checkAssociativity (x, op);
03652 
03653   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (op, OPF_MANYOPM,
03654                            opFormUnion_createAnyOp (op), 
03655                            ltoken_undefined);
03656 
03657   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
03658 
03659   t-&gt;error_reported = FALSE;
03660   t-&gt;wrapped = 0;
03661   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, x);
03662   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, y);
03663   t-&gt;name = nn;
03664   t-&gt;args = args;
03665   t-&gt;kind = TRM_APPLICATION;
03666   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03667   t-&gt;given = t-&gt;sort;
03668   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();    <font class="comment">/* sort_equal */</font>
03669   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03670   <font class="keywordflow">return</font> (t);
03671 }
03672 
03673 <font class="comment">/*@only@*/</font> quantifiedTermNode
03674   quantifiedTermNode_copy (quantifiedTermNode q)<font class="keyword"></font>
03675 <font class="keyword"></font>{
03676   quantifiedTermNode ret = (quantifiedTermNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
03677 
03678   ret-&gt;quantifiers = <a class="code" href="quantifierNodeList_c.html#a3">quantifierNodeList_copy</a> (q-&gt;quantifiers);
03679   ret-&gt;open = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (q-&gt;open);
03680   ret-&gt;close = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (q-&gt;close);
03681   ret-&gt;body = <a class="code" href="abstract_c.html#a244">termNode_copySafe</a> (q-&gt;body);
03682 
03683   <font class="keywordflow">return</font> (ret);
03684 }
03685 
03686 <font class="comment">/*@only@*/</font> termNode
<a name="l03687"></a><a class="code" href="abstract_c.html#a182">03687</a> <a class="code" href="abstract_c.html#a182">makeQuantifiedTermNode</a> (quantifierNodeList qn, ltoken open,
03688                         termNode t, ltoken close)<font class="keyword"></font>
03689 <font class="keyword"></font>{
03690   sort sort;
03691   termNode n = (termNode) dmalloc (<font class="keyword">sizeof</font> (*n));
03692   quantifiedTermNode q = (quantifiedTermNode) dmalloc (<font class="keyword">sizeof</font> (*q));
03693 
03694   n-&gt;name = NULL; <font class="comment">/*&gt; missing this --- detected by lclint &lt;*/</font>
03695   n-&gt;error_reported = FALSE;
03696   n-&gt;wrapped = 0;
03697   n-&gt;error_reported = FALSE;
03698   n-&gt;kind = TRM_QUANTIFIER;
03699   n-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
03700   n-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03701   n-&gt;kind = TRM_UNCHANGEDALL;
03702   n-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> (); <font class="comment">/*&lt; forgot this &gt;*/</font>
03703 
03704   <a class="code" href="termNodeList_c.html#a16">termNodeList_free</a> (t-&gt;args);
03705   t-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
03706 
03707   sort = sort_bool;
03708   n-&gt;sort = sort;
03709   (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, sort);
03710 
03711   q-&gt;quantifiers = qn;
03712   q-&gt;open = open;
03713   q-&gt;close = close;
03714   q-&gt;body = t;
03715 
03716   n-&gt;quantified = q;
03717   <font class="keywordflow">return</font> (n);
03718 }
03719 
03720 <font class="comment">/*@only@*/</font> termNode
<a name="l03721"></a><a class="code" href="abstract_c.html#a183">03721</a> <a class="code" href="abstract_c.html#a183">makePostfixTermNode</a> (<font class="comment">/*@returned@*/</font> <font class="comment">/*@only@*/</font> termNode secondary, ltokenList postfixops)<font class="keyword"></font>
03722 <font class="keyword"></font>{
03723   termNode top = secondary;
03724 
03725   ltokenList_elements (postfixops, op)<font class="keyword"></font>
03726 <font class="keyword">    </font>{
03727       top = <a class="code" href="abstract_c.html#a184">makePostfixTermNode2</a> (top, ltoken_copy (op));
03728       <font class="comment">/*@i@*/</font> } end_ltokenList_elements;
03729 
03730   <a class="code" href="ltokenList_c.html#a14">ltokenList_free</a> (postfixops);
03731 
03732   <font class="keywordflow">return</font> (top); <font class="comment">/* dep as only? */</font>
03733 }
03734 
03735 <font class="comment">/*</font>
03736 <font class="comment">** secondary is returned in the args list</font>
03737 <font class="comment">*/</font>
03738 
03739 <font class="comment">/*@only@*/</font> termNode
<a name="l03740"></a><a class="code" href="abstract_c.html#a184">03740</a> <a class="code" href="abstract_c.html#a184">makePostfixTermNode2</a> (<font class="comment">/*@returned@*/</font> <font class="comment">/*@only@*/</font> termNode secondary, 
03741                       <font class="comment">/*@only@*/</font> ltoken postfixop)<font class="keyword"></font>
03742 <font class="keyword"></font>{
03743   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03744 
03745   opFormNode opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (postfixop,
03746                                       OPF_MANYOP, opFormUnion_createAnyOp (postfixop),
03747                                       ltoken_undefined);
03748   nameNode nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
03749   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
03750 
03751   t-&gt;error_reported = FALSE;
03752   t-&gt;wrapped = 0;
03753   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, secondary);
03754   t-&gt;name = nn;
03755   t-&gt;args = args;
03756   t-&gt;kind = TRM_APPLICATION;
03757   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03758   t-&gt;given = t-&gt;sort;
03759   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
03760   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03761   <font class="keywordflow">return</font> t;
03762 }
03763 
03764 <font class="comment">/*@only@*/</font> termNode
<a name="l03765"></a><a class="code" href="abstract_c.html#a185">03765</a> <a class="code" href="abstract_c.html#a185">makePrefixTermNode</a> (ltoken op, termNode arg)<font class="keyword"></font>
03766 <font class="keyword"></font>{
03767   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03768   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
03769   opFormNode opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (op, OPF_ANYOPM, opFormUnion_createAnyOp (op),
03770                                       ltoken_undefined);
03771   nameNode nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
03772 
03773   t-&gt;error_reported = FALSE;
03774   t-&gt;wrapped = 0;
03775   t-&gt;name = nn;
03776   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, arg);
03777   t-&gt;args = args;
03778   t-&gt;kind = TRM_APPLICATION;
03779   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03780   t-&gt;given = t-&gt;sort;
03781   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
03782   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03783   <font class="keywordflow">return</font> t;
03784 }
03785 
03786 <font class="comment">/*@only@*/</font> termNode
<a name="l03787"></a><a class="code" href="abstract_c.html#a186">03787</a> <a class="code" href="abstract_c.html#a186">makeOpCallTermNode</a> (ltoken op, ltoken open,
03788                     termNodeList args, ltoken close)<font class="keyword"></font>
03789 <font class="keyword"></font>{
03790   <font class="comment">/* like prefixTerm, but with opId LPAR termNodeList  RPAR */</font>
03791   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03792   nameNode nn = <a class="code" href="abstract_c.html#a99">makeNameNodeId</a> (op);
03793   
03794   t-&gt;error_reported = FALSE;
03795   t-&gt;wrapped = 0;
03796   t-&gt;name = nn;
03797   t-&gt;args = args;
03798   t-&gt;kind = TRM_APPLICATION;
03799   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03800   t-&gt;given = t-&gt;sort;
03801   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
03802   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03803 
03804   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (open);
03805   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (close);
03806 
03807   <font class="keywordflow">return</font> t;
03808 }
03809 
03810 <font class="comment">/*@exposed@*/</font> termNode
<a name="l03811"></a><a class="code" href="abstract_c.html#a187">03811</a> <a class="code" href="abstract_c.html#a187">CollapseInfixTermNode</a> (<font class="comment">/*@returned@*/</font> termNode secondary, termNodeList infix)<font class="keyword"></font>
03812 <font class="keyword"></font>{
03813   termNode left = secondary;
03814 
03815   termNodeList_elements (infix, node)<font class="keyword"></font>
03816 <font class="keyword">    </font>{
03817       <a class="code" href="termNodeList_c.html#a4">termNodeList_addl</a> (node-&gt;args, termNode_copySafe (left));
03818       left = node;
03819       <font class="comment">/*    computePossibleSorts (left); */</font>
03820     } end_termNodeList_elements;
03821 
03822   <font class="keywordflow">return</font> (left);
03823 }
03824 
03825 <font class="keyword">static</font> <font class="keywordtype">void</font>
03826 checkAssociativity (termNode x, ltoken op)<font class="keyword"></font>
03827 <font class="keyword"></font>{
03828   ltoken lastOpToken;
03829 
03830   <font class="keywordflow">if</font> (x-&gt;wrapped == 0 &amp;&amp;        <font class="comment">/* no parentheses */</font>
03831       x-&gt;kind == TRM_APPLICATION &amp;&amp; x-&gt;name != (nameNode) 0 &amp;&amp;
03832       (!x-&gt;name-&gt;isOpId))
03833     {
03834       lastOpToken = nameNode2anyOp (x-&gt;name);
03835 
03836       <font class="keywordflow">if</font> ((ltoken_getCode (lastOpToken) == logicalOp &amp;&amp;
03837            ltoken_getCode (op) == logicalOp) ||
03838           ((ltoken_getCode (lastOpToken) == simpleOp ||
03839             ltoken_getCode (lastOpToken) == LLT_MULOP) &amp;&amp;
03840            (ltoken_getCode (op) == simpleOp ||
03841             ltoken_getCode (op) == LLT_MULOP)))
03842         <font class="keywordflow">if</font> (ltoken_getText (lastOpToken) != ltoken_getText (op))
03843           {
03844             <a class="code" href="llerror_c.html#a54">lclerror</a> (op, 
03845                       message
03846                       (<font class="stringliteral">"Parentheses needed to specify associativity of %s and %s"</font>,
03847                        cstring_fromChars (lsymbol_toChars (ltoken_getText (lastOpToken))),
03848                        <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (ltoken_getText (op)))));
03849           }
03850     }
03851 }
03852 
03853 termNodeList
<a name="l03854"></a><a class="code" href="abstract_c.html#a188">03854</a> <a class="code" href="abstract_c.html#a188">pushInfixOpPartNode</a> (<font class="comment">/*@returned@*/</font> termNodeList x, ltoken op,
03855                      <font class="comment">/*@only@*/</font> termNode secondary)<font class="keyword"></font>
03856 <font class="keyword"></font>{
03857   termNode lastLeftTerm;
03858   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
03859   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03860   opFormNode opform;
03861   nameNode nn;
03862 
03863   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, secondary);
03864   
03865   <font class="keywordflow">if</font> (!termNodeList_empty (x))
03866     {
03867       <a class="code" href="termNodeList_c.html#a5">termNodeList_reset</a> (x);
03868       lastLeftTerm = <a class="code" href="termNodeList_c.html#a10">termNodeList_current</a> (x);
03869       checkAssociativity (lastLeftTerm, op);
03870     }
03871 
03872   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (op, OPF_MANYOPM, 
03873                            opFormUnion_createAnyOp (op), ltoken_undefined);
03874 
03875   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
03876 
03877   t-&gt;error_reported = FALSE;
03878   t-&gt;wrapped = 0;
03879   t-&gt;name = nn;
03880   t-&gt;kind = TRM_APPLICATION;
03881   t-&gt;args = args;
03882   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
03883   t-&gt;given = t-&gt;sort;
03884   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
03885   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
03886   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (x, t);
03887   <font class="comment">/* don't compute sort yet, do it in CollapseInfixTermNode */</font>
03888   <font class="keywordflow">return</font> (x);
03889 }
03890 
03891 termNode
<a name="l03892"></a><a class="code" href="abstract_c.html#a189">03892</a> <a class="code" href="abstract_c.html#a189">updateMatchedNode</a> (<font class="comment">/*@only@*/</font> termNode left, <font class="comment">/*@returned@*/</font> termNode t, 
03893                    <font class="comment">/*@only@*/</font> termNode right)<font class="keyword"></font>
03894 <font class="keyword"></font>{
03895   opFormNode op;
03896 
03897   <font class="keywordflow">if</font> ((t == (termNode) 0) || (t-&gt;name == NULL) || t-&gt;name-&gt;isOpId)
03898     {
03899       llbugexitlit (<font class="stringliteral">"updateMatchedNode: expect opForm in nameNode"</font>);
03900     }
03901 
03902   op = t-&gt;name-&gt;content.opform;
03903   llassert (op != NULL);
03904 
03905   <font class="keywordflow">if</font> (left == (termNode) 0)
03906     {
03907       <font class="keywordflow">if</font> (right == (termNode) 0)
03908         {
03909           <font class="comment">/* op-&gt;kind is not changed */</font>
03910           <a class="code" href="abstract_c.html#a243">termNode_free</a> (right);
03911         }
03912       <font class="keywordflow">else</font>
03913         {
03914           op-&gt;kind = OPF_MIDDLEM;
03915           op-&gt;key = opFormNode2key (op, OPF_MIDDLEM);
03916           <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (t-&gt;args, right);
03917         }
03918     }
03919   <font class="keywordflow">else</font>
03920     {
03921       <a class="code" href="termNodeList_c.html#a4">termNodeList_addl</a> (t-&gt;args, left);
03922       <font class="keywordflow">if</font> (right == (termNode) 0)
03923         {
03924           op-&gt;kind = OPF_MMIDDLE;
03925           op-&gt;key = opFormNode2key (op, OPF_MMIDDLE);
03926         }
03927       <font class="keywordflow">else</font>
03928         {
03929           op-&gt;kind = OPF_MMIDDLEM;
03930           op-&gt;key = opFormNode2key (op, OPF_MMIDDLEM);
03931           <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (t-&gt;args, right);
03932         }
03933     }
03934   <font class="keywordflow">return</font> t;
03935 }
03936 
03937 <font class="comment">/*@only@*/</font> termNode
<a name="l03938"></a><a class="code" href="abstract_c.html#a190">03938</a>   <a class="code" href="abstract_c.html#a190">updateSqBracketedNode</a> (<font class="comment">/*@only@*/</font> termNode left,
03939                          <font class="comment">/*@only@*/</font> <font class="comment">/*@returned@*/</font> termNode t,
03940                          <font class="comment">/*@only@*/</font> termNode right)<font class="keyword"></font>
03941 <font class="keyword"></font>{
03942   opFormNode op;
03943 
03944   <font class="keywordflow">if</font> ((t == (termNode) 0) || (t-&gt;name == NULL) || (t-&gt;name-&gt;isOpId))
03945     {
03946       llbugexitlit (<font class="stringliteral">"updateSqBracketededNode: expect opForm in nameNode"</font>);
03947     }
03948 
03949   op = t-&gt;name-&gt;content.opform;
03950   llassert (op != NULL);
03951 
03952   <font class="keywordflow">if</font> (left == (termNode) 0)
03953     {
03954       <font class="keywordflow">if</font> (right == (termNode) 0)
03955         {
03956           <font class="comment">/* op-&gt;kind is not changed */</font>
03957         }
03958       <font class="keywordflow">else</font>
03959         {
03960           op-&gt;kind = OPF_BMIDDLEM;
03961           op-&gt;key = opFormNode2key (op, OPF_BMIDDLEM);
03962           <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (t-&gt;args, right);
03963         }
03964     }
03965   <font class="keywordflow">else</font>
03966     {
03967       <a class="code" href="termNodeList_c.html#a4">termNodeList_addl</a> (t-&gt;args, left);
03968 
03969       <font class="keywordflow">if</font> (right == (termNode) 0)
03970         {
03971           op-&gt;kind = OPF_BMMIDDLE;
03972           op-&gt;key = opFormNode2key (op, OPF_BMMIDDLE);
03973         }
03974       <font class="keywordflow">else</font>
03975         {
03976           op-&gt;kind = OPF_BMMIDDLEM;
03977           op-&gt;key = opFormNode2key (op, OPF_BMMIDDLEM);
03978           <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (t-&gt;args, right);
03979         }
03980     }
03981   <font class="keywordflow">return</font> t;
03982 }
03983 
03984 <font class="comment">/*@only@*/</font> termNode
<a name="l03985"></a><a class="code" href="abstract_c.html#a191">03985</a> <a class="code" href="abstract_c.html#a191">makeSqBracketedNode</a> (ltoken lbracket,
03986                      termNodeList args, ltoken rbracket)<font class="keyword"></font>
03987 <font class="keyword"></font>{
03988   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
03989   <font class="keywordtype">int</font> size;
03990   opFormNode opform;
03991   nameNode nn;
03992 
03993   t-&gt;error_reported = FALSE;
03994   t-&gt;wrapped = 0;
03995   
03996   size = termNodeList_size (args);
03997   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (lbracket, OPF_BMIDDLE, opFormUnion_createMiddle (size),
03998                            rbracket);
03999   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
04000   t-&gt;name = nn;
04001   t-&gt;kind = TRM_APPLICATION;
04002   t-&gt;args = args;
04003   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04004   t-&gt;given = t-&gt;sort;
04005   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04006   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04007  <font class="comment">/* do sort checking later, not here, incomplete parse */</font>
04008   <font class="keywordflow">return</font> (t);
04009 }
04010 
04011 <font class="comment">/*@only@*/</font> termNode
<a name="l04012"></a><a class="code" href="abstract_c.html#a192">04012</a> <a class="code" href="abstract_c.html#a192">makeMatchedNode</a> (ltoken open, termNodeList args, ltoken close)<font class="keyword"></font>
04013 <font class="keyword"></font>{
04014   <font class="comment">/*   matched : open args close */</font>
04015   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
04016   <font class="keywordtype">int</font> size;
04017   opFormNode opform;
04018   nameNode nn;
04019 
04020   t-&gt;error_reported = FALSE;
04021   t-&gt;wrapped = 0;
04022   
04023   size = termNodeList_size (args);
04024   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (open, OPF_MIDDLE, opFormUnion_createMiddle (size), close);
04025   nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
04026   t-&gt;name = nn;
04027   t-&gt;kind = TRM_APPLICATION;
04028   t-&gt;args = args;
04029   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04030   t-&gt;given = t-&gt;sort;
04031   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04032   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04033  <font class="comment">/* do sort checking later, not here, incomplete parse */</font>
04034   <font class="keywordflow">return</font> (t);
04035 }
04036 
04037 <font class="comment">/*@only@*/</font> termNode
<a name="l04038"></a><a class="code" href="abstract_c.html#a193">04038</a> <a class="code" href="abstract_c.html#a193">makeSimpleTermNode</a> (ltoken varid)<font class="keyword"></font>
04039 <font class="keyword"></font>{
04040   sort theSort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04041   lsymbol sym;
04042   opInfo oi;
04043   varInfo vi;
04044   termNode n = (termNode) dmalloc (<font class="keyword">sizeof</font> (*n));
04045   
04046   n-&gt;error_reported = FALSE;
04047   n-&gt;wrapped = 0;
04048   n-&gt;name = (nameNode) 0;
04049   n-&gt;given = theSort;
04050   n-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
04051   n-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04052   n-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04053   
04054   sym = ltoken_getText (varid);
04055   
04056   <font class="comment">/* lookup current scope */</font>
04057     vi = <a class="code" href="symtable_c.html#a51">symtable_varInfoInScope</a> (g_symtab, sym);
04058 
04059   <font class="keywordflow">if</font> (varInfo_exists (vi))
04060     {
04061       theSort = vi-&gt;sort;
04062       n-&gt;kind = TRM_VAR;
04063       n-&gt;sort = theSort;
04064       n-&gt;literal = varid;
04065       (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, theSort);
04066     }
04067   <font class="keywordflow">else</font>
04068     {                           <font class="comment">/* need to handle LCL constants */</font>
04069       vi = <a class="code" href="symtable_c.html#a50">symtable_varInfo</a> (g_symtab, sym);
04070 
04071       <font class="keywordflow">if</font> (varInfo_exists (vi) &amp;&amp; vi-&gt;kind == VRK_CONST)
04072         {
04073           theSort = vi-&gt;sort;
04074           n-&gt;kind = TRM_CONST;
04075           n-&gt;sort = theSort;
04076           n-&gt;literal = varid;
04077           (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, theSort);
04078         }
04079       <font class="keywordflow">else</font>
04080         {                       <font class="comment">/* and LSL operators (true, false, new, nil, etc) */</font>
04081           nameNode nn = <a class="code" href="abstract_c.html#a99">makeNameNodeId</a> (ltoken_copy (varid));
04082           oi = <a class="code" href="symtable_c.html#a40">symtable_opInfo</a> (g_symtab, nn);
04083 
04084           <font class="keywordflow">if</font> (opInfo_exists (oi) &amp;&amp; (oi-&gt;name-&gt;isOpId) &amp;&amp;
04085               !sigNodeSet_isEmpty (oi-&gt;signatures))
04086             {
04087               sigNodeSet_elements (oi-&gt;signatures, x)<font class="keyword"></font>
04088 <font class="keyword">                </font>{
04089                   <font class="keywordflow">if</font> (ltokenList_empty (x-&gt;domain))
04090                     <font class="comment">/* yes, it really is empty, not not empty */</font>
04091                     {
04092                       lslOp op = (lslOp) dmalloc (<font class="keyword">sizeof</font> (*op));
04093                       
04094                       op-&gt;name = <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (nn);
04095                       op-&gt;signature = x;
04096                       (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, sigNode_rangeSort (x));
04097                       (<font class="keywordtype">void</font>) <a class="code" href="lslOpSet_c.html#a4">lslOpSet_insert</a> (n-&gt;possibleOps, op);
04098                     }
04099                 } end_sigNodeSet_elements;
04100             }
04101 
04102           <a class="code" href="abstract_c.html#a231">nameNode_free</a> (nn);
04103           
04104           <font class="keywordflow">if</font> (sortSet_size (n-&gt;possibleSorts) == 0)
04105             {
04106               lclerror 
04107                 (varid, 
04108                  <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Unrecognized identifier (constant, variable or operator): %s"</font>,
04109                           ltoken_getRawString (varid)));
04110 
04111             }
04112           
04113           n-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04114           n-&gt;literal = varid;
04115           n-&gt;kind = TRM_ZEROARY;
04116         }
04117     }
04118 
04119   <font class="keywordflow">return</font> (n);
04120 }
04121 
04122 <font class="comment">/*@only@*/</font> termNode
<a name="l04123"></a><a class="code" href="abstract_c.html#a194">04123</a> <a class="code" href="abstract_c.html#a194">makeSelectTermNode</a> (termNode pri, ltoken select, <font class="comment">/*@dependent@*/</font> ltoken id)<font class="keyword"></font>
04124 <font class="keyword"></font>{
04125   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
04126   opFormNode opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (select,
04127                                       OPF_MSELECT, opFormUnion_createAnyOp (id),
04128                                       ltoken_undefined);
04129   nameNode nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
04130   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
04131 
04132   t-&gt;error_reported = FALSE;
04133   t-&gt;wrapped = 0;
04134   t-&gt;name = nn;
04135   t-&gt;kind = TRM_APPLICATION;
04136   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, pri);
04137   t-&gt;args = args;
04138   t-&gt;kind = TRM_APPLICATION;
04139   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04140   t-&gt;given = t-&gt;sort;
04141   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04142   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04143 
04144   <font class="keywordflow">return</font> t;
04145 }
04146 
04147 <font class="comment">/*@only@*/</font> termNode
<a name="l04148"></a><a class="code" href="abstract_c.html#a195">04148</a> <a class="code" href="abstract_c.html#a195">makeMapTermNode</a> (termNode pri, ltoken map, <font class="comment">/*@dependent@*/</font> ltoken id)<font class="keyword"></font>
04149 <font class="keyword"></font>{
04150   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
04151   opFormNode opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (map, OPF_MMAP, opFormUnion_createAnyOp (id),
04152                                       ltoken_undefined);
04153   nameNode nn = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
04154   termNodeList args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
04155 
04156   t-&gt;error_reported = FALSE;
04157   t-&gt;wrapped = 0;
04158   t-&gt;kind = TRM_APPLICATION;
04159   t-&gt;name = nn;
04160   <a class="code" href="termNodeList_c.html#a2">termNodeList_addh</a> (args, pri);
04161   t-&gt;args = args;
04162   t-&gt;kind = TRM_APPLICATION;
04163   t-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04164   t-&gt;given = t-&gt;sort;
04165   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04166   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04167   <font class="keywordflow">return</font> t;
04168 }
04169 
04170 <font class="comment">/*@only@*/</font> termNode
<a name="l04171"></a><a class="code" href="abstract_c.html#a196">04171</a> <a class="code" href="abstract_c.html#a196">makeLiteralTermNode</a> (ltoken tok, sort s)<font class="keyword"></font>
04172 <font class="keyword"></font>{
04173   nameNode nn = <a class="code" href="abstract_c.html#a99">makeNameNodeId</a> (ltoken_copy (tok));
04174   opInfo oi = <a class="code" href="symtable_c.html#a40">symtable_opInfo</a> (g_symtab, nn);
04175   lslOp op = (lslOp) dmalloc (<font class="keyword">sizeof</font> (*op));  
04176   termNode n = (termNode) dmalloc (<font class="keyword">sizeof</font> (*n));
04177   sigNode sign;
04178   ltoken range;
04179 
04180   n-&gt;name = nn;
04181   n-&gt;error_reported = FALSE;
04182   n-&gt;wrapped = 0;
04183   n-&gt;kind = TRM_LITERAL;
04184   n-&gt;literal = tok;
04185   n-&gt;given = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04186   n-&gt;sort = n-&gt;given;
04187   n-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
04188   n-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04189   n-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04190 
04191   <font class="comment">/* look up signatures for this operator too */</font>
04192   
04193   range = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, sort_getLsymbol (s));
04194   sign = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, ltokenList_new (), 
04195                             <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (range));
04196   
04197   <font class="keywordflow">if</font> (opInfo_exists (oi) &amp;&amp; (oi-&gt;name-&gt;isOpId) 
04198       &amp;&amp; (sigNodeSet_size (oi-&gt;signatures) &gt; 0))
04199     {
04200       sigNodeSet_elements (oi-&gt;signatures, x)<font class="keyword"></font>
04201 <font class="keyword">        </font>{
04202           <font class="keywordflow">if</font> (ltokenList_empty (x-&gt;domain))
04203             {
04204               lslOp opn = (lslOp) dmalloc (<font class="keyword">sizeof</font> (*opn));
04205               sort sort;
04206 
04207               opn-&gt;name = <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (nn);
04208               opn-&gt;signature = x;
04209               sort = <a class="code" href="abstract_c.html#a224">sigNode_rangeSort</a> (x);
04210               (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, sort);
04211               (<font class="keywordtype">void</font>) <a class="code" href="lslOpSet_c.html#a4">lslOpSet_insert</a> (n-&gt;possibleOps, opn);
04212             }
04213         } end_sigNodeSet_elements;
04214     }
04215   
04216   <font class="comment">/* insert into literal term */</font>
04217   (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, s);
04218   
04219   op-&gt;name = <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (nn);
04220   op-&gt;signature = sign;
04221   (<font class="keywordtype">void</font>) <a class="code" href="lslOpSet_c.html#a4">lslOpSet_insert</a> (n-&gt;possibleOps, op);
04222 
04223   <font class="comment">/* enter the literal as an operator into the operator table */</font>
04224   <font class="comment">/* 8/9/93.  C's char constant 'c' syntax conflicts</font>
04225 <font class="comment">     with LSL's lslinit.lsi table.  Throw out, because it's not</font>
04226 <font class="comment">     needed anyway.  */</font>
04227   <font class="comment">/*  symtable_enterOp (g_symtab, nn, sign); */</font>
04228 
04229   <font class="keywordflow">if</font> (s == sort_int)
04230     {
04231       sigNode osign;
04232       lslOp opn = (lslOp) dmalloc (<font class="keyword">sizeof</font> (*opn));
04233 
04234       <font class="comment">/* if it is a C int, we should overload it as double too because</font>
04235 <font class="comment">         C allows you to say "x &gt; 2". */</font>
04236       
04237       (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (n-&gt;possibleSorts, sort_double);
04238       
04239       ltoken_setText (range, lsymbol_fromChars (<font class="stringliteral">"double"</font>));
04240       osign = <a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_undefined, ltokenList_new (), range);
04241       opn-&gt;name = <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (nn);
04242       opn-&gt;signature = osign;
04243       (<font class="keywordtype">void</font>) <a class="code" href="lslOpSet_c.html#a4">lslOpSet_insert</a> (n-&gt;possibleOps, opn);
04244       
04245       <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nameNode_copySafe (nn), <a class="code" href="abstract_c.html#a239">sigNode_copy</a> (osign));
04246     }
04247   <font class="keywordflow">else</font>
04248     {
04249       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (range);
04250     }
04251       
04252   <font class="comment">/* future: could overload cstrings to be both char_Vec as well as</font>
04253 <font class="comment">     char_ObjPtr */</font>
04254   
04255   <font class="comment">/*@-mustfree@*/</font>
04256   <font class="keywordflow">return</font> n;
04257 } <font class="comment">/*@=mustfree@*/</font>
04258 
04259 <font class="comment">/*@only@*/</font> termNode
<a name="l04260"></a><a class="code" href="abstract_c.html#a197">04260</a> <a class="code" href="abstract_c.html#a197">makeUnchangedTermNode1</a> (ltoken op, <font class="comment">/*@unused@*/</font> ltoken all)<font class="keyword"></font>
04261 <font class="keyword"></font>{
04262   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
04263 
04264   t-&gt;error_reported = FALSE;
04265   t-&gt;wrapped = 0;
04266   t-&gt;kind = TRM_UNCHANGEDALL;
04267   t-&gt;sort = sort_bool;
04268   t-&gt;literal = op;
04269   t-&gt;given = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04270   t-&gt;name = NULL; <font class="comment">/*&lt; missing this &gt;*/</font>
04271   t-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
04272   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04273   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04274   (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (t-&gt;possibleSorts, t-&gt;sort);
04275 
04276   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (all);
04277 
04278   <font class="keywordflow">return</font> t;
04279 }
04280 
04281 <font class="comment">/*@only@*/</font> termNode
<a name="l04282"></a><a class="code" href="abstract_c.html#a198">04282</a> <a class="code" href="abstract_c.html#a198">makeUnchangedTermNode2</a> (ltoken op, storeRefNodeList x)<font class="keyword"></font>
04283 <font class="keyword"></font>{
04284   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
04285   ltoken errtok;
04286   sort sort;
04287 
04288   t-&gt;name = NULL; <font class="comment">/*&lt; missing this &gt;*/</font>
04289   t-&gt;error_reported = FALSE;
04290   t-&gt;wrapped = 0;
04291   t-&gt;kind = TRM_UNCHANGEDOTHERS;
04292   t-&gt;sort = sort_bool;
04293   t-&gt;literal = op;
04294   t-&gt;unchanged = x;
04295   t-&gt;given = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04296   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04297   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04298   t-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> ();
04299 
04300   (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (t-&gt;possibleSorts, t-&gt;sort);
04301   <font class="comment">/* check storeRefNode's are mutable, uses sort of term */</font>
04302   
04303   storeRefNodeList_elements (x, sto)<font class="keyword"></font>
04304 <font class="keyword">    </font>{
04305       <font class="keywordflow">if</font> (storeRefNode_isTerm (sto))
04306         {
04307           sort = sto-&gt;content.term-&gt;sort;
04308           <font class="keywordflow">if</font> (!<a class="code" href="sort_c.html#a103">sort_mutable</a> (sort))
04309             {
04310               errtok = <a class="code" href="abstract_c.html#a74">termNode_errorToken</a> (sto-&gt;content.term);
04311               <a class="code" href="llerror_c.html#a54">lclerror</a> (errtok, 
04312                         message (<font class="stringliteral">"Term denoting immutable object used in unchanged list: %q"</font>,
04313                                  termNode_unparse (sto-&gt;content.term)));
04314             }
04315         }
04316       <font class="keywordflow">else</font>
04317         {
04318           <font class="keywordflow">if</font> (storeRefNode_isType (sto))
04319             {
04320               lclTypeSpecNode type = sto-&gt;content.type;
04321               sort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (type);
04322               <font class="keywordflow">if</font> (!<a class="code" href="sort_c.html#a103">sort_mutable</a> (sort))
04323                 {
04324                   errtok = <a class="code" href="abstract_c.html#a76">lclTypeSpecNode_errorToken</a> (type);
04325                   <a class="code" href="llerror_c.html#a54">lclerror</a> (errtok, message (<font class="stringliteral">"Immutable type used in unchanged list: %q"</font>,
04326                                              sort_unparse (sort)));
04327                 }
04328             }
04329         }
04330     } end_storeRefNodeList_elements;
04331   
04332   <font class="keywordflow">return</font> t;
04333 }
04334 
04335 <font class="comment">/*@only@*/</font> termNode
<a name="l04336"></a><a class="code" href="abstract_c.html#a199">04336</a>   <a class="code" href="abstract_c.html#a199">makeSizeofTermNode</a> (ltoken op, lclTypeSpecNode type)<font class="keyword"></font>
04337 <font class="keyword"></font>{
04338   termNode t = (termNode) dmalloc (<font class="keyword">sizeof</font> (*t));
04339   
04340   t-&gt;name = NULL; <font class="comment">/*&lt; missing this &gt;*/</font>
04341   t-&gt;error_reported = FALSE;
04342   t-&gt;wrapped = 0;
04343   t-&gt;kind = TRM_SIZEOF;
04344   t-&gt;sort = sort_int;
04345   t-&gt;literal = op;
04346   t-&gt;sizeofField = type;
04347   t-&gt;given = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
04348   t-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a0">sortSet_new</a> ();
04349   t-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a1">lslOpSet_new</a> ();
04350   t-&gt;args = <a class="code" href="termNodeList_c.html#a0">termNodeList_new</a> (); 
04351 
04352   (<font class="keywordtype">void</font>) <a class="code" href="sortSet_c.html#a3">sortSet_insert</a> (t-&gt;possibleSorts, t-&gt;sort);
04353   <font class="comment">/* nothing to check */</font>
04354   <font class="keywordflow">return</font> (t);
04355 }
04356 
04357 <font class="comment">/*@only@*/</font> cstring
<a name="l04358"></a><a class="code" href="abstract_c.html#a200">04358</a> <a class="code" href="abstract_c.html#a200">claimNode_unparse</a> (claimNode c)<font class="keyword"></font>
04359 <font class="keyword"></font>{
04360   <font class="keywordflow">if</font> (c != (claimNode) 0)
04361     {
04362       cstring s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"claims (%q)%q{\n%q"</font>, 
04363                            paramNodeList_unparse (c-&gt;params),
04364                            <a class="code" href="varDeclarationNodeList_c.html#a3">varDeclarationNodeList_unparse</a> (c-&gt;globals),
04365                            lclPredicateNode_unparse (c-&gt;require));
04366 
04367       <font class="keywordflow">if</font> (c-&gt;body != NULL)
04368         {
04369           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%qbody {%q}\n"</font>, s, programNode_unparse (c-&gt;body));
04370         }
04371       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q}\n"</font>, s, lclPredicateNode_unparse (c-&gt;ensures));
04372       <font class="keywordflow">return</font> s;
04373     }
04374   <font class="keywordflow">return</font> cstring_undefined;
04375 }
04376 
04377 <font class="keyword">static</font> <font class="keywordtype">void</font>
04378 WrongArity (ltoken tok, <font class="keywordtype">int</font> expect, <font class="keywordtype">int</font> size)<font class="keyword"></font>
04379 <font class="keyword"></font>{
04380   <a class="code" href="llerror_c.html#a54">lclerror</a> (tok, message (<font class="stringliteral">"Expecting %d arguments but given %d"</font>, expect, size));
04381 }
04382 
04383 <font class="keyword">static</font> cstring
04384 printTermNode2 (<font class="comment">/*@null@*/</font> opFormNode op, termNodeList args, sort sort)<font class="keyword"></font>
04385 <font class="keyword"></font>{
04386   <font class="keywordflow">if</font> (op != (opFormNode) 0)
04387     {
04388       cstring s = cstring_undefined;
04389       cstring sortText;
04390       cstring sortSpace;
04391 
04392       <font class="keywordflow">if</font> (sort != <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ())
04393         {
04394           sortText = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">": %s"</font>, cstring_fromChars (lsymbol_toChars (sort_getLsymbol (sort))));
04395           sortSpace = cstring_makeLiteral (<font class="stringliteral">" "</font>);
04396         }
04397       <font class="keywordflow">else</font>
04398         {
04399           sortText = cstring_undefined;
04400           sortSpace = cstring_undefined;
04401         }
04402 
04403       <font class="keywordflow">switch</font> (op-&gt;kind)
04404         {
04405         <font class="keywordflow">case</font> OPF_IF:
04406           {
04407             <font class="keywordtype">int</font> size = termNodeList_size (args);
04408 
04409             <font class="keywordflow">if</font> (size == 3)
04410               {
04411                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"if %q then %q else %q\n"</font>,
04412                              termNode_unparse (termNodeList_getN (args, 0)),
04413                              <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (termNodeList_getN (args, 1)),
04414                              <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (termNodeList_getN (args, 2)));
04415               }
04416             <font class="keywordflow">else</font>
04417               {
04418                 WrongArity (op-&gt;tok, 3, size);
04419                 s = cstring_makeLiteral (<font class="stringliteral">"if __ then __ else __"</font>);
04420               }
04421             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04422             <font class="keywordflow">break</font>;
04423           }
04424         <font class="keywordflow">case</font> OPF_ANYOP:
04425           {                     <font class="comment">/* ymtan ? */</font>
04426             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s %s"</font>, 
04427                          ltoken_getRawString (op-&gt;content.anyop), 
04428                          sortText);
04429             <font class="keywordflow">break</font>;
04430           }
04431         <font class="keywordflow">case</font> OPF_MANYOP:
04432           {
04433             <font class="keywordtype">int</font> size = termNodeList_size (args);
04434 
04435             <font class="keywordflow">if</font> (size == 1)
04436               {
04437                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q "</font>, termNode_unparse (termNodeList_head (args)));
04438               }
04439             <font class="keywordflow">else</font>
04440               {
04441                 WrongArity (op-&gt;content.anyop, 1, size);
04442                 s = cstring_makeLiteral (<font class="stringliteral">"__ "</font>);
04443               }
04444             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s%s"</font>, s, ltoken_getRawString (op-&gt;content.anyop),
04445                          sortText);
04446             <font class="keywordflow">break</font>;
04447           }
04448         <font class="keywordflow">case</font> OPF_ANYOPM:
04449           {
04450             <font class="keywordtype">int</font> size = termNodeList_size (args);
04451 
04452             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s "</font>, ltoken_getRawString (op-&gt;content.anyop));
04453 
04454             <font class="keywordflow">if</font> (size == 1)
04455               {
04456                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q"</font>, s, termNode_unparse (termNodeList_head (args)));
04457               }
04458             <font class="keywordflow">else</font>
04459               {
04460                 WrongArity (op-&gt;content.anyop, 1, size);
04461                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q__"</font>, s);
04462               }
04463             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04464             <font class="keywordflow">break</font>;
04465           }
04466         <font class="keywordflow">case</font> OPF_MANYOPM:
04467           {
04468             <font class="keywordtype">int</font> size = termNodeList_size (args);
04469 
04470             <font class="keywordflow">if</font> (size == 2)
04471               {
04472                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q %s %q"</font>,
04473                              termNode_unparse (termNodeList_getN (args, 0)),
04474                              ltoken_getRawString (op-&gt;content.anyop),
04475                              <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (termNodeList_getN (args, 1)));
04476               }
04477             <font class="keywordflow">else</font>
04478               {
04479                 WrongArity (op-&gt;content.anyop, 2, size);
04480                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ %s __"</font>, ltoken_getRawString (op-&gt;content.anyop));
04481               }
04482             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04483             <font class="keywordflow">break</font>;
04484           }
04485         <font class="keywordflow">case</font> OPF_MIDDLE:
04486           {
04487             <font class="keywordtype">int</font> size = termNodeList_size (args);
04488             <font class="keywordtype">int</font> expect = op-&gt;content.middle;
04489             
04490             <font class="comment">/* ymtan ? use { or openSym token ? */</font>
04491             
04492             <font class="keywordflow">if</font> (size == expect)
04493               {
04494                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"{%q}"</font>, termNodeList_unparse (args));
04495               }
04496             <font class="keywordflow">else</font>
04497               {
04498                 WrongArity (op-&gt;tok, expect, size);
04499                 s = cstring_makeLiteral (<font class="stringliteral">"{ * }"</font>);
04500               }
04501 
04502             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04503             <font class="keywordflow">break</font>; <font class="comment">/*** &lt;&lt;&lt;--- bug detected by LCLint ***/</font>
04504           }
04505         <font class="keywordflow">case</font> OPF_MMIDDLE:
04506           {
04507             <font class="keywordtype">int</font> size = termNodeList_size (args);
04508             <font class="keywordtype">int</font> expect = op-&gt;content.middle + 1;
04509 
04510             <font class="keywordflow">if</font> (size == expect)
04511               {
04512                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q{%q}"</font>,
04513                              termNode_unparse (termNodeList_head (args)),
04514                              <a class="code" href="termNodeList_c.html#a13">termNodeList_unparseTail</a> (args));
04515               }
04516             <font class="keywordflow">else</font>
04517               {
04518                 WrongArity (op-&gt;tok, expect, size);
04519                 s = cstring_makeLiteral (<font class="stringliteral">"__ { * }"</font>);
04520               }
04521 
04522             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04523             <font class="keywordflow">break</font>;
04524           }
04525         <font class="keywordflow">case</font> OPF_MIDDLEM:
04526           {
04527             <font class="keywordtype">int</font> size = termNodeList_size (args);
04528             <font class="keywordtype">int</font> expect = op-&gt;content.middle + 1;
04529 
04530             <font class="keywordflow">if</font> (size == expect)
04531               {
04532                 <a class="code" href="termNodeList_c.html#a6">termNodeList_finish</a> (args);
04533 
04534                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"{%q}%s%s%q"</font>,
04535                              termNodeList_unparseToCurrent (args),
04536                              sortText, sortSpace,
04537                              <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (termNodeList_current (args)));
04538               }
04539             <font class="keywordflow">else</font>
04540               {
04541                 WrongArity (op-&gt;tok, expect, size);
04542 
04543                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"{ * }%s __"</font>, sortText);
04544 
04545                <font class="comment">/* used to put in extra space! evs 94-01-05 */</font>
04546               }
04547             <font class="keywordflow">break</font>;
04548           }
04549         <font class="keywordflow">case</font> OPF_MMIDDLEM:
04550           {
04551             <font class="keywordtype">int</font> size = termNodeList_size (args);
04552             <font class="keywordtype">int</font> expect = op-&gt;content.middle + 2;
04553 
04554             <font class="keywordflow">if</font> (size == expect)
04555               {
04556                 <a class="code" href="termNodeList_c.html#a6">termNodeList_finish</a> (args);
04557 
04558                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q {%q} %s%s%q"</font>,
04559                              termNode_unparse (termNodeList_head (args)),
04560                              <a class="code" href="termNodeList_c.html#a15">termNodeList_unparseSecondToCurrent</a> (args),
04561                              sortText, sortSpace,
04562                              <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (termNodeList_current (args)));
04563               }
04564             <font class="keywordflow">else</font>
04565               {
04566                 WrongArity (op-&gt;tok, expect, size);
04567                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"__ { * } %s __"</font>, sortText);
04568 
04569                <font class="comment">/* also had extra space? */</font>
04570               }
04571             <font class="keywordflow">break</font>;
04572           }
04573         <font class="keywordflow">case</font> OPF_BMIDDLE:
04574           {
04575             <font class="keywordtype">int</font> size = termNodeList_size (args);
04576             <font class="keywordtype">int</font> expect = op-&gt;content.middle;
04577 
04578             <font class="keywordflow">if</font> (size == expect)
04579               {
04580                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[%q]"</font>, termNodeList_unparse (args));
04581               }
04582             <font class="keywordflow">else</font>
04583               {
04584                 WrongArity (op-&gt;tok, expect, size);
04585                 s = cstring_makeLiteral (<font class="stringliteral">"[ * ]"</font>);
04586               }
04587             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04588             <font class="keywordflow">break</font>;
04589           }
04590         <font class="keywordflow">case</font> OPF_BMMIDDLE:
04591           {
04592             <font class="keywordtype">int</font> size = termNodeList_size (args);
04593             <font class="keywordtype">int</font> expect = op-&gt;content.middle + 1;
04594 
04595             <font class="keywordflow">if</font> (size == expect)
04596               {
04597                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q[%q]"</font>,
04598                              termNode_unparse (termNodeList_head (args)),
04599                              <a class="code" href="termNodeList_c.html#a13">termNodeList_unparseTail</a> (args));
04600               }
04601             <font class="keywordflow">else</font>
04602               {
04603                 WrongArity (op-&gt;tok, expect, size);
04604                 s = cstring_makeLiteral (<font class="stringliteral">"__ [ * ]"</font>);
04605               }
04606 
04607             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04608             <font class="keywordflow">break</font>;
04609           }
04610         <font class="keywordflow">case</font> OPF_BMMIDDLEM:
04611           {
04612             <font class="keywordtype">int</font> size = termNodeList_size (args);
04613             <font class="keywordtype">int</font> expect = op-&gt;content.middle + 1;
04614 
04615             <font class="keywordflow">if</font> (size == expect)
04616               {
04617                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q[%q] __"</font>,
04618                              termNode_unparse (termNodeList_head (args)),
04619                              <a class="code" href="termNodeList_c.html#a13">termNodeList_unparseTail</a> (args));
04620               }
04621             <font class="keywordflow">else</font>
04622               {
04623                 WrongArity (op-&gt;tok, expect, size);
04624                 s = cstring_makeLiteral (<font class="stringliteral">"__ [ * ] __"</font>);
04625               }
04626             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s"</font>, s, sortText);
04627             <font class="keywordflow">break</font>;
04628           }
04629         <font class="keywordflow">case</font> OPF_BMIDDLEM:
04630           {
04631             <font class="keywordtype">int</font> size = termNodeList_size (args);
04632             <font class="keywordtype">int</font> expect = op-&gt;content.middle + 1;
04633 
04634             <font class="keywordflow">if</font> (size == expect)
04635               {
04636                 <a class="code" href="termNodeList_c.html#a6">termNodeList_finish</a> (args);
04637 
04638                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[%q]%s%s%q"</font>,
04639                              termNodeList_unparseToCurrent (args),
04640                              sortText, sortSpace,
04641                              <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (termNodeList_current (args)));
04642               }
04643             <font class="keywordflow">else</font>
04644               {
04645                 WrongArity (op-&gt;tok, expect, size);
04646                 s = cstring_makeLiteral (<font class="stringliteral">"[ * ] __"</font>);
04647               }
04648             
04649             <font class="keywordflow">break</font>;
04650           }
04651         <font class="keywordflow">case</font> OPF_SELECT:
04652           {                     <font class="comment">/* ymtan constant, check args ? */</font>
04653             s = <a class="code" href="cstring_c.html#a44">cstring_prependChar</a> (<font class="charliteral">'.'</font>, ltoken_getRawString (op-&gt;content.id));
04654             <font class="keywordflow">break</font>;
04655           }
04656         <font class="keywordflow">case</font> OPF_MAP:
04657           s = <a class="code" href="cstring_c.html#a42">cstring_concat</a> (cstring_makeLiteralTemp (<font class="stringliteral">"-&gt;"</font>), 
04658                               ltoken_getRawString (op-&gt;content.id));
04659           <font class="keywordflow">break</font>;
04660         <font class="keywordflow">case</font> OPF_MSELECT:
04661           {
04662             <font class="keywordtype">int</font> size = termNodeList_size (args);
04663 
04664             <font class="keywordflow">if</font> (size == 1)
04665               {
04666                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q.%s"</font>, termNode_unparse (termNodeList_head (args)),
04667                              ltoken_getRawString (op-&gt;content.id));
04668               }
04669             <font class="keywordflow">else</font>
04670               {
04671                 WrongArity (op-&gt;content.id, 1, size);
04672                 s = <a class="code" href="cstring_c.html#a42">cstring_concat</a> (cstring_makeLiteralTemp (<font class="stringliteral">"__."</font>), 
04673                                     ltoken_getRawString (op-&gt;content.id));
04674               }
04675             <font class="keywordflow">break</font>;
04676           }
04677         <font class="keywordflow">case</font> OPF_MMAP:
04678           {
04679             <font class="keywordtype">int</font> size = termNodeList_size (args);
04680 
04681             <font class="keywordflow">if</font> (size == 1)
04682               {
04683                 s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q-&gt;%s"</font>, termNode_unparse (termNodeList_head (args)),
04684                              ltoken_getRawString (op-&gt;content.id));
04685               }
04686             <font class="keywordflow">else</font>
04687               {
04688                 WrongArity (op-&gt;content.id, 1, size);
04689                 s = <a class="code" href="cstring_c.html#a42">cstring_concat</a> (cstring_makeLiteralTemp (<font class="stringliteral">"__-&gt;"</font>), 
04690                                     ltoken_getRawString (op-&gt;content.id));
04691               }
04692             <font class="keywordflow">break</font>;
04693           }
04694         }
04695 
04696       <a class="code" href="cstring_c.html#a27">cstring_free</a> (sortSpace);
04697       <a class="code" href="cstring_c.html#a27">cstring_free</a> (sortText);
04698       <font class="keywordflow">return</font> s;
04699     }
04700   <font class="keywordflow">return</font> cstring_undefined;
04701 }
04702 
04703 <font class="comment">/*@only@*/</font> cstring
<a name="l04704"></a><a class="code" href="abstract_c.html#a203">04704</a> <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (<font class="comment">/*@null@*/</font> termNode n)<font class="keyword"></font>
04705 <font class="keyword"></font>{
04706   cstring s = cstring_undefined;
04707   cstring back = cstring_undefined;
04708   cstring front = cstring_undefined;
04709   <font class="keywordtype">int</font> count;
04710 
04711   <font class="keywordflow">if</font> (n != (termNode) 0)
04712     {
04713       <font class="keywordflow">for</font> (count = n-&gt;wrapped; count &gt; 0; count--)
04714         {
04715           front = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (front, <font class="charliteral">'('</font>);
04716           back = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (back, <font class="charliteral">')'</font>);
04717         }
04718 
04719       <font class="keywordflow">switch</font> (n-&gt;kind)
04720         {
04721         <font class="keywordflow">case</font> TRM_LITERAL:
04722         <font class="keywordflow">case</font> TRM_CONST:
04723         <font class="keywordflow">case</font> TRM_VAR:
04724         <font class="keywordflow">case</font> TRM_ZEROARY:
04725           s = <a class="code" href="cstring_c.html#a9">cstring_copy</a> (ltoken_getRawString (n-&gt;literal));
04726           <font class="keywordflow">break</font>;
04727         <font class="keywordflow">case</font> TRM_APPLICATION:
04728           {
04729             nameNode nn = n-&gt;name;
04730             <font class="keywordflow">if</font> (nn != (nameNode) 0)
04731               {
04732                 <font class="keywordflow">if</font> (nn-&gt;isOpId)
04733                   {
04734                     s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s (%q) "</font>,
04735                                  ltoken_getRawString (nn-&gt;content.opid),
04736                                  <a class="code" href="termNodeList_c.html#a12">termNodeList_unparse</a> (n-&gt;args));
04737                    <font class="comment">/* must we handle n-&gt;given ? skip for now */</font>
04738                   }
04739                 <font class="keywordflow">else</font>
04740                   {
04741                     s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q "</font>, printTermNode2 (nn-&gt;content.opform, n-&gt;args, n-&gt;given));
04742                   }
04743               }
04744             <font class="keywordflow">else</font>
04745               {
04746                 llfatalbug
04747                   (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"termNode_unparse: expect non-empty nameNode: TRM_APPLICATION: %q"</font>,
04748                             nameNode_unparse (nn)));
04749               }
04750             <font class="keywordflow">break</font>;
04751           }
04752         <font class="keywordflow">case</font> TRM_UNCHANGEDALL:
04753           s = cstring_makeLiteral (<font class="stringliteral">"unchanged (all)"</font>);
04754           <font class="keywordflow">break</font>;
04755         <font class="keywordflow">case</font> TRM_UNCHANGEDOTHERS:
04756           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"unchanged (%q)"</font>, storeRefNodeList_unparse (n-&gt;unchanged));
04757           <font class="keywordflow">break</font>;
04758         <font class="keywordflow">case</font> TRM_SIZEOF:
04759           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"sizeof (%q)"</font>, lclTypeSpecNode_unparse (n-&gt;sizeofField));
04760           <font class="keywordflow">break</font>;
04761         <font class="keywordflow">case</font> TRM_QUANTIFIER:
04762           {
04763             quantifiedTermNode x = n-&gt;quantified;
04764             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s%q%s"</font>,
04765                          quantifierNodeList_unparse (x-&gt;quantifiers),
04766                          ltoken_getRawString (x-&gt;open),
04767                          <a class="code" href="abstract_c.html#a203">termNode_unparse</a> (x-&gt;body),
04768                          ltoken_getRawString (x-&gt;close));
04769             <font class="keywordflow">break</font>;
04770           }
04771         }
04772     }
04773   <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q%q"</font>, front, s, back));
04774 }
04775 
04776 <font class="keyword">static</font> <font class="keywordtype">void</font> modifyNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> modifyNode m)<font class="keyword"></font>
04777 <font class="keyword"></font>{
04778   <font class="keywordflow">if</font> (m != (modifyNode) 0)
04779     {
04780       
04781       <font class="keywordflow">if</font> (m-&gt;hasStoreRefList)
04782         {
04783           <a class="code" href="storeRefNodeList_c.html#a5">storeRefNodeList_free</a> (m-&gt;list);
04784           <font class="comment">/*@-branchstate@*/</font> 
04785         } 
04786       <font class="comment">/*@=branchstate@*/</font>
04787 
04788       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (m-&gt;tok);
04789       <a class="code" href="general_c.html#a0">sfree</a> (m);
04790     }
04791 }
04792 
04793 <font class="comment">/*@only@*/</font> cstring
<a name="l04794"></a><a class="code" href="abstract_c.html#a205">04794</a> <a class="code" href="abstract_c.html#a205">modifyNode_unparse</a> (<font class="comment">/*@null@*/</font> modifyNode m)<font class="keyword"></font>
04795 <font class="keyword"></font>{
04796   <font class="keywordflow">if</font> (m != (modifyNode) 0)
04797     {
04798       <font class="keywordflow">if</font> (m-&gt;hasStoreRefList)
04799         {
04800           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"  modifies %q; \n"</font>, storeRefNodeList_unparse (m-&gt;list)));
04801         }
04802       <font class="keywordflow">else</font>
04803         {
04804           <font class="keywordflow">if</font> (m-&gt;modifiesNothing)
04805             {
04806               <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"modifies nothing; \n"</font>));
04807             }
04808           <font class="keywordflow">else</font>
04809             {
04810               <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"modifies anything; \n"</font>));
04811             }
04812         }
04813     }
04814   <font class="keywordflow">return</font> cstring_undefined;
04815 }
04816 
04817 <font class="comment">/*@only@*/</font> cstring
<a name="l04818"></a><a class="code" href="abstract_c.html#a206">04818</a> <a class="code" href="abstract_c.html#a206">programNode_unparse</a> (programNode p)<font class="keyword"></font>
04819 <font class="keyword"></font>{
04820   <font class="keywordflow">if</font> (p != (programNode) 0)
04821     {
04822       cstring s = cstring_undefined;
04823       <font class="keywordtype">int</font> count;
04824 
04825       <font class="keywordflow">switch</font> (p-&gt;kind)
04826         {
04827         <font class="keywordflow">case</font> ACT_SELF:
04828           {
04829             cstring back = cstring_undefined;
04830             
04831             <font class="keywordflow">for</font> (count = p-&gt;wrapped; count &gt; 0; count--)
04832               {
04833                 s = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (s, <font class="charliteral">'('</font>);
04834                 back = <a class="code" href="cstring_c.html#a37">cstring_appendChar</a> (back, <font class="charliteral">')'</font>);
04835               }
04836             s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%q%q"</font>, s, stmtNode_unparse (p-&gt;content.self), back);
04837             <font class="keywordflow">break</font>;
04838           }
04839         <font class="keywordflow">case</font> ACT_ITER:
04840           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"*(%q)"</font>, programNodeList_unparse (p-&gt;content.args));
04841           <font class="keywordflow">break</font>;
04842         <font class="keywordflow">case</font> ACT_ALTERNATE:
04843           s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"|(%q)"</font>, programNodeList_unparse (p-&gt;content.args));
04844           <font class="keywordflow">break</font>;
04845         <font class="keywordflow">case</font> ACT_SEQUENCE:
04846           s = <a class="code" href="programNodeList_c.html#a3">programNodeList_unparse</a> (p-&gt;content.args);
04847           <font class="keywordflow">break</font>;
04848         }
04849 
04850       <font class="keywordflow">return</font> s;
04851     }
04852   <font class="keywordflow">return</font> cstring_undefined;
04853 }
04854 
04855 <font class="comment">/*@only@*/</font> cstring
<a name="l04856"></a><a class="code" href="abstract_c.html#a207">04856</a> <a class="code" href="abstract_c.html#a207">stmtNode_unparse</a> (stmtNode x)<font class="keyword"></font>
04857 <font class="keyword"></font>{
04858   cstring s = cstring_undefined;
04859 
04860   <font class="keywordflow">if</font> (x != (stmtNode) 0)
04861     {
04862       <font class="keywordflow">if</font> (ltoken_isValid (x-&gt;lhs))
04863         {
04864           s = <a class="code" href="cstring_c.html#a42">cstring_concat</a> (ltoken_getRawString (x-&gt;lhs), 
04865                               cstring_makeLiteralTemp (<font class="stringliteral">" = "</font>));
04866         }
04867 
04868       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q%s (%q)"</font>, s,
04869                    ltoken_getRawString (x-&gt;<font class="keyword">operator</font>),
04870                    <a class="code" href="termNodeList_c.html#a12">termNodeList_unparse</a> (x-&gt;args));
04871     }
04872 
04873   <font class="keywordflow">return</font> s;
04874 }
04875 
04876 <font class="comment">/*@only@*/</font> lslOp
<a name="l04877"></a><a class="code" href="abstract_c.html#a208">04877</a>   <a class="code" href="abstract_c.html#a208">makelslOpNode</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> nameNode name, 
04878                        <font class="comment">/*@dependent@*/</font> sigNode s)<font class="keyword"></font>
04879 <font class="keyword"></font>{
04880   lslOp x = (lslOp) dmalloc (<font class="keyword">sizeof</font> (*x));
04881 
04882   x-&gt;name = name;
04883   x-&gt;signature = s;
04884 
04885   <font class="comment">/* enter operator info into symtab */</font>
04886   <font class="comment">/* if not, they may need to be renamed in LCL imports */</font>
04887 
04888   <font class="keywordflow">if</font> (g_lslParsingTraits)
04889     {
04890       <font class="keywordflow">if</font> (name != NULL)
04891         {
04892           <a class="code" href="symtable_c.html#a37">symtable_enterOp</a> (g_symtab, nameNode_copySafe (name), <a class="code" href="abstract_c.html#a239">sigNode_copy</a> (s));
04893         }
04894     }
04895   <font class="keywordflow">else</font>
04896     {
04897             <font class="comment">/* nameNode_free (name); */</font>  <font class="comment">/* YIKES! */</font>
04898     }
04899 
04900   <font class="keywordflow">return</font> x;
04901 }
04902 
04903 <font class="comment">/*@only@*/</font> cstring
<a name="l04904"></a><a class="code" href="abstract_c.html#a209">04904</a> <a class="code" href="abstract_c.html#a209">lslOp_unparse</a> (lslOp x)<font class="keyword"></font>
04905 <font class="keyword"></font>{
04906   <font class="keywordtype">char</font> *s = mstring_createEmpty ();
04907 
04908   <font class="keywordflow">if</font> (x != (lslOp) 0)
04909     {
04910       s = <a class="code" href="general_c.html#a24">mstring_concatFree</a> (s, cstring_toCharsSafe (nameNode_unparse (x-&gt;name)));
04911 
04912       <font class="keywordflow">if</font> (x-&gt;signature != (sigNode) 0)
04913         {
04914           s = <a class="code" href="general_c.html#a24">mstring_concatFree</a> (s, cstring_toCharsSafe (sigNode_unparse (x-&gt;signature)));
04915         }
04916     }
04917 
04918   <font class="keywordflow">return</font> cstring_fromCharsO (s);
04919 }
04920 
04921 <font class="keyword">static</font> <font class="keywordtype">bool</font>
04922 sameOpFormNode (<font class="comment">/*@null@*/</font> opFormNode n1, <font class="comment">/*@null@*/</font> opFormNode n2)<font class="keyword"></font>
04923 <font class="keyword"></font>{
04924   <font class="keywordflow">if</font> (n1 == n2)
04925     <font class="keywordflow">return</font> TRUE;
04926 
04927   <font class="keywordflow">if</font> (n1 == 0)
04928     <font class="keywordflow">return</font> FALSE;
04929 
04930   <font class="keywordflow">if</font> (n2 == 0)
04931     <font class="keywordflow">return</font> FALSE;
04932 
04933   <font class="keywordflow">if</font> (n1-&gt;kind == n2-&gt;kind)
04934     {
04935       <font class="keywordflow">switch</font> (n1-&gt;kind)
04936         {
04937         <font class="keywordflow">case</font> OPF_IF:
04938           <font class="keywordflow">return</font> TRUE;
04939         <font class="keywordflow">case</font> OPF_ANYOP:
04940         <font class="keywordflow">case</font> OPF_MANYOP:
04941         <font class="keywordflow">case</font> OPF_ANYOPM:
04942           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a62">ltoken_similar</a> (n1-&gt;content.anyop, n2-&gt;content.anyop));
04943         <font class="keywordflow">case</font> OPF_MANYOPM:
04944           {
04945             <font class="comment">/* want to treat eq and = the same */</font>
04946             <font class="keywordflow">return</font> <a class="code" href="abstract_c.html#a62">ltoken_similar</a> (n1-&gt;content.anyop, n2-&gt;content.anyop);
04947           }
04948         <font class="keywordflow">case</font> OPF_MIDDLE:
04949         <font class="keywordflow">case</font> OPF_MMIDDLE:
04950         <font class="keywordflow">case</font> OPF_MIDDLEM:
04951         <font class="keywordflow">case</font> OPF_MMIDDLEM:
04952           <font class="comment">/* need to check the rawText of openSym and closeSym */</font>
04953           <font class="keywordflow">if</font> ((<font class="keywordtype">int</font>) n1-&gt;content.middle == (<font class="keywordtype">int</font>) n2-&gt;content.middle)
04954             {
04955               <font class="keywordflow">if</font> (lsymbol_equal (ltoken_getRawText (n1-&gt;tok),
04956                                    <a class="code" href="ltoken_c.html#a40">ltoken_getRawText</a> (n2-&gt;tok)) &amp;&amp;
04957                   lsymbol_equal (ltoken_getRawText (n1-&gt;close),
04958                                    <a class="code" href="ltoken_c.html#a40">ltoken_getRawText</a> (n2-&gt;close)))
04959                 <font class="keywordflow">return</font> TRUE;
04960             }
04961           <font class="keywordflow">return</font> FALSE;
04962         <font class="keywordflow">case</font> OPF_BMIDDLE:
04963         <font class="keywordflow">case</font> OPF_BMMIDDLE:
04964         <font class="keywordflow">case</font> OPF_BMIDDLEM:
04965         <font class="keywordflow">case</font> OPF_BMMIDDLEM:
04966           <font class="keywordflow">return</font> ((<font class="keywordtype">int</font>) n1-&gt;content.middle == (<font class="keywordtype">int</font>) n2-&gt;content.middle);
04967         <font class="keywordflow">case</font> OPF_SELECT:
04968         <font class="keywordflow">case</font> OPF_MAP:
04969         <font class="keywordflow">case</font> OPF_MSELECT:
04970         <font class="keywordflow">case</font> OPF_MMAP:
04971           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a62">ltoken_similar</a> (n1-&gt;content.id, n2-&gt;content.id));
04972         }
04973     }
04974   <font class="keywordflow">return</font> FALSE;
04975 }
04976 
04977 <font class="keywordtype">bool</font>
<a name="l04978"></a><a class="code" href="abstract_c.html#a211">04978</a> <a class="code" href="abstract_c.html#a211">sameNameNode</a> (<font class="comment">/*@null@*/</font> nameNode n1, <font class="comment">/*@null@*/</font> nameNode n2)<font class="keyword"></font>
04979 <font class="keyword"></font>{
04980   <font class="keywordflow">if</font> (n1 == n2)
04981     <font class="keywordflow">return</font> TRUE;
04982   <font class="keywordflow">if</font> (n1 != (nameNode) 0 &amp;&amp; n2 != (nameNode) 0)
04983     {
04984       <font class="keywordflow">if</font> (bool_equal (n1-&gt;isOpId, n2-&gt;isOpId))
04985         {
04986           <font class="keywordflow">if</font> (n1-&gt;isOpId)
04987             <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a62">ltoken_similar</a> (n1-&gt;content.opid, n2-&gt;content.opid));
04988           <font class="keywordflow">else</font>
04989             <font class="keywordflow">return</font> sameOpFormNode (n1-&gt;content.opform,
04990                                    n2-&gt;content.opform);
04991         }
04992     }
04993   <font class="keywordflow">return</font> FALSE;
04994 }
04995 
04996 <font class="keywordtype">void</font> CTypesNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> CTypesNode x)<font class="keyword"></font>
04997 <font class="keyword"></font>{
04998   <font class="keywordflow">if</font> (x != NULL)
04999     {
05000       <a class="code" href="ltokenList_c.html#a14">ltokenList_free</a> (x-&gt;ctypes);
05001       <a class="code" href="general_c.html#a0">sfree</a> (x);
05002     }
05003 }
05004 
05005 <font class="comment">/*@null@*/</font> CTypesNode CTypesNode_copy (<font class="comment">/*@null@*/</font> CTypesNode x)<font class="keyword"></font>
05006 <font class="keyword"></font>{
05007   <font class="keywordflow">if</font> (x != NULL)
05008     {
05009       CTypesNode newnode = (CTypesNode) dmalloc (<font class="keyword">sizeof</font> (*newnode));
05010       newnode-&gt;intfield = x-&gt;intfield;
05011       newnode-&gt;ctypes = <a class="code" href="ltokenList_c.html#a10">ltokenList_copy</a> (x-&gt;ctypes);
05012       newnode-&gt;sort = x-&gt;sort;
05013       
05014       <font class="keywordflow">return</font> newnode;
05015     }
05016   <font class="keywordflow">else</font>
05017     {
05018       <font class="keywordflow">return</font> NULL;
05019     }
05020 }  
05021 
05022 <font class="comment">/*@only@*/</font> CTypesNode
<a name="l05023"></a><a class="code" href="abstract_c.html#a212">05023</a>   <a class="code" href="abstract_c.html#a212">makeCTypesNode</a> (<font class="comment">/*@only@*/</font> CTypesNode ctypes, ltoken ct)<font class="keyword"></font>
05024 <font class="keyword"></font>{
05025   <font class="comment">/*@only@*/</font> CTypesNode newnode;
05026   lsymbol sortname;
05027   bits sortbits;
05028 
05029   <font class="keywordflow">if</font> (ctypes == (CTypesNode) NULL)
05030     {
05031       newnode = (CTypesNode) dmalloc (<font class="keyword">sizeof</font> (*newnode));
05032       newnode-&gt;intfield = 0;
05033       newnode-&gt;ctypes = <a class="code" href="ltokenList_c.html#a0">ltokenList_new</a> ();
05034       newnode-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
05035     }
05036   <font class="keywordflow">else</font>
05037     {
05038       newnode = ctypes;
05039     }
05040 
05041   <font class="keywordflow">if</font> ((ltoken_getIntField (ct) &amp; newnode-&gt;intfield) != 0)
05042     {
05043       <a class="code" href="llerror_c.html#a54">lclerror</a> (ct,
05044                 message
05045                 (<font class="stringliteral">"Duplicate type specifier ignored: %s"</font>,
05046                  cstring_fromChars 
05047                  (lsymbol_toChars
05048                   (lclctype_toSortDebug (ltoken_getIntField (ct))))));
05049 
05050       <font class="comment">/* evs --- don't know how to generator this error */</font>
05051      
05052       <font class="comment">/* Use previous value, to keep things consistent  */</font>
05053       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (ct);
05054       <font class="keywordflow">return</font> newnode;
05055     }
05056 
05057   sortbits = newnode-&gt;intfield | ltoken_getIntField (ct);
05058   sortname = <a class="code" href="lclctypes_c.html#a2">lclctype_toSort</a> (sortbits);
05059 
05060   <font class="keywordflow">if</font> (sortname == <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"error"</font>))
05061     {
05062       <a class="code" href="llerror_c.html#a54">lclerror</a> (ct, cstring_makeLiteral (<font class="stringliteral">"Invalid combination of type specifiers"</font>));
05063     }
05064   <font class="keywordflow">else</font>
05065     {
05066       newnode-&gt;intfield = sortbits;
05067     }
05068 
05069   <a class="code" href="ltokenList_c.html#a4">ltokenList_addh</a> (newnode-&gt;ctypes, ct);
05070   
05071   <font class="comment">/*</font>
05072 <font class="comment">  ** Sorts are assigned after CTypesNode is created during parsing,</font>
05073 <font class="comment">  ** see bison grammar. </font>
05074 <font class="comment">  */</font>
05075 
05076   <font class="keywordflow">return</font> newnode;
05077 }
05078 
05079 <font class="comment">/*@only@*/</font> CTypesNode          
<a name="l05080"></a><a class="code" href="abstract_c.html#a213">05080</a> <a class="code" href="abstract_c.html#a213">makeTypeSpecifier</a> (ltoken typedefname)<font class="keyword"></font>
05081 <font class="keyword"></font>{
05082   CTypesNode newnode = (CTypesNode) dmalloc (<font class="keyword">sizeof</font> (*newnode));
05083   typeInfo ti = <a class="code" href="symtable_c.html#a49">symtable_typeInfo</a> (g_symtab, ltoken_getText (typedefname));
05084 
05085   newnode-&gt;intfield = 0;
05086   newnode-&gt;ctypes = <a class="code" href="ltokenList_c.html#a1">ltokenList_singleton</a> (ltoken_copy (typedefname));
05087   
05088   <font class="comment">/* if we see "bool" include bool.h header file */</font>
05089 
05090   <font class="keywordflow">if</font> (ltoken_getText (typedefname) == lsymbol_bool)
05091     {
05092       <a class="code" href="lh_c.html#a17">lhIncludeBool</a> ();
05093     }
05094   
05095   <font class="keywordflow">if</font> (typeInfo_exists (ti))
05096     {
05097      <font class="comment">/* must we be concern about whether this type is exported by module?</font>
05098 <font class="comment">        No.  Because all typedef's are exported.  No hiding supported. */</font>
05099      <font class="comment">/* Later, may want to keep types around too */</font>
05100      <font class="comment">/* 3/2/93, use underlying sort */</font>
05101       newnode-&gt;sort = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (ti-&gt;basedOn);
05102     }
05103   <font class="keywordflow">else</font>
05104     {
05105       <a class="code" href="llerror_c.html#a54">lclerror</a> (typedefname, message (<font class="stringliteral">"Unrecognized type: %s"</font>, 
05106                                       ltoken_getRawString (typedefname)));
05107       <font class="comment">/* evs --- Don't know how to get this message */</font>
05108 
05109       newnode-&gt;sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
05110     }
05111   
05112   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (typedefname);
05113   <font class="keywordflow">return</font> newnode;
05114 }
05115 
<a name="l05116"></a><a class="code" href="abstract_c.html#a214">05116</a> <font class="keywordtype">bool</font> <a class="code" href="abstract_c.html#a214">sigNode_equal</a> (sigNode n1, sigNode n2)<font class="keyword"></font>
05117 <font class="keyword"></font>{
05118  <font class="comment">/* n1 and n2 are never 0 */</font>
05119 
05120   <font class="keywordflow">return</font> ((n1 == n2) ||
05121           (n1-&gt;key == n2-&gt;key &amp;&amp;
05122            <a class="code" href="abstract_c.html#a62">ltoken_similar</a> (n1-&gt;range, n2-&gt;range) &amp;&amp;
05123            <a class="code" href="ltokenList_c.html#a9">ltokenList_equal</a> (n1-&gt;domain, n2-&gt;domain)));
05124 }
05125 
05126 sort
<a name="l05127"></a><a class="code" href="abstract_c.html#a215">05127</a> <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (sort base, <font class="comment">/*@null@*/</font> typeExpr t)<font class="keyword"></font>
05128 <font class="keyword"></font>{
05129   <font class="keywordflow">if</font> (t != (typeExpr) 0)
05130     {
05131       <font class="keywordflow">switch</font> (t-&gt;kind)
05132         {
05133         <font class="keywordflow">case</font> TEXPR_BASE:
05134           <font class="keywordflow">return</font> base;
05135         <font class="keywordflow">case</font> TEXPR_PTR:
05136           <font class="keywordflow">return</font> <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (sort_makePtr (ltoken_undefined, base),
05137                                    t-&gt;content.pointer);
05138         <font class="keywordflow">case</font> TEXPR_ARRAY:
05139           <font class="keywordflow">return</font> <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (sort_makeArr (ltoken_undefined, base),
05140                                    t-&gt;content.array.elementtype);
05141         <font class="keywordflow">case</font> TEXPR_FCN:
05142           <font class="comment">/* map all hof types to some sort of SRT_HOF */</font>
05143           <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a66">sort_makeHOFSort</a> (base);
05144         }
05145     }
05146   <font class="keywordflow">return</font> base;
05147 }
05148 
05149 <font class="keyword">static</font> sort
05150 typeExpr2returnSort (sort base, <font class="comment">/*@null@*/</font> typeExpr t)<font class="keyword"></font>
05151 <font class="keyword"></font>{
05152   <font class="keywordflow">if</font> (t != (typeExpr) 0)
05153     {
05154       <font class="keywordflow">switch</font> (t-&gt;kind)
05155         {
05156         <font class="keywordflow">case</font> TEXPR_BASE:
05157           <font class="keywordflow">return</font> base;
05158         <font class="keywordflow">case</font> TEXPR_PTR:
05159           <font class="keywordflow">return</font> typeExpr2returnSort (sort_makePtr (ltoken_undefined, base),
05160                                       t-&gt;content.pointer);
05161         <font class="keywordflow">case</font> TEXPR_ARRAY:
05162           <font class="keywordflow">return</font> typeExpr2returnSort (sort_makeArr (ltoken_undefined, base),
05163                                       t-&gt;content.array.elementtype);
05164         <font class="keywordflow">case</font> TEXPR_FCN:
05165           <font class="keywordflow">return</font> typeExpr2returnSort (base, t-&gt;content.function.returntype);
05166         }
05167     }
05168   <font class="keywordflow">return</font> base;
05169 }
05170 
05171 sort
<a name="l05172"></a><a class="code" href="abstract_c.html#a217">05172</a> <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (lclTypeSpecNode type)<font class="keyword"></font>
05173 <font class="keyword"></font>{
05174   <font class="keywordflow">if</font> (type != (lclTypeSpecNode) 0)
05175     {
05176       <font class="keywordflow">switch</font> (type-&gt;kind)
05177         {
05178         <font class="keywordflow">case</font> LTS_TYPE:
05179           llassert (type-&gt;content.type != NULL);
05180           <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a77">sort_makePtrN</a> (type-&gt;content.type-&gt;sort, type-&gt;pointers);
05181         <font class="keywordflow">case</font> LTS_STRUCTUNION:
05182           llassert (type-&gt;content.structorunion != NULL);
05183           <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a77">sort_makePtrN</a> (type-&gt;content.structorunion-&gt;sort,
05184                                 type-&gt;pointers);
05185         <font class="keywordflow">case</font> LTS_ENUM:
05186           llassert (type-&gt;content.enumspec != NULL);
05187           <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a77">sort_makePtrN</a> (type-&gt;content.enumspec-&gt;sort, 
05188                                 type-&gt;pointers);
05189         <font class="keywordflow">case</font> LTS_CONJ:
05190           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (type-&gt;content.conj-&gt;a));
05191         }
05192     }
05193   <font class="keywordflow">return</font> (<a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ());
05194 }
05195 
05196 lsymbol
<a name="l05197"></a><a class="code" href="abstract_c.html#a218">05197</a> <a class="code" href="abstract_c.html#a218">checkAndEnterTag</a> (tagKind k, ltoken opttagid)<font class="keyword"></font>
05198 <font class="keyword"></font>{
05199   <font class="comment">/* should be tagKind, instead of int */</font>
05200   tagInfo t;
05201   sort sort = <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
05202   
05203   <font class="keywordflow">if</font> (!ltoken_isUndefined (opttagid))
05204     {
05205       <font class="keywordflow">switch</font> (k)
05206         {
05207         <font class="keywordflow">case</font> TAG_FWDSTRUCT:
05208         <font class="keywordflow">case</font> TAG_STRUCT:
05209           sort = <a class="code" href="sort_c.html#a83">sort_makeStr</a> (opttagid);
05210           <font class="keywordflow">break</font>;
05211         <font class="keywordflow">case</font> TAG_FWDUNION:
05212         <font class="keywordflow">case</font> TAG_UNION:
05213           sort = <a class="code" href="sort_c.html#a86">sort_makeUnion</a> (opttagid);
05214           <font class="keywordflow">break</font>;
05215         <font class="keywordflow">case</font> TAG_ENUM:
05216           sort = <a class="code" href="sort_c.html#a89">sort_makeEnum</a> (opttagid);
05217           <font class="keywordflow">break</font>;
05218         }      
05219 
05220       <font class="comment">/* see if it is already in symbol table */</font>
05221       t = <a class="code" href="symtable_c.html#a41">symtable_tagInfo</a> (g_symtab, ltoken_getText (opttagid));
05222       
05223       <font class="keywordflow">if</font> (tagInfo_exists (t))
05224         {
05225           <font class="keywordflow">if</font> (t-&gt;kind == TAG_FWDUNION || t-&gt;kind == TAG_FWDSTRUCT)
05226             {
05227               <font class="comment">/* this is fine, for mutually recursive types */</font>
05228             }
05229           <font class="keywordflow">else</font>
05230             {                   <font class="comment">/* this is not good, complain later */</font>
05231               cstring s;
05232 
05233               <font class="keywordflow">switch</font> (k)
05234                 {
05235                 <font class="keywordflow">case</font> TAG_ENUM:
05236                   s = cstring_makeLiteral (<font class="stringliteral">"Enum"</font>);
05237                   <font class="keywordflow">break</font>;
05238                 <font class="keywordflow">case</font> TAG_STRUCT:
05239                 <font class="keywordflow">case</font> TAG_FWDSTRUCT:
05240                   s = cstring_makeLiteral (<font class="stringliteral">"Struct"</font>);
05241                   <font class="keywordflow">break</font>;
05242                 <font class="keywordflow">case</font> TAG_UNION:
05243                 <font class="keywordflow">case</font> TAG_FWDUNION:
05244                   s = cstring_makeLiteral (<font class="stringliteral">"Union"</font>);
05245                   <font class="keywordflow">break</font>;
05246                 }
05247 
05248               t-&gt;sort = sort;
05249               t-&gt;kind = k;
05250               <a class="code" href="llerror_c.html#a54">lclerror</a> (opttagid, 
05251                         message (<font class="stringliteral">"Tag redefined: %q %s"</font>, s, 
05252                                  ltoken_getRawString (opttagid)));
05253               
05254             }
05255 
05256           <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (opttagid);
05257         }
05258       <font class="keywordflow">else</font>
05259         {
05260           tagInfo newnode = (tagInfo) dmalloc (<font class="keyword">sizeof</font> (*newnode));
05261       
05262           newnode-&gt;sort = sort;
05263           newnode-&gt;kind = k;
05264           newnode-&gt;id = opttagid;
05265           newnode-&gt;imported = FALSE;
05266           newnode-&gt;content.decls = <a class="code" href="stDeclNodeList_c.html#a0">stDeclNodeList_new</a> ();
05267 
05268           (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a38">symtable_enterTag</a> (g_symtab, newnode);
05269         }
05270     }
05271 
05272   <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a113">sort_getLsymbol</a> (sort);
05273 }
05274 
05275 <font class="keyword">static</font> sort
05276 extractReturnSort (lclTypeSpecNode t, declaratorNode d)<font class="keyword"></font>
05277 <font class="keyword"></font>{
05278   sort sort;
05279   sort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (t);
05280   sort = typeExpr2returnSort (sort, d-&gt;type);
05281   <font class="keywordflow">return</font> sort;
05282 }
05283 
05284 <font class="keywordtype">void</font>
<a name="l05285"></a><a class="code" href="abstract_c.html#a219">05285</a> <a class="code" href="abstract_c.html#a219">signNode_free</a> (<font class="comment">/*@only@*/</font> signNode sn)<font class="keyword"></font>
05286 <font class="keyword"></font>{
05287   <a class="code" href="sortList_c.html#a7">sortList_free</a> (sn-&gt;domain);
05288   <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (sn-&gt;tok);
05289   <a class="code" href="general_c.html#a0">sfree</a> (sn);
05290 }
05291 
05292 <font class="comment">/*@only@*/</font> cstring
<a name="l05293"></a><a class="code" href="abstract_c.html#a220">05293</a> <a class="code" href="abstract_c.html#a220">signNode_unparse</a> (signNode sn)<font class="keyword"></font>
05294 <font class="keyword"></font>{
05295   cstring s = cstring_undefined;
05296 
05297   <font class="keywordflow">if</font> (sn != (signNode) 0)
05298     {
05299       s = <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">": %q -&gt; %s"</font>, sortList_unparse (sn-&gt;domain),
05300                    <a class="code" href="sort_c.html#a115">sort_unparseName</a> (sn-&gt;range));
05301     }
05302   <font class="keywordflow">return</font> s;
05303 }
05304 
05305 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> pairNodeList
05306   globalList_toPairNodeList (globalList g)<font class="keyword"></font>
05307 <font class="keyword"></font>{
05308   <font class="comment">/* expect list to be globals, drop private ones */</font>
05309   pairNodeList result = <a class="code" href="pairNodeList_c.html#a0">pairNodeList_new</a> ();
05310   pairNode p;
05311   declaratorNode vdnode;
05312   lclTypeSpecNode type;
05313   sort sort;
05314   lsymbol sym;
05315   initDeclNodeList decls;
05316 
05317   varDeclarationNodeList_elements (g, x)<font class="keyword"></font>
05318 <font class="keyword">  </font>{
05319     <font class="keywordflow">if</font> (x-&gt;isSpecial)
05320       {
05321         ;
05322       }
05323     <font class="keywordflow">else</font>
05324       {
05325         <font class="keywordflow">if</font> (x-&gt;isGlobal &amp;&amp; !x-&gt;isPrivate)
05326           {
05327             type = x-&gt;type;
05328             decls = x-&gt;decls;
05329             
05330             initDeclNodeList_elements (decls, init)<font class="keyword"></font>
05331 <font class="keyword">              </font>{
05332                 p = (pairNode) dmalloc (<font class="keyword">sizeof</font> (*p));
05333                 
05334                 vdnode = init-&gt;declarator;
05335                 sym = ltoken_getText (vdnode-&gt;id);
05336                 <font class="comment">/* 2/21/93, not sure if it should be extractReturnSort,</font>
05337 <font class="comment">                   or some call to typeExpr2ptrSort */</font>
05338                 sort = extractReturnSort (type, vdnode);
05339                 p-&gt;sort = <a class="code" href="sort_c.html#a74">sort_makeGlobal</a> (sort);
05340                 <font class="comment">/*      if (!sort_isArrayKind (sort)) p-&gt;sort = sort_makeObj (sort);</font>
05341 <font class="comment">                        else p-&gt;sort = sort; */</font>
05342                 <font class="comment">/*      p-&gt;name = sym; */</font>
05343                 p-&gt;tok = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (vdnode-&gt;id);
05344                 <a class="code" href="pairNodeList_c.html#a2">pairNodeList_addh</a> (result, p);
05345               } end_initDeclNodeList_elements;
05346           }
05347       }
05348   } end_varDeclarationNodeList_elements;
05349   <font class="keywordflow">return</font> result;
05350 }
05351 
05352 <font class="keywordtype">void</font>
<a name="l05353"></a><a class="code" href="abstract_c.html#a222">05353</a> <a class="code" href="abstract_c.html#a222">enteringFcnScope</a> (lclTypeSpecNode t, declaratorNode d, globalList g)<font class="keyword"></font>
05354 <font class="keyword"></font>{
05355   scopeInfo si = (scopeInfo) dmalloc (<font class="keyword">sizeof</font> (*si));
05356   varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
05357   sort returnSort;
05358   ltoken result = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_id);
05359   pairNodeList paramPairs, globals;
05360   fctInfo fi    = (fctInfo) dmalloc (<font class="keyword">sizeof</font> (*fi));
05361   signNode sign = (signNode) dmalloc (<font class="keyword">sizeof</font> (*sign));
05362   sortList domain = <a class="code" href="sortList_c.html#a0">sortList_new</a> ();
05363   <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> key;
05364 
05365   paramPairs = extractParams (d-&gt;type);
05366   returnSort = extractReturnSort (t, d);
05367   globals = globalList_toPairNodeList (g);
05368 
05369   sign-&gt;tok = ltoken_undefined;
05370   sign-&gt;range = returnSort;
05371 
05372   key = MASH (0, sort_getLsymbol (returnSort));
05373 
05374   pairNodeList_elements (paramPairs, p)<font class="keyword"></font>
05375 <font class="keyword">  </font>{
05376     <a class="code" href="sortList_c.html#a2">sortList_addh</a> (domain, p-&gt;sort);
05377     key = MASH (key, sort_getLsymbol (p-&gt;sort));
05378   } end_pairNodeList_elements;
05379 
05380   sign-&gt;domain = domain;
05381   sign-&gt;key = key;
05382 
05383   <font class="comment">/* push fcn onto symbol table stack first */</font>
05384   fi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (d-&gt;id);
05385   fi-&gt;export = TRUE;
05386   fi-&gt;signature = sign;
05387   fi-&gt;globals = globals;
05388 
05389   (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a44">symtable_enterFct</a> (g_symtab, fi);
05390 
05391   <font class="comment">/* push new fcn scope */</font>
05392   si-&gt;kind = SPE_FCN;
05393   <a class="code" href="symtable_c.html#a42">symtable_enterScope</a> (g_symtab, si);
05394 
05395   <font class="comment">/* add "result" with return type to current scope */</font>
05396   ltoken_setText (result, lsymbol_fromChars (<font class="stringliteral">"result"</font>));
05397 
05398   vi-&gt;id = result;
05399   vi-&gt;sort = <a class="code" href="sort_c.html#a73">sort_makeFormal</a> (returnSort);      <font class="comment">/* make appropriate values */</font>
05400   vi-&gt;kind = VRK_PARAM;
05401   vi-&gt;export = TRUE;
05402 
05403   (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
05404 
05405   <font class="comment">/*</font>
05406 <font class="comment">  ** evs - 4 Mar 1995 </font>
05407 <font class="comment">  **   pust globals first (they are in outer scope)</font>
05408 <font class="comment">  */</font>
05409 
05410   <font class="comment">/* push onto symbol table the global variables declared in this function,</font>
05411 <font class="comment">     together with their respective sorts */</font>
05412 
05413   pairNodeList_elements (globals, gl)<font class="keyword"></font>
05414 <font class="keyword">    </font>{
05415       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (vi-&gt;id);
05416       vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (gl-&gt;tok);
05417       vi-&gt;kind = VRK_GLOBAL;
05418       vi-&gt;sort = gl-&gt;sort;
05419       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
05420     } end_pairNodeList_elements;
05421 
05422   <font class="comment">/*</font>
05423 <font class="comment">  ** could enter a new scope; instead, warn when variable shadows global</font>
05424 <font class="comment">  ** that is used</font>
05425 <font class="comment">  */</font>
05426 
05427   <font class="comment">/*</font>
05428 <font class="comment">  ** push onto symbol table the formal parameters of this function,</font>
05429 <font class="comment">  ** together with their respective sorts </font>
05430 <font class="comment">  */</font>
05431 
05432   pairNodeList_elements (paramPairs, pair)<font class="keyword"></font>
05433 <font class="keyword">    </font>{
05434       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (vi-&gt;id);
05435       vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (pair-&gt;tok);
05436       vi-&gt;sort = pair-&gt;sort;
05437       vi-&gt;kind = VRK_PARAM;
05438       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
05439     } end_pairNodeList_elements;
05440 
05441   <a class="code" href="pairNodeList_c.html#a4">pairNodeList_free</a> (paramPairs);
05442   <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
05443 }
05444 
05445 <font class="keywordtype">void</font>
<a name="l05446"></a><a class="code" href="abstract_c.html#a223">05446</a> <a class="code" href="abstract_c.html#a223">enteringClaimScope</a> (paramNodeList params, globalList g)<font class="keyword"></font>
05447 <font class="keyword"></font>{
05448   scopeInfo si = (scopeInfo) dmalloc (<font class="keyword">sizeof</font> (*si));
05449   pairNodeList globals;
05450   lclTypeSpecNode paramtype;
05451   typeExpr paramdecl;
05452   sort sort;
05453 
05454   globals = globalList_toPairNodeList (g);
05455   <font class="comment">/* push new claim scope */</font>
05456   si-&gt;kind = SPE_CLAIM;
05457 
05458   <a class="code" href="symtable_c.html#a42">symtable_enterScope</a> (g_symtab, si);
05459   
05460   <font class="comment">/* push onto symbol table the formal parameters of this function,</font>
05461 <font class="comment">     together with their respective sorts */</font>
05462   
05463   paramNodeList_elements (params, param)<font class="keyword"></font>
05464 <font class="keyword">    </font>{
05465       paramdecl = param-&gt;paramdecl;
05466       paramtype = param-&gt;type;
05467       <font class="keywordflow">if</font> (paramdecl != (typeExpr) 0 &amp;&amp; paramtype != (lclTypeSpecNode) 0)
05468         {
05469           varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
05470           
05471           sort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (paramtype);
05472           sort = <a class="code" href="sort_c.html#a73">sort_makeFormal</a> (sort);
05473           vi-&gt;sort = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (sort, paramdecl);
05474           vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (extractDeclarator (paramdecl));
05475           vi-&gt;kind = VRK_PARAM;
05476           vi-&gt;export = TRUE;
05477 
05478           (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
05479           <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
05480         }
05481     } end_paramNodeList_elements;
05482   
05483   <font class="comment">/* push onto symbol table the global variables declared in this function,</font>
05484 <font class="comment">     together with their respective sorts */</font>
05485 
05486   pairNodeList_elements (globals, g2)<font class="keyword"></font>
05487 <font class="keyword">    </font>{
05488       varInfo vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
05489       
05490       vi-&gt;id = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (g2-&gt;tok);
05491       vi-&gt;kind = VRK_GLOBAL;
05492       vi-&gt;sort = g2-&gt;sort;
05493       vi-&gt;export = TRUE;
05494 
05495       <font class="comment">/* should catch duplicates in formals */</font>
05496       (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);  
05497       <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
05498     } end_pairNodeList_elements;
05499 
05500   <a class="code" href="pairNodeList_c.html#a4">pairNodeList_free</a> (globals);
05501   <font class="comment">/* should not free it here! ltoken_free (claimId); @*/</font>
05502 }
05503 
05504 <font class="keyword">static</font> <font class="comment">/*@only@*/</font> pairNodeList
05505   extractParams (<font class="comment">/*@null@*/</font> typeExpr te)<font class="keyword"></font>
05506 <font class="keyword"></font>{
05507  <font class="comment">/* extract the parameters from a function header declarator's typeExpr */</font>
05508   sort sort;
05509   typeExpr paramdecl;
05510   paramNodeList params;
05511   lclTypeSpecNode paramtype;
05512   pairNodeList head = <a class="code" href="pairNodeList_c.html#a0">pairNodeList_new</a> ();
05513   pairNode pair;
05514 
05515   <font class="keywordflow">if</font> (te != (typeExpr) 0)
05516     {
05517       params = typeExpr_toParamNodeList (te);
05518       <font class="keywordflow">if</font> (paramNodeList_isDefined (params))
05519         {
05520           paramNodeList_elements (params, param)<font class="keyword"></font>
05521 <font class="keyword">          </font>{
05522             paramdecl = param-&gt;paramdecl;
05523             paramtype = param-&gt;type;
05524             <font class="keywordflow">if</font> (paramdecl != (typeExpr) 0 &amp;&amp; paramtype != (lclTypeSpecNode) 0)
05525               {
05526                 pair = (pairNode) dmalloc (<font class="keyword">sizeof</font> (*pair));
05527                 sort = <a class="code" href="abstract_c.html#a217">lclTypeSpecNode2sort</a> (paramtype);
05528                 <font class="comment">/* 2/17/93, was sort_makeVal (sort) */</font>
05529                 sort = <a class="code" href="sort_c.html#a73">sort_makeFormal</a> (sort);
05530                 pair-&gt;sort = <a class="code" href="abstract_c.html#a215">typeExpr2ptrSort</a> (sort, paramdecl);
05531                 <font class="comment">/* pair-&gt;name = ltoken_getText (extractDeclarator (paramdecl)); */</font>
05532                 pair-&gt;tok = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (extractDeclarator (paramdecl));
05533                 <a class="code" href="pairNodeList_c.html#a2">pairNodeList_addh</a> (head, pair);
05534               }
05535           } end_paramNodeList_elements;
05536         }
05537     }
05538   <font class="keywordflow">return</font> head;
05539 }
05540 
05541 sort
<a name="l05542"></a><a class="code" href="abstract_c.html#a224">05542</a> <a class="code" href="abstract_c.html#a224">sigNode_rangeSort</a> (sigNode sig)<font class="keyword"></font>
05543 <font class="keyword"></font>{
05544   <font class="keywordflow">if</font> (sig == (sigNode) 0)
05545     {
05546       <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a65">sort_makeNoSort</a> ();
05547     }
05548   <font class="keywordflow">else</font>
05549     {
05550       <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a116">sort_fromLsymbol</a> (ltoken_getText (sig-&gt;range));
05551     }
05552 }
05553 
05554 <font class="comment">/*@only@*/</font> sortList
<a name="l05555"></a><a class="code" href="abstract_c.html#a225">05555</a>   <a class="code" href="abstract_c.html#a225">sigNode_domain</a> (sigNode sig)<font class="keyword"></font>
05556 <font class="keyword"></font>{
05557   sortList domain = <a class="code" href="sortList_c.html#a0">sortList_new</a> ();
05558 
05559   <font class="keywordflow">if</font> (sig == (sigNode) 0)
05560     {
05561       ;
05562     }
05563   <font class="keywordflow">else</font>
05564     {
05565       ltokenList dom = sig-&gt;domain;
05566 
05567       ltokenList_elements (dom, tok)<font class="keyword"></font>
05568 <font class="keyword">      </font>{
05569         <a class="code" href="sortList_c.html#a2">sortList_addh</a> (domain, sort_fromLsymbol (ltoken_getText (tok)));
05570       } end_ltokenList_elements;
05571     }
05572 
05573   <font class="keywordflow">return</font> domain;
05574 }
05575 
05576 opFormUnion
<a name="l05577"></a><a class="code" href="abstract_c.html#a226">05577</a> <a class="code" href="abstract_c.html#a226">opFormUnion_createAnyOp</a> (<font class="comment">/*@temp@*/</font> ltoken t)<font class="keyword"></font>
05578 <font class="keyword"></font>{
05579   opFormUnion u;
05580 
05581   <font class="comment">/* do not distinguish between .anyop and .id */</font>
05582   u.anyop = t;
05583   <font class="keywordflow">return</font> u;
05584 }
05585 
05586 opFormUnion
<a name="l05587"></a><a class="code" href="abstract_c.html#a227">05587</a> <a class="code" href="abstract_c.html#a227">opFormUnion_createMiddle</a> (<font class="keywordtype">int</font> middle)<font class="keyword"></font>
05588 <font class="keyword"></font>{
05589   opFormUnion u;
05590   
05591   u.middle = middle;
05592   <font class="keywordflow">return</font> u;
05593 }
05594 
05595 paramNode
<a name="l05596"></a><a class="code" href="abstract_c.html#a228">05596</a> <a class="code" href="abstract_c.html#a228">markYieldParamNode</a> (paramNode p)<font class="keyword"></font>
05597 <font class="keyword"></font>{
05598   p-&gt;kind = PYIELD;
05599 
05600   llassert (p-&gt;type != NULL);
05601   p-&gt;type-&gt;quals = <a class="code" href="qualList_c.html#a4">qualList_add</a> (p-&gt;type-&gt;quals, qual_createYield ());
05602 
05603     <font class="keywordflow">return</font> (p);
05604 }
05605 
05606 <font class="comment">/*@only@*/</font> lclTypeSpecNode
05607   lclTypeSpecNode_copySafe (lclTypeSpecNode n)<font class="keyword"></font>
05608 <font class="keyword"></font>{
05609   lclTypeSpecNode ret = <a class="code" href="abstract_c.html#a229">lclTypeSpecNode_copy</a> (n);
05610   
05611   llassert (ret != NULL);
05612   <font class="keywordflow">return</font> ret;
05613 }
05614 
05615 <font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> lclTypeSpecNode
<a name="l05616"></a><a class="code" href="abstract_c.html#a229">05616</a>   <a class="code" href="abstract_c.html#a229">lclTypeSpecNode_copy</a> (<font class="comment">/*@null@*/</font> lclTypeSpecNode n)<font class="keyword"></font>
05617 <font class="keyword"></font>{
05618   <font class="keywordflow">if</font> (n != NULL)
05619     {
05620       <font class="keywordflow">switch</font> (n-&gt;kind)
05621         {
05622         <font class="keywordflow">case</font> LTS_CONJ:
05623           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a111">makeLclTypeSpecNodeConj</a> (lclTypeSpecNode_copy (n-&gt;content.conj-&gt;a),
05624                                            <a class="code" href="abstract_c.html#a229">lclTypeSpecNode_copy</a> (n-&gt;content.conj-&gt;b)));
05625         <font class="keywordflow">case</font> LTS_TYPE:
05626           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a112">makeLclTypeSpecNodeType</a> (CTypesNode_copy (n-&gt;content.type)));
05627         <font class="keywordflow">case</font> LTS_STRUCTUNION:
05628           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a113">makeLclTypeSpecNodeSU</a> (strOrUnionNode_copy (n-&gt;content.structorunion)));
05629         <font class="keywordflow">case</font> LTS_ENUM:
05630           <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a114">makeLclTypeSpecNodeEnum</a> (enumSpecNode_copy (n-&gt;content.enumspec)));
05631         }
05632     }
05633   
05634   <font class="keywordflow">return</font> NULL;
05635 }
05636 
05637 <font class="keywordtype">void</font> lclTypeSpecNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> lclTypeSpecNode n)<font class="keyword"></font>
05638 <font class="keyword"></font>{
05639   <font class="keywordflow">if</font> (n != NULL)
05640     {
05641       <font class="keywordflow">switch</font> (n-&gt;kind)
05642         {
05643         <font class="keywordflow">case</font> LTS_CONJ:
05644           lclTypeSpecNode_free (n-&gt;content.conj-&gt;a);
05645           lclTypeSpecNode_free (n-&gt;content.conj-&gt;b);
05646           <font class="keywordflow">break</font>;
05647         <font class="keywordflow">case</font> LTS_TYPE:
05648           CTypesNode_free (n-&gt;content.type);
05649           <font class="keywordflow">break</font>;
05650         <font class="keywordflow">case</font> LTS_STRUCTUNION:
05651           strOrUnionNode_free (n-&gt;content.structorunion);
05652           <font class="keywordflow">break</font>;
05653         <font class="keywordflow">case</font> LTS_ENUM:
05654           enumSpecNode_free (n-&gt;content.enumspec);
05655           <font class="keywordflow">break</font>;
05656         }
05657 
05658       <a class="code" href="qualList_c.html#a11">qualList_free</a> (n-&gt;quals);
05659       <a class="code" href="general_c.html#a0">sfree</a> (n);
05660     }
05661 }
05662 
05663 <font class="keyword">static</font> <font class="comment">/*@null@*/</font> opFormNode opFormNode_copy (<font class="comment">/*@null@*/</font> opFormNode op)<font class="keyword"></font>
05664 <font class="keyword"></font>{
05665   <font class="keywordflow">if</font> (op != NULL)
05666     {
05667       opFormNode ret = (opFormNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
05668       
05669       ret-&gt;tok = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (op-&gt;tok);
05670       ret-&gt;kind = op-&gt;kind;
05671       ret-&gt;content = op-&gt;content;
05672       ret-&gt;key = op-&gt;key;
05673       ret-&gt;close = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (op-&gt;close);
05674       
05675       <font class="keywordflow">return</font> ret;
05676     }
05677   <font class="keywordflow">else</font>
05678     {
05679       <font class="keywordflow">return</font> NULL;
05680     }
05681 }
05682 
05683 <font class="keywordtype">void</font> opFormNode_free (<font class="comment">/*@null@*/</font> opFormNode op)<font class="keyword"></font>
05684 <font class="keyword"></font>{
05685   <a class="code" href="general_c.html#a0">sfree</a> (op);
05686 }
05687 
<a name="l05688"></a><a class="code" href="abstract_c.html#a231">05688</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a231">nameNode_free</a> (nameNode n)<font class="keyword"></font>
05689 <font class="keyword"></font>{
05690   
05691   <font class="keywordflow">if</font> (n != NULL)
05692     {
05693       <font class="keywordflow">if</font> (!n-&gt;isOpId)
05694         {
05695           opFormNode_free (n-&gt;content.opform);
05696         }
05697       
05698       <a class="code" href="general_c.html#a0">sfree</a> (n);
05699     }
05700 }
05701 
05702 <font class="keywordtype">bool</font>
<a name="l05703"></a><a class="code" href="abstract_c.html#a232">05703</a> <a class="code" href="abstract_c.html#a232">lslOp_equal</a> (lslOp x, lslOp y)<font class="keyword"></font>
05704 <font class="keyword"></font>{
05705   <font class="keywordflow">return</font> ((x == y) ||
05706           ((x != 0) &amp;&amp; (y != 0) &amp;&amp;
05707            <a class="code" href="abstract_c.html#a211">sameNameNode</a> (x-&gt;name, y-&gt;name) &amp;&amp;
05708            <a class="code" href="abstract_c.html#a214">sigNode_equal</a> (x-&gt;signature, y-&gt;signature)));
05709 }
05710 
<a name="l05711"></a><a class="code" href="abstract_c.html#a233">05711</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a233">lslOp_free</a> (lslOp x)<font class="keyword"></font>
05712 <font class="keyword"></font>{
05713   <a class="code" href="abstract_c.html#a231">nameNode_free</a> (x-&gt;name);
05714   <a class="code" href="general_c.html#a0">sfree</a> (x);
05715 }
05716 
<a name="l05717"></a><a class="code" href="abstract_c.html#a234">05717</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a234">sigNode_free</a> (sigNode x)<font class="keyword"></font>
05718 <font class="keyword"></font>{
05719   <font class="keywordflow">if</font> (x != NULL)
05720     {
05721       <a class="code" href="ltokenList_c.html#a14">ltokenList_free</a> (x-&gt;domain);
05722       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;tok);
05723       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;range);
05724       <a class="code" href="general_c.html#a0">sfree</a> (x);
05725     }
05726 }
05727 
<a name="l05728"></a><a class="code" href="abstract_c.html#a235">05728</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a235">declaratorNode_free</a> (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> declaratorNode x)<font class="keyword"></font>
05729 <font class="keyword"></font>{
05730   <font class="keywordflow">if</font> (x != NULL)
05731     {
05732       <a class="code" href="abstract_c.html#a133">typeExpr_free</a> (x-&gt;type);
05733       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;id);
05734       <a class="code" href="general_c.html#a0">sfree</a> (x);
05735     }
05736 }
05737 
05738 <font class="keywordtype">void</font> abstBodyNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> abstBodyNode n)<font class="keyword"></font>
05739 <font class="keyword"></font>{
05740   <font class="keywordflow">if</font> (n != NULL)
05741     {
05742       lclPredicateNode_free (n-&gt;typeinv);
05743       <a class="code" href="fcnNodeList_c.html#a5">fcnNodeList_free</a> (n-&gt;fcns);
05744       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;tok);
05745       <a class="code" href="general_c.html#a0">sfree</a> (n);
05746     }
05747 }
05748 
<a name="l05749"></a><a class="code" href="abstract_c.html#a236">05749</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a236">fcnNode_free</a> (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> fcnNode f)<font class="keyword"></font>
05750 <font class="keyword"></font>{
05751   <font class="keywordflow">if</font> (f != NULL)
05752     {
05753       lclTypeSpecNode_free (f-&gt;typespec);
05754       <a class="code" href="abstract_c.html#a235">declaratorNode_free</a> (f-&gt;declarator);
05755       globalList_free (f-&gt;globals);
05756       <a class="code" href="varDeclarationNodeList_c.html#a4">varDeclarationNodeList_free</a> (f-&gt;inits);
05757       <a class="code" href="letDeclNodeList_c.html#a4">letDeclNodeList_free</a> (f-&gt;lets);
05758       lclPredicateNode_free (f-&gt;checks);
05759       lclPredicateNode_free (f-&gt;require);
05760       lclPredicateNode_free (f-&gt;claim);
05761       lclPredicateNode_free (f-&gt;ensures);
05762       modifyNode_free (f-&gt;modify);
05763       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (f-&gt;name);
05764       <a class="code" href="general_c.html#a0">sfree</a> (f);
05765     }
05766 }
05767 
<a name="l05768"></a><a class="code" href="abstract_c.html#a237">05768</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a237">declaratorInvNode_free</a> (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> declaratorInvNode x)<font class="keyword"></font>
05769 <font class="keyword"></font>{
05770   <font class="keywordflow">if</font> (x != NULL)
05771     {
05772       <a class="code" href="abstract_c.html#a235">declaratorNode_free</a> (x-&gt;declarator);
05773       abstBodyNode_free (x-&gt;body);
05774       <a class="code" href="general_c.html#a0">sfree</a> (x);
05775     }
05776 }
05777 
<a name="l05778"></a><a class="code" href="abstract_c.html#a238">05778</a> <font class="comment">/*@only@*/</font> lslOp <a class="code" href="abstract_c.html#a238">lslOp_copy</a> (lslOp x)<font class="keyword"></font>
05779 <font class="keyword"></font>{
05780   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a208">makelslOpNode</a> (nameNode_copy (x-&gt;name), x-&gt;signature));
05781 }
05782 
<a name="l05783"></a><a class="code" href="abstract_c.html#a239">05783</a> sigNode <a class="code" href="abstract_c.html#a239">sigNode_copy</a> (sigNode s)<font class="keyword"></font>
05784 <font class="keyword"></font>{
05785   llassert (s != NULL);
05786   <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a101">makesigNode</a> (ltoken_copy (s-&gt;tok), 
05787                              <a class="code" href="ltokenList_c.html#a10">ltokenList_copy</a> (s-&gt;domain), 
05788                              <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (s-&gt;range)));
05789 }
05790 
<a name="l05791"></a><a class="code" href="abstract_c.html#a240">05791</a> <font class="comment">/*@null@*/</font> nameNode <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (<font class="comment">/*@null@*/</font> nameNode n)<font class="keyword"></font>
05792 <font class="keyword"></font>{
05793   <font class="keywordflow">if</font> (n == NULL) <font class="keywordflow">return</font> NULL;
05794   <font class="keywordflow">return</font> <a class="code" href="abstract_c.html#a241">nameNode_copySafe</a> (n);
05795 }
05796 
<a name="l05797"></a><a class="code" href="abstract_c.html#a241">05797</a> nameNode <a class="code" href="abstract_c.html#a241">nameNode_copySafe</a> (nameNode n)<font class="keyword"></font>
05798 <font class="keyword"></font>{
05799   <font class="keywordflow">if</font> (n-&gt;isOpId)
05800     {
05801       <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a99">makeNameNodeId</a> (ltoken_copy (n-&gt;content.opid)));
05802     }
05803   <font class="keywordflow">else</font>
05804     {
05805       <font class="comment">/* error should be detected by lclint: forgot to copy opform! */</font>
05806       <font class="keywordflow">return</font> (<a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opFormNode_copy (n-&gt;content.opform)));
05807     }
05808 }
05809 
<a name="l05810"></a><a class="code" href="abstract_c.html#a242">05810</a> <font class="keywordtype">bool</font> <a class="code" href="abstract_c.html#a242">initDeclNode_isRedeclaration</a> (initDeclNode d)<font class="keyword"></font>
05811 <font class="keyword"></font>{
05812   <font class="keywordflow">return</font> (d-&gt;declarator-&gt;isRedecl);
05813 }
05814 
<a name="l05815"></a><a class="code" href="abstract_c.html#a243">05815</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a243">termNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> termNode t)<font class="keyword"></font>
05816 <font class="keyword"></font>{
05817   <a class="code" href="general_c.html#a0">sfree</a> (t);
05818 }
05819 
<a name="l05820"></a><a class="code" href="abstract_c.html#a244">05820</a> <font class="comment">/*@only@*/</font> termNode <a class="code" href="abstract_c.html#a244">termNode_copySafe</a> (termNode t)<font class="keyword"></font>
05821 <font class="keyword"></font>{
05822   termNode ret = termNode_copy (t);
05823 
05824   llassert (ret != NULL);
05825   <font class="keywordflow">return</font> ret;
05826 }
05827 
05828 <font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> termNode termNode_copy (<font class="comment">/*@null@*/</font> termNode t)<font class="keyword"></font>
05829 <font class="keyword"></font>{
05830   <font class="keywordflow">if</font> (t != NULL)
05831     {
05832       termNode ret = (termNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
05833 
05834       ret-&gt;wrapped = t-&gt;wrapped;
05835       ret-&gt;kind = t-&gt;kind;
05836       ret-&gt;sort = t-&gt;sort;
05837       ret-&gt;given = t-&gt;given;
05838       ret-&gt;possibleSorts = <a class="code" href="sortSet_c.html#a10">sortSet_copy</a> (t-&gt;possibleSorts);
05839       ret-&gt;error_reported = t-&gt;error_reported;
05840       ret-&gt;possibleOps = <a class="code" href="lslOpSet_c.html#a6">lslOpSet_copy</a> (t-&gt;possibleOps);
05841       ret-&gt;name = <a class="code" href="abstract_c.html#a240">nameNode_copy</a> (t-&gt;name);
05842       ret-&gt;args = <a class="code" href="termNodeList_c.html#a9">termNodeList_copy</a> (t-&gt;args);
05843       
05844       <font class="keywordflow">if</font> (t-&gt;kind == TRM_LITERAL 
05845           || t-&gt;kind == TRM_SIZEOF 
05846           || t-&gt;kind == TRM_VAR
05847           || t-&gt;kind == TRM_CONST 
05848           || t-&gt;kind == TRM_ZEROARY)
05849         {
05850           ret-&gt;literal = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (t-&gt;literal);
05851         }
05852       
05853       <font class="keywordflow">if</font> (t-&gt;kind == TRM_UNCHANGEDOTHERS)
05854         {
05855           ret-&gt;unchanged = <a class="code" href="storeRefNodeList_c.html#a3">storeRefNodeList_copy</a> (t-&gt;unchanged);
05856         }
05857       
05858       <font class="keywordflow">if</font> (t-&gt;kind == TRM_QUANTIFIER)
05859         {
05860           ret-&gt;quantified = quantifiedTermNode_copy (t-&gt;quantified);
05861         }
05862       
05863       <font class="keywordflow">if</font> (t-&gt;kind == TRM_SIZEOF)
05864         {
05865           ret-&gt;sizeofField = lclTypeSpecNode_copySafe (t-&gt;sizeofField);
05866         }
05867   
05868       <font class="keywordflow">return</font> ret;
05869     }
05870   <font class="keywordflow">else</font>
05871     {
05872 
05873       <font class="keywordflow">return</font> NULL;
05874     }
05875 }
05876 
<a name="l05877"></a><a class="code" href="abstract_c.html#a245">05877</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a245">importNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> importNode x)<font class="keyword"></font>
05878 <font class="keyword"></font>{
05879   <a class="code" href="general_c.html#a0">sfree</a> (x);
05880 }
05881 
<a name="l05882"></a><a class="code" href="abstract_c.html#a246">05882</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a246">initDeclNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> initDeclNode x)<font class="keyword"></font>
05883 <font class="keyword"></font>{
05884   <font class="keywordflow">if</font> (x != NULL)
05885     {
05886       <a class="code" href="abstract_c.html#a235">declaratorNode_free</a> (x-&gt;declarator);
05887       <a class="code" href="abstract_c.html#a243">termNode_free</a> (x-&gt;value);
05888       <a class="code" href="general_c.html#a0">sfree</a> (x);
05889     }
05890 }
05891 
<a name="l05892"></a><a class="code" href="abstract_c.html#a247">05892</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a247">letDeclNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> letDeclNode x)<font class="keyword"></font>
05893 <font class="keyword"></font>{
05894   <font class="keywordflow">if</font> (x != NULL)
05895     {
05896       lclTypeSpecNode_free (x-&gt;sortspec);
05897       <a class="code" href="abstract_c.html#a243">termNode_free</a> (x-&gt;term);
05898       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;varid);
05899       <a class="code" href="general_c.html#a0">sfree</a> (x);
05900     }
05901 }
05902 
<a name="l05903"></a><a class="code" href="abstract_c.html#a248">05903</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a248">pairNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> pairNode x)<font class="keyword"></font>
05904 <font class="keyword"></font>{
05905   <a class="code" href="general_c.html#a0">sfree</a> (x);
05906 }
05907 
<a name="l05908"></a><a class="code" href="abstract_c.html#a249">05908</a> <font class="comment">/*@null@*/</font> paramNode <a class="code" href="abstract_c.html#a249">paramNode_copy</a> (<font class="comment">/*@null@*/</font> paramNode p)<font class="keyword"></font>
05909 <font class="keyword"></font>{
05910   <font class="keywordflow">if</font> (p != NULL)
05911     {
05912       paramNode ret = (paramNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
05913 
05914       ret-&gt;type = <a class="code" href="abstract_c.html#a229">lclTypeSpecNode_copy</a> (p-&gt;type);
05915       ret-&gt;paramdecl = typeExpr_copy (p-&gt;paramdecl);
05916       ret-&gt;kind = p-&gt;kind;
05917       <font class="keywordflow">return</font> ret;
05918     }
05919 
05920   <font class="keywordflow">return</font> NULL;
05921 }
05922 
<a name="l05923"></a><a class="code" href="abstract_c.html#a250">05923</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a250">paramNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> paramNode x)<font class="keyword"></font>
05924 <font class="keyword"></font>{
05925   <font class="keywordflow">if</font> (x != NULL)
05926     {
05927       lclTypeSpecNode_free (x-&gt;type);
05928       <a class="code" href="abstract_c.html#a133">typeExpr_free</a> (x-&gt;paramdecl);
05929       <a class="code" href="general_c.html#a0">sfree</a> (x);
05930     }
05931 }
05932 
<a name="l05933"></a><a class="code" href="abstract_c.html#a251">05933</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a251">programNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> programNode x)<font class="keyword"></font>
05934 <font class="keyword"></font>{
05935   <font class="keywordflow">if</font> (x != NULL)
05936     {
05937       <font class="keywordflow">switch</font> (x-&gt;kind)
05938         {
05939         <font class="keywordflow">case</font> ACT_SELF: stmtNode_free (x-&gt;content.self); <font class="keywordflow">break</font>;
05940         <font class="keywordflow">case</font> ACT_ITER:
05941         <font class="keywordflow">case</font> ACT_ALTERNATE:
05942         <font class="keywordflow">case</font> ACT_SEQUENCE: <a class="code" href="programNodeList_c.html#a4">programNodeList_free</a> (x-&gt;content.args); <font class="keywordflow">break</font>;
05943         BADDEFAULT;
05944         }
05945       <a class="code" href="general_c.html#a0">sfree</a> (x);
05946     }
05947 }
05948 
<a name="l05949"></a><a class="code" href="abstract_c.html#a252">05949</a> quantifierNode <a class="code" href="abstract_c.html#a252">quantifierNode_copy</a> (quantifierNode x)<font class="keyword"></font>
05950 <font class="keyword"></font>{
05951   quantifierNode ret = (quantifierNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
05952   
05953   ret-&gt;quant = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (x-&gt;quant);
05954   ret-&gt;vars = <a class="code" href="varNodeList_c.html#a5">varNodeList_copy</a> (x-&gt;vars);
05955   ret-&gt;isForall = x-&gt;isForall;
05956   
05957   <font class="keywordflow">return</font> ret;
05958 }
05959 
<a name="l05960"></a><a class="code" href="abstract_c.html#a253">05960</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a253">quantifierNode_free</a> (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> quantifierNode x)<font class="keyword"></font>
05961 <font class="keyword"></font>{
05962   <font class="keywordflow">if</font> (x != NULL)
05963     {
05964       <a class="code" href="varNodeList_c.html#a4">varNodeList_free</a> (x-&gt;vars);
05965       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;quant);
05966       <a class="code" href="general_c.html#a0">sfree</a> (x);
05967     }
05968 }
05969 
<a name="l05970"></a><a class="code" href="abstract_c.html#a254">05970</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a254">replaceNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> replaceNode x)<font class="keyword"></font>
05971 <font class="keyword"></font>{
05972   <font class="keywordflow">if</font> (x != NULL)
05973     {
05974       <font class="keywordflow">if</font> (x-&gt;isCType)
05975         {
05976           ;
05977         }
05978       <font class="keywordflow">else</font>
05979         {
05980           <a class="code" href="abstract_c.html#a231">nameNode_free</a> (x-&gt;content.renamesortname.name);
05981           <a class="code" href="abstract_c.html#a234">sigNode_free</a> (x-&gt;content.renamesortname.signature);
05982         }
05983 
05984       <a class="code" href="abstract_c.html#a260">typeNameNode_free</a> (x-&gt;<font class="keyword">typename</font>);
05985       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;tok);
05986       <a class="code" href="general_c.html#a0">sfree</a> (x);
05987     }
05988 }
05989 
<a name="l05990"></a><a class="code" href="abstract_c.html#a255">05990</a> storeRefNode <a class="code" href="abstract_c.html#a255">storeRefNode_copy</a> (storeRefNode x)<font class="keyword"></font>
05991 <font class="keyword"></font>{
05992   storeRefNode ret = (storeRefNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
05993 
05994   ret-&gt;kind = x-&gt;kind;
05995 
05996   <font class="keywordflow">switch</font> (x-&gt;kind)
05997     {
05998     <font class="keywordflow">case</font> SRN_TERM:
05999       ret-&gt;content.term = <a class="code" href="abstract_c.html#a244">termNode_copySafe</a> (x-&gt;content.term); 
06000       <font class="keywordflow">break</font>;
06001     <font class="keywordflow">case</font> SRN_OBJ: <font class="keywordflow">case</font> SRN_TYPE:
06002       ret-&gt;content.type = <a class="code" href="abstract_c.html#a229">lclTypeSpecNode_copy</a> (x-&gt;content.type);
06003       <font class="keywordflow">break</font>;
06004     <font class="keywordflow">case</font> SRN_SPECIAL:
06005       ret-&gt;content.ref = <a class="code" href="sRef_c.html#a234">sRef_copy</a> (x-&gt;content.ref);
06006       <font class="keywordflow">break</font>;
06007     }
06008 
06009   <font class="keywordflow">return</font> ret;
06010 }
06011 
<a name="l06012"></a><a class="code" href="abstract_c.html#a256">06012</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a256">storeRefNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> storeRefNode x)<font class="keyword"></font>
06013 <font class="keyword"></font>{
06014   <font class="keywordflow">if</font> (x != NULL)
06015     {
06016       <font class="keywordflow">if</font> (storeRefNode_isTerm (x))
06017         {
06018           <a class="code" href="abstract_c.html#a243">termNode_free</a> (x-&gt;content.term);
06019         }
06020       <font class="keywordflow">else</font> <font class="keywordflow">if</font> (storeRefNode_isType (x) || storeRefNode_isObj (x))
06021         {
06022           lclTypeSpecNode_free (x-&gt;content.type);
06023         }
06024       <font class="keywordflow">else</font>
06025         {
06026           <font class="comment">/* nothing to free */</font>
06027         }
06028 
06029       <a class="code" href="general_c.html#a0">sfree</a> (x);
06030     }
06031 }
06032 
<a name="l06033"></a><a class="code" href="abstract_c.html#a257">06033</a> stDeclNode <a class="code" href="abstract_c.html#a257">stDeclNode_copy</a> (stDeclNode x)<font class="keyword"></font>
06034 <font class="keyword"></font>{
06035   stDeclNode ret = (stDeclNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
06036   
06037   ret-&gt;lcltypespec = lclTypeSpecNode_copySafe (x-&gt;lcltypespec);
06038   ret-&gt;declarators = <a class="code" href="declaratorNodeList_c.html#a4">declaratorNodeList_copy</a> (x-&gt;declarators);
06039   
06040   <font class="keywordflow">return</font> ret;
06041 }
06042 
<a name="l06043"></a><a class="code" href="abstract_c.html#a258">06043</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a258">stDeclNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> stDeclNode x)<font class="keyword"></font>
06044 <font class="keyword"></font>{
06045   <font class="keywordflow">if</font> (x != NULL)
06046     {
06047       lclTypeSpecNode_free (x-&gt;lcltypespec);
06048       <a class="code" href="declaratorNodeList_c.html#a5">declaratorNodeList_free</a> (x-&gt;declarators);
06049       <a class="code" href="general_c.html#a0">sfree</a> (x);
06050     }
06051 }
06052 
<a name="l06053"></a><a class="code" href="abstract_c.html#a259">06053</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a259">traitRefNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> traitRefNode x)<font class="keyword"></font>
06054 <font class="keyword"></font>{
06055   <font class="keywordflow">if</font> (x != NULL)
06056     {
06057       <a class="code" href="ltokenList_c.html#a14">ltokenList_free</a> (x-&gt;traitid);
06058       renamingNode_free (x-&gt;rename);
06059       <a class="code" href="general_c.html#a0">sfree</a> (x);
06060     }
06061 }
06062 
<a name="l06063"></a><a class="code" href="abstract_c.html#a260">06063</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a260">typeNameNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> typeNameNode n)<font class="keyword"></font>
06064 <font class="keyword"></font>{
06065   <font class="keywordflow">if</font> (n != NULL)
06066     {
06067       typeNamePack_free (n-&gt;<font class="keyword">typename</font>);
06068       opFormNode_free (n-&gt;opform);
06069       <a class="code" href="general_c.html#a0">sfree</a> (n);
06070     }
06071 }
06072 
<a name="l06073"></a><a class="code" href="abstract_c.html#a261">06073</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a261">varDeclarationNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> varDeclarationNode x)<font class="keyword"></font>
06074 <font class="keyword"></font>{
06075   <font class="keywordflow">if</font> (x != NULL)
06076     {
06077       <font class="keywordflow">if</font> (x-&gt;isSpecial)
06078         {
06079           ;
06080         }
06081       <font class="keywordflow">else</font>
06082         {
06083           lclTypeSpecNode_free (x-&gt;type);
06084           <a class="code" href="initDeclNodeList_c.html#a4">initDeclNodeList_free</a> (x-&gt;decls);
06085           <a class="code" href="general_c.html#a0">sfree</a> (x);
06086         }
06087     }
06088 }
06089 
<a name="l06090"></a><a class="code" href="abstract_c.html#a262">06090</a> varNode <a class="code" href="abstract_c.html#a262">varNode_copy</a> (varNode x)<font class="keyword"></font>
06091 <font class="keyword"></font>{
06092   varNode ret = (varNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
06093 
06094   ret-&gt;varid = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (x-&gt;varid);
06095   ret-&gt;isObj = x-&gt;isObj;
06096   ret-&gt;type = lclTypeSpecNode_copySafe (x-&gt;type);
06097   ret-&gt;sort = x-&gt;sort;
06098   
06099   <font class="keywordflow">return</font> ret;
06100 }
06101 
<a name="l06102"></a><a class="code" href="abstract_c.html#a263">06102</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a263">varNode_free</a> (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> varNode x)<font class="keyword"></font>
06103 <font class="keyword"></font>{
06104   <font class="keywordflow">if</font> (x != NULL)
06105     {
06106       lclTypeSpecNode_free (x-&gt;type);
06107       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;varid);
06108       <a class="code" href="general_c.html#a0">sfree</a> (x);
06109     }
06110 }
06111 
06112 <font class="keywordtype">void</font> stmtNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> stmtNode x)<font class="keyword"></font>
06113 <font class="keyword"></font>{
06114   <font class="keywordflow">if</font> (x != NULL)
06115     {
06116       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;lhs);
06117       <a class="code" href="termNodeList_c.html#a16">termNodeList_free</a> (x-&gt;args);
06118       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;<font class="keyword">operator</font>);
06119       <a class="code" href="general_c.html#a0">sfree</a> (x);
06120     }
06121 }
06122 
06123 <font class="keywordtype">void</font> renamingNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> renamingNode x)<font class="keyword"></font>
06124 <font class="keyword"></font>{
06125   <font class="keywordflow">if</font> (x != NULL)
06126     {
06127       <font class="keywordflow">if</font> (x-&gt;is_replace)
06128         {
06129           <a class="code" href="replaceNodeList_c.html#a4">replaceNodeList_free</a> (x-&gt;content.replace);
06130         }
06131       <font class="keywordflow">else</font>
06132         {
06133           nameAndReplaceNode_free (x-&gt;content.name);
06134         }
06135 
06136       <a class="code" href="general_c.html#a0">sfree</a> (x);
06137     }
06138 }
06139 
06140 <font class="keywordtype">void</font> nameAndReplaceNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> nameAndReplaceNode x)<font class="keyword"></font>
06141 <font class="keyword"></font>{
06142   <font class="keywordflow">if</font> (x != NULL)
06143     {
06144       <a class="code" href="typeNameNodeList_c.html#a4">typeNameNodeList_free</a> (x-&gt;namelist);
06145       <a class="code" href="replaceNodeList_c.html#a4">replaceNodeList_free</a> (x-&gt;replacelist);
06146       <a class="code" href="general_c.html#a0">sfree</a> (x);
06147     }
06148 }
06149 
06150 <font class="keywordtype">void</font> typeNamePack_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> typeNamePack x)<font class="keyword"></font>
06151 <font class="keyword"></font>{
06152   <font class="keywordflow">if</font> (x != NULL)
06153     {
06154       lclTypeSpecNode_free (x-&gt;type);
06155       abstDeclaratorNode_free (x-&gt;abst);
06156       <a class="code" href="general_c.html#a0">sfree</a> (x);
06157     }
06158 }
06159 
<a name="l06160"></a><a class="code" href="abstract_c.html#a264">06160</a> cstring <a class="code" href="abstract_c.html#a264">interfaceNode_unparse</a> (interfaceNode x)<font class="keyword"></font>
06161 <font class="keyword"></font>{
06162   <font class="keywordflow">if</font> (x != NULL)
06163     {
06164       <font class="keywordflow">switch</font> (x-&gt;kind)
06165         {
06166         <font class="keywordflow">case</font> INF_IMPORTS:
06167           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[imports] %q"</font>, importNodeList_unparse (x-&gt;content.imports)));
06168         <font class="keywordflow">case</font> INF_USES:   
06169           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[uses] %q"</font>, traitRefNodeList_unparse (x-&gt;content.uses)));
06170         <font class="keywordflow">case</font> INF_EXPORT: 
06171           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[export] %q"</font>, exportNode_unparse (x-&gt;content.export)));
06172         <font class="keywordflow">case</font> INF_PRIVATE: 
06173           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"[private] %q"</font>, privateNode_unparse (x-&gt;content.<font class="keyword">private</font>)));
06174         }
06175 
06176       BADBRANCH;
06177     }
06178   <font class="keywordflow">else</font>
06179     {
06180       <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"&lt;interface node undefined&gt;"</font>));
06181     }
06182 }
06183 
<a name="l06184"></a><a class="code" href="abstract_c.html#a265">06184</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a265">interfaceNode_free</a> (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> interfaceNode x)<font class="keyword"></font>
06185 <font class="keyword"></font>{
06186   <font class="keywordflow">if</font> (x != NULL)
06187     {
06188       
06189       <font class="keywordflow">switch</font> (x-&gt;kind)
06190         {
06191         <font class="keywordflow">case</font> INF_IMPORTS: <a class="code" href="importNodeList_c.html#a4">importNodeList_free</a> (x-&gt;content.imports); <font class="keywordflow">break</font>;
06192         <font class="keywordflow">case</font> INF_USES:    <a class="code" href="traitRefNodeList_c.html#a4">traitRefNodeList_free</a> (x-&gt;content.uses); <font class="keywordflow">break</font>;
06193         <font class="keywordflow">case</font> INF_EXPORT:  exportNode_free (x-&gt;content.export); <font class="keywordflow">break</font>;
06194         <font class="keywordflow">case</font> INF_PRIVATE: privateNode_free (x-&gt;content.<font class="keyword">private</font>); <font class="keywordflow">break</font>;
06195         }
06196       <a class="code" href="general_c.html#a0">sfree</a> (x);
06197     }
06198 }
06199 
06200 <font class="keywordtype">void</font> exportNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> exportNode x)<font class="keyword"></font>
06201 <font class="keyword"></font>{
06202   <font class="keywordflow">if</font> (x != NULL)
06203     {
06204       <font class="keywordflow">switch</font> (x-&gt;kind)
06205         {
06206         <font class="keywordflow">case</font> XPK_CONST: constDeclarationNode_free (x-&gt;content.constdeclaration); <font class="keywordflow">break</font>;
06207         <font class="keywordflow">case</font> XPK_VAR:   <a class="code" href="abstract_c.html#a261">varDeclarationNode_free</a> (x-&gt;content.vardeclaration); <font class="keywordflow">break</font>;
06208         <font class="keywordflow">case</font> XPK_TYPE: typeNode_free (x-&gt;content.type); <font class="keywordflow">break</font>;
06209         <font class="keywordflow">case</font> XPK_FCN:  <a class="code" href="abstract_c.html#a236">fcnNode_free</a> (x-&gt;content.fcn); <font class="keywordflow">break</font>;
06210         <font class="keywordflow">case</font> XPK_CLAIM: claimNode_free (x-&gt;content.claim); <font class="keywordflow">break</font>;
06211         <font class="keywordflow">case</font> XPK_ITER: iterNode_free (x-&gt;content.iter); <font class="keywordflow">break</font>;
06212         }
06213 
06214       <a class="code" href="general_c.html#a0">sfree</a> (x);
06215     }
06216 }
06217 
06218 <font class="keywordtype">void</font> privateNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> privateNode x)<font class="keyword"></font>
06219 <font class="keyword"></font>{
06220   <font class="keywordflow">if</font> (x != NULL)
06221     {
06222       <font class="keywordflow">switch</font> (x-&gt;kind)
06223         {
06224         <font class="keywordflow">case</font> PRIV_CONST:
06225           constDeclarationNode_free (x-&gt;content.constdeclaration); <font class="keywordflow">break</font>;
06226         <font class="keywordflow">case</font> PRIV_VAR: 
06227           <a class="code" href="abstract_c.html#a261">varDeclarationNode_free</a> (x-&gt;content.vardeclaration); <font class="keywordflow">break</font>;
06228         <font class="keywordflow">case</font> PRIV_TYPE: 
06229           typeNode_free (x-&gt;content.type); <font class="keywordflow">break</font>;
06230         <font class="keywordflow">case</font> PRIV_FUNCTION:
06231           <a class="code" href="abstract_c.html#a236">fcnNode_free</a> (x-&gt;content.fcn); <font class="keywordflow">break</font>;
06232         }
06233 
06234       <a class="code" href="general_c.html#a0">sfree</a> (x);
06235     }
06236 }
06237 
06238 <font class="keywordtype">void</font> constDeclarationNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> constDeclarationNode x)<font class="keyword"></font>
06239 <font class="keyword"></font>{
06240   <font class="keywordflow">if</font> (x != NULL)
06241     {
06242       lclTypeSpecNode_free (x-&gt;type);
06243       <a class="code" href="initDeclNodeList_c.html#a4">initDeclNodeList_free</a> (x-&gt;decls);
06244       <a class="code" href="general_c.html#a0">sfree</a> (x);
06245     }
06246 }
06247 
06248 <font class="keywordtype">void</font> typeNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> typeNode t)<font class="keyword"></font>
06249 <font class="keyword"></font>{
06250   <font class="keywordflow">if</font> (t != NULL)
06251     {
06252       <font class="keywordflow">switch</font> (t-&gt;kind)
06253         {
06254         <font class="keywordflow">case</font> TK_ABSTRACT: abstractNode_free (t-&gt;content.abstract); <font class="keywordflow">break</font>;
06255         <font class="keywordflow">case</font> TK_EXPOSED:  exposedNode_free (t-&gt;content.exposed); <font class="keywordflow">break</font>;
06256         <font class="keywordflow">case</font> TK_UNION: taggedUnionNode_free (t-&gt;content.taggedunion); <font class="keywordflow">break</font>;
06257         }
06258 
06259       <a class="code" href="general_c.html#a0">sfree</a> (t);
06260     }
06261 }
06262 
06263 <font class="keywordtype">void</font> claimNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> claimNode x)<font class="keyword"></font>
06264 <font class="keyword"></font>{
06265   <font class="keywordflow">if</font> (x != NULL)
06266     {
06267       <a class="code" href="paramNodeList_c.html#a7">paramNodeList_free</a> (x-&gt;params);
06268       globalList_free (x-&gt;globals);
06269       <a class="code" href="letDeclNodeList_c.html#a4">letDeclNodeList_free</a> (x-&gt;lets);
06270       lclPredicateNode_free (x-&gt;require);
06271       <a class="code" href="abstract_c.html#a251">programNode_free</a> (x-&gt;body);
06272       lclPredicateNode_free (x-&gt;ensures);
06273       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;name);
06274       <a class="code" href="general_c.html#a0">sfree</a> (x);
06275     }
06276 }
06277 
06278 <font class="keywordtype">void</font> iterNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> iterNode x)<font class="keyword"></font>
06279 <font class="keyword"></font>{
06280   <font class="keywordflow">if</font> (x != NULL)
06281     {
06282       <a class="code" href="paramNodeList_c.html#a7">paramNodeList_free</a> (x-&gt;params);
06283       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;name);
06284       <a class="code" href="general_c.html#a0">sfree</a> (x);
06285     }
06286 }
06287 
06288 <font class="keywordtype">void</font> abstractNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> abstractNode x)<font class="keyword"></font>
06289 <font class="keyword"></font>{
06290   <font class="keywordflow">if</font> (x != NULL)
06291     {
06292       abstBodyNode_free (x-&gt;body);
06293       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;tok);
06294       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;name);
06295       <a class="code" href="general_c.html#a0">sfree</a> (x);
06296     }
06297 }
06298 
06299 <font class="keywordtype">void</font> exposedNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> exposedNode x)<font class="keyword"></font>
06300 <font class="keyword"></font>{
06301   <font class="keywordflow">if</font> (x != NULL)
06302     {
06303       lclTypeSpecNode_free (x-&gt;type);
06304       <a class="code" href="declaratorInvNodeList_c.html#a4">declaratorInvNodeList_free</a> (x-&gt;decls);
06305       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;tok);
06306       <a class="code" href="general_c.html#a0">sfree</a> (x);
06307     }
06308 }
06309 
06310 <font class="keywordtype">void</font> taggedUnionNode_free (<font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> taggedUnionNode x)<font class="keyword"></font>
06311 <font class="keyword"></font>{
06312   <font class="keywordflow">if</font> (x != NULL)
06313     {
06314       <a class="code" href="stDeclNodeList_c.html#a5">stDeclNodeList_free</a> (x-&gt;structdecls);
06315       <a class="code" href="abstract_c.html#a235">declaratorNode_free</a> (x-&gt;declarator);
06316       <a class="code" href="general_c.html#a0">sfree</a> (x);
06317     }
06318 }
06319 
06320 <font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> strOrUnionNode 
06321   strOrUnionNode_copy (<font class="comment">/*@null@*/</font> strOrUnionNode n)<font class="keyword"></font>
06322 <font class="keyword"></font>{
06323   <font class="keywordflow">if</font> (n != NULL)
06324     {
06325       strOrUnionNode ret = (strOrUnionNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
06326 
06327       ret-&gt;kind = n-&gt;kind;
06328       ret-&gt;tok = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (n-&gt;tok);
06329       ret-&gt;opttagid = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (n-&gt;opttagid);
06330       ret-&gt;sort = n-&gt;sort;
06331       ret-&gt;structdecls = <a class="code" href="stDeclNodeList_c.html#a3">stDeclNodeList_copy</a> (n-&gt;structdecls);
06332 
06333       <font class="keywordflow">return</font> ret;
06334     }
06335   <font class="keywordflow">else</font>
06336     {
06337       <font class="keywordflow">return</font> NULL;
06338     }
06339 }
06340 
06341 <font class="keywordtype">void</font> strOrUnionNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> strOrUnionNode n)<font class="keyword"></font>
06342 <font class="keyword"></font>{
06343   <font class="keywordflow">if</font> (n != NULL)
06344     {
06345       <a class="code" href="stDeclNodeList_c.html#a5">stDeclNodeList_free</a> (n-&gt;structdecls);
06346       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;tok);
06347       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (n-&gt;opttagid);
06348       <a class="code" href="general_c.html#a0">sfree</a> (n);
06349     }
06350 }
06351 
06352 <font class="keywordtype">void</font> enumSpecNode_free (<font class="comment">/*@null@*/</font> <font class="comment">/*@only@*/</font> enumSpecNode x)<font class="keyword"></font>
06353 <font class="keyword"></font>{
06354   <font class="keywordflow">if</font> (x != NULL)
06355     {
06356       <a class="code" href="ltokenList_c.html#a14">ltokenList_free</a> (x-&gt;enums);
06357       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;tok);
06358       <a class="code" href="ltoken_c.html#a43">ltoken_free</a> (x-&gt;opttagid);
06359       <a class="code" href="general_c.html#a0">sfree</a> (x);
06360     }
06361 }
06362 
06363 <font class="comment">/*@only@*/</font> <font class="comment">/*@null@*/</font> enumSpecNode enumSpecNode_copy (<font class="comment">/*@null@*/</font> enumSpecNode x)<font class="keyword"></font>
06364 <font class="keyword"></font>{
06365   <font class="keywordflow">if</font> (x != NULL)
06366     {
06367       enumSpecNode ret = (enumSpecNode) dmalloc (<font class="keyword">sizeof</font> (*ret));
06368 
06369       ret-&gt;tok = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (x-&gt;tok);
06370       ret-&gt;opttagid = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (x-&gt;opttagid);
06371       ret-&gt;enums = <a class="code" href="ltokenList_c.html#a10">ltokenList_copy</a> (x-&gt;enums);
06372       ret-&gt;sort = x-&gt;sort;
06373 
06374       <font class="keywordflow">return</font> ret;
06375     }
06376   <font class="keywordflow">else</font>
06377     {
06378       <font class="keywordflow">return</font> NULL;
06379     }
06380 }
06381 
<a name="l06382"></a><a class="code" href="abstract_c.html#a266">06382</a> <font class="keywordtype">void</font> <a class="code" href="abstract_c.html#a266">lsymbol_setbool</a> (lsymbol s)<font class="keyword"></font>
06383 <font class="keyword"></font>{
06384   lsymbol_bool = s;
06385 }
06386 
<a name="l06387"></a><a class="code" href="abstract_c.html#a267">06387</a> lsymbol <a class="code" href="abstract_c.html#a267">lsymbol_getbool</a> ()<font class="keyword"></font>
06388 <font class="keyword"></font>{
06389   <font class="keywordflow">return</font> lsymbol_bool;
06390 }
06391 
<a name="l06392"></a><a class="code" href="abstract_c.html#a268">06392</a> lsymbol <a class="code" href="abstract_c.html#a268">lsymbol_getBool</a> ()<font class="keyword"></font>
06393 <font class="keyword"></font>{
06394   <font class="keywordflow">return</font> lsymbol_Bool;
06395 }
06396 
<a name="l06397"></a><a class="code" href="abstract_c.html#a269">06397</a> lsymbol <a class="code" href="abstract_c.html#a269">lsymbol_getFALSE</a> ()<font class="keyword"></font>
06398 <font class="keyword"></font>{
06399   <font class="keywordflow">return</font> lsymbol_FALSE;
06400 }
06401 
<a name="l06402"></a><a class="code" href="abstract_c.html#a270">06402</a> lsymbol <a class="code" href="abstract_c.html#a270">lsymbol_getTRUE</a> ()<font class="keyword"></font>
06403 <font class="keyword"></font>{
06404   <font class="keywordflow">return</font> lsymbol_TRUE;
06405 }
06406 
06407 
</div></pre><hr><address><small>Generated at Fri Nov 3 18:57:38 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
