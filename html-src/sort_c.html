<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>sort.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.3 on Fri Nov 3 18:58:05 2000 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>sort.c File Reference</h1><code>#include "lclintMacros.nf"</code><br>
<code>#include "llbasic.h"</code><br>
<code>#include "llgrammar.h"</code><br>
<code>#include "lclscan.h"</code><br>

<p>
<a href="sort_c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a0">MAXBUFFLEN</a>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a1">DELTA</a>&nbsp;&nbsp;&nbsp;100</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a2">NOSORTHANDLE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a3">HOFSORTHANDLE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a4">MAX_SORT_DEPTH</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a64">sort_destroyMod</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a65">sort_makeNoSort</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a66">sort_makeHOFSort</a> (sort base)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a69">sort_makeSort</a> ( ltoken t, lsymbol n)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a72">sort_makeSyn</a> (ltoken t, sort s, lsymbol n)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a73">sort_makeFormal</a> (sort insort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a74">sort_makeGlobal</a> (sort insort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a75">sort_makeObj</a> (sort sor)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a76">sort_makePtr</a> (ltoken t, sort baseSort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a77">sort_makePtrN</a> (sort s, int pointers)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a78">sort_makeArr</a> (ltoken t, sort baseSort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a79">sort_makeVec</a> (ltoken t, sort arraySort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a80">sort_makeVal</a> (sort sor)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a81">sort_makeImmutable</a> (ltoken t, lsymbol name)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a82">sort_makeMutable</a> (ltoken t, lsymbol name)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a83">sort_makeStr</a> (ltoken opttagid)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a84">sort_updateStr</a> (sort strSort, smemberInfo *info)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a85">sort_makeTuple</a> (ltoken t, sort strSort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a86">sort_makeUnion</a> (ltoken opttagid)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a87">sort_updateUnion</a> (sort unionSort, smemberInfo *info)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken t, sort unionSort)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a89">sort_makeEnum</a> (ltoken opttagid)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a90">sort_updateEnum</a> (sort enumSort, smemberInfo *info)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a91">sort_init</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a92">sort_lookupName</a> (lsymbol name)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a93">sort_printStats</a> (void)</td></tr>
<tr><td nowrap align=right valign=top>sortNode&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a94">sort_lookup</a> (sort sor)</td></tr>
<tr><td nowrap align=right valign=top>sortNode&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a95">sort_quietLookup</a> (sort sor)</td></tr>
<tr><td nowrap align=right valign=top>cstring&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a98">sort_unparse</a> (sort s)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a100">sort_getUnderlying</a> (sort s)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a103">sort_mutable</a> (sort s)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a104">sort_setExporting</a> (bool flag)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a105">sort_isValidSort</a> (sort s)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a106">sort_dump</a> (FILE *f, bool lco)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a109">sort_import</a> (tsource *imported, ltoken tok, mapping * map)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a110">sort_equal</a> (sort *s1, sort *s2)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a111">sort_compatible</a> (sort s1, sort s2)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a112">sort_compatible_modulo_cstring</a> (sort s1, sort s2)</td></tr>
<tr><td nowrap align=right valign=top>lsymbol&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a113">sort_getLsymbol</a> (sort sor)</td></tr>
<tr><td nowrap align=right valign=top>char*&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a114">sort_getName</a> (sort s)</td></tr>
<tr><td nowrap align=right valign=top>cstring&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a115">sort_unparseName</a> (sort s)</td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a116">sort_fromLsymbol</a> (lsymbol sortid)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a117">sort_isHOFSortKind</a> (sort s)</td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a5">sort_bool</a></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a6">sort_capBool</a></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a7">sort_int</a></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a8">sort_char</a></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a9">sort_float</a></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a10">sort_double</a></td></tr>
<tr><td nowrap align=right valign=top>sort&nbsp;</td><td valign=bottom><a class="el" href="sort_c.html#a11">sort_cstring</a></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a name="a1" doxytag="sort.c::DELTA"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define DELTA&nbsp;&nbsp;&nbsp;100
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00053">53</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a3" doxytag="sort.c::HOFSORTHANDLE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define HOFSORTHANDLE&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00059">59</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a0" doxytag="sort.c::MAXBUFFLEN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define MAXBUFFLEN&nbsp;&nbsp;&nbsp;1024
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00050">50</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a4" doxytag="sort.c::MAX_SORT_DEPTH"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define MAX_SORT_DEPTH&nbsp;&nbsp;&nbsp;10
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02243">2243</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a2" doxytag="sort.c::NOSORTHANDLE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
#define NOSORTHANDLE&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00056">56</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a111" doxytag="sort.c::sort_compatible"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_compatible (
          </b></td>
          <td valign="bottom"><b>
sort <em>s1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>s2</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03017">3017</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="checking_c-source.html#l00384">checkLclPredicate</a>(), and <a class="el" href="sort_c-source.html#l03033">sort_compatible_modulo_cstring</a>().<div class="fragment"><pre>03018 {
03019   sort syn1, syn2;
03020  <font class="comment">/* later: might consider "char" and enum types the same as "int" */</font>
03021   <font class="keywordflow">if</font> (s1 == s2)
03022     <font class="keywordflow">return</font> TRUE;
03023  <font class="comment">/* handle synonym sorts */</font>
03024   syn1 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s1);
03025   syn2 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s2);
03026   <font class="keywordflow">if</font> (syn1 == syn2)
03027     <font class="keywordflow">return</font> TRUE;
03028   <font class="comment">/* makes bool and Bool equal */</font>
03029   <font class="keywordflow">return</font> FALSE;
03030 }
</div></pre>    </td>
  </tr>
</table>
<a name="a112" doxytag="sort.c::sort_compatible_modulo_cstring"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_compatible_modulo_cstring (
          </b></td>
          <td valign="bottom"><b>
sort <em>s1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>s2</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03033">3033</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.<div class="fragment"><pre>03034 {
03035  <font class="comment">/* like sort_compatible but also handles special cstring inits,</font>
03036 <font class="comment">    allows the following 2 cases:</font>
03037 <font class="comment">     char c[] = "abc"; (LHS: char_Obj_Arr, RHS = char_Vec)</font>
03038 <font class="comment">                       (c as implicitly coerced into c^)</font>
03039 <font class="comment">     char *d = "abc";  (LHS: char_Obj_Ptr, RHS = char_Vec)</font>
03040 <font class="comment">                       (d as implicitly coerced into d[]^)</font>
03041 <font class="comment">                       */</font>
03042   sort syn1, syn2;
03043   <font class="keywordflow">if</font> (<a class="code" href="sort_c.html#a111">sort_compatible</a> (s1, s2))
03044     <font class="keywordflow">return</font> TRUE;
03045   syn1 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s1);
03046   syn2 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (s2);
03047   <font class="keywordflow">if</font> (sort_cstring == syn2 &amp;&amp;
03048       (syn1 == char_obj_ptrSort || syn1 == char_obj_ArrSort))
03049     <font class="keywordflow">return</font> TRUE;
03050   <font class="keywordflow">return</font> FALSE;
03051 }
</div></pre>    </td>
  </tr>
</table>
<a name="a64" doxytag="sort.c::sort_destroyMod"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void sort_destroyMod (
          </b></td>
          <td valign="bottom"><b>
void&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00195">195</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.<div class="fragment"><pre>00201 {
00202   <font class="keywordflow">if</font> (sortTable != NULL)  
00203     {
00204       <font class="keywordtype">int</font> i;
00205 
00206       <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
00207         {
00208           sortNode_free (sortTable[i]);
00209         }
00210 
00211       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (arrayRefNameNode);
00212       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (ptr2arrayNameNode);
00213       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (deRefNameNode);
00214       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (nilNameNode);
00215       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (plusNameNode);
00216       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (minusNameNode);
00217       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (condNameNode);
00218       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (eqNameNode);
00219       <a class="code" href="abstract_c.html#a231">nameNode_free</a> (neqNameNode);
00220 
00221       <a class="code" href="general_c.html#a0">sfree</a> (sortTable);
00222       <font class="comment">/*@-branchstate@*/</font>
00223     }
00224 }
</div></pre>    </td>
  </tr>
</table>
<a name="a106" doxytag="sort.c::sort_dump"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void sort_dump (
          </b></td>
          <td valign="bottom"><b>
FILE * <em>f</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
bool <em>lco</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02329">2329</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="imports_c-source.html#l00048">outputLCSFile</a>().<div class="fragment"><pre>02330 {
02331   <font class="keywordtype">int</font> i;
02332   sortNode s;
02333   smemberInfo *mem;
02334 
02335   fprintf (f, <font class="stringliteral">"%s\n"</font>, BEGINSORTTABLE);
02336   llassert (sortTable != NULL);
02337 
02338   <font class="keywordflow">for</font> (i = 2; i &lt; sortTableSize; i++)
02339     {
02340       <font class="comment">/* skips 0 and 1, noSort and HOFSort */</font>
02341       s = sortTable[i];
02342       
02343       <font class="comment">/* if (lco &amp;&amp; !s.export) continue; */</font>
02344       <font class="comment">/* Difficult to keep track of where each op and sort belong to</font>
02345 <font class="comment">         which LCL type.  Easiest to export them all (even private sorts and</font>
02346 <font class="comment">         op's) but for checking imported modules, we only use LCL types and</font>
02347 <font class="comment">         variables to check, i.e., we don't rely on sorts and op's for such</font>
02348 <font class="comment">         checking. */</font>
02349       
02350       <font class="keywordflow">if</font> (s.kind == SRT_NONE)
02351         <font class="keywordflow">continue</font>;
02352       
02353       <font class="keywordflow">if</font> (lco)
02354         {
02355           fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02356         }
02357 
02358       <font class="keywordflow">if</font> (lsymbol_isDefined (s.name))
02359         {
02360           fprintf (f, <font class="stringliteral">"sort %s "</font>, lsymbol_toCharsSafe (s.name));
02361         }
02362       <font class="keywordflow">else</font>
02363         {
02364           llcontbug (message (<font class="stringliteral">"Invalid sort in sort_dump: sort %d; sortname: %s.  This may result from using .lcs files produced by an old version of LCLint.  Remove the .lcs files, and rerun LCLint."</font>,
02365                               i, lsymbol_toString (s.name)));
02366           fprintf (f, <font class="stringliteral">"sort _error_ "</font>);
02367         }
02368       
02369       <font class="keywordflow">if</font> (!lco &amp;&amp; !s.export)
02370         fprintf (f, <font class="stringliteral">"private "</font>);
02371 
02372       <font class="comment">/*@-loopswitchbreak@*/</font>
02373       <font class="keywordflow">switch</font> (s.kind)
02374         {
02375         <font class="keywordflow">case</font> SRT_HOF:
02376           fprintf (f, <font class="stringliteral">"hof nil nil\n"</font>);
02377           <font class="keywordflow">break</font>;
02378         <font class="keywordflow">case</font> SRT_PRIM:
02379           <font class="keywordflow">if</font> (s.abstract)
02380             fprintf (f, <font class="stringliteral">"immutable nil nil\n"</font>);
02381           <font class="keywordflow">else</font>
02382             fprintf (f, <font class="stringliteral">"primitive nil nil\n"</font>);
02383           <font class="keywordflow">break</font>;
02384         <font class="keywordflow">case</font> SRT_OBJ:
02385           <font class="keywordflow">if</font> (s.abstract)
02386             fprintf (f, <font class="stringliteral">"mutable %s nil\n"</font>,
02387                      lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02388           <font class="keywordflow">else</font>
02389             fprintf (f, <font class="stringliteral">"obj %s nil\n"</font>,
02390                      lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02391           <font class="keywordflow">break</font>;
02392         <font class="keywordflow">case</font> SRT_SYN:
02393           fprintf (f, <font class="stringliteral">"synonym %s nil\n"</font>,
02394                    lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02395           <font class="keywordflow">break</font>;
02396         <font class="keywordflow">case</font> SRT_PTR:
02397           fprintf (f, <font class="stringliteral">"ptr %s nil\n"</font>, lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02398           <font class="keywordflow">break</font>;
02399         <font class="keywordflow">case</font> SRT_ARRAY:
02400           fprintf (f, <font class="stringliteral">"arr %s nil\n"</font>,
02401                    lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02402           <font class="keywordflow">break</font>;
02403         <font class="keywordflow">case</font> SRT_VECTOR:
02404           fprintf (f, <font class="stringliteral">"vec %s %s\n"</font>,
02405                    lsymbol_toCharsSafe (sortTable[s.baseSort].name),
02406                    <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sortTable[s.objSort].name));
02407           <font class="keywordflow">break</font>;
02408         <font class="keywordflow">case</font> SRT_STRUCT:
02409           <font class="keywordflow">if</font> (s.tag == lsymbol_undefined)
02410             {
02411               <font class="comment">/* we need to make up a tag to prevent excessive</font>
02412 <font class="comment">                 growth of .lcs files when tags are overloaded</font>
02413 <font class="comment">                 */</font>
02414               llbuglit (<font class="stringliteral">"Struct has no tag"</font>);
02415             }
02416           <font class="keywordflow">else</font>
02417             fprintf (f, <font class="stringliteral">"str %s nil\n"</font>, lsymbol_toCharsSafe (s.tag));
02418 
02419           <font class="keywordflow">for</font> (mem = s.members;
02420                mem != smemberInfo_undefined; mem = mem-&gt;next)
02421             {
02422               <font class="keywordflow">if</font> (lco)
02423                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02424               fprintf (f, <font class="stringliteral">"sort %s strMem %s nil\n"</font>, lsymbol_toCharsSafe (mem-&gt;name),
02425                        <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sortTable[mem-&gt;sort].name));
02426             }
02427           <font class="keywordflow">if</font> (lco)
02428             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02429           fprintf (f, <font class="stringliteral">"sort strEnd nil nil nil\n"</font>);
02430           <font class="keywordflow">break</font>;
02431         <font class="keywordflow">case</font> SRT_UNION:
02432           <font class="keywordflow">if</font> (s.tag == lsymbol_undefined)
02433             llbuglit (<font class="stringliteral">"Union has no tag"</font>);
02434           <font class="keywordflow">else</font>
02435             fprintf (f, <font class="stringliteral">"union %s nil\n"</font>, lsymbol_toCharsSafe (s.tag));
02436           <font class="keywordflow">for</font> (mem = s.members;
02437                mem != smemberInfo_undefined; mem = mem-&gt;next)
02438             {
02439               <font class="keywordflow">if</font> (lco)
02440                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02441               fprintf (f, <font class="stringliteral">"sort %s unionMem %s nil\n"</font>, lsymbol_toCharsSafe (mem-&gt;name),
02442                        <a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sortTable[mem-&gt;sort].name));
02443             }
02444           <font class="keywordflow">if</font> (lco)
02445             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02446           fprintf (f, <font class="stringliteral">"sort unionEnd nil nil nil\n"</font>);
02447           <font class="keywordflow">break</font>;
02448         <font class="keywordflow">case</font> SRT_ENUM:
02449           <font class="keywordflow">if</font> (s.tag == lsymbol_undefined)
02450             {
02451               llbuglit (<font class="stringliteral">"Enum has no tag"</font>);
02452             }
02453 
02454           fprintf (f, <font class="stringliteral">"enum %s nil\n"</font>, lsymbol_toCharsSafe (s.tag));
02455 
02456           <font class="keywordflow">for</font> (mem = s.members;
02457                mem != smemberInfo_undefined; mem = mem-&gt;next)
02458             {
02459               <font class="keywordflow">if</font> (lco)
02460                 fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02461               fprintf (f, <font class="stringliteral">"sort %s enumMem nil nil\n"</font>, lsymbol_toCharsSafe (mem-&gt;name));
02462             }
02463           <font class="keywordflow">if</font> (lco)
02464             fprintf (f, <font class="stringliteral">"%%LCL"</font>);
02465           fprintf (f, <font class="stringliteral">"sort enumEnd nil nil nil\n"</font>);
02466           <font class="keywordflow">break</font>;
02467         <font class="keywordflow">case</font> SRT_TUPLE:
02468           fprintf (f, <font class="stringliteral">"tup %s nil\n"</font>, lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02469           <font class="keywordflow">break</font>;
02470         <font class="keywordflow">case</font> SRT_UNIONVAL:
02471           fprintf (f, <font class="stringliteral">"unionval %s nil\n"</font>,
02472                    lsymbol_toCharsSafe (sortTable[s.baseSort].name));
02473           <font class="keywordflow">break</font>;
02474         <font class="keywordflow">default</font>:
02475           fprintf (f, <font class="stringliteral">"sort_dump: unexpected sort: %d"</font>, (<font class="keywordtype">int</font>)s.kind);
02476         }                       <font class="comment">/* switch */</font>
02477       <font class="comment">/*@=loopswitchbreak@*/</font>
02478     }
02479 
02480   fprintf (f, <font class="stringliteral">"%s\n"</font>, SORTTABLEEND);
02481 }
</div></pre>    </td>
  </tr>
</table>
<a name="a110" doxytag="sort.c::sort_equal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_equal (
          </b></td>
          <td valign="bottom"><b>
sort * <em>s1</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort * <em>s2</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02999">2999</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sortSet_c-source.html#l00125">sortSet_member</a>(), and <a class="el" href="symtable_c-source.html#l02082">symtable_opsWithLegalDomain</a>().<div class="fragment"><pre>03000 {
03001   sort syn1, syn2;
03002   <font class="keywordflow">if</font> ((s1 != 0) &amp;&amp; (s2 != 0))
03003     {
03004       <font class="keywordflow">if</font> ((*s1) == (*s2))
03005         <font class="keywordflow">return</font> TRUE;
03006      <font class="comment">/* handle synonym sorts */</font>
03007       syn1 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (*s1);
03008       syn2 = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (*s2);
03009       <font class="keywordflow">if</font> (syn1 == syn2)
03010         <font class="keywordflow">return</font> TRUE;
03011      <font class="comment">/* makes bool and Bool equal */</font>
03012     }
03013   <font class="keywordflow">return</font> FALSE;
03014 }
</div></pre>    </td>
  </tr>
</table>
<a name="a116" doxytag="sort.c::sort_fromLsymbol"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_fromLsymbol (
          </b></td>
          <td valign="bottom"><b>
lsymbol <em>sortid</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03120">3120</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="lslparse_c-source.html#l00150">processTraitSortId</a>(), and <a class="el" href="abstract_c-source.html#l05542">sigNode_rangeSort</a>().<div class="fragment"><pre>03121 {
03122  <font class="comment">/* like sort_lookupName but creates sort if not already present */</font>
03123   sort sort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (sortid);
03124   <font class="keywordflow">if</font> (sort == NOSORTHANDLE)
03125     sort = <a class="code" href="sort_c.html#a69">sort_makeSort</a> (ltoken_undefined, sortid);
03126   <font class="keywordflow">return</font> sort;
03127 }
</div></pre>    </td>
  </tr>
</table>
<a name="a113" doxytag="sort.c::sort_getLsymbol"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
lsymbol sort_getLsymbol (
          </b></td>
          <td valign="bottom"><b>
sort <em>sor</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03054">3054</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05197">checkAndEnterTag</a>(), and <a class="el" href="symtable_c-source.html#l00511">symtable_enterType</a>().<div class="fragment"><pre>03055 {
03056  <font class="comment">/*  sortNode sn = sort_lookup (sor); */</font>
03057   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sor);
03058   <font class="keywordflow">return</font> sn.name;
03059 }
</div></pre>    </td>
  </tr>
</table>
<a name="a114" doxytag="sort.c::sort_getName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
char * sort_getName (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03063">3063</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.<div class="fragment"><pre>03064 {
03065   <font class="keywordflow">return</font> (<a class="code" href="lsymbol_c.html#a16">lsymbol_toCharsSafe</a> (sort_getLsymbol (s)));
03066 }
</div></pre>    </td>
  </tr>
</table>
<a name="a100" doxytag="sort.c::sort_getUnderlying"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_getUnderlying (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02265">2265</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05080">makeTypeSpecifier</a>(), <a class="el" href="sort_c-source.html#l03017">sort_compatible</a>(), <a class="el" href="sort_c-source.html#l03033">sort_compatible_modulo_cstring</a>(), <a class="el" href="sort_c-source.html#l02999">sort_equal</a>(), <a class="el" href="sort_c-source.html#l00489">sort_makeFormal</a>(), <a class="el" href="sort_c-source.html#l00514">sort_makeGlobal</a>(), and <a class="el" href="sort_c-source.html#l00544">sort_makeObj</a>().<div class="fragment"><pre>02266 {
02267   <font class="keywordflow">return</font> sort_getUnderlyingAux (s, 0);
02268 }
</div></pre>    </td>
  </tr>
</table>
<a name="a109" doxytag="sort.c::sort_import"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void sort_import (
          </b></td>
          <td valign="bottom"><b>
tsource * <em>imported</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
ltoken <em>tok</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
mapping * <em>map</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02867">2867</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="imports_c-source.html#l00165">processImport</a>().<div class="fragment"><pre>02868 {
02869   <font class="comment">/* tok is only used for error message line number */</font>
02870   <font class="keywordtype">char</font> *buf, *importfile;
02871   tsource *lclsource;
02872   sort bsort;
02873   lsymbolList slist = <a class="code" href="lsymbolList_c.html#a0">lsymbolList_new</a> ();
02874 
02875   buf = <a class="code" href="source_c.html#a4">tsource_nextLine</a> (imported);
02876 
02877   llassert (buf != NULL);
02878 
02879   importfile = tsource_fileName (imported);
02880 
02881   <font class="keywordflow">if</font> (!<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCLSortTable"</font>))
02882     {
02883       lclsource = <a class="code" href="lclscan_c.html#a12">LCLScanSource</a> ();
02884 
02885       <a class="code" href="llerror_c.html#a56">lclfatalerror</a> (tok, message (<font class="stringliteral">"Expecting \"%%LCLSortTable\" line "</font>
02886                                    <font class="stringliteral">"in import file %s:\n%s"</font>,
02887                                    cstring_fromChars (importfile), 
02888                                    <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (buf)));
02889       
02890     }
02891 
02892   <font class="keywordflow">for</font> (;;)
02893     {
02894       buf = <a class="code" href="source_c.html#a4">tsource_nextLine</a> (imported);
02895 
02896       llassert (buf != NULL);
02897 
02898       <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCLSortTableEnd"</font>))
02899         {
02900           <font class="keywordflow">break</font>;
02901         }
02902       <font class="keywordflow">else</font>
02903         { <font class="comment">/* a good line, remove %LCL from line first */</font>
02904           <font class="keywordflow">if</font> (<a class="code" href="general_c.html#a10">firstWord</a> (buf, <font class="stringliteral">"%LCL"</font>))
02905             {
02906               parseSortLine (buf + 4, tok, imported, map, slist);
02907             }
02908           <font class="keywordflow">else</font>
02909             {
02910               lclsource = <a class="code" href="lclscan_c.html#a12">LCLScanSource</a> ();
02911               lclfatalerror
02912                 (tok, 
02913                  <a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"Expecting '%%LCL' prefix in import file %s:\n%s\n"</font>,
02914                           cstring_fromChars (importfile), 
02915                           <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (buf)));
02916             }
02917         }
02918     }
02919 
02920   <font class="comment">/* now process the smemberInfo in the sort List */</font>
02921   lsymbolList_elements (slist, s)<font class="keyword"></font>
02922 <font class="keyword">    </font>{
02923       <font class="keywordflow">if</font> (s != lsymbol_undefined)
02924         {
02925           sort sor;
02926           sortNode sn;
02927 
02928           sor = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (s);
02929           sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sor);
02930           
02931           <font class="keywordflow">switch</font> (sn.kind)
02932             {
02933             <font class="keywordflow">case</font> SRT_ENUM:
02934               {                 <font class="comment">/* update the symbol table with members of enum */</font>
02935                 varInfo vi;
02936                 smemberInfo *mlist = sn.members;
02937                 <font class="keywordflow">for</font> (; mlist != NULL; mlist = mlist-&gt;next)
02938                   {
02939                     <font class="comment">/* check that enumeration constants are unique */</font>
02940                     vi = <a class="code" href="symtable_c.html#a50">symtable_varInfo</a> (g_symtab, mlist-&gt;name);
02941                     <font class="keywordflow">if</font> (!varInfo_exists (vi))
02942                       { <font class="comment">/* put info into symbol table */</font>
02943                         vi = (varInfo) dmalloc (<font class="keyword">sizeof</font> (*vi));
02944                         vi-&gt;id = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (NOTTOKEN, mlist-&gt;name);
02945                         vi-&gt;kind = VRK_ENUM;
02946                         vi-&gt;sort = sor;
02947                         vi-&gt;export = TRUE;
02948 
02949                         (<font class="keywordtype">void</font>) <a class="code" href="symtable_c.html#a47">symtable_enterVar</a> (g_symtab, vi);
02950                         <a class="code" href="symtable_c.html#a29">varInfo_free</a> (vi);
02951                       }
02952                     <font class="keywordflow">else</font>
02953                       {
02954                         lclplainerror 
02955                           (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%s: enum member %s of %s has already been declared"</font>,
02956                                     cstring_fromChars (importfile), 
02957                                     <a class="code" href="lsymbol_c.html#a15">lsymbol_toString</a> (mlist-&gt;name),
02958                                     <a class="code" href="lsymbol_c.html#a15">lsymbol_toString</a> (sn.name)));
02959                       }
02960                   }
02961                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02962               }
02963             <font class="keywordflow">case</font> SRT_STRUCT:
02964             <font class="keywordflow">case</font> SRT_UNION:
02965               {
02966                 smemberInfo *mlist = sn.members;
02967 
02968                 <font class="keywordflow">for</font> (; mlist != NULL; mlist = mlist-&gt;next)
02969                   {
02970                     bsort = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (lsymbol_translateSort (map, mlist-&gt;sortname));
02971                     <font class="keywordflow">if</font> (sort_isNoSort (bsort))
02972                       {
02973                         <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%s: member %s of %s has unknown sort\n"</font>,
02974                                          cstring_fromChars (importfile), 
02975                                          <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (mlist-&gt;name)),
02976                                          <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (sn.name))));
02977                       }
02978                     <font class="keywordflow">else</font>
02979                       {
02980                         mlist-&gt;sort = bsort;
02981                       }
02982                   }
02983                 <font class="comment">/*@switchbreak@*/</font> <font class="keywordflow">break</font>;
02984               }
02985             <font class="keywordflow">default</font>:
02986               <a class="code" href="llerror_c.html#a47">lclbug</a> (message (<font class="stringliteral">"%s: %s has unexpected sort kind %s"</font>,
02987                                cstring_fromChars (importfile), 
02988                                <a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (lsymbol_toChars (sn.name)),
02989                                sort_unparseKind (sn.kind)));
02990             }
02991         }
02992     } end_lsymbolList_elements;
02993   
02994   <font class="comment">/* list and sorts in it are not used anymore */</font>
02995   <a class="code" href="lsymbolList_c.html#a3">lsymbolList_free</a> (slist);
02996 }
</div></pre>    </td>
  </tr>
</table>
<a name="a91" doxytag="sort.c::sort_init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void sort_init (
          </b></td>
          <td valign="bottom"><b>
void&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01786">1786</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.<div class="fragment"><pre>01798 {
01799   <font class="comment">/* on alpha, declaration does not allocate storage */</font>
01800   opFormNode opform;
01801   opFormUnion u;
01802   underscoreSymbol = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_"</font>);
01803 
01804   <font class="comment">/*</font>
01805 <font class="comment">  ** commonly used data for generating operators </font>
01806 <font class="comment">  */</font>
01807   
01808   <a class="code" href="abstract_c.html#a266">lsymbol_setbool</a> (lsymbol_fromChars (<font class="stringliteral">"bool"</font>));
01809   intToken = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_SORT, lsymbol_fromChars (<font class="stringliteral">"int"</font>));
01810   
01811   <font class="comment">/*</font>
01812 <font class="comment">  ** __ \eq __: sort, sort -&gt; bool </font>
01813 <font class="comment">  */</font>
01814 
01815   u.anyop = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_eq);
01816   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01817   eqNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01818   
01819   <font class="comment">/*</font>
01820 <font class="comment">  ** __ \neq __: sort, sort -&gt; bool </font>
01821 <font class="comment">  */</font>
01822 
01823   u.anyop = <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_neq);
01824   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01825   neqNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01826   
01827   <font class="comment">/*</font>
01828 <font class="comment">  **if __ then __ else __: bool, sort, sort -&gt; sort </font>
01829 <font class="comment">  */</font>
01830 
01831   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_IF, 
01832                            opFormUnion_createMiddle (0), ltoken_undefined);
01833   condNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01834   
01835   <font class="comment">/* operator: __[__]: arraySort, int -&gt; elementSort_Obj */</font>
01836   u.middle = 1;
01837   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_copy (ltoken_lbracked), OPF_BMMIDDLE, u,
01838                            <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_rbracket));
01839   arrayRefNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01840   
01841   <font class="comment">/* operator: __[]: ptrSort -&gt; arraySort */</font>
01842   u.middle = 0;
01843   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_copy (ltoken_lbracked), 
01844                            OPF_BMMIDDLE, u,
01845                            <a class="code" href="ltoken_c.html#a39">ltoken_copy</a> (ltoken_rbracket));
01846   ptr2arrayNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01847   
01848   <font class="comment">/* operator: *__ */</font>
01849   u.anyop = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (LLT_MULOP, lsymbol_fromChars (<font class="stringliteral">"*"</font>));
01850   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_ANYOPM, u, ltoken_undefined);
01851   deRefNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01852   
01853   <font class="comment">/* operator: __ + __ */</font>
01854   u.anyop = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleOp, lsymbol_fromChars (<font class="stringliteral">"+"</font>));
01855   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01856   plusNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01857   
01858   <font class="comment">/* operator: __ - __ */</font>
01859   u.anyop = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleOp, lsymbol_fromChars (<font class="stringliteral">"-"</font>));
01860   opform = <a class="code" href="abstract_c.html#a106">makeOpFormNode</a> (ltoken_undefined, OPF_MANYOPM, u, ltoken_undefined);
01861   minusNameNode = <a class="code" href="abstract_c.html#a98">makeNameNodeForm</a> (opform);
01862   
01863   <font class="comment">/* operator: NIL */</font>
01864   nilNameNode = (nameNode) dmalloc (<font class="keyword">sizeof</font> (*nilNameNode));
01865   nilNameNode-&gt;isOpId = TRUE;
01866   nilNameNode-&gt;content.opid = <a class="code" href="ltoken_c.html#a34">ltoken_createType</a> (simpleId, SID_OP, 
01867                                                  lsymbol_fromChars (<font class="stringliteral">"NIL"</font>));
01868 
01869   noSort.kind = SRT_NONE;
01870   noSort.name = <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_unknown"</font>);;
01871   noSort.tag = lsymbol_undefined;
01872   noSort.baseSort = NOSORTHANDLE;
01873   noSort.objSort = NOSORTHANDLE;
01874   noSort.members = smemberInfo_undefined;
01875   noSort.export = FALSE;
01876   noSort.mutable = FALSE;
01877   noSort.abstract = FALSE;
01878   noSort.imported = FALSE;
01879   noSort.handle = NOSORTHANDLE;
01880   
01881   <font class="comment">/*</font>
01882 <font class="comment">  ** Store the null sort into table, and in the process initialize the sort table. </font>
01883 <font class="comment">  ** Must be the first sort_enter so NOSORTHANDLE is truly = 0. Similarly, </font>
01884 <font class="comment">  ** for HOFSORTHANDLE = 1.</font>
01885 <font class="comment">  */</font>
01886   
01887   noSort.handle = sort_enterGlobal (noSort);
01888   (<font class="keywordtype">void</font>) sort_enterGlobal (HOFSort); 
01889   
01890   <font class="comment">/* Other builtin sorts */</font>
01891   
01892   sort_bool = <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"bool"</font>));
01893   sort_capBool = sort_makeSortNoOps (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"Bool"</font>));
01894   
01895   llassert (sortTable != NULL);
01896 
01897   <font class="comment">/* make sort_Bool a synonym for sort_bool */</font>
01898   sortTable[sort_capBool].kind = SRT_SYN;
01899   sortTable[sort_capBool].baseSort = sort_bool;
01900   sortTable[sort_capBool].mutable = FALSE;
01901   sortTable[sort_capBool].abstract = TRUE;
01902   
01903   sort_int = sort_makeLiteralSort (ltoken_undefined, 
01904                                    lsymbol_fromChars (<font class="stringliteral">"int"</font>));
01905   sort_char = sort_makeLiteralSort (ltoken_undefined,
01906                                     lsymbol_fromChars (<font class="stringliteral">"char"</font>));
01907   sort_void = sort_makeLiteralSort (ltoken_undefined,
01908                                     lsymbol_fromChars (<font class="stringliteral">"void"</font>));
01909   
01910   <font class="comment">/* sort_cstring is char__Vec, for C strings eg: "xyz" */</font>
01911   char_obj_ptrSort = <a class="code" href="sort_c.html#a76">sort_makePtr</a> (ltoken_undefined, sort_char);
01912   char_obj_ArrSort = <a class="code" href="sort_c.html#a78">sort_makeArr</a> (ltoken_undefined, sort_char);
01913   
01914   sort_cstring = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (char_obj_ArrSort);
01915   sort_float = sort_makeLiteralSort (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"float"</font>));
01916   sort_double = sort_makeLiteralSort (ltoken_undefined, lsymbol_fromChars (<font class="stringliteral">"double"</font>));
01917 }
</div></pre>    </td>
  </tr>
</table>
<a name="a117" doxytag="sort.c::sort_isHOFSortKind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_isHOFSortKind (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03130">3130</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.<div class="fragment"><pre>03131 {
03132   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
03133   <font class="keywordflow">if</font> (sn.kind == SRT_HOF)
03134     <font class="keywordflow">return</font> TRUE;
03135   <font class="keywordflow">return</font> FALSE;
03136 }
</div></pre>    </td>
  </tr>
</table>
<a name="a105" doxytag="sort.c::sort_isValidSort"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_isValidSort (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02318">2318</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l00779">makeModifyNodeRef</a>().<div class="fragment"><pre>02319 {
02320   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02321   sortKind k = sn.kind;
02322   <font class="keywordflow">if</font> (k != SRT_NONE &amp;&amp; k &gt; SRT_FIRST &amp;&amp; k &lt; SRT_LAST)
02323     <font class="keywordflow">return</font> TRUE;
02324   <font class="keywordflow">else</font>
02325     <font class="keywordflow">return</font> FALSE;
02326 }
</div></pre>    </td>
  </tr>
</table>
<a name="a94" doxytag="sort.c::sort_lookup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sortNode sort_lookup (
          </b></td>
          <td valign="bottom"><b>
sort <em>sor</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02034">2034</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l00707">sort_makeArr</a>(), <a class="el" href="sort_c-source.html#l00489">sort_makeFormal</a>(), <a class="el" href="sort_c-source.html#l00514">sort_makeGlobal</a>(), <a class="el" href="sort_c-source.html#l00625">sort_makePtr</a>(), <a class="el" href="sort_c-source.html#l01109">sort_makeTuple</a>(), <a class="el" href="sort_c-source.html#l01382">sort_makeUnionVal</a>(), <a class="el" href="sort_c-source.html#l00779">sort_makeVec</a>(), <a class="el" href="sort_c-source.html#l01525">sort_updateEnum</a>(), <a class="el" href="sort_c-source.html#l01084">sort_updateStr</a>(), and <a class="el" href="sort_c-source.html#l01355">sort_updateUnion</a>().<div class="fragment"><pre>02035 {
02036   <font class="comment">/* ymtan: can sor be 0 ? */</font>
02037   <font class="comment">/* evs --- yup...0 should return noSort ? */</font>
02038   
02039   <font class="keywordflow">if</font> (sor &gt; 0U &amp;&amp; sor &lt; (<font class="keywordtype">unsigned</font>) sortTableSize)
02040     {
02041       llassert (sortTable != NULL);
02042       <font class="keywordflow">return</font> sortTable[sor];
02043     }
02044 
02045   llassert (sor == 0);
02046   <font class="keywordflow">return</font> noSort;
02047 }
</div></pre>    </td>
  </tr>
</table>
<a name="a92" doxytag="sort.c::sort_lookupName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_lookupName (
          </b></td>
          <td valign="bottom"><b>
lsymbol <em>name</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01920">1920</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="symtable_c-source.html#l00958">o_fctInfo</a>(), <a class="el" href="sort_c-source.html#l03120">sort_fromLsymbol</a>(), <a class="el" href="sort_c-source.html#l02867">sort_import</a>(), <a class="el" href="sort_c-source.html#l00707">sort_makeArr</a>(), <a class="el" href="sort_c-source.html#l01467">sort_makeEnum</a>(), <a class="el" href="sort_c-source.html#l00910">sort_makeImmutable</a>(), <a class="el" href="sort_c-source.html#l00951">sort_makeMutable</a>(), <a class="el" href="sort_c-source.html#l00544">sort_makeObj</a>(), <a class="el" href="sort_c-source.html#l00625">sort_makePtr</a>(), <a class="el" href="sort_c-source.html#l00356">sort_makeSort</a>(), <a class="el" href="sort_c-source.html#l01022">sort_makeStr</a>(), <a class="el" href="sort_c-source.html#l00439">sort_makeSyn</a>(), <a class="el" href="sort_c-source.html#l01109">sort_makeTuple</a>(), <a class="el" href="sort_c-source.html#l01297">sort_makeUnion</a>(), <a class="el" href="sort_c-source.html#l01382">sort_makeUnionVal</a>(), and <a class="el" href="sort_c-source.html#l00779">sort_makeVec</a>().<div class="fragment"><pre>01921 {
01922   <font class="keywordtype">long</font> <font class="keywordtype">int</font> i;
01923 
01924   <font class="keywordflow">if</font> (name == lsymbol_undefined)
01925     {
01926       <font class="keywordflow">return</font> NOSORTHANDLE;
01927     }
01928 
01929   llassert (sortTable != NULL);
01930 
01931   <font class="keywordflow">for</font> (i = 0; i &lt; sortTableSize; i++)
01932     {
01933       <font class="keywordflow">if</font> (sortTable[i].name == name)
01934         {
01935           <font class="keywordflow">return</font> i;
01936         }
01937     }
01938 
01939   <font class="keywordflow">return</font> NOSORTHANDLE;
01940 }
</div></pre>    </td>
  </tr>
</table>
<a name="a78" doxytag="sort.c::sort_makeArr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeArr (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>baseSort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00707">707</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l01786">sort_init</a>(), and <a class="el" href="sort_c-source.html#l00625">sort_makePtr</a>().<div class="fragment"><pre>00708 {
00709   sortNode s, outSort, old;
00710   sort handle, vecHandle;
00711   <font class="keywordtype">int</font> dim;
00712   lsymbol name;
00713 
00714   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (baseSort);
00715 
00716   <font class="keywordflow">if</font> (s.kind == SRT_HOF)
00717     <font class="keywordflow">return</font> baseSort;
00718   <font class="keywordflow">if</font> (s.kind == SRT_NONE)
00719     <font class="keywordflow">return</font> baseSort;
00720 
00721   <font class="keywordflow">if</font> (s.kind != SRT_ARRAY &amp;&amp; s.kind != SRT_STRUCT &amp;&amp;
00722       s.kind != SRT_UNION &amp;&amp; s.kind != SRT_OBJ)
00723    <font class="comment">/* base is not an array, struct or obj.  Need to insert a Obj. */</font>
00724     baseSort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (baseSort);
00725 
00726   name = sp (sp (underscoreSymbol, sort_getLsymbol (baseSort)),
00727              <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Arr"</font>));
00728   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00729 
00730  <font class="comment">/* must not clash with any LSL sorts */</font>
00731   outSort.name = name;
00732   outSort.kind = SRT_ARRAY;
00733   outSort.baseSort = baseSort;
00734   outSort.objSort = NOSORTHANDLE;
00735   outSort.members = smemberInfo_undefined;
00736   outSort.mutable = TRUE;
00737   outSort.export = exporting;
00738   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00739   outSort.abstract = FALSE;
00740   outSort.handle = handle;
00741   
00742   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00743     {
00744       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00745         {
00746           outSort.handle = handle = sort_enterNew (outSort);
00747 
00748           <font class="keywordflow">for</font> (old = outSort, dim = 0;
00749                old.kind == SRT_ARRAY;
00750                dim++, old = <a class="code" href="sort_c.html#a94">sort_lookup</a> (old.baseSort))
00751             {
00752               ;
00753             }
00754 
00755           vecHandle = <a class="code" href="sort_c.html#a79">sort_makeVec</a> (t, handle);
00756           genArrOps (baseSort, handle, dim, vecHandle);
00757         }
00758       <font class="keywordflow">else</font>
00759         {
00760           outSort.handle = handle = sort_enterNew (outSort);
00761         }
00762     }
00763   <font class="keywordflow">else</font>
00764     {
00765       llassert (sortTable != NULL);
00766 
00767       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_ARRAY)
00768         {
00769           sortError (t, handle, outSort);
00770         }
00771 
00772       smemberInfo_free (outSort.members);
00773     }
00774 
00775   <font class="keywordflow">return</font> handle;
00776 }
</div></pre>    </td>
  </tr>
</table>
<a name="a89" doxytag="sort.c::sort_makeEnum"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeEnum (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>opttagid</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01467">1467</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05197">checkAndEnterTag</a>(), and <a class="el" href="abstract_c-source.html#l01755">makeEnumSpecNode</a>().<div class="fragment"><pre>01468 {
01469   sortNode outSort;
01470   sort handle;
01471   <font class="keywordtype">bool</font> isNew;
01472   lsymbol name;
01473 
01474   llassert (sortTable != NULL);
01475 
01476   <font class="keywordflow">if</font> (ltoken_isUndefined (opttagid))
01477     {
01478       opttagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, newEnumTag ());
01479       outSort.realtag = FALSE;
01480     }
01481   <font class="keywordflow">else</font>
01482     outSort.realtag = TRUE;
01483   
01484   <font class="comment">/* must not clash with any LSL sorts, tag2sortname adds "_" prefix */</font>
01485 
01486   name = sortTag_toSymbol (<font class="stringliteral">"Enum"</font>, opttagid, &amp;isNew);
01487   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01488   outSort.name = name;
01489   outSort.kind = SRT_ENUM;
01490   outSort.tag = ltoken_getText (opttagid);
01491   outSort.baseSort = NOSORTHANDLE;
01492   outSort.objSort = NOSORTHANDLE;
01493   outSort.members = smemberInfo_undefined;
01494   outSort.export = exporting;
01495   outSort.mutable = FALSE;
01496   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01497   outSort.abstract = FALSE;
01498   outSort.handle = handle;
01499 
01500   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01501     {
01502       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01503         {
01504           outSort.handle = handle = sort_enterNew (outSort);
01505         }
01506       <font class="keywordflow">else</font>
01507         {
01508           outSort.handle = handle = sort_enterNewForce (outSort);
01509         }
01510     }
01511   <font class="keywordflow">else</font> 
01512     {
01513       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_ENUM)
01514         {
01515           sortError (opttagid, handle, outSort);
01516         }
01517 
01518       smemberInfo_free (outSort.members);
01519     }
01520 
01521   <font class="keywordflow">return</font> handle;
01522 }
</div></pre>    </td>
  </tr>
</table>
<a name="a73" doxytag="sort.c::sort_makeFormal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeFormal (
          </b></td>
          <td valign="bottom"><b>
sort <em>insort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00489">489</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05446">enteringClaimScope</a>(), and <a class="el" href="abstract_c-source.html#l05353">enteringFcnScope</a>().<div class="fragment"><pre>00490 {
00491   sortNode s;
00492   sort sor, handle;
00493 
00494   sor = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (insort);
00495   handle = sor;
00496   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (sor);
00497 
00498   <font class="keywordflow">switch</font> (s.kind)
00499     {
00500     <font class="keywordflow">case</font> SRT_STRUCT:
00501       handle = <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken_undefined, sor);
00502       <font class="keywordflow">break</font>;
00503     <font class="keywordflow">case</font> SRT_UNION:
00504       handle = <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken_undefined, sor);
00505       <font class="keywordflow">break</font>;
00506     <font class="keywordflow">default</font>:
00507       <font class="keywordflow">break</font>;
00508     }
00509 
00510   <font class="keywordflow">return</font> handle;
00511 }
</div></pre>    </td>
  </tr>
</table>
<a name="a74" doxytag="sort.c::sort_makeGlobal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeGlobal (
          </b></td>
          <td valign="bottom"><b>
sort <em>insort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00514">514</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l02631">makeVarDeclarationNode</a>(), and <a class="el" href="abstract_c-source.html#l01905">makestrOrUnionNode</a>().<div class="fragment"><pre>00515 {
00516   <font class="comment">/* Make a Obj if not an array or a struct */</font>
00517   sortNode s;
00518   sort sor, handle;
00519   sor = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (insort);
00520   handle = sor;
00521   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (sor);
00522 
00523   <font class="keywordflow">switch</font> (s.kind)
00524     {
00525     <font class="keywordflow">case</font> SRT_ARRAY:
00526     <font class="keywordflow">case</font> SRT_STRUCT:
00527     <font class="keywordflow">case</font> SRT_UNION:
00528     <font class="keywordflow">case</font> SRT_HOF:
00529     <font class="keywordflow">case</font> SRT_NONE:
00530       <font class="keywordflow">break</font>;
00531     <font class="keywordflow">case</font> SRT_VECTOR:
00532     <font class="keywordflow">case</font> SRT_TUPLE:
00533     <font class="keywordflow">case</font> SRT_UNIONVAL:
00534       llcontbuglit (<font class="stringliteral">"sort_makeGlobal: can't make vectors, tuples, or unionvals global"</font>);
00535       <font class="keywordflow">break</font>;
00536     <font class="keywordflow">default</font>:
00537       handle = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (sor);
00538       <font class="keywordflow">break</font>;
00539     }
00540   <font class="keywordflow">return</font> handle;
00541 }
</div></pre>    </td>
  </tr>
</table>
<a name="a66" doxytag="sort.c::sort_makeHOFSort"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeHOFSort (
          </b></td>
          <td valign="bottom"><b>
sort <em>base</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00233">233</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05127">typeExpr2ptrSort</a>().<div class="fragment"><pre>00234 {
00235   sortNode outSort;
00236   sort handle;
00237 
00238   outSort.kind = SRT_HOF;
00239   outSort.name = <a class="code" href="cstring_c.html#a47">cstring_toSymbol</a> (message (<font class="stringliteral">"_HOF_sort_%d"</font>, sortTableSize));
00240   outSort.tag = lsymbol_undefined;
00241   outSort.baseSort = base;
00242   outSort.objSort = NOSORTHANDLE;
00243   outSort.members = smemberInfo_undefined;
00244   outSort.export = exporting;
00245   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00246   outSort.mutable = FALSE;
00247   outSort.abstract = FALSE;
00248 
00249   llassert (sortTable != NULL);
00250 
00251   outSort.handle = handle = sortTableSize;
00252   sortTable[handle] = outSort;
00253 
00254   sortTableSize++;
00255   <font class="keywordflow">return</font> handle;
00256 }
</div></pre>    </td>
  </tr>
</table>
<a name="a81" doxytag="sort.c::sort_makeImmutable"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeImmutable (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
lsymbol <em>name</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00910">910</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l02744">makeAbstractNode</a>(), <a class="el" href="sort_c-source.html#l01786">sort_init</a>(), and <a class="el" href="sort_c-source.html#l00951">sort_makeMutable</a>().<div class="fragment"><pre>00911 {
00912   sortNode outSort;
00913   sort handle;
00914 
00915   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00916 
00917   outSort.kind = SRT_PRIM;
00918   outSort.name = name;
00919   outSort.baseSort = NOSORTHANDLE;
00920   outSort.objSort = NOSORTHANDLE;
00921   outSort.members = smemberInfo_undefined;
00922   outSort.export = exporting;
00923   outSort.mutable = FALSE;
00924   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00925   outSort.abstract = TRUE;
00926   outSort.handle = handle;
00927 
00928   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00929     {
00930       outSort.handle = handle = sort_enterNew (outSort);
00931       overloadSizeof (handle);
00932     }
00933   <font class="keywordflow">else</font>
00934     {                           <font class="comment">/* complain */</font>
00935       llassert (sortTable != NULL);
00936 
00937       <font class="keywordflow">if</font> ((sortTable[handle].kind != SRT_PRIM) &amp;&amp;
00938           (sortTable[handle].abstract) &amp;&amp;
00939           (!sortTable[handle].mutable))
00940         {
00941           sortError (t, handle, outSort);
00942         }
00943 
00944       smemberInfo_free (outSort.members);
00945     }
00946 
00947   <font class="keywordflow">return</font> handle;
00948 }
</div></pre>    </td>
  </tr>
</table>
<a name="a82" doxytag="sort.c::sort_makeMutable"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeMutable (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
lsymbol <em>name</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00951">951</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l02744">makeAbstractNode</a>().<div class="fragment"><pre>00952 {
00953   sort immutable_old, handle, baseSort;
00954   lsymbol objName;
00955 
00956   immutable_old = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00957 
00958  <font class="comment">/* First generate the value sort */</font>
00959   baseSort = <a class="code" href="sort_c.html#a81">sort_makeImmutable</a> (t, name);
00960 
00961   llassert (sortTable != NULL);
00962 
00963   <font class="comment">/* to prevent duplicate error messages */</font>
00964   <font class="keywordflow">if</font> (immutable_old != NOSORTHANDLE &amp;&amp;
00965       (sortTable[baseSort].kind != SRT_PRIM) &amp;&amp;
00966       (sortTable[baseSort].abstract) &amp;&amp;
00967       (!sortTable[baseSort].mutable))
00968     {
00969      <font class="comment">/* already complained */</font>
00970       handle = NOSORTHANDLE;
00971     }
00972   <font class="keywordflow">else</font>
00973     {                           <font class="comment">/* sort_makeImmutable must have succeeded */</font>
00974       sortNode outSort;
00975 
00976      <font class="comment">/* must not clash with any LSL sorts */</font>
00977       objName = sp (sp (underscoreSymbol, name),
00978                     <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Obj"</font>));
00979       handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (objName);
00980 
00981       outSort.kind = SRT_OBJ;
00982       outSort.name = objName;
00983       outSort.tag = lsymbol_undefined;
00984       outSort.baseSort = baseSort;
00985       outSort.objSort = NOSORTHANDLE;
00986       outSort.members = smemberInfo_undefined;
00987       outSort.mutable = TRUE;
00988       outSort.export = exporting;
00989       outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00990       outSort.abstract = TRUE;
00991       outSort.handle = handle;
00992 
00993       <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00994         {
00995           <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00996             {
00997               outSort.handle = handle = sort_enterNew (outSort);
00998             }
00999           <font class="keywordflow">else</font>
01000             {
01001               handle = sort_enterNew (outSort);
01002             }
01003         }
01004       <font class="keywordflow">else</font> 
01005         {
01006           llassert (sortTable != NULL);
01007 
01008           <font class="keywordflow">if</font> ((sortTable[handle].kind != SRT_OBJ) 
01009               &amp;&amp; sortTable[handle].abstract
01010               &amp;&amp; sortTable[handle].mutable)
01011             {
01012               sortError (t, handle, outSort);
01013             }
01014 
01015           smemberInfo_free (outSort.members);
01016         }
01017     }
01018   <font class="keywordflow">return</font> handle;
01019 }
</div></pre>    </td>
  </tr>
</table>
<a name="a65" doxytag="sort.c::sort_makeNoSort"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeNoSort (
          </b></td>
          <td valign="bottom"><b>
void&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00227">227</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05197">checkAndEnterTag</a>(), <a class="el" href="abstract_c-source.html#l05172">lclTypeSpecNode2sort</a>(), <a class="el" href="abstract_c-source.html#l02518">makeArrayNode</a>(), <a class="el" href="abstract_c-source.html#l05023">makeCTypesNode</a>(), <a class="el" href="abstract_c-source.html#l01852">makeEnumSpecNode2</a>(), <a class="el" href="abstract_c-source.html#l02036">makeForwardstrOrUnionNode</a>(), <a class="el" href="abstract_c-source.html#l02135">makeFunctionNode</a>(), <a class="el" href="abstract_c-source.html#l03590">makeIfTermNode</a>(), <a class="el" href="abstract_c-source.html#l03644">makeInfixTermNode</a>(), <a class="el" href="abstract_c-source.html#l00964">makeLetDeclNode</a>(), <a class="el" href="abstract_c-source.html#l04171">makeLiteralTermNode</a>(), <a class="el" href="abstract_c-source.html#l04148">makeMapTermNode</a>(), <a class="el" href="abstract_c-source.html#l04012">makeMatchedNode</a>(), <a class="el" href="abstract_c-source.html#l03787">makeOpCallTermNode</a>(), <a class="el" href="abstract_c-source.html#l02497">makePointerNode</a>(), <a class="el" href="abstract_c-source.html#l03740">makePostfixTermNode2</a>(), <a class="el" href="abstract_c-source.html#l03765">makePrefixTermNode</a>(), <a class="el" href="abstract_c-source.html#l04123">makeSelectTermNode</a>(), <a class="el" href="abstract_c-source.html#l04038">makeSimpleTermNode</a>(), <a class="el" href="abstract_c-source.html#l04336">makeSizeofTermNode</a>(), <a class="el" href="abstract_c-source.html#l03985">makeSqBracketedNode</a>(), <a class="el" href="abstract_c-source.html#l02170">makeTypeExpr</a>(), <a class="el" href="abstract_c-source.html#l05080">makeTypeSpecifier</a>(), <a class="el" href="abstract_c-source.html#l04260">makeUnchangedTermNode1</a>(), <a class="el" href="abstract_c-source.html#l04282">makeUnchangedTermNode2</a>(), <a class="el" href="abstract_c-source.html#l03068">makeVarNode</a>(), <a class="el" href="symtable_c-source.html#l00958">o_fctInfo</a>(), <a class="el" href="abstract_c-source.html#l03854">pushInfixOpPartNode</a>(), and <a class="el" href="abstract_c-source.html#l05542">sigNode_rangeSort</a>().<div class="fragment"><pre>00228 {
00229   <font class="keywordflow">return</font> NOSORTHANDLE;
00230 }
</div></pre>    </td>
  </tr>
</table>
<a name="a75" doxytag="sort.c::sort_makeObj"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeObj (
          </b></td>
          <td valign="bottom"><b>
sort <em>sor</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00544">544</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l00779">makeModifyNodeRef</a>(), <a class="el" href="abstract_c-source.html#l03068">makeVarNode</a>(), <a class="el" href="sort_c-source.html#l00707">sort_makeArr</a>(), <a class="el" href="sort_c-source.html#l00514">sort_makeGlobal</a>(), and <a class="el" href="sort_c-source.html#l00625">sort_makePtr</a>().<div class="fragment"><pre>00545 {
00546   sortNode baseSortNode, outSort;
00547   sort baseSort, handle;
00548   lsymbol name;
00549 
00550  <font class="comment">/* skip the synonym sort */</font>
00551   baseSort = <a class="code" href="sort_c.html#a100">sort_getUnderlying</a> (sor);
00552   baseSortNode = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (baseSort);
00553   <font class="keywordflow">switch</font> (baseSortNode.kind)
00554     {
00555     <font class="keywordflow">case</font> SRT_HOF:
00556     <font class="keywordflow">case</font> SRT_NONE:
00557       <font class="keywordflow">return</font> baseSort;
00558     <font class="keywordflow">case</font> SRT_VECTOR:
00559       <font class="keywordflow">if</font> (baseSortNode.objSort != 0)
00560         <font class="keywordflow">return</font> baseSortNode.objSort;
00561       <font class="keywordflow">else</font>                      <font class="comment">/* must have well-defined objSort field */</font>
00562         {
00563           llcontbuglit (<font class="stringliteral">"sort_makeObj: Inconsistent vector reps:invalid objSort field"</font>);
00564           <font class="keywordflow">return</font> baseSort;
00565         }
00566     <font class="keywordflow">case</font> SRT_TUPLE:
00567     <font class="keywordflow">case</font> SRT_UNIONVAL:
00568      <font class="comment">/* need to map *_Struct_Tuple to *_Struct and *_Union_UnionVal to</font>
00569 <font class="comment">      *_Union, according to sort naming conventions */</font>
00570       <font class="keywordflow">if</font> (baseSortNode.baseSort != NOSORTHANDLE)
00571        <font class="comment">/* for tuples and unionvals, baseSort field keeps the map from</font>
00572 <font class="comment">          value sort to obj sort. */</font>
00573         <font class="keywordflow">return</font> baseSortNode.baseSort;
00574       <font class="keywordflow">else</font>                      <font class="comment">/* valid tuples and unionvals must have baseSort fields */</font>
00575         {
00576           llcontbuglit (<font class="stringliteral">"sort_makeObj: Inconsistent tuples or unionvals reps: invalid baseSort field"</font>);
00577           <font class="keywordflow">return</font> baseSort;
00578         }
00579     <font class="keywordflow">default</font>:
00580       name = sp (sp (underscoreSymbol, sort_getLsymbol (baseSort)),
00581                  <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Obj"</font>));
00582       handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00583 
00584       outSort.kind = SRT_OBJ;
00585       <font class="comment">/* must not clash with any LSL sorts */</font>
00586       outSort.name = name;
00587       outSort.tag = lsymbol_undefined;
00588       outSort.baseSort = baseSort;
00589       outSort.objSort = NOSORTHANDLE;
00590       outSort.members = smemberInfo_undefined;
00591       outSort.mutable = TRUE;
00592       outSort.export = exporting;
00593       outSort.abstract = FALSE;
00594       outSort.handle = handle;
00595       outSort.imported = TRUE;
00596 
00597       <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00598         {
00599           <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00600             {
00601               outSort.handle = handle = sort_enterNew (outSort);
00602             }
00603           <font class="keywordflow">else</font>
00604             {
00605               outSort.handle = handle = sort_enterNew (outSort);
00606             }
00607         }
00608       <font class="keywordflow">else</font>
00609         {
00610           llassert (sortTable != NULL);
00611 
00612           <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_OBJ)
00613             {
00614               sortError (ltoken_undefined, handle, outSort);
00615             }
00616 
00617           smemberInfo_free (outSort.members);
00618         }
00619 
00620       <font class="keywordflow">return</font> handle;
00621     }
00622 }
</div></pre>    </td>
  </tr>
</table>
<a name="a76" doxytag="sort.c::sort_makePtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makePtr (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>baseSort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00625">625</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l01786">sort_init</a>().<div class="fragment"><pre>00626 {
00627   sortNode s, outSort;
00628   sort handle, arrayHandle;
00629   lsymbol name;
00630 
00631   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (baseSort);
00632 
00633   <font class="keywordflow">if</font> (s.kind == SRT_HOF)
00634     {
00635       <font class="keywordflow">return</font> baseSort;
00636     }
00637   <font class="keywordflow">if</font> (s.kind == SRT_NONE)
00638     {
00639       <font class="keywordflow">return</font> baseSort;
00640     }
00641 
00642   <font class="keywordflow">if</font> (s.kind != SRT_ARRAY &amp;&amp; s.kind != SRT_STRUCT &amp;&amp;
00643       s.kind != SRT_UNION)
00644     <font class="comment">/* &amp;&amp; s.kind != SRT_OBJ) */</font>
00645     <font class="comment">/* base is not an SRT_ARRAY, struct or union.  Need to insert a obj. */</font>
00646     baseSort = <a class="code" href="sort_c.html#a75">sort_makeObj</a> (baseSort);
00647   
00648   name = sp (sp (underscoreSymbol, sort_getLsymbol (baseSort)),
00649              <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Ptr"</font>));
00650   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00651   
00652   outSort.kind = SRT_PTR;
00653   outSort.name = name;
00654   outSort.tag = lsymbol_undefined;
00655   outSort.baseSort = baseSort;
00656   outSort.objSort = NOSORTHANDLE;
00657   outSort.members = smemberInfo_undefined;
00658   outSort.mutable = FALSE;
00659   outSort.export = exporting;
00660   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00661   outSort.abstract = FALSE;
00662   outSort.handle = handle;
00663   
00664   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00665     {
00666       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00667         {
00668           outSort.handle = handle = sort_enterNew (outSort);
00669           arrayHandle = <a class="code" href="sort_c.html#a78">sort_makeArr</a> (t, baseSort);
00670           genPtrOps (baseSort, handle, arrayHandle);
00671         }
00672       <font class="keywordflow">else</font>
00673         {
00674           outSort.handle = handle = sort_enterNew (outSort);
00675         }
00676     }
00677   <font class="keywordflow">else</font>
00678     {
00679       llassert (sortTable != NULL);
00680 
00681       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_PTR)
00682         {
00683           sortError (t, handle, outSort);
00684         }
00685       smemberInfo_free (outSort.members);
00686     }
00687   <font class="keywordflow">return</font> handle;
00688 }
</div></pre>    </td>
  </tr>
</table>
<a name="a77" doxytag="sort.c::sort_makePtrN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makePtrN (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
int <em>pointers</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00691">691</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05172">lclTypeSpecNode2sort</a>().<div class="fragment"><pre>00692 {
00693   llassert (pointers &gt;= 0);
00694 
00695   <font class="keywordflow">if</font> (pointers == 0)
00696     {
00697       <font class="keywordflow">return</font> s;
00698     }
00699   <font class="keywordflow">else</font>
00700     {
00701       <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a77">sort_makePtrN</a> (sort_makePtr (ltoken_undefined, s), 
00702                             pointers - 1);
00703     }
00704 }
</div></pre>    </td>
  </tr>
</table>
<a name="a69" doxytag="sort.c::sort_makeSort"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeSort (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
lsymbol <em>n</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00356">356</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l03120">sort_fromLsymbol</a>().<div class="fragment"><pre>00357 {
00358   <font class="comment">/*</font>
00359 <font class="comment">  ** Expects n to be a new sort.</font>
00360 <font class="comment">  ** Generate a sort with the given name.  Useful for LSL sorts. </font>
00361 <font class="comment">  */</font>
00362 
00363   sort handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (n);
00364 
00365   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00366     {
00367       sortNode outSort;
00368 
00369       outSort.handle = handle;      
00370       outSort.kind = SRT_PRIM;
00371       outSort.name = n;
00372       outSort.tag = lsymbol_undefined;
00373       outSort.baseSort = NOSORTHANDLE;
00374       outSort.objSort = NOSORTHANDLE;
00375       outSort.members = smemberInfo_undefined;
00376       outSort.export = exporting;
00377       outSort.mutable = FALSE;
00378       outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00379       outSort.abstract = FALSE;
00380 
00381       <font class="comment">/* Put into sort table, sort_enter checks for duplicates. */</font>
00382       outSort.handle = handle = sort_enterNew (outSort);
00383     }
00384   <font class="keywordflow">else</font>
00385     {
00386       <font class="comment">/* don't override old info */</font>
00387      ;
00388     }
00389 
00390   <font class="keywordflow">return</font> handle;
00391 }
</div></pre>    </td>
  </tr>
</table>
<a name="a83" doxytag="sort.c::sort_makeStr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeStr (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>opttagid</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01022">1022</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05197">checkAndEnterTag</a>(), <a class="el" href="abstract_c-source.html#l02036">makeForwardstrOrUnionNode</a>(), and <a class="el" href="abstract_c-source.html#l01905">makestrOrUnionNode</a>().<div class="fragment"><pre>01023 {
01024   sortNode outSort;
01025   sort handle;
01026   <font class="keywordtype">bool</font> isNewTag;
01027   lsymbol name;
01028 
01029   <font class="comment">/* must not clash with any LSL sorts, tag2sortname adds "_" prefix */</font>
01030   <font class="comment">/* isNewTag true means that the name generated is new */</font>
01031 
01032   <font class="keywordflow">if</font> (ltoken_isUndefined (opttagid))
01033     {
01034       opttagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, newStructTag ());
01035 
01036       outSort.realtag = FALSE;
01037     }
01038   <font class="keywordflow">else</font>
01039     {
01040       outSort.realtag = TRUE;
01041     }
01042   
01043   name = sortTag_toSymbol (<font class="stringliteral">"Struct"</font>, opttagid, &amp;isNewTag);
01044   
01045   llassert (sortTable != NULL);
01046   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01047   outSort.name = name;
01048   outSort.kind = SRT_STRUCT;
01049   outSort.tag = ltoken_getText (opttagid);
01050   outSort.baseSort = NOSORTHANDLE;
01051   outSort.objSort = NOSORTHANDLE;
01052   outSort.members = smemberInfo_undefined;
01053   outSort.export = exporting;
01054   outSort.mutable = TRUE;
01055   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01056   outSort.abstract = FALSE;
01057   outSort.handle = handle;
01058 
01059   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01060     {
01061       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01062         {
01063           outSort.handle = handle = sort_enterNew (outSort);
01064         }
01065       <font class="keywordflow">else</font>
01066         {
01067           outSort.handle = handle = sort_enterNewForce (outSort);
01068         }
01069     }
01070   <font class="keywordflow">else</font> 
01071     {
01072       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_STRUCT)
01073         {
01074           sortError (opttagid, handle, outSort);
01075         }
01076 
01077       smemberInfo_free (outSort.members);
01078     }
01079 
01080   <font class="keywordflow">return</font> handle;
01081 }
</div></pre>    </td>
  </tr>
</table>
<a name="a72" doxytag="sort.c::sort_makeSyn"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeSyn (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>s</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
lsymbol <em>n</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00439">439</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l00194">declareForwardType</a>().<div class="fragment"><pre>00440 {
00441   <font class="comment">/* make a synonym sort with name n that is == to sort s */</font>
00442   <font class="comment">/* expect n to be a new sort name */</font>
00443   sortNode outSort;
00444   sort handle;
00445   <font class="comment">/* must not clash with any LSL sorts */</font>
00446   lsymbol newname = sp (underscoreSymbol, n);
00447   
00448   <font class="keywordflow">if</font> (n == lsymbol_undefined)
00449     {
00450       llbuglit (<font class="stringliteral">"sort_makeSyn: synonym must have name"</font>);
00451     }
00452 
00453   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (newname);
00454 
00455   outSort.kind = SRT_SYN;
00456   outSort.name = newname;
00457   outSort.baseSort = s;
00458   outSort.objSort = NOSORTHANDLE;
00459   <font class="comment">/* info is not duplicated */</font>
00460   outSort.tag = lsymbol_undefined;
00461   outSort.members = smemberInfo_undefined;
00462   outSort.export = exporting;
00463   outSort.mutable = FALSE;
00464   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00465   outSort.abstract = FALSE;
00466   outSort.handle = handle;
00467 
00468   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00469     {
00470       outSort.handle = handle = sort_enterNew (outSort);
00471       <font class="comment">/* No operators to generate for synonyms */</font>
00472     }
00473   <font class="keywordflow">else</font>
00474     {
00475       llassert (sortTable != NULL);
00476       
00477       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_SYN)
00478         {
00479           sortError (t, handle, outSort);
00480         }
00481 
00482       smemberInfo_free (outSort.members);
00483     }
00484 
00485   <font class="keywordflow">return</font> handle;
00486 }
</div></pre>    </td>
  </tr>
</table>
<a name="a85" doxytag="sort.c::sort_makeTuple"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeTuple (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>strSort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01109">1109</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l00489">sort_makeFormal</a>(), <a class="el" href="sort_c-source.html#l00858">sort_makeVal</a>(), and <a class="el" href="sort_c-source.html#l01084">sort_updateStr</a>().<div class="fragment"><pre>01110 {
01111   sort handle;
01112   sortNode outSort, s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (strSort);
01113   lsymbol name;
01114 
01115   <font class="keywordflow">if</font> (s.kind != SRT_STRUCT)
01116     {
01117       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sort_makeTuple: Only structs can become tuples: given sort is %s"</font>,
01118                            sort_unparseKind (s.kind)));
01119     }
01120 
01121   name = sp (s.name, lsymbol_fromChars (<font class="stringliteral">"_Tuple"</font>));
01122   llassert (sortTable != NULL);
01123   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01124 
01125   outSort.kind = SRT_TUPLE;
01126   outSort.name = name;
01127   outSort.tag = s.tag;
01128   outSort.realtag = s.realtag;
01129   outSort.baseSort = strSort;
01130   outSort.objSort = NOSORTHANDLE;
01131   outSort.members = smemberInfo_undefined;
01132   outSort.export = exporting;
01133   outSort.abstract = FALSE;
01134   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01135   outSort.mutable = FALSE;
01136   outSort.handle = handle;
01137 
01138   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01139     {
01140       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01141         {
01142           outSort.handle = handle = sort_enterNew (outSort);
01143 
01144           sort_addTupleMembers (handle, strSort);
01145           genTupleOps (handle);
01146         }
01147       <font class="keywordflow">else</font>
01148         {
01149           outSort.handle = handle = sort_enterNew (outSort);
01150         }
01151     }
01152   <font class="keywordflow">else</font> 
01153     {
01154       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_TUPLE)
01155         {
01156           sortError (t, handle, outSort);
01157         }
01158 
01159       smemberInfo_free (outSort.members);
01160     }
01161 
01162   <font class="keywordflow">return</font> handle;
01163 }
</div></pre>    </td>
  </tr>
</table>
<a name="a86" doxytag="sort.c::sort_makeUnion"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeUnion (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>opttagid</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01297">1297</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05197">checkAndEnterTag</a>(), <a class="el" href="abstract_c-source.html#l02036">makeForwardstrOrUnionNode</a>(), and <a class="el" href="abstract_c-source.html#l01905">makestrOrUnionNode</a>().<div class="fragment"><pre>01298 {
01299   sortNode outSort;
01300   sort handle;
01301   <font class="keywordtype">bool</font> isNewTag; 
01302   lsymbol name;
01303 
01304   <font class="comment">/* must not clash with any LSL sorts, tag2sortname adds "_" prefix */</font>
01305   <font class="comment">/* isNewTag true means that the name generated is new */</font>
01306 
01307   <font class="keywordflow">if</font> (ltoken_isUndefined (opttagid))
01308     {
01309       opttagid = <a class="code" href="ltoken_c.html#a32">ltoken_create</a> (simpleId, newUnionTag ());
01310       outSort.realtag = FALSE;
01311     }
01312   <font class="keywordflow">else</font>
01313     outSort.realtag = TRUE;
01314 
01315   llassert (sortTable != NULL);
01316   name = sortTag_toSymbol (<font class="stringliteral">"Union"</font>, opttagid, &amp;isNewTag);
01317   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01318   outSort.name = name;
01319   outSort.kind = SRT_UNION;
01320   outSort.tag = ltoken_getText (opttagid);
01321   outSort.baseSort = NOSORTHANDLE;
01322   outSort.objSort = NOSORTHANDLE;
01323   outSort.members = smemberInfo_undefined;
01324   outSort.export = exporting;
01325   outSort.mutable = TRUE;
01326   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01327   outSort.abstract = FALSE;
01328   outSort.handle = handle;
01329   
01330   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01331     {
01332       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01333         {
01334           outSort.handle = handle = sort_enterNew (outSort);
01335         }
01336       <font class="keywordflow">else</font>
01337         {
01338           outSort.handle = handle = sort_enterNewForce (outSort);
01339         }
01340     }
01341   <font class="keywordflow">else</font> 
01342     {
01343       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_UNION)
01344         {
01345           sortError (opttagid, handle, outSort);
01346         }
01347 
01348       smemberInfo_free (outSort.members);
01349     }
01350 
01351   <font class="keywordflow">return</font> handle;
01352 }
</div></pre>    </td>
  </tr>
</table>
<a name="a88" doxytag="sort.c::sort_makeUnionVal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeUnionVal (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>unionSort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01382">1382</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l00489">sort_makeFormal</a>(), <a class="el" href="sort_c-source.html#l00858">sort_makeVal</a>(), and <a class="el" href="sort_c-source.html#l01355">sort_updateUnion</a>().<div class="fragment"><pre>01383 {
01384   sort handle;
01385   sortNode outSort, s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (unionSort);
01386   lsymbol name;
01387 
01388   <font class="keywordflow">if</font> (s.kind != SRT_UNION)
01389     {
01390       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sort_makeUnion: only unions can become unionVals: given sort is: %s"</font>,
01391                            sort_unparseKind (s.kind)));
01392     }
01393 
01394   llassert (sortTable != NULL);
01395 
01396   name = sp (s.name, lsymbol_fromChars (<font class="stringliteral">"_UnionVal"</font>));
01397   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
01398 
01399   outSort.kind = SRT_UNIONVAL;
01400   outSort.name = name;
01401   outSort.tag = s.tag;
01402   outSort.realtag = s.realtag;
01403   outSort.baseSort = unionSort;
01404   outSort.objSort = NOSORTHANDLE;
01405   outSort.members = smemberInfo_undefined;
01406   outSort.export = exporting;
01407   outSort.abstract = FALSE;
01408   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
01409   outSort.mutable = FALSE;
01410   outSort.handle = handle;
01411 
01412   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
01413     {
01414       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
01415         {
01416           outSort.handle = handle = sort_enterNew (outSort);
01417 
01418           <font class="comment">/* Add members to the unionVal's. */</font>
01419           <font class="comment">/* same as structs and tuples */</font>
01420 
01421           sort_addTupleMembers (handle, unionSort);
01422           genUnionOps (handle);
01423         }
01424       <font class="keywordflow">else</font>
01425         {
01426           outSort.handle = handle = sort_enterNew (outSort);
01427         }
01428     }
01429   <font class="keywordflow">else</font> 
01430     {
01431       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_UNIONVAL)
01432         {
01433           sortError (t, handle, outSort);
01434         }
01435 
01436       smemberInfo_free (outSort.members);
01437     }
01438 
01439   <font class="keywordflow">return</font> handle;
01440 }
</div></pre>    </td>
  </tr>
</table>
<a name="a80" doxytag="sort.c::sort_makeVal"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeVal (
          </b></td>
          <td valign="bottom"><b>
sort <em>sor</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00858">858</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l03068">makeVarNode</a>(), <a class="el" href="sort_c-source.html#l01786">sort_init</a>(), and <a class="el" href="sort_c-source.html#l00779">sort_makeVec</a>().<div class="fragment"><pre>00859 {
00860   sort retSort = sor;
00861   sortNode rsn, s;
00862 
00863   llassert (sortTable != NULL);
00864   s = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (sor);
00865 
00866   <font class="keywordflow">switch</font> (s.kind)
00867     {
00868     <font class="keywordflow">case</font> SRT_PRIM:
00869     <font class="keywordflow">case</font> SRT_ENUM:
00870     <font class="keywordflow">case</font> SRT_PTR:
00871     <font class="keywordflow">case</font> SRT_TUPLE:
00872     <font class="keywordflow">case</font> SRT_UNIONVAL:
00873     <font class="keywordflow">case</font> SRT_VECTOR:
00874     <font class="keywordflow">case</font> SRT_HOF:
00875     <font class="keywordflow">case</font> SRT_NONE:
00876      <font class="comment">/* Do nothing for basic types and pointers. */</font>
00877       retSort = sor;
00878       <font class="keywordflow">break</font>;
00879     <font class="keywordflow">case</font> SRT_SYN:
00880       <font class="keywordflow">return</font> <a class="code" href="sort_c.html#a80">sort_makeVal</a> (sortTable[sor].baseSort);
00881     <font class="keywordflow">case</font> SRT_OBJ:
00882      <font class="comment">/* Strip out the last Obj's */</font>
00883       <font class="keywordflow">if</font> (s.baseSort == NOSORTHANDLE)
00884         {
00885           llbuglit (<font class="stringliteral">"sort_makeVal: expecting a base sort for Obj"</font>);
00886         }
00887       retSort = s.baseSort;
00888       <font class="keywordflow">break</font>;
00889     <font class="keywordflow">case</font> SRT_ARRAY:
00890       retSort = <a class="code" href="sort_c.html#a79">sort_makeVec</a> (ltoken_undefined, sor);
00891       <font class="keywordflow">break</font>;
00892     <font class="keywordflow">case</font> SRT_STRUCT:
00893       retSort = <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken_undefined, sor);
00894       <font class="keywordflow">break</font>;
00895     <font class="keywordflow">case</font> SRT_UNION:
00896       retSort = <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken_undefined, sor);
00897       <font class="keywordflow">break</font>;
00898     <font class="keywordflow">default</font>:
00899       llbuglit (<font class="stringliteral">"sort_makeVal: invalid sort kind"</font>);
00900     }
00901   rsn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (retSort);
00902   <font class="keywordflow">if</font> (rsn.kind == SRT_NONE)
00903     {
00904       <a class="code" href="llerror_c.html#a43">llfatalbug</a> (message (<font class="stringliteral">"sort_makeVal: invalid return sort kind: %d"</font>, (<font class="keywordtype">int</font>)rsn.kind));
00905     }
00906   <font class="keywordflow">return</font> retSort;
00907 }
</div></pre>    </td>
  </tr>
</table>
<a name="a79" doxytag="sort.c::sort_makeVec"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_makeVec (
          </b></td>
          <td valign="bottom"><b>
ltoken <em>t</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
sort <em>arraySort</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00779">779</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l00707">sort_makeArr</a>(), and <a class="el" href="sort_c-source.html#l00858">sort_makeVal</a>().<div class="fragment"><pre>00780 {
00781   sortNode s, outSort, old;
00782   sort baseSort, handle, elementSort;
00783   <font class="keywordtype">int</font> dim;                      <font class="comment">/* array dimension count. */</font>
00784   lsymbol name;
00785 
00786   s = <a class="code" href="sort_c.html#a94">sort_lookup</a> (arraySort);
00787 
00788   <font class="keywordflow">if</font> (s.kind == SRT_HOF)
00789     <font class="keywordflow">return</font> arraySort;
00790   <font class="keywordflow">if</font> (s.kind == SRT_NONE)
00791     <font class="keywordflow">return</font> arraySort;
00792 
00793   <font class="keywordflow">if</font> (s.kind != SRT_ARRAY)
00794     {
00795       llbug (message (<font class="stringliteral">"sort_makeVec: only arrays can become vectors: given sort is %s"</font>,
00796                       sort_unparseKind (s.kind)));
00797     }
00798 
00799   <font class="keywordflow">if</font> (s.baseSort == NOSORTHANDLE)
00800     llbuglit (<font class="stringliteral">"sort_makeVec: arrays must have base (element) sort"</font>);
00801 
00802  <font class="comment">/* Vectors return "values", so make array elements values. */</font>
00803 
00804   baseSort = s.baseSort;
00805   elementSort = <a class="code" href="sort_c.html#a80">sort_makeVal</a> (baseSort);
00806 
00807   name = sp (sp (underscoreSymbol, sort_getLsymbol (elementSort)),
00808              <a class="code" href="lsymbol_c.html#a14">lsymbol_fromChars</a> (<font class="stringliteral">"_Vec"</font>));
00809   handle = <a class="code" href="sort_c.html#a92">sort_lookupName</a> (name);
00810 
00811   outSort.baseSort = elementSort;
00812   outSort.name = name;
00813   outSort.objSort = arraySort;
00814   outSort.kind = SRT_VECTOR;
00815   outSort.members = smemberInfo_undefined;
00816   outSort.mutable = FALSE;
00817   outSort.export = exporting;
00818   outSort.imported = <a class="code" href="context_c.html#a232">context_inImport</a> ();
00819   outSort.abstract = FALSE;
00820   outSort.handle = handle;
00821 
00822   <font class="keywordflow">if</font> (handle == NOSORTHANDLE)
00823     {
00824       <font class="keywordflow">if</font> (sort_isNewEntry (outSort))
00825         {
00826           outSort.handle = handle = sort_enterNew (outSort);
00827 
00828           <font class="keywordflow">for</font> (old = outSort, dim = 0;
00829                old.kind == SRT_VECTOR;
00830                dim++, old = <a class="code" href="sort_c.html#a94">sort_lookup</a> (old.baseSort))
00831             {
00832               ;
00833             }
00834 
00835           genVecOps (elementSort, handle, dim);
00836         }
00837       <font class="keywordflow">else</font>
00838         {
00839           outSort.handle = handle = sort_enterNew (outSort);
00840         }
00841     }
00842   <font class="keywordflow">else</font>
00843     {
00844       llassert (sortTable != NULL);
00845 
00846       <font class="keywordflow">if</font> (sortTable[handle].kind != SRT_VECTOR)
00847         {
00848           sortError (t, handle, outSort);
00849         }
00850 
00851       smemberInfo_free (outSort.members);
00852     }
00853 
00854   <font class="keywordflow">return</font> handle;
00855 }
</div></pre>    </td>
  </tr>
</table>
<a name="a103" doxytag="sort.c::sort_mutable"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_mutable (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02290">2290</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l00779">makeModifyNodeRef</a>(), and <a class="el" href="abstract_c-source.html#l04282">makeUnchangedTermNode2</a>().<div class="fragment"><pre>02291 {
02292  <font class="comment">/* if s is not a valid sort, then returns false */</font>
02293   sortNode sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02294   <font class="keywordflow">if</font> (sn.mutable)
02295     <font class="keywordflow">return</font> TRUE;
02296   <font class="keywordflow">return</font> FALSE;
02297 }
</div></pre>    </td>
  </tr>
</table>
<a name="a93" doxytag="sort.c::sort_printStats"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
void sort_printStats (
          </b></td>
          <td valign="bottom"><b>
void&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02026">2026</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.<div class="fragment"><pre>02027 {
02028   <font class="comment">/* only for debugging */</font>
02029   printf (<font class="stringliteral">"sortTableSize = %d; sortTableAlloc = %d\n"</font>, sortTableSize,
02030           sortTableAlloc);
02031 }
</div></pre>    </td>
  </tr>
</table>
<a name="a95" doxytag="sort.c::sort_quietLookup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sortNode sort_quietLookup (
          </b></td>
          <td valign="bottom"><b>
sort <em>sor</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02050">2050</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="sort_c-source.html#l02243">MAX_SORT_DEPTH</a>(), <a class="el" href="sort_c-source.html#l03054">sort_getLsymbol</a>(), <a class="el" href="sort_c-source.html#l02867">sort_import</a>(), <a class="el" href="sort_c-source.html#l03130">sort_isHOFSortKind</a>(), <a class="el" href="sort_c-source.html#l02318">sort_isValidSort</a>(), <a class="el" href="sort_c-source.html#l00544">sort_makeObj</a>(), <a class="el" href="sort_c-source.html#l00858">sort_makeVal</a>(), <a class="el" href="sort_c-source.html#l02290">sort_mutable</a>(), and <a class="el" href="sort_c-source.html#l02099">sort_unparse</a>().<div class="fragment"><pre>02051 {
02052   <font class="comment">/* ymtan: can sor be 0 ? */</font>
02053   <font class="keywordflow">if</font> (sor &gt; 0U &amp;&amp; sor &lt; (<font class="keywordtype">unsigned</font>) sortTableSize)
02054     {
02055       llassert (sortTable != NULL);
02056       <font class="keywordflow">return</font> (sortTable[sor]);
02057     }
02058   <font class="keywordflow">else</font>
02059     {
02060       <font class="keywordflow">return</font> noSort;
02061     }
02062 }
</div></pre>    </td>
  </tr>
</table>
<a name="a104" doxytag="sort.c::sort_setExporting"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_setExporting (
          </b></td>
          <td valign="bottom"><b>
bool <em>flag</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02300">2300</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="imports_c-source.html#l00165">processImport</a>(), and <a class="el" href="symtable_c-source.html#l00734">symtable_export</a>().<div class="fragment"><pre>02301 {
02302   <font class="keywordtype">bool</font> old;
02303   old = exporting;
02304   exporting = flag;
02305   <font class="keywordflow">return</font> old;
02306 }
</div></pre>    </td>
  </tr>
</table>
<a name="a98" doxytag="sort.c::sort_unparse"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
cstring sort_unparse (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l02099">2099</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l02556">makeConstDeclarationNode</a>(), and <a class="el" href="abstract_c-source.html#l02631">makeVarDeclarationNode</a>().<div class="fragment"><pre>02100 {
02101  <font class="comment">/* printing routine for sorts */</font>
02102   sortNode sn;
02103   lsymbol name;
02104 
02105   sn = <a class="code" href="sort_c.html#a95">sort_quietLookup</a> (s);
02106   name = sn.name;
02107 
02108   <font class="keywordflow">switch</font> (sn.kind)
02109     {
02110     <font class="keywordflow">case</font> SRT_NONE:
02111       <font class="keywordflow">if</font> (name == lsymbol_undefined)
02112         {
02113           <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"_unknown"</font>);
02114         }
02115 
02116       <font class="keywordflow">return</font> (cstring_fromCharsNew (lsymbol_toChars (name)));
02117     <font class="keywordflow">case</font> SRT_HOF:
02118       <font class="keywordflow">return</font> cstring_makeLiteral (<font class="stringliteral">"procedural"</font>);
02119     <font class="keywordflow">case</font> SRT_PRIM:
02120       <font class="keywordflow">return</font> (cstring_fromCharsNew (lsymbol_toChars (name)));
02121     <font class="keywordflow">case</font> SRT_SYN:
02122       <font class="keywordflow">return</font> (cstring_fromCharsNew (lsymbol_toChars (name)));
02123 
02124     <font class="keywordflow">case</font> SRT_PTR:
02125       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"%q *"</font>, sort_unparse (sort_makeVal (sn.baseSort))));
02126     <font class="keywordflow">case</font> SRT_OBJ:
02127       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj %q"</font>, sort_unparse (sn.baseSort)));
02128     <font class="keywordflow">case</font> SRT_ARRAY:
02129       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"array of %q"</font>, sort_unparse (sort_makeVal (sn.baseSort))));
02130     <font class="keywordflow">case</font> SRT_VECTOR:
02131       <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"vector of %q"</font>, sort_unparse (sn.baseSort)));
02132     <font class="keywordflow">case</font> SRT_TUPLE:
02133       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02134         {
02135           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"struct %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02136         }
02137       <font class="keywordflow">else</font>
02138         {
02139           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"struct {%q}"</font>, printStructMembers (sn.members)));
02140         }
02141     <font class="keywordflow">case</font> SRT_UNIONVAL:
02142       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02143         {
02144           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"union %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02145         }
02146       <font class="keywordflow">else</font>
02147         {
02148           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"union {%q}"</font>, printStructMembers (sn.members)));
02149         }
02150     <font class="keywordflow">case</font> SRT_ENUM:
02151       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02152         {
02153           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"enum %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02154         }
02155       <font class="keywordflow">else</font>
02156         {
02157           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"enum {%q}"</font>, printEnumMembers (sn.members)));
02158         }
02159     <font class="keywordflow">case</font> SRT_STRUCT:
02160       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02161         {
02162           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj struct %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02163         }
02164       <font class="keywordflow">else</font>
02165         {
02166           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj struct {%q}"</font>, printStructMembers (sn.members)));
02167         }
02168     <font class="keywordflow">case</font> SRT_UNION:
02169       <font class="keywordflow">if</font> (sn.tag != lsymbol_undefined &amp;&amp; sn.realtag)
02170         {
02171           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj union %s"</font>, cstring_fromChars (lsymbol_toChars (sn.tag))));
02172         }
02173       <font class="keywordflow">else</font>
02174         {
02175           <font class="keywordflow">return</font> (<a class="code" href="message_c.html#a18">message</a> (<font class="stringliteral">"obj union {%q}"</font>, printStructMembers (sn.members)));
02176         }
02177     <font class="keywordflow">default</font>:
02178       <font class="keywordflow">return</font> (cstring_makeLiteral (<font class="stringliteral">"illegal"</font>));
02179     }
02180 }
</div></pre>    </td>
  </tr>
</table>
<a name="a115" doxytag="sort.c::sort_unparseName"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
cstring sort_unparseName (
          </b></td>
          <td valign="bottom"><b>
sort <em>s</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l03069">3069</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l05293">signNode_unparse</a>().<div class="fragment"><pre>03070 {
03071     <font class="keywordflow">return</font> (<a class="code" href="cstring_c.html#a28">cstring_fromChars</a> (sort_getName (s)));
03072 }
</div></pre>    </td>
  </tr>
</table>
<a name="a90" doxytag="sort.c::sort_updateEnum"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_updateEnum (
          </b></td>
          <td valign="bottom"><b>
sort <em>enumSort</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
smemberInfo * <em>info</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01525">1525</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l01755">makeEnumSpecNode</a>().<div class="fragment"><pre>01526 {
01527   <font class="comment">/*</font>
01528 <font class="comment">  ** Expect enumSort to be in sort table but not yet filled in.</font>
01529 <font class="comment">  ** Return TRUE if it is "new" </font>
01530 <font class="comment">  */</font>
01531 
01532   sortNode sn;
01533 
01534   llassert (sortTable != NULL);
01535 
01536   sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (enumSort);
01537   <font class="keywordflow">if</font> (sn.members == (smemberInfo *) 0)
01538     {
01539       sortTable[enumSort].members = info;
01540       genEnumOps (enumSort);
01541       <font class="keywordflow">return</font> TRUE;
01542     }
01543   <font class="keywordflow">else</font>
01544     {
01545       smemberInfo_free (info);
01546       <font class="keywordflow">return</font> FALSE;
01547     }
01548 }
</div></pre>    </td>
  </tr>
</table>
<a name="a84" doxytag="sort.c::sort_updateStr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_updateStr (
          </b></td>
          <td valign="bottom"><b>
sort <em>strSort</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
smemberInfo * <em>info</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01084">1084</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l01905">makestrOrUnionNode</a>().<div class="fragment"><pre>01085 {
01086   <font class="comment">/* expect strSort to be in sort table but not yet filled in */</font>
01087   <font class="comment">/* return TRUE if it is "new" */</font>
01088   sort tupleSort;
01089   sortNode sn;
01090   
01091   llassert (sortTable != NULL);
01092   sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (strSort);
01093 
01094   <font class="keywordflow">if</font> (sn.members == (smemberInfo *) 0)
01095     {
01096       sortTable[strSort].members = info;
01097       tupleSort = <a class="code" href="sort_c.html#a85">sort_makeTuple</a> (ltoken_undefined, strSort);
01098       genStrOps (strSort, tupleSort);
01099       <font class="keywordflow">return</font> TRUE;
01100     }
01101   <font class="keywordflow">else</font>
01102     {
01103       smemberInfo_free (info);
01104       <font class="keywordflow">return</font> FALSE;
01105     }
01106 }
</div></pre>    </td>
  </tr>
</table>
<a name="a87" doxytag="sort.c::sort_updateUnion"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
bool sort_updateUnion (
          </b></td>
          <td valign="bottom"><b>
sort <em>unionSort</em>, 
          </b></td>
        </tr>
        <tr>
          <td></td>
          <td><b>
smemberInfo * <em>info</em>&nbsp;)
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l01355">1355</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.
<p>
Referenced by <a class="el" href="abstract_c-source.html#l01905">makestrOrUnionNode</a>().<div class="fragment"><pre>01356 {
01357  <font class="comment">/* expect unionSort to be in sort table but not yet filled in */</font>
01358  <font class="comment">/* return TRUE if it is "new" */</font>
01359   sort uValSort;
01360   sortNode sn;
01361 
01362   llassert (sortTable != NULL);
01363 
01364   sn = <a class="code" href="sort_c.html#a94">sort_lookup</a> (unionSort);
01365 
01366   <font class="keywordflow">if</font> (sn.members == (smemberInfo *) 0)
01367     {
01368       sortTable[unionSort].members = info;
01369       uValSort = <a class="code" href="sort_c.html#a88">sort_makeUnionVal</a> (ltoken_undefined, unionSort);
01370       <font class="comment">/* same as struct operations */</font>
01371       genStrOps (unionSort, uValSort);
01372       <font class="keywordflow">return</font> TRUE;
01373     }
01374   <font class="keywordflow">else</font>
01375     {
01376       smemberInfo_free (info);
01377       <font class="keywordflow">return</font> FALSE;
01378     }
01379 }
</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a5" doxytag="sort.c::sort_bool"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_bool
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00118">118</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a6" doxytag="sort.c::sort_capBool"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_capBool
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00119">119</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a8" doxytag="sort.c::sort_char"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_char
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00121">121</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="sort.c::sort_cstring"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_cstring
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00124">124</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a10" doxytag="sort.c::sort_double"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_double
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00123">123</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a9" doxytag="sort.c::sort_float"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_float
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00122">122</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<a name="a7" doxytag="sort.c::sort_int"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td nowrap valign="top"><b> 
sort sort_int
          </b></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="sort_c-source.html#l00120">120</a> of file <a class="el" href="sort_c-source.html">sort.c</a>.    </td>
  </tr>
</table>
<hr><address><small>Generated at Fri Nov 3 18:58:06 2000 for LCLint by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.3 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
